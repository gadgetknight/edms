==== FILE: main.py ====
# main.py

"""
EDSI Veterinary Management System - Main Application Entry Point
Version: 2.0.5
Purpose: Simplified main application with clean Splash -> Login -> Horse Management flow.
         Corrected UserManagementScreen instantiation to pass current_user_id.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Gemini, further modified by Coding partner)

Changelog:
- v2.0.5 (2025-05-26):
    - Modified UserManagementScreen() instantiation in show_user_management_screen
      to pass 'current_user_id' as a positional argument.
- v2.0.4 (2025-05-26):
    - Removed `current_user` keyword argument from `UserManagementScreen()` instantiation.
# ... (previous changelog entries)
"""

import sys
import os
import logging
from logging.handlers import RotatingFileHandler
from typing import Optional
import traceback

from PySide6.QtWidgets import (
    QApplication,
    QMessageBox,
    QDialog,
)
from PySide6.QtCore import (
    Qt,
)
from sqlalchemy import text

project_root = os.path.abspath(os.path.join(os.path.dirname(__file__)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from config.database_config import db_manager
from config.app_config import AppConfig
from views.auth.splash_screen import SplashScreen
from views.auth.small_login_dialog import SmallLoginDialog
from views.horse.horse_unified_management import HorseUnifiedManagement
from views.admin.user_management_screen import UserManagementScreen

exception_logger = logging.getLogger("GlobalExceptionHook")


def global_exception_hook(exctype, value, tb):
    """Handle uncaught exceptions globally"""
    formatted_traceback = "".join(traceback.format_exception(exctype, value, tb))
    exception_logger.critical(
        f"Unhandled exception: {exctype.__name__}: {value}\n{formatted_traceback}",
        exc_info=(exctype, value, tb),
    )
    app_instance = QApplication.instance()
    if app_instance:
        QMessageBox.critical(
            None,
            "Critical Application Error",
            f"A critical error occurred: {value}\n\nPlease check logs for details.",
        )


class EDSIApplication(QApplication):
    def __init__(self):
        super().__init__(sys.argv)
        sys.excepthook = global_exception_hook
        self.current_user_id: Optional[str] = None  # Ensure this is set at login
        self.splash_screen: Optional[SplashScreen] = None
        self.login_dialog: Optional[SmallLoginDialog] = None
        self.horse_management_screen: Optional[HorseUnifiedManagement] = None
        self.user_management_screen: Optional[UserManagementScreen] = None
        self.active_screen_name: Optional[str] = None
        self.setup_logging()
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"Starting {AppConfig.APP_NAME} v{AppConfig.APP_VERSION}")
        self.logger.info(f"Python version: {sys.version}")  # Log Python version
        self.logger.info(
            f"PySide6 version: {self.applicationVersion()}"
        )  # Log PySide6/Qt version
        self.setApplicationName(AppConfig.APP_NAME)
        self.setApplicationVersion(AppConfig.APP_VERSION)
        self.setOrganizationName("EDSI")
        AppConfig.ensure_directories()
        self.initialize_database()
        self.show_splash_screen()

    def setup_logging(self):
        log_config = AppConfig.get_logging_config()
        if not os.path.exists(log_config["log_dir"]):
            try:
                os.makedirs(log_config["log_dir"])
            except OSError as e:
                print(f"Error creating log directory: {e}", file=sys.stderr)
                logging.basicConfig(
                    level=log_config["level"],
                    format="%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s",
                    handlers=[logging.StreamHandler(sys.stdout)],
                )
                logging.warning(
                    "Log directory creation failed. Logging to console only."
                )
                return
        root_logger = logging.getLogger()
        root_logger.setLevel(log_config["level"])
        if root_logger.hasHandlers():
            root_logger.handlers.clear()
        formatter = logging.Formatter(
            "%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s"
        )
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(formatter)
        root_logger.addHandler(console_handler)
        try:
            file_handler = RotatingFileHandler(
                log_config["app_log_file"],
                maxBytes=log_config["log_max_bytes"],
                backupCount=log_config["log_backup_count"],
                encoding="utf-8",
            )
            file_handler.setFormatter(formatter)
            root_logger.addHandler(file_handler)
            logging.info("Logging configured (Console and File)")
        except Exception as e:
            print(f"Error setting up file logger: {e}", file=sys.stderr)
            logging.info("Logging configured (Console only due to file handler error)")

    def initialize_database(self):
        self.logger.info("Initializing database...")
        try:
            db_manager.initialize_database()
            with db_manager.get_session() as session:
                session.execute(text("SELECT 1"))
            self.logger.info("Database initialized successfully")
        except Exception as e:
            self.logger.critical(f"Database initialization failed: {e}", exc_info=True)
            QMessageBox.critical(
                None,
                "Database Error",
                f"Failed to initialize database: {e}\n\nThe application will exit.",
            )
            sys.exit(1)

    def show_splash_screen(self):
        self.logger.info("Showing splash screen")
        self._cleanup_screens(keep_main=False)
        self.splash_screen = SplashScreen()
        self.splash_screen.login_requested.connect(self.show_login_dialog)
        self.splash_screen.exit_requested.connect(self.quit_application)
        self.splash_screen.show()

    def show_login_dialog(self):
        self.logger.info("Showing login dialog")
        if self.login_dialog and self.login_dialog.isVisible():
            self.login_dialog.raise_()
            self.login_dialog.activateWindow()
            return
        parent_widget = (
            self.splash_screen
            if self.splash_screen and self.splash_screen.isVisible()
            else None
        )
        self.login_dialog = SmallLoginDialog(parent=parent_widget)
        self.login_dialog.login_successful.connect(self.handle_login_success)
        self.login_dialog.dialog_closed.connect(self.handle_login_dialog_closed)
        self.login_dialog.setModal(True)
        self.login_dialog.show()

    def handle_login_success(self, user_id: str):  # user_id here is typically username
        self.current_user_id = user_id  # Store the logged-in user's identifier
        self.logger.info(f"User '{user_id}' logged in successfully")
        if self.login_dialog:
            try:
                self.login_dialog.login_successful.disconnect(self.handle_login_success)
                self.login_dialog.dialog_closed.disconnect(
                    self.handle_login_dialog_closed
                )
            except RuntimeError:
                self.logger.debug("Slots already disconnected from login_dialog.")
            self.login_dialog.close()
            self.login_dialog.deleteLater()
            self.login_dialog = None
        if self.splash_screen:
            self.splash_screen.close()
            self.splash_screen.deleteLater()
            self.splash_screen = None
        self.show_horse_management_screen()

    def handle_login_dialog_closed(self):
        self.logger.debug("Login dialog closed signal received.")
        if not self.current_user_id:
            if self.login_dialog:
                self.login_dialog.deleteLater()
                self.login_dialog = None
            if not (self.splash_screen and self.splash_screen.isVisible()):
                self.logger.info("Login dialog closed, no splash. Returning to splash.")
                self.show_splash_screen()
            else:
                self.logger.info("Login dialog closed. Splash screen remains active.")

    def show_horse_management_screen(self):
        if not self.current_user_id:
            self.logger.warning("Attempted to show Horse Management without login.")
            self.show_splash_screen()
            return
        self.logger.info(
            f"Showing Horse Management screen for user: {self.current_user_id}"
        )
        self._cleanup_screens(keep_main=False)
        self.horse_management_screen = HorseUnifiedManagement(
            current_user=self.current_user_id
        )  # Pass user_id
        self.active_screen_name = "Horse Management"
        self.horse_management_screen.exit_requested.connect(self.handle_logout)
        self.horse_management_screen.closing.connect(self.on_main_screen_closing)
        self.horse_management_screen.setup_requested.connect(
            self.show_user_management_screen
        )
        self.horse_management_screen.show()
        self.logger.info("Horse Management Screen shown.")

    def show_user_management_screen(self):
        self.logger.info(
            "Setup icon clicked, attempting to show User Management Screen."
        )
        if not self.current_user_id:
            self.logger.error("Cannot show User Management Screen: No user logged in.")
            QMessageBox.warning(
                None,
                "Authentication Error",
                "No user is currently logged in. Please log in to access setup.",
            )
            return

        if self.user_management_screen and self.user_management_screen.isVisible():
            self.logger.info(
                "User Management Screen is already visible. Activating and raising."
            )
            self.user_management_screen.activateWindow()
            self.user_management_screen.raise_()
            return
        if self.user_management_screen:
            self.logger.info("Re-showing existing User Management Screen instance.")
            self.user_management_screen.show()
            self.user_management_screen.activateWindow()
            self.user_management_screen.raise_()
            return

        self.logger.info("Creating new User Management Screen instance.")
        # MODIFIED: Pass current_user_id as the first positional argument
        self.user_management_screen = UserManagementScreen(self.current_user_id)

        self.user_management_screen.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose)
        self.user_management_screen.destroyed.connect(
            self.handle_user_management_destroyed
        )

        self.user_management_screen.show()
        self.logger.info("User Management Screen shown.")

    def handle_user_management_destroyed(self):
        self.logger.info(
            "User Management Screen was closed and its instance destroyed."
        )
        self.user_management_screen = None

    def handle_logout(self):
        active_user = self.current_user_id or "Unknown user"
        screen_name = self.active_screen_name or "current screen"
        self.logger.info(f"User '{active_user}' logging out from {screen_name}.")
        self.current_user_id = None
        self.active_screen_name = None
        self.logger.info("Logout requested. Application will now exit.")
        self.quit_application()

    def on_main_screen_closing(self):
        self.logger.info("Main application screen (Horse Management) is closing.")
        if self.current_user_id:
            self.logger.info("Main screen closed by user; initiating application quit.")
            self.quit_application()

    def quit_application(self):
        self.logger.info("Application quit requested.")
        self._cleanup_screens(keep_main=False)
        self.quit()

    def _cleanup_screens(self, keep_main: bool = False):
        self.logger.debug(f"Cleanup screens called. Keep main: {keep_main}")
        if self.user_management_screen:
            self.logger.debug("Cleaning up User Management Screen.")
            try:
                self.user_management_screen.destroyed.disconnect(
                    self.handle_user_management_destroyed
                )
            except RuntimeError:
                pass
            self.user_management_screen.close()
            self.user_management_screen = None
        if self.splash_screen:
            try:
                self.splash_screen.login_requested.disconnect(self.show_login_dialog)
                self.splash_screen.exit_requested.disconnect(self.quit_application)
            except RuntimeError:
                pass
            self.splash_screen.close()
            self.splash_screen.deleteLater()
            self.splash_screen = None
            self.logger.debug("Splash screen cleaned up.")
        if self.login_dialog:
            try:
                self.login_dialog.login_successful.disconnect(self.handle_login_success)
                self.login_dialog.dialog_closed.disconnect(
                    self.handle_login_dialog_closed
                )
            except RuntimeError:
                pass
            self.login_dialog.close()
            self.login_dialog.deleteLater()
            self.login_dialog = None
            self.logger.debug("Login dialog cleaned up.")
        if not keep_main and self.horse_management_screen:
            self.logger.debug("Cleaning up Horse Management Screen.")
            try:
                self.horse_management_screen.exit_requested.disconnect(
                    self.handle_logout
                )
                self.horse_management_screen.closing.disconnect(
                    self.on_main_screen_closing
                )
                self.horse_management_screen.setup_requested.disconnect(
                    self.show_user_management_screen
                )
            except RuntimeError:
                pass
            self.horse_management_screen.close()
            self.horse_management_screen.deleteLater()
            self.horse_management_screen = None
            self.logger.debug("Horse management screen cleaned up.")
        self.logger.debug("Screens cleanup finished.")

    def run(self):
        self.logger.info(f"Starting {AppConfig.APP_NAME} event loop")
        try:
            exit_code = self.exec()
            self.logger.info(f"Application finished with exit code: {exit_code}")
            return exit_code
        except Exception as e:
            self.logger.critical(f"Critical error in event loop: {e}", exc_info=True)
            QMessageBox.critical(
                None,
                "Fatal Error",
                f"A fatal error occurred in the application event loop: {e}\nPlease check logs.",
            )
            return 1


def main():
    if not os.path.exists(AppConfig.LOG_DIR):
        try:
            os.makedirs(AppConfig.LOG_DIR)
        except OSError as e:
            print(
                f"Could not create log directory: {AppConfig.LOG_DIR}. Error: {e}",
                file=sys.stderr,
            )
    try:
        app = EDSIApplication()
        exit_code = app.run()
        logging.info(f"Application exiting with code {exit_code}")
        sys.exit(exit_code)
    except Exception as e:
        critical_logger = logging.getLogger("main_entry_point")
        critical_logger.critical(
            f"Fatal error starting or running application: {e}", exc_info=True
        )
        try:
            if not QApplication.instance():
                QApplication(sys.argv)
            QMessageBox.critical(
                None,
                "Fatal Application Error",
                f"A fatal error occurred: {e}\nApplication will exit. Check logs.",
            )
        except Exception as mb_error:
            print(
                f"Could not display fatal error message box: {mb_error}",
                file=sys.stderr,
            )
        sys.exit(1)


if __name__ == "__main__":
    if not os.path.exists(AppConfig.LOG_DIR):
        try:
            os.makedirs(AppConfig.LOG_DIR)
        except:
            pass
    logging.basicConfig(
        level=AppConfig.LOGGING_LEVEL,
        format="%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)],
    )
    main_logger = logging.getLogger(__name__)
    main_logger.info("Application main script started.")
    main()
    main_logger.info("Application main script finished.")


==== FILE: views/admin/user_management_screen.py ====
# views/admin/user_management_screen.py
"""
EDSI Veterinary Management System - User Management Screen
Version: 1.12.5
Purpose: Provides a tabbed UI for managing users, locations, charge codes, and master owners.
         Corrected TypeError for AddEditUserDialog instantiation.
Last Updated: May 27, 2025
Author: Gemini (based on user's v1.12.4)

Changelog:
- v1.12.5 (2025-05-27):
    - Functional Fix: Corrected `AddEditUserDialog` instantiation in `_add_new_user`
      and `_edit_selected_user` to pass `parent_view` (as the first positional argument
      for the parent widget) and `user_controller`. For edit mode, `current_user_object`
      is passed instead of `user`. Removed `current_user_id` from the call as it's not
      an explicit __init__ parameter for the provided AddEditUserDialog v1.0.0.
      This resolves `TypeError: AddEditUserDialog.__init__() got an unexpected keyword argument 'parent'`.
- v1.12.4 (User Provided Baseline):
    - Docstring version set to 1.12.4. Assumed to contain fixes from v1.12.3 (conceptual).
- v1.12.3 (Conceptual - Contained the NameError fix for DARK_PRIMARY_ACTION):
    - Functional Fix: Ensured `QColor` is imported from `PySide6.QtGui`.
    - Functional Fix: Ensured all necessary color constants from `config.app_config`
      are correctly imported and accessible within stylesheet f-strings.
- v1.12.2 (2025-05-27 - Produced DARK_PRIMARY_ACTION NameError):
    - User Management Tab UI Refinement:
        - Removed the search input, roles filter, and status filter elements from this tab's layout.
        - Changed the user list from QTableWidget to QListWidget (`users_list_widget`).
        - Implemented `UserListItemWidget` for a custom row display.
- v1.11.0 (2025-05-27):
    - Major UI Refactor: Main layout to QTabWidget.
- v1.10.12 (2025-05-26) (User's original baseline from commit 4bf96c1):
    - Original structure.
"""
import logging
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QComboBox,
    QCheckBox,
    QMessageBox,
    QAbstractItemView,
    QHeaderView,
    QTabWidget,
    QListWidget,
    QListWidgetItem,
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QIcon, QCloseEvent, QColor

from views.base_view import BaseView
from controllers.user_controller import UserController
from controllers.location_controller import LocationController
from controllers.charge_code_controller import ChargeCodeController
from controllers.owner_controller import OwnerController

from models import User as UserModel
from models import Location as LocationModel
from models import ChargeCode as ChargeCodeModel
from models import Owner as OwnerModel

from .dialogs.add_edit_user_dialog import AddEditUserDialog
from .dialogs.add_edit_location_dialog import AddEditLocationDialog
from .dialogs.add_edit_charge_code_dialog import AddEditChargeCodeDialog

from config.app_config import (
    DARK_SUCCESS_ACTION,
    DARK_DANGER_ACTION,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_BORDER,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_WIDGET_BACKGROUND,
    DARK_PRIMARY_ACTION,
)

import os

try:
    current_script_path = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.abspath(os.path.join(current_script_path, "..", ".."))
    assets_path = os.path.join(project_root, "assets", "icons")
except Exception:
    assets_path = "assets/icons"


class UserListItemWidget(QWidget):
    def __init__(self, user_model: UserModel, parent=None):
        super().__init__(parent)
        self.setContentsMargins(0, 0, 0, 0)
        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 5, 8, 5)
        layout.setSpacing(10)

        label_style = (
            f"color: {DARK_TEXT_SECONDARY}; padding-top: 2px; font-size: 11px;"
        )
        value_box_style = (
            f"background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; padding: 4px 6px; border-radius: 3px; "
            f"font-size: 11px; min-height: 18px;"
        )

        id_label_widget = QLabel("User ID:")
        id_label_widget.setStyleSheet(label_style)
        id_label_widget.setFixedWidth(65)
        self.id_value_label = QLabel(user_model.user_id)
        self.id_value_label.setStyleSheet(value_box_style)
        self.id_value_label.setMinimumWidth(100)

        name_label_widget = QLabel("User Name:")
        name_label_widget.setStyleSheet(label_style)
        name_label_widget.setFixedWidth(85)
        self.name_value_label = QLabel(user_model.user_name or "N/A")
        self.name_value_label.setStyleSheet(value_box_style)

        layout.addWidget(id_label_widget)
        layout.addWidget(self.id_value_label)
        layout.addSpacing(20)
        layout.addWidget(name_label_widget)
        layout.addWidget(self.name_value_label, 1)
        self.setMinimumHeight(
            max(
                self.id_value_label.sizeHint().height(),
                self.name_value_label.sizeHint().height(),
                28,
            )
            + 6
        )


class UserManagementScreen(BaseView):
    horse_management_requested = Signal()
    main_tab_widget: Optional[QTabWidget]

    users_list_widget: Optional[QListWidget]
    add_user_button: Optional[QPushButton]
    edit_user_button: Optional[QPushButton]
    delete_user_button: Optional[QPushButton]
    current_selected_user_id: Optional[str] = None

    locations_table: Optional[QTableWidget]
    add_location_button: Optional[QPushButton]
    edit_location_button: Optional[QPushButton]
    delete_location_button: Optional[QPushButton]
    current_selected_location_id: Optional[int] = None

    charge_codes_table: Optional[QTableWidget]
    add_charge_code_button: Optional[QPushButton]
    edit_charge_code_button: Optional[QPushButton]
    delete_charge_code_button: Optional[QPushButton]
    current_selected_charge_code_id: Optional[int] = None

    owners_table: Optional[QTableWidget]
    add_owner_button: Optional[QPushButton]
    edit_owner_button: Optional[QPushButton]
    delete_owner_button: Optional[QPushButton]
    current_selected_owner_id: Optional[int] = None

    def __init__(self, current_user_id: str, parent: Optional[QWidget] = None):
        self.main_tab_widget = None
        self.users_list_widget = None
        self.add_user_button, self.edit_user_button, self.delete_user_button = (
            None,
            None,
            None,
        )
        self.locations_table = None
        (
            self.add_location_button,
            self.edit_location_button,
            self.delete_location_button,
        ) = (None, None, None)
        self.charge_codes_table = None
        (
            self.add_charge_code_button,
            self.edit_charge_code_button,
            self.delete_charge_code_button,
        ) = (None, None, None)
        self.owners_table = None
        self.add_owner_button, self.edit_owner_button, self.delete_owner_button = (
            None,
            None,
            None,
        )

        super().__init__(parent)

        self.logger = logging.getLogger(self.__class__.__name__)
        self.current_user_id = (
            current_user_id  # This is the ID of the admin using this screen
        )
        self.user_controller = UserController()
        self.location_controller = LocationController()
        self.charge_code_controller = ChargeCodeController()
        self.owner_controller = OwnerController()

        self.setWindowTitle("User & System Management")
        self.load_all_data()
        self.logger.info(
            f"UserManagementScreen (v1.12.5) initialized for user: {self.current_user_id}"
        )

    def _get_crud_button_style(
        self, button_type="default", is_add_button_specific_style=False
    ) -> str:
        base_style = f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;"
        if is_add_button_specific_style:
            bg_color = DARK_SUCCESS_ACTION
            text_color = "white"
            border_color = DARK_SUCCESS_ACTION
        elif button_type == "delete":
            bg_color = DARK_DANGER_ACTION
            text_color = "white"
            border_color = DARK_DANGER_ACTION
        else:
            bg_color = DARK_BUTTON_BG
            text_color = DARK_TEXT_PRIMARY
            border_color = DARK_BORDER

        return f"""
            QPushButton {{
                background-color: {bg_color}; color: {text_color}; border: 1px solid {border_color};
                border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;
            }}
            QPushButton:hover {{ background-color: {QColor(bg_color).lighter(115).name()}; }}
            QPushButton:pressed {{ background-color: {QColor(bg_color).darker(110).name()}; }}
            QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER}; }}
        """

    def setup_ui(self):
        self.logger.info(
            "****** UserManagementScreen.setup_ui() (v1.12.5) ENTERED ******"
        )
        container_layout = getattr(
            self, "main_content_layout", QVBoxLayout(self.central_widget)
        )
        if not hasattr(self, "main_content_layout"):
            self.central_widget.setLayout(container_layout)
        while container_layout.count():
            item = container_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.main_tab_widget = QTabWidget()
        self.main_tab_widget.setStyleSheet(
            f"""
            QTabWidget::pane {{
                border: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND};
                border-top-left-radius: 0px; border-top-right-radius: 6px;
                border-bottom-left-radius: 6px; border-bottom-right-radius: 6px;
            }}
            QTabBar::tab {{
                background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_SECONDARY};
                border: 1px solid {DARK_BORDER}; border-bottom: none; 
                padding: 8px 20px; margin-right: 1px;
                border-top-left-radius: 5px; border-top-right-radius: 5px; min-width: 150px;
            }}
            QTabBar::tab:selected {{
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border-bottom: 1px solid {DARK_WIDGET_BACKGROUND}; 
            }}
            QTabBar::tab:!selected:hover {{ background-color: {DARK_BUTTON_HOVER}; }}
        """
        )

        user_management_tab = self._create_user_management_tab()
        self.main_tab_widget.addTab(user_management_tab, "👤 User Management")
        locations_tab = self._create_locations_tab()
        self.main_tab_widget.addTab(locations_tab, "📍 Manage Locations")
        charge_codes_tab = self._create_charge_codes_tab()
        self.main_tab_widget.addTab(charge_codes_tab, "💲 Manage Charge Codes")
        owners_tab = self._create_owners_tab()
        self.main_tab_widget.addTab(owners_tab, "👥 Master Owner List")

        container_layout.addWidget(self.main_tab_widget)
        self.main_tab_widget.currentChanged.connect(self._on_tab_changed)
        self.logger.info("UserManagementScreen.setup_ui (v1.12.5) FINISHED.")

    def _on_tab_changed(self, index: int):
        self.logger.info(f"Tab changed to index: {index}")
        self.current_selected_user_id = None
        self.current_selected_location_id = None
        self.current_selected_charge_code_id = None
        self.current_selected_owner_id = None

        if self.users_list_widget and index != 0:
            self.users_list_widget.clearSelection()
        if self.locations_table and index != 1:
            self.locations_table.clearSelection()
        if self.charge_codes_table and index != 2:
            self.charge_codes_table.clearSelection()
        if self.owners_table and index != 3:
            self.owners_table.clearSelection()

        if index == 0:
            self.load_users_data()
        elif index == 1:
            self.load_locations_data()
        elif index == 2:
            self.load_charge_codes_data()
        elif index == 3:
            self.load_master_owners_data()
        self._update_crud_button_states()

    def _create_crud_button_panel(
        self,
        add_text: str,
        edit_text_base: str,
        delete_text_base: str,
        add_slot,
        edit_slot,
        delete_slot,
    ) -> (QHBoxLayout, QPushButton, QPushButton, QPushButton):
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        add_button = QPushButton(add_text)
        is_user_add_btn = "User" in add_text
        add_button.setStyleSheet(
            self._get_crud_button_style(is_add_button_specific_style=is_user_add_btn)
        )
        add_button.clicked.connect(add_slot)

        edit_button = QPushButton(f"Edit Selected {edit_text_base}")
        edit_button.setStyleSheet(self._get_crud_button_style("default"))
        edit_button.clicked.connect(edit_slot)
        edit_button.setEnabled(False)

        delete_button = QPushButton(f"Delete Selected {delete_text_base}")
        delete_button.setStyleSheet(self._get_crud_button_style("delete"))
        delete_button.clicked.connect(delete_slot)
        delete_button.setEnabled(False)

        button_layout.addWidget(add_button)
        button_layout.addWidget(edit_button)
        button_layout.addWidget(delete_button)
        button_layout.addStretch()
        return button_layout, add_button, edit_button, delete_button

    def _create_user_management_tab(self) -> QWidget:
        tab_widget = QWidget()
        main_layout = QVBoxLayout(tab_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        (
            crud_buttons_layout,
            self.add_user_button,
            self.edit_user_button,
            self.delete_user_button,
        ) = self._create_crud_button_panel(
            "➕ Add New User",
            "User",
            "User",
            self._add_new_user,
            self._edit_selected_user,
            self._delete_selected_user,
        )
        main_layout.addLayout(crud_buttons_layout)

        current_users_label = QLabel("Current Users:")
        current_users_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-weight: bold; padding-top: 10px;"
        )
        main_layout.addWidget(current_users_label)

        self.users_list_widget = QListWidget()
        self.users_list_widget.setStyleSheet(
            f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER}; 
                border-radius: 4px; 
                background-color: {DARK_WIDGET_BACKGROUND};
            }}
            QListWidget::item {{
                border-bottom: 1px solid {DARK_HEADER_FOOTER}; 
                padding: 0px;
            }}
            QListWidget::item:selected {{
                background-color: {QColor(DARK_PRIMARY_ACTION).lighter(130).name()};
            }}
             QListWidget::item:selected:!active {{
                background-color: {QColor(DARK_PRIMARY_ACTION).lighter(130).name()};
                color: {DARK_TEXT_PRIMARY};
            }}
            QListWidget::item:selected:active {{
                background-color: {QColor(DARK_PRIMARY_ACTION).lighter(130).name()};
                color: {DARK_TEXT_PRIMARY};
            }}
        """
        )
        self.users_list_widget.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.users_list_widget.currentItemChanged.connect(self._on_user_selected)
        main_layout.addWidget(self.users_list_widget)
        return tab_widget

    def _create_locations_tab(self) -> QWidget:
        tab_widget = QWidget()
        main_layout = QVBoxLayout(tab_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        (
            buttons_layout,
            self.add_location_button,
            self.edit_location_button,
            self.delete_location_button,
        ) = self._create_crud_button_panel(
            "➕ Add New Location",
            "Location",
            "Location",
            self._add_new_location,
            self._edit_selected_location,
            self._delete_selected_location,
        )
        self.add_location_button.setStyleSheet(
            self._get_crud_button_style(is_add_button_specific_style=True)
        )
        main_layout.addLayout(buttons_layout)
        current_items_label = QLabel("Managed Locations:")
        current_items_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-weight: bold; padding-top: 10px;"
        )
        main_layout.addWidget(current_items_label)
        self.locations_table = QTableWidget()
        self.locations_table.setColumnCount(3)
        self.locations_table.setHorizontalHeaderLabels(
            ["Location Name", "Full Address", "Active"]
        )
        self.locations_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )
        self.locations_table.setEditTriggers(
            QAbstractItemView.EditTrigger.NoEditTriggers
        )
        self.locations_table.horizontalHeader().setSectionResizeMode(
            QHeaderView.ResizeMode.Stretch
        )
        self.locations_table.itemSelectionChanged.connect(self._on_location_selected)
        main_layout.addWidget(self.locations_table)
        return tab_widget

    def _create_charge_codes_tab(self) -> QWidget:
        tab_widget = QWidget()
        main_layout = QVBoxLayout(tab_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        (
            buttons_layout,
            self.add_charge_code_button,
            self.edit_charge_code_button,
            self.delete_charge_code_button,
        ) = self._create_crud_button_panel(
            "➕ Add New Charge Code",
            "Charge Code",
            "Charge Code",
            self._add_new_charge_code,
            self._edit_selected_charge_code,
            self._delete_selected_charge_code,
        )
        self.add_charge_code_button.setStyleSheet(
            self._get_crud_button_style(is_add_button_specific_style=True)
        )
        main_layout.addLayout(buttons_layout)
        current_items_label = QLabel("Managed Charge Codes:")
        current_items_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-weight: bold; padding-top: 10px;"
        )
        main_layout.addWidget(current_items_label)
        self.charge_codes_table = QTableWidget()
        self.charge_codes_table.setColumnCount(5)
        self.charge_codes_table.setHorizontalHeaderLabels(
            ["Code", "Description", "Category", "Std. Price", "Active"]
        )
        self.charge_codes_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )
        self.charge_codes_table.setEditTriggers(
            QAbstractItemView.EditTrigger.NoEditTriggers
        )
        self.charge_codes_table.horizontalHeader().setSectionResizeMode(
            QHeaderView.ResizeMode.Stretch
        )
        self.charge_codes_table.itemSelectionChanged.connect(
            self._on_charge_code_selected
        )
        main_layout.addWidget(self.charge_codes_table)
        return tab_widget

    def _create_owners_tab(self) -> QWidget:
        tab_widget = QWidget()
        main_layout = QVBoxLayout(tab_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        (
            buttons_layout,
            self.add_owner_button,
            self.edit_owner_button,
            self.delete_owner_button,
        ) = self._create_crud_button_panel(
            "➕ Add New Owner",
            "Owner",
            "Owner",
            self._add_new_owner,
            self._edit_selected_owner,
            self._delete_selected_owner,
        )
        self.add_owner_button.setStyleSheet(
            self._get_crud_button_style(is_add_button_specific_style=True)
        )
        main_layout.addLayout(buttons_layout)
        self.add_owner_button.setEnabled(False)
        self.edit_owner_button.setEnabled(False)
        current_items_label = QLabel("Master Owner List:")
        current_items_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-weight: bold; padding-top: 10px;"
        )
        main_layout.addWidget(current_items_label)
        self.owners_table = QTableWidget()
        self.owners_table.setColumnCount(4)
        self.owners_table.setHorizontalHeaderLabels(
            ["Account #", "Owner Name", "Primary Phone", "Active"]
        )
        self.owners_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )
        self.owners_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.owners_table.horizontalHeader().setSectionResizeMode(
            QHeaderView.ResizeMode.Stretch
        )
        self.owners_table.itemSelectionChanged.connect(self._on_master_owner_selected)
        main_layout.addWidget(self.owners_table)
        return tab_widget

    def _update_crud_button_states(self):
        current_tab_index = (
            self.main_tab_widget.currentIndex() if self.main_tab_widget else -1
        )
        user_selected = self.current_selected_user_id is not None
        location_selected = self.current_selected_location_id is not None
        charge_code_selected = self.current_selected_charge_code_id is not None
        owner_selected = self.current_selected_owner_id is not None

        if self.edit_user_button:
            self.edit_user_button.setEnabled(current_tab_index == 0 and user_selected)
        if self.delete_user_button:
            self.delete_user_button.setEnabled(current_tab_index == 0 and user_selected)
        if self.edit_location_button:
            self.edit_location_button.setEnabled(
                current_tab_index == 1 and location_selected
            )
        if self.delete_location_button:
            self.delete_location_button.setEnabled(
                current_tab_index == 1 and location_selected
            )
        if self.edit_charge_code_button:
            self.edit_charge_code_button.setEnabled(
                current_tab_index == 2 and charge_code_selected
            )
        if self.delete_charge_code_button:
            self.delete_charge_code_button.setEnabled(
                current_tab_index == 2 and charge_code_selected
            )
        if self.edit_owner_button:
            self.edit_owner_button.setEnabled(
                current_tab_index == 3 and owner_selected and False
            )
        if self.delete_owner_button:
            self.delete_owner_button.setEnabled(
                current_tab_index == 3 and owner_selected
            )

    def load_all_data(self):
        self.logger.info(
            "UserManagementScreen: Loading initial data for the first tab."
        )
        self._on_tab_changed(0)
        if hasattr(self, "update_status_bar") and callable(self.update_status_bar):
            self.update_status_bar("Ready.")
        elif (
            hasattr(self, "parent_view")
            and self.parent_view
            and hasattr(self.parent_view, "update_status")
            and callable(self.parent_view.update_status)
        ):
            self.parent_view.update_status("User Management Ready.")
        else:
            self.logger.warning(
                "update_status_bar method not found on self or parent_view."
            )

    def load_users_data(self):
        self.logger.info("Loading users data for User Management tab (custom list)...")
        if not self.users_list_widget:
            self.logger.warning("User list widget not ready.")
            return
        try:
            users = self.user_controller.get_all_users(include_inactive=True)
            self.users_list_widget.clear()
            for user in users:
                list_item = QListWidgetItem(self.users_list_widget)
                item_widget = UserListItemWidget(user, self.users_list_widget)
                list_item.setSizeHint(item_widget.sizeHint())
                list_item.setData(Qt.ItemDataRole.UserRole, user.user_id)
                self.users_list_widget.addItem(list_item)
                self.users_list_widget.setItemWidget(list_item, item_widget)
            self.logger.info(f"Loaded {len(users)} users into custom list.")
        except Exception as e:
            self.logger.error(
                f"Error loading user data into custom list: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Load Error", f"Could not load users: {e}")
        self.current_selected_user_id = None
        self._update_crud_button_states()

    @Slot()
    def _on_user_selected(self):
        self.current_selected_user_id = None
        if self.users_list_widget and self.users_list_widget.currentItem():
            list_item = self.users_list_widget.currentItem()
            self.current_selected_user_id = list_item.data(Qt.ItemDataRole.UserRole)
        self.logger.info(f"User selected from list: {self.current_selected_user_id}")
        self._update_crud_button_states()

    @Slot()
    def _add_new_user(self):
        # Corrected: AddEditUserDialog (v1.0.0) expects parent_view, user_controller, current_user_object
        dialog = AddEditUserDialog(
            parent_view=self,
            user_controller=self.user_controller,
            # current_user_object is None for new user (default)
            # current_user_id (for who is performing action) is not taken by this dialog's __init__
        )
        if dialog.exec():
            self.load_users_data()
            self.show_status_message("User added successfully.", True)

    @Slot()
    def _edit_selected_user(self):
        if not self.current_selected_user_id:
            self.show_warning("Edit User", "Select user.")
            return
        user_to_edit = self.user_controller.get_user_by_login_id(
            self.current_selected_user_id
        )
        if not user_to_edit:
            self.show_error("Error", "User not found.")
            self.load_users_data()
            return
        # Corrected: AddEditUserDialog expects parent_view, user_controller, current_user_object
        dialog = AddEditUserDialog(
            parent_view=self,
            user_controller=self.user_controller,
            current_user_object=user_to_edit,
        )
        if dialog.exec():
            self.load_users_data()
            self.show_status_message(f"User '{user_to_edit.user_id}' updated.", True)
            self._try_reselect_item(
                self.users_list_widget, self.current_selected_user_id
            )

    def _try_reselect_item(self, list_or_table_widget, item_id_to_select):
        if not list_or_table_widget or item_id_to_select is None:
            self._update_crud_button_states()
            return
        found = False
        if isinstance(list_or_table_widget, QListWidget):
            for i in range(list_or_table_widget.count()):
                list_item = list_or_table_widget.item(i)
                if (
                    list_item
                    and list_item.data(Qt.ItemDataRole.UserRole) == item_id_to_select
                ):
                    list_or_table_widget.setCurrentItem(list_item)
                    if list_or_table_widget == self.users_list_widget:
                        self._on_user_selected()
                    found = True
                    break
        elif isinstance(list_or_table_widget, QTableWidget):
            for row in range(list_or_table_widget.rowCount()):
                item = list_or_table_widget.item(row, 0)
                if item and item.data(Qt.ItemDataRole.UserRole) == item_id_to_select:
                    list_or_table_widget.setCurrentCell(row, 0)
                    if list_or_table_widget == self.locations_table:
                        self._on_location_selected()
                    elif list_or_table_widget == self.charge_codes_table:
                        self._on_charge_code_selected()
                    elif list_or_table_widget == self.owners_table:
                        self._on_master_owner_selected()
                    found = True
                    break
        if not found:
            if hasattr(list_or_table_widget, "clearSelection"):
                list_or_table_widget.clearSelection()
            if list_or_table_widget == self.users_list_widget:
                self.current_selected_user_id = None
            elif list_or_table_widget == self.locations_table:
                self.current_selected_location_id = None
            elif list_or_table_widget == self.charge_codes_table:
                self.current_selected_charge_code_id = None
            elif list_or_table_widget == self.owners_table:
                self.current_selected_owner_id = None
        self._update_crud_button_states()

    @Slot()
    def _delete_selected_user(self):
        self._generic_delete_action(
            self.current_selected_user_id,
            "User",
            self.user_controller.delete_user_permanently,
            self.load_users_data,
            "current_selected_user_id",
            self.users_list_widget,
        )

    def load_locations_data(self):
        self.logger.info("Loading locations data for tab...")
        if not self.locations_table:
            self.logger.warning("Locations table not ready.")
            return
        try:
            locs = self.location_controller.get_all_locations(status_filter="all")
            self.locations_table.setRowCount(0)
            self.locations_table.setSortingEnabled(False)
            for r, l_obj in enumerate(locs):
                self.locations_table.insertRow(r)
                self.locations_table.setItem(
                    r, 0, QTableWidgetItem(l_obj.location_name or "N/A")
                )
                addr_parts = [
                    l_obj.address_line1,
                    l_obj.address_line2,
                    l_obj.city,
                    l_obj.state_code,
                    l_obj.zip_code,
                    l_obj.country_code,
                ]
                full_addr = ", ".join(filter(None, addr_parts))
                display_text = (
                    l_obj.location_name
                    if l_obj.location_name
                    else (full_addr if full_addr else "N/A")
                )
                if (
                    l_obj.location_name
                    and full_addr
                    and l_obj.location_name.lower()
                    != full_addr.lower().replace(",", "").strip()
                ):
                    display_text = f"{l_obj.location_name} ({full_addr})"
                elif not l_obj.location_name and full_addr:
                    display_text = full_addr
                self.locations_table.setItem(r, 1, QTableWidgetItem(display_text))
                self.locations_table.setItem(
                    r, 2, QTableWidgetItem("Yes" if l_obj.is_active else "No")
                )
                self.locations_table.item(r, 0).setData(
                    Qt.ItemDataRole.UserRole, l_obj.location_id
                )
            self.locations_table.setSortingEnabled(True)
            self.logger.info(f"Loaded {len(locs)} locations.")
        except Exception as e:
            self.logger.error(f"Error loading locations: {e}", exc_info=True)
        self.current_selected_location_id = None
        self._update_crud_button_states()

    @Slot()
    def _on_location_selected(self):
        self.current_selected_location_id = None
        if self.locations_table and self.locations_table.selectedItems():
            item = self.locations_table.item(self.locations_table.currentRow(), 0)
            if item:
                self.current_selected_location_id = item.data(Qt.ItemDataRole.UserRole)
        self.logger.info(f"Location selected: {self.current_selected_location_id}")
        self._update_crud_button_states()

    @Slot()
    def _add_new_location(self):
        dialog = AddEditLocationDialog(
            parent_view=self,
            controller=self.location_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec():
            self.load_locations_data()
            self.show_status_message("Location added.", True)

    @Slot()
    def _edit_selected_location(self):
        if not self.current_selected_location_id:
            self.show_warning("Edit Location", "Select location.")
            return
        loc_to_edit = self.location_controller.get_location_by_id(
            self.current_selected_location_id
        )
        if not loc_to_edit:
            self.show_error("Error", "Location not found.")
            self.load_locations_data()
            return
        dialog = AddEditLocationDialog(
            parent_view=self,
            controller=self.location_controller,
            location=loc_to_edit,
            current_user_id=self.current_user_id,
        )
        if dialog.exec():
            self.load_locations_data()
            self.show_status_message(
                f"Location '{loc_to_edit.location_name}' updated.", True
            )
            self._try_reselect_item(
                self.locations_table, self.current_selected_location_id
            )

    @Slot()
    def _delete_selected_location(self):
        self._generic_delete_action(
            self.current_selected_location_id,
            "Location",
            self.location_controller.delete_location,
            self.load_locations_data,
            "current_selected_location_id",
            self.locations_table,
        )

    def load_charge_codes_data(self):
        self.logger.info("Loading charge codes data for tab...")
        if not self.charge_codes_table:
            self.logger.warning("Charge codes table not ready.")
            return
        try:
            ccs = self.charge_code_controller.get_all_charge_codes(status_filter="all")
            self.charge_codes_table.setRowCount(0)
            self.charge_codes_table.setSortingEnabled(False)
            for r, c_obj in enumerate(ccs):
                self.charge_codes_table.insertRow(r)
                self.charge_codes_table.setItem(r, 0, QTableWidgetItem(c_obj.code))
                self.charge_codes_table.setItem(
                    r, 1, QTableWidgetItem(c_obj.description or "")
                )
                self.charge_codes_table.setItem(
                    r, 2, QTableWidgetItem(c_obj.category or "")
                )
                self.charge_codes_table.setItem(
                    r,
                    3,
                    QTableWidgetItem(
                        f"{c_obj.standard_charge:.2f}"
                        if c_obj.standard_charge is not None
                        else "0.00"
                    ),
                )
                self.charge_codes_table.setItem(
                    r, 4, QTableWidgetItem("Yes" if c_obj.is_active else "No")
                )
                self.charge_codes_table.item(r, 0).setData(
                    Qt.ItemDataRole.UserRole, c_obj.charge_code_id
                )
            self.charge_codes_table.setSortingEnabled(True)
            self.logger.info(f"Loaded {len(ccs)} charge codes.")
        except Exception as e:
            self.logger.error(f"Error loading charge codes: {e}", exc_info=True)
        self.current_selected_charge_code_id = None
        self._update_crud_button_states()

    @Slot()
    def _on_charge_code_selected(self):
        self.current_selected_charge_code_id = None
        if self.charge_codes_table and self.charge_codes_table.selectedItems():
            item = self.charge_codes_table.item(self.charge_codes_table.currentRow(), 0)
            if item:
                self.current_selected_charge_code_id = item.data(
                    Qt.ItemDataRole.UserRole
                )
        self.logger.info(
            f"Charge Code selected: {self.current_selected_charge_code_id}"
        )
        self._update_crud_button_states()

    @Slot()
    def _add_new_charge_code(self):
        # AddEditChargeCodeDialog (v1.1.3) __init__: (self, parent, controller, charge_code=None)
        # It does not take current_user_id.
        dialog = AddEditChargeCodeDialog(
            parent=self, controller=self.charge_code_controller
        )
        if dialog.exec():
            self.load_charge_codes_data()
            self.show_status_message("Charge code added.", True)

    @Slot()
    def _edit_selected_charge_code(self):
        if not self.current_selected_charge_code_id:
            self.show_warning("Edit Charge Code", "Select charge code.")
            return
        cc_to_edit = self.charge_code_controller.get_charge_code_by_id(
            self.current_selected_charge_code_id
        )
        if not cc_to_edit:
            self.show_error("Error", "Charge code not found.")
            self.load_charge_codes_data()
            return
        # AddEditChargeCodeDialog (v1.1.3) __init__: (self, parent, controller, charge_code=None)
        dialog = AddEditChargeCodeDialog(
            parent=self, controller=self.charge_code_controller, charge_code=cc_to_edit
        )
        if dialog.exec():
            self.load_charge_codes_data()
            self.show_status_message(f"Charge code '{cc_to_edit.code}' updated.", True)
            self._try_reselect_item(
                self.charge_codes_table, self.current_selected_charge_code_id
            )

    @Slot()
    def _delete_selected_charge_code(self):
        self._generic_delete_action(
            self.current_selected_charge_code_id,
            "Charge Code",
            self.charge_code_controller.toggle_charge_code_status,
            self.load_charge_codes_data,
            "current_selected_charge_code_id",
            self.charge_codes_table,
        )

    def load_master_owners_data(self):
        self.logger.info("Loading master owners data for tab...")
        if not self.owners_table:
            self.logger.warning("Owners table not ready.")
            return
        try:
            owners = (
                self.owner_controller.get_all_master_owners(include_inactive=True)
                if hasattr(self.owner_controller, "get_all_master_owners")
                else []
            )
            if not hasattr(self.owner_controller, "get_all_master_owners"):
                self.logger.error("OwnerController missing 'get_all_master_owners'.")
                QMessageBox.warning(
                    self, "Load Error", "Cannot load owners: Controller method missing."
                )
                return
            self.owners_table.setRowCount(0)
            self.owners_table.setSortingEnabled(False)
            for r, o_obj in enumerate(owners):
                self.owners_table.insertRow(r)
                self.owners_table.setItem(
                    r, 0, QTableWidgetItem(o_obj.account_number or "")
                )
                name_disp = (
                    o_obj.farm_name
                    or f"{o_obj.first_name or ''} {o_obj.last_name or ''}".strip()
                    or f"ID: {o_obj.owner_id}"
                )
                self.owners_table.setItem(r, 1, QTableWidgetItem(name_disp))
                self.owners_table.setItem(r, 2, QTableWidgetItem(o_obj.phone or ""))
                self.owners_table.setItem(
                    r, 3, QTableWidgetItem("Yes" if o_obj.is_active else "No")
                )
                self.owners_table.item(r, 0).setData(
                    Qt.ItemDataRole.UserRole, o_obj.owner_id
                )
            self.owners_table.setSortingEnabled(True)
            self.logger.info(f"Loaded {len(owners)} master owners.")
        except Exception as e:
            self.logger.error(f"Error loading master owners: {e}", exc_info=True)
        self.current_selected_owner_id = None
        self._update_crud_button_states()

    @Slot()
    def _on_master_owner_selected(self):
        self.current_selected_owner_id = None
        if self.owners_table and self.owners_table.selectedItems():
            item = self.owners_table.item(self.owners_table.currentRow(), 0)
            if item:
                self.current_selected_owner_id = item.data(Qt.ItemDataRole.UserRole)
        self.logger.info(f"Master Owner selected: {self.current_selected_owner_id}")
        self._update_crud_button_states()

    @Slot()
    def _add_new_owner(self):
        self.show_info(
            "Not Implemented", "Adding master owners is not yet implemented."
        )

    @Slot()
    def _edit_selected_owner(self):
        self.show_info(
            "Not Implemented", "Editing master owners is not yet implemented."
        )

    @Slot()
    def _delete_selected_owner(self):
        self._generic_delete_action(
            self.current_selected_owner_id,
            "Master Owner",
            self.owner_controller.delete_master_owner,
            self.load_master_owners_data,
            "current_selected_owner_id",
            self.owners_table,
        )

    def _generic_delete_action(
        self,
        item_id,
        item_name_singular: str,
        controller_delete_method,
        load_data_method,
        current_selection_attr: str,
        list_or_table_widget,
    ):
        if not item_id:
            self.show_warning(
                f"Delete {item_name_singular}",
                f"Please select a {item_name_singular.lower()} to delete.",
            )
            return
        item_repr = f"{item_name_singular} ID {item_id}"
        current_row_widget = None
        if (
            isinstance(list_or_table_widget, QListWidget)
            and list_or_table_widget.currentItem()
        ):
            current_row_widget = list_or_table_widget.itemWidget(
                list_or_table_widget.currentItem()
            )
            if isinstance(current_row_widget, UserListItemWidget):
                item_repr = f"User '{current_row_widget.name_value_label.text()}' (ID: {current_row_widget.id_value_label.text()})"
        elif (
            isinstance(list_or_table_widget, QTableWidget)
            and list_or_table_widget.selectedItems()
        ):
            current_row = list_or_table_widget.currentRow()
            name_col_idx = 1 if item_name_singular in ["User", "Master Owner"] else 0
            if list_or_table_widget.columnCount() > name_col_idx:
                name_item = list_or_table_widget.item(current_row, name_col_idx)
                id_item = list_or_table_widget.item(current_row, 0)
                id_val = id_item.text() if id_item else str(item_id)
                name_val = name_item.text() if name_item else ""
                item_repr = f"{item_name_singular} '{name_val}' (ID: {id_val})"
        if (
            QMessageBox.question(
                self,
                f"Confirm Delete",
                f"Are you sure you want to permanently delete {item_repr}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
            == QMessageBox.StandardButton.Yes
        ):
            try:
                success, message = (
                    controller_delete_method(item_id)
                    if item_name_singular == "Charge Code"
                    else controller_delete_method(item_id, self.current_user_id)
                )
                if success:
                    self.show_status_message(message, True)
                    load_data_method()
                    setattr(self, current_selection_attr, None)
                else:
                    self.show_error_message(f"Delete Failed", message)
            except Exception as e:
                self.logger.error(
                    f"Error deleting {item_name_singular.lower()} ID {item_id}: {e}",
                    exc_info=True,
                )
                self.show_error_message(
                    "Delete Error", f"An unexpected error occurred: {e}"
                )
        self._update_crud_button_states()

    def closeEvent(self, event: QCloseEvent):
        self.logger.info("User Management screen closing.")
        super().closeEvent(event)


==== FILE: views/base_view.py ====
# views/base_view.py

"""
EDSI Veterinary Management System - Base View Class
Version: 1.1.8
Purpose: Provides a base class for all main views/screens in the application,
         handling common UI setup like dark theme and status messages.
         Corrected missing import for DARK_TEXT_TERTIARY.
Last Updated: May 21, 2025
Author: Gemini

Changelog:
- v1.1.8 (2025-05-21):
    - Added `DARK_TEXT_TERTIARY` to the imports from `config.app_config`
      to resolve a NameError during theme application.
- v1.1.7 (2025-05-21):
    - Added `DARK_PRIMARY_ACTION` to the imports from `config.app_config`
      to resolve a NameError during theme application.
- v1.1.6 (2025-05-21):
    - Added unconditional print statements in `__init__` before and after calling
      `apply_dark_theme_palette_and_global_styles`, and at the start/end of
      `apply_dark_theme_palette_and_global_styles` itself, to check the type of
      `self.tab_widget` if the instance is `HorseUnifiedManagement`.
- v1.1.5 (2025-05-20):
    - Added detailed logging to BaseView.setup_ui to trace layout management
      and confirm if the default or overridden setup_ui is being used.
- v1.1.4 (2025-05-18):
    - Ensured central_widget always has a layout, even in default setup_ui.
- v1.1.3 (2025-05-17):
    - Added placeholder for status_bar if not created by subclass.
- v1.1.2 (2025-05-16):
    - Added show_confirmation_dialog and show_error_dialog methods.
    - Refined status message display and clearing.
- v1.1.1 (2025-05-15):
    - Standardized status message methods (show_info, show_warning, show_error).
- v1.1.0 (2025-05-14):
    - Initial implementation with dark theme palette and global styles.
    - Basic UI setup with a central widget.
    - Abstracted common UI functionalities.
"""

import logging
from PySide6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QLabel,
    QApplication,
    QMessageBox,
    QStatusBar,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer

from config.app_config import (
    DARK_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_WIDGET_BACKGROUND,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DEFAULT_FONT_FAMILY,
    DARK_HEADER_FOOTER,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
    DARK_TEXT_TERTIARY,  # ADDED THIS IMPORT
)


class BaseView(QMainWindow):
    """
    Base class for all main views/screens in the application.
    Handles common setup like dark theme, status messages, and basic layout.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} started.")

        # Set window flags if needed, e.g., to remove native title bar for custom one
        # self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)

        # Central widget and layout
        # This is crucial: ensure central_widget is created BEFORE setCentralWidget
        # and before setup_ui (which might replace its layout or add to it).
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.logger.info(
            f"BaseView __init__ for {self.__class__.__name__}: central_widget created."
        )

        # Allow subclasses to define their own UI structure
        # The `setup_ui` method in the subclass (e.g., UserManagementScreen)
        # is responsible for populating self.central_widget.
        if hasattr(self, "setup_ui") and callable(self.setup_ui):
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Calling overridden setup_ui()."
            )
            self.setup_ui()  # This will call the setup_ui of the subclass
        else:
            # Default UI setup if subclass doesn't provide one
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Using default BaseView setup_ui()."
            )
            default_layout = QVBoxLayout(
                self.central_widget
            )  # Apply layout to central_widget
            default_label = QLabel(f"Welcome to {self.__class__.__name__}")
            default_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            default_layout.addWidget(default_label)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QVBoxLayout set on central_widget."
            )

        # Apply theme and styles after the subclass's setup_ui has potentially created widgets
        # Check type of self.tab_widget if it's HorseUnifiedManagement
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: BEFORE apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        self.apply_dark_theme_palette_and_global_styles()

        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: AFTER apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        # Initialize status bar if not already done by subclass
        if not hasattr(self, "status_bar") or self.status_bar is None:
            self.status_bar = QStatusBar()
            self.setStatusBar(self.status_bar)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QStatusBar created and set."
            )
            self.update_status("Ready", 0)  # Initial status

        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} finished.")

    def set_title(self, title: str):
        self.setWindowTitle(title)

    def apply_dark_theme_palette_and_global_styles(self):
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: START. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(
            QPalette.ColorRole.AlternateBase, QColor(DARK_BACKGROUND)
        )  # For item views like QListWidget
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(
            QPalette.ColorRole.BrightText, Qt.GlobalColor.red
        )  # Often used for errors or important highlights
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(
            QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG)
        )  # Selection background
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )  # Selection text

        # Disabled states
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Text,
            QColor(DARK_TEXT_TERTIARY),
        )  # THIS LINE WAS CAUSING THE NameError
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.ButtonText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.WindowText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Base,
            QColor(DARK_HEADER_FOOTER),
        )

        QApplication.setPalette(palette)
        QApplication.instance().setPalette(palette)  # Ensure it's applied globally

        # Global stylesheet (can be overridden by more specific stylesheets)
        # Styles for common widgets to ensure consistency
        # More specific styling should be done in individual view/widget files
        # using object names or class selectors.
        QApplication.instance().setStyleSheet(
            f"""
            QMainWindow, QDialog, QWidget {{
                font-family: "{DEFAULT_FONT_FAMILY}";
                font-size: 13px;
                color: {DARK_TEXT_PRIMARY};
                background-color: {DARK_BACKGROUND};
            }}
            QToolTip {{
                color: {DARK_TEXT_PRIMARY};
                background-color: {DARK_WIDGET_BACKGROUND};
                border: 1px solid {DARK_BORDER};
                padding: 4px;
                border-radius: 3px;
            }}
            QStatusBar {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_SECONDARY};
                border-top: 1px solid {DARK_BORDER};
            }}
            QStatusBar QLabel {{ /* Ensure labels in status bar inherit color */
                color: {DARK_TEXT_SECONDARY};
                background-color: transparent; /* Important for status bar labels */
                padding: 0 2px; /* Minimal padding for status bar items */
            }}
            QMenuBar {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_PRIMARY};
                border-bottom: 1px solid {DARK_BORDER};
            }}
            QMenuBar::item {{
                spacing: 3px; /* spacing between menu bar items */
                padding: 4px 10px;
                background: transparent;
                border-radius: 4px;
            }}
            QMenuBar::item:selected {{ /* when selected using mouse or keyboard */
                background: {DARK_ITEM_HOVER};
            }}
            QMenuBar::item:pressed {{
                background: {DARK_PRIMARY_ACTION};
            }}
            QMenu {{
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                padding: 5px;
            }}
            QMenu::item {{
                padding: 5px 20px 5px 20px;
            }}
            QMenu::item:selected {{
                background-color: {DARK_HIGHLIGHT_BG};
                color: {DARK_HIGHLIGHT_TEXT};
            }}
            QMenu::separator {{
                height: 1px;
                background: {DARK_BORDER};
                margin-left: 5px;
                margin-right: 5px;
            }}
            /* Basic ScrollBar Styling */
            QScrollBar:vertical {{
                border: 1px solid {DARK_BORDER};
                background: {DARK_WIDGET_BACKGROUND};
                width: 12px;
                margin: 0px 0px 0px 0px;
            }}
            QScrollBar::handle:vertical {{
                background: {DARK_TEXT_SECONDARY};
                min-height: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                border: none;
                background: none;
                height: 0px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }}
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
                background: none;
            }}

            QScrollBar:horizontal {{
                border: 1px solid {DARK_BORDER};
                background: {DARK_WIDGET_BACKGROUND};
                height: 12px;
                margin: 0px 0px 0px 0px;
            }}
            QScrollBar::handle:horizontal {{
                background: {DARK_TEXT_SECONDARY};
                min-width: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
                border: none;
                background: none;
                width: 0px;
                subcontrol-position: left;
                subcontrol-origin: margin;
            }}
            QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {{
                background: none;
            }}
        """
        )
        self.logger.info(
            f"Dark theme palette and global styles applied for {self.__class__.__name__}."
        )
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: END. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

    def update_status(self, message: str, timeout: int = 5000):
        """Displays a message on the status bar for a specified duration."""
        if hasattr(self, "status_bar") and self.status_bar:
            self.status_bar.showMessage(message, timeout)
            self.logger.info(f"Status update: {message}")
        else:
            self.logger.warning(
                f"Attempted to update status for {self.__class__.__name__}, but no status_bar attribute found or it is None."
            )

    def show_info(self, title: str, message: str):
        self.logger.info(f"Displaying Info: {title} - {message}")
        QMessageBox.information(self, title, message)

    def show_warning(self, title: str, message: str):
        self.logger.warning(f"Displaying Warning: {title} - {message}")
        QMessageBox.warning(self, title, message)

    def show_error(self, title: str, message: str):
        self.logger.error(f"Displaying Error: {title} - {message}")
        QMessageBox.critical(self, title, message)

    def show_question(self, title: str, message: str) -> bool:
        self.logger.info(f"Asking Question: {title} - {message}")
        reply = QMessageBox.question(
            self,
            title,
            message,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )
        return reply == QMessageBox.StandardButton.Yes


==== FILE: views/main_menu.py ====
# views/main_menu.py

"""
EDSI Veterinary Management System - Main Menu
Version: 1.0.2
Purpose: Modern unified main menu with consolidated management screens.
         Fixed PyQt6 to PySide6 imports for consistency.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v1.0.2 (2025-05-24):
    - Fixed imports from PyQt6 to PySide6 for consistency with rest of application
    - Changed pyqtSignal to Signal from PySide6.QtCore
- v1.0.1 (2025-05-12): Updated for unified management approach
  - Replaced separate horse operations (Add, Edit, Delete) with single "Horse Management"
  - Removed horse_review_update_selected, add_new_horse_selected, delete_horse_selected signals
  - Added horse_management_selected signal for unified interface
  - Updated menu options to reflect modern management screens
  - Simplified menu structure for better user experience
- v1.0.0 (2025-05-12): Initial implementation
  - Created complete main menu matching COBOL layout
  - Implemented all menu option signals
  - Added keyboard navigation support
  - Included proper styling and layout
"""

from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QGridLayout,
    QLabel,
    QPushButton,
    QFrame,
    QSpacerItem,
    QSizePolicy,
    QGroupBox,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QFont
from views.base_view import BaseView
from config.app_config import AppConfig
import logging


class MainMenu(BaseView):
    """Primary menu screen with unified management approach"""

    # Signals for menu selections
    horse_management_selected = Signal()  # Option 1 - Unified horse operations
    table_maintenance_selected = Signal()  # Option 2
    print_reports_selected = Signal()  # Option 3
    owners_ar_selected = Signal()  # Option 4
    system_utilities_selected = Signal()  # Option 5
    mass_update_selected = Signal()  # Option 6
    logoff_exit_selected = Signal()  # Option 9
    logoff_no_exit_selected = Signal()  # Option X

    def __init__(self, current_user=None):
        self.current_user = current_user or "Unknown"
        super().__init__()
        self.setup_main_menu_ui()
        self.logger = logging.getLogger(self.__class__.__name__)

    def setup_main_menu_ui(self):
        """Setup the main menu UI"""
        self.set_title("Primary Menu")
        self.resize(700, 600)
        self.center_on_screen()

        # Header section
        self.setup_header()

        # Main menu options
        self.setup_menu_options()

        # Footer section
        self.setup_footer()

    def setup_header(self):
        """Setup header with title and user info"""
        header_frame = QFrame()
        header_layout = QVBoxLayout(header_frame)

        # Main title
        title_label = QLabel("EDSI Primary Menu")
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 24, QFont.Weight.Bold)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_PRIMARY_ACTION};
            padding: 10px;
        """
        )

        # User info
        user_info_label = QLabel(f"Current User: {self.current_user}")
        user_info_label.setAlignment(Qt.AlignmentFlag.AlignRight)
        user_info_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_TEXT_SECONDARY};
            font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
            padding: 5px;
        """
        )

        header_layout.addWidget(title_label)
        header_layout.addWidget(user_info_label)

        # Set up the main window layout instead of using the base view methods
        if not hasattr(self, "main_layout"):
            self.main_layout = QVBoxLayout(self.central_widget)
            self.main_layout.setContentsMargins(20, 20, 20, 20)

        self.main_layout.addWidget(header_frame)

    def setup_menu_options(self):
        """Setup main menu options grid"""
        # Create menu group box
        menu_group = QGroupBox("Select an option:")
        menu_group.setStyleSheet(
            f"""
            QGroupBox {{
                font-size: {AppConfig.DEFAULT_FONT_SIZE + 2}pt;
                font-weight: bold;
                color: {AppConfig.DARK_TEXT_PRIMARY};
                padding-top: 15px;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
            }}
        """
        )

        # Create grid layout for menu options
        menu_layout = QGridLayout(menu_group)
        menu_layout.setSpacing(15)
        menu_layout.setContentsMargins(20, 20, 20, 20)

        # Define menu options (number, text, signal) - Updated for unified approach
        menu_options = [
            ("1.", "Horse Management", self.horse_management_selected),
            ("2.", "Table Maintenance", self.table_maintenance_selected),
            ("3.", "Print Reports & Billing", self.print_reports_selected),
            ("4.", "Owners A/R", self.owners_ar_selected),
            ("5.", "System Utilities", self.system_utilities_selected),
            ("6.", "Mass Update", self.mass_update_selected),
            ("9.", "Logoff & Exit", self.logoff_exit_selected),
            ("X.", "Logoff, No Exit", self.logoff_no_exit_selected),
        ]

        # Create buttons for each option
        self.menu_buttons = {}
        row = 0
        col = 0
        max_cols = 2

        for number, text, signal in menu_options:
            button = self.create_menu_button(number, text, signal)
            menu_layout.addWidget(button, row, col)
            self.menu_buttons[number] = button

            col += 1
            if col >= max_cols:
                col = 0
                row += 1

        # Add the menu group to content area
        self.main_layout.addWidget(menu_group, 1)  # Take up most space

    def create_menu_button(self, number, text, signal):
        """Create a styled menu button"""
        button = QPushButton(f"{number} {text}")
        button.setMinimumHeight(50)
        button.setMinimumWidth(280)

        # Special styling for exit options
        if number in ["9.", "X."]:
            button.setStyleSheet(
                f"""
                QPushButton {{
                    background-color: {AppConfig.DARK_DANGER_ACTION};
                    color: white;
                    border: none;
                    padding: 10px;
                    text-align: left;
                    font-size: {AppConfig.DEFAULT_FONT_SIZE + 1}pt;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background-color: #5a6268;
                }}
                QPushButton:pressed {{
                    background-color: #495057;
                }}
            """
            )
        else:
            button.setStyleSheet(
                f"""
                QPushButton {{
                    background-color: {AppConfig.DARK_PRIMARY_ACTION};
                    color: white;
                    border: none;
                    padding: 10px;
                    text-align: left;
                    font-size: {AppConfig.DEFAULT_FONT_SIZE + 1}pt;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background-color: #106ebe;
                }}
                QPushButton:pressed {{
                    background-color: #005a9e;
                }}
            """
            )

        button.clicked.connect(lambda checked, s=signal: s.emit())
        return button

    def setup_footer(self):
        """Setup footer with instructions"""
        footer_frame = QFrame()
        footer_layout = QHBoxLayout(footer_frame)

        instruction_label = QLabel(
            "Select an option by clicking or pressing the corresponding number/letter"
        )
        instruction_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        instruction_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_TEXT_SECONDARY};
            font-style: italic;
            font-size: {AppConfig.SMALL_FONT_SIZE + 1}pt;
            padding: 10px;
        """
        )

        footer_layout.addWidget(instruction_label)
        self.main_layout.addWidget(footer_frame)

    def center_on_screen(self):
        """Center the main menu on the display"""
        screen = self.screen().availableGeometry()
        size = self.geometry()
        self.move(
            (screen.width() - size.width()) // 2, (screen.height() - size.height()) // 2
        )

    def keyPressEvent(self, event):
        """Handle keyboard shortcuts for menu options"""
        key = event.text().upper()

        # Map keys to signals - Updated for unified approach
        key_mappings = {
            "1": self.horse_management_selected,
            "2": self.table_maintenance_selected,
            "3": self.print_reports_selected,
            "4": self.owners_ar_selected,
            "5": self.system_utilities_selected,
            "6": self.mass_update_selected,
            "9": self.logoff_exit_selected,
            "X": self.logoff_no_exit_selected,
        }

        if key in key_mappings:
            self.logger.info(f"Menu option {key} selected via keyboard")
            key_mappings[key].emit()
        else:
            super().keyPressEvent(event)


==== FILE: views/admin/dialogs/add_edit_user_dialog.py ====
# views/admin/dialogs/add_edit_user_dialog.py
"""
EDSI Veterinary Management System - Add/Edit User Dialog
Version: 1.0.0
Purpose: Dialog for creating new users and editing existing user details.
Last Updated: May 20, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-05-20):
    - Initial implementation.
    - Provides form fields for username, full_name, email, password, role, and is_active.
    - Handles both "add" and "edit" modes.
    - Includes basic validation (required fields, password match).
    - Interacts with UserController to save user data.
    - Styled for dark theme.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QComboBox,
    QCheckBox,
    QDialogButtonBox,
    QLabel,
    QMessageBox,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.user_controller import UserController
from models.user_models import User  # Assuming User model is in user_models.py
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_BORDER,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_SUCCESS_ACTION,
    DARK_HEADER_FOOTER,
    DEFAULT_FONT_FAMILY,
)


class AddEditUserDialog(QDialog):
    """Dialog for adding or editing user information."""

    USER_ROLES = ["admin", "vet", "staff", "owner"]  # Define available roles

    def __init__(
        self,
        parent_view,
        user_controller: UserController,
        current_user_object: Optional[User] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.user_controller = user_controller
        self.current_user_object = (
            current_user_object  # User object if editing, None if adding
        )

        self.is_edit_mode = self.current_user_object is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} User")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.current_user_object:
            self._populate_fields()

        self.logger.info(
            f"AddEditUserDialog initialized. Edit mode: {self.is_edit_mode}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(
            QPalette.ColorRole.AlternateBase, QColor(DARK_WIDGET_BACKGROUND)
        )  # for combobox dropdown
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(
            QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red)
        )  # For validation errors if needed
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(
            QPalette.ColorRole.Highlight, QColor(DARK_PRIMARY_ACTION)
        )  # Selection in combobox
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _get_input_field_style(self) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px; /* Ensure fields are not too small */
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QComboBox QAbstractItemView {{ /* Style for the dropdown list */
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_PRIMARY_ACTION}70; /* Alpha for selection */
            }}
            QCheckBox {{
                color: {DARK_TEXT_PRIMARY};
                background-color: transparent;
            }}
            QCheckBox::indicator {{
                width: 13px;
                height: 13px;
            }}
        """

    def _get_dialog_button_style(self) -> str:
        return (
            f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        form_layout = QFormLayout()
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(
            Qt.AlignmentFlag.AlignRight
        )  # Align labels to the right
        form_layout.setFieldGrowthPolicy(
            QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow
        )

        # Input fields
        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter unique username")
        self.full_name_input = QLineEdit()
        self.full_name_input.setPlaceholderText("Enter user's full name")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Enter user's email address")

        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText(
            "Enter password (leave blank to keep current)"
        )
        self.confirm_password_input = QLineEdit()
        self.confirm_password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.confirm_password_input.setPlaceholderText("Confirm new password")

        self.role_combo = QComboBox()
        self.role_combo.addItems(self.USER_ROLES)

        self.is_active_checkbox = QCheckBox("User is Active")
        self.is_active_checkbox.setChecked(True)  # Default for new users

        # Apply styles
        input_style = self._get_input_field_style()
        self.username_input.setStyleSheet(input_style)
        self.full_name_input.setStyleSheet(input_style)
        self.email_input.setStyleSheet(input_style)
        self.password_input.setStyleSheet(input_style)
        self.confirm_password_input.setStyleSheet(input_style)
        self.role_combo.setStyleSheet(input_style)
        self.is_active_checkbox.setStyleSheet(
            input_style
        )  # Checkbox style defined in input_style

        # Add rows to form layout
        form_layout.addRow(QLabel("Username*:"), self.username_input)
        form_layout.addRow(QLabel("Full Name*:"), self.full_name_input)
        form_layout.addRow(QLabel("Email:"), self.email_input)
        form_layout.addRow(
            QLabel("Password:" if self.is_edit_mode else "Password*:"),
            self.password_input,
        )
        form_layout.addRow(QLabel("Confirm Password:"), self.confirm_password_input)
        form_layout.addRow(QLabel("Role*:"), self.role_combo)
        form_layout.addRow(QLabel("Status:"), self.is_active_checkbox)

        # Styling for QLabel in QFormLayout (optional, could be global)
        for i in range(form_layout.rowCount()):
            label_widget = form_layout.labelForField(
                form_layout.itemAt(i, QFormLayout.ItemRole.FieldRole).widget()
            )
            if label_widget:
                label_widget.setStyleSheet(
                    f"color: {DARK_TEXT_SECONDARY}; background: transparent; padding-top: 3px;"
                )

        layout.addLayout(form_layout)

        # Dialog buttons
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Save User" if self.is_edit_mode else "Add User")

        # Apply generic style and then override for OK button
        dialog_button_style = self._get_dialog_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(dialog_button_style)
        ok_button.setStyleSheet(
            dialog_button_style
            + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
        )

        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        """Populate fields if in edit mode."""
        if self.current_user_object:
            self.username_input.setText(self.current_user_object.username)
            self.username_input.setReadOnly(True)  # Username typically not editable
            self.username_input.setStyleSheet(
                self._get_input_field_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; }}"
            )  # Visually indicate read-only
            self.full_name_input.setText(self.current_user_object.full_name or "")
            self.email_input.setText(self.current_user_object.email or "")
            # Password fields remain blank; only for setting new password
            role_index = self.role_combo.findText(
                self.current_user_object.role, Qt.MatchFlag.MatchExactly
            )
            if role_index >= 0:
                self.role_combo.setCurrentIndex(role_index)
            else:
                self.logger.warning(
                    f"Role '{self.current_user_object.role}' not found in USER_ROLES. Defaulting."
                )
                self.role_combo.setCurrentIndex(0)  # Default to first role if not found
            self.is_active_checkbox.setChecked(self.current_user_object.is_active)

    def _validate_input(self) -> bool:
        """Performs basic validation on input fields."""
        username = self.username_input.text().strip()
        full_name = self.full_name_input.text().strip()
        password = self.password_input.text()  # No strip, spaces might be intentional
        confirm_password = self.confirm_password_input.text()
        # email = self.email_input.text().strip() # Email validation can be complex

        if not username:
            QMessageBox.warning(self, "Validation Error", "Username cannot be empty.")
            self.username_input.setFocus()
            return False
        if not full_name:
            QMessageBox.warning(self, "Validation Error", "Full Name cannot be empty.")
            self.full_name_input.setFocus()
            return False

        if not self.is_edit_mode and not password:  # Password required for new user
            QMessageBox.warning(
                self, "Validation Error", "Password cannot be empty for new users."
            )
            self.password_input.setFocus()
            return False

        if password and password != confirm_password:
            QMessageBox.warning(self, "Validation Error", "Passwords do not match.")
            self.confirm_password_input.setFocus()
            return False

        # Basic email format check (very lenient)
        email = self.email_input.text().strip()
        if email and ("@" not in email or "." not in email.split("@")[-1]):
            QMessageBox.warning(
                self, "Validation Error", "Please enter a valid email address."
            )
            self.email_input.setFocus()
            return False

        return True

    def get_user_data(self) -> Optional[Dict]:
        """Collects and returns user data from the form fields."""
        if not self._validate_input():
            return None

        data = {
            "username": self.username_input.text().strip(),
            "full_name": self.full_name_input.text().strip(),
            "email": self.email_input.text().strip()
            or None,  # Allow empty email if not required
            "role": self.role_combo.currentText(),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        # Only include password if it's being set/changed
        password = self.password_input.text()
        if password:
            data["password"] = password  # Controller will hash it

        return data

    def _on_accept(self):
        """Handles the OK/Save button click."""
        user_data = self.get_user_data()
        if user_data is None:
            return  # Validation failed or data issue

        try:
            if self.is_edit_mode and self.current_user_object:
                self.logger.info(
                    f"Attempting to update user ID: {self.current_user_object.user_id}"
                )
                # Username is not in user_data if it's read-only, controller needs user_id
                success, message = self.user_controller.update_user(
                    self.current_user_object.user_id, user_data
                )
            else:
                self.logger.info(
                    f"Attempting to create new user: {user_data['username']}"
                )
                success, message, _ = self.user_controller.create_user(
                    user_data
                )  # create_user returns (success, msg, user_obj)

            if success:
                self.logger.info(f"User operation successful: {message}")
                self.accept()  # Closes the dialog with Accepted status
            else:
                self.logger.warning(f"User operation failed: {message}")
                QMessageBox.critical(self, "Operation Failed", message)
        except Exception as e:
            self.logger.error(f"Error during user save/update: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")


==== FILE: views/admin/dialogs/add_edit_location_dialog.py ====
# views/admin/dialogs/add_edit_location_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Location Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing practice locations.
Last Updated: May 19, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-05-19):
    - Initial implementation for adding and editing locations.
    - Fields: Location Name, Description, Is Active.
    - Uses LocationController for backend operations.
    - Styled for dark theme using imported constants.
"""
# Ensure NO leading spaces/tabs before this comment or the imports below

import logging
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QTextEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.location_controller import LocationController
from models import Location as LocationModel

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class AddEditLocationDialog(QDialog):
    def __init__(
        self,
        parent_view,
        controller: LocationController,
        current_user_id: str,
        location: Optional[LocationModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.controller = controller
        self.current_user_id = current_user_id
        self.location = location
        self.is_edit_mode = location is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Location")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()
        if self.is_edit_mode and self.location:
            self._populate_fields()

    def _get_dialog_specific_input_field_style(self) -> str:
        """Generates style string for input fields within this dialog."""
        return f"""
            QLineEdit, QTextEdit {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QTextEdit:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        """Generates generic button style string for this dialog."""
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.WrapAllRows)
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)

        input_style = self._get_dialog_specific_input_field_style()
        dialog_styles = (
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top:3px; }}"
            + f"QCheckBox::indicator {{ width: 13px; height: 13px; }}"
        )
        self.setStyleSheet(dialog_styles)

        self.location_name_input = QLineEdit()
        self.location_name_input.setStyleSheet(input_style)
        self.location_name_input.setPlaceholderText("e.g., Main Barn, Paddock A")
        form_layout.addRow("Location Name*:", self.location_name_input)

        self.description_input = QTextEdit()
        self.description_input.setStyleSheet(input_style)
        self.description_input.setPlaceholderText(
            "Optional description or details about the location"
        )
        self.description_input.setFixedHeight(80)
        form_layout.addRow("Description:", self.description_input)

        self.is_active_checkbox = QCheckBox("Location is Active")
        self.is_active_checkbox.setChecked(True)
        form_layout.addRow("", self.is_active_checkbox)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith("#"):
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        """Populates fields if in edit mode."""
        if self.location:
            self.location_name_input.setText(self.location.location_name)
            self.description_input.setPlainText(self.location.description or "")
            self.is_active_checkbox.setChecked(self.location.is_active)

    def get_data(self) -> Dict[str, Any]:
        """Collects data from the form fields."""
        return {
            "location_name": self.location_name_input.text().strip(),
            "description": self.description_input.toPlainText().strip(),
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        """Validates form data and accepts dialog if valid."""
        data = self.get_data()

        is_valid, errors = self.controller.validate_location_data(
            data,
            is_new=(not self.is_edit_mode),
            location_id_to_check_for_unique=(
                self.location.location_id
                if self.is_edit_mode and self.location
                else None
            ),
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.location:
                success, message = self.controller.update_location(
                    self.location.location_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_location(
                    data, self.current_user_id
                )

            if success:
                if hasattr(self.parent(), "show_info"):
                    self.parent().show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during location save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


==== FILE: views/admin/dialogs/add_edit_charge_code_dialog.py ====
# views/admin/dialogs/add_edit_charge_code_dialog.py

"""
EDSI Veterinary Management System - Add/Edit Charge Code Dialog
Version: 1.1.3
Purpose: Dialog for creating and editing charge codes.
         Resolves circular import and adds missing Optional/Dict import.
Last Updated: May 19, 2025
Author: Claude Assistant

Changelog:
- v1.1.3 (2025-05-19):
    - Added `from typing import Optional, Dict` to resolve NameError for 'Optional'.
- v1.1.2 (2025-05-19):
    - Resolved circular import with UserManagementScreen by removing the import
      and defining necessary style helper methods locally within this dialog.
- v1.1.1 (2025-05-19):
    - Corrected AppConfig constant usage. Imported constants directly instead of
      accessing them via the AppConfig class for palette and button styling.
- v1.1.0 (2025-05-18):
    - Initial version based on artifact and integrated into UserManagementScreen.
"""

import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, Dict  # ADDED Optional and Dict here

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QTextEdit,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCode as ChargeCodeModel

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class AddEditChargeCodeDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        charge_code: Optional[ChargeCodeModel] = None,
    ):  # Optional is now defined
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.controller = controller
        self.charge_code = charge_code
        self.is_edit_mode = charge_code is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Charge Code")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()
        self._populate_fields()

    def _get_dialog_specific_input_field_style(self):
        """Generates style string for input fields within this dialog."""
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QComboBox::drop-down {{
                border: none; background-color: transparent;
                subcontrol-position: right center; width: 15px;
            }}
            QComboBox::down-arrow {{ image: url(none); }}
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self):
        """Generates generic button style string for this dialog."""
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.WrapAllRows)
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)

        input_style = self._get_dialog_specific_input_field_style()
        dialog_styles = (
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top:3px; }}"
            + f"QCheckBox::indicator {{ width: 13px; height: 13px; }}"
        )
        self.setStyleSheet(dialog_styles)

        self.code_input = QLineEdit()
        self.code_input.setStyleSheet(input_style)
        self.code_input.setPlaceholderText("Unique code (e.g., EXAM01)")
        form_layout.addRow("Code*:", self.code_input)

        self.alt_code_input = QLineEdit()
        self.alt_code_input.setStyleSheet(input_style)
        self.alt_code_input.setPlaceholderText("Alternative code (optional)")
        form_layout.addRow("Alt. Code:", self.alt_code_input)

        self.description_input = QTextEdit()
        self.description_input.setStyleSheet(input_style)
        self.description_input.setPlaceholderText(
            "Detailed description of the charge code"
        )
        self.description_input.setFixedHeight(80)
        form_layout.addRow("Description*:", self.description_input)

        self.category_input = QLineEdit()
        self.category_input.setStyleSheet(input_style)
        self.category_input.setPlaceholderText("e.g., Veterinary, Pharmacy, Boarding")
        form_layout.addRow("Category:", self.category_input)

        self.standard_charge_input = QDoubleSpinBox()
        self.standard_charge_input.setStyleSheet(input_style)
        self.standard_charge_input.setDecimals(2)
        self.standard_charge_input.setRange(0.00, 999999.99)
        self.standard_charge_input.setPrefix("$ ")
        form_layout.addRow("Standard Charge*:", self.standard_charge_input)

        self.is_active_checkbox = QCheckBox("Charge Code is Active")
        self.is_active_checkbox.setChecked(True)
        form_layout.addRow("", self.is_active_checkbox)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith("#"):
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        if self.is_edit_mode and self.charge_code:
            self.code_input.setText(self.charge_code.code)
            self.alt_code_input.setText(self.charge_code.alternate_code or "")
            self.description_input.setPlainText(self.charge_code.description)
            self.category_input.setText(self.charge_code.category or "")
            self.standard_charge_input.setValue(
                float(self.charge_code.standard_charge)
                if self.charge_code.standard_charge is not None
                else 0.0
            )
            self.is_active_checkbox.setChecked(self.charge_code.is_active)
        elif not self.is_edit_mode:
            self.is_active_checkbox.setChecked(True)

    def get_data(self) -> Optional[Dict]:  # Dict is now defined
        code = self.code_input.text().strip().upper()
        description = self.description_input.toPlainText().strip()
        standard_charge_value = self.standard_charge_input.value()

        errors = []
        if not code:
            errors.append("Code is required.")
        if not description:
            errors.append("Description is required.")

        charge_decimal = None
        try:
            charge_decimal = Decimal(str(standard_charge_value))
            if charge_decimal < Decimal("0.00"):
                errors.append("Standard Charge cannot be negative.")
        except InvalidOperation:
            errors.append("Standard Charge must be a valid number.")

        if errors:
            QMessageBox.warning(self, "Input Error", "\n".join(errors))
            return None

        return {
            "code": code,
            "alternate_code": self.alt_code_input.text().strip().upper() or None,
            "description": description,
            "category": self.category_input.text().strip() or None,
            "standard_charge": charge_decimal,
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        data = self.get_data()
        if data is None:
            return

        try:
            if self.is_edit_mode and self.charge_code:
                success, message = self.controller.update_charge_code(
                    self.charge_code.charge_code_id, data
                )
            else:
                success, message, _ = self.controller.create_charge_code(data)

            if success:
                QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(
                f"Error during charge code save/update: {e}", exc_info=True
            )
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


==== FILE: controllers/user_controller.py ====
# controllers/user_controller.py
"""
EDSI Veterinary Management System - User Controller
Version: 1.2.4
Purpose: Handles user authentication, CRUD operations.
         - Aligned password handling with User model's bcrypt methods.
         - Ensured case-insensitive username login.
Last Updated: May 23, 2025
Author: Gemini (based on user's v1.2.3)

Changelog:
- v1.2.4 (2025-05-23):
    - Removed internal `_hash_password` method (used sha256).
    - Modified `authenticate_user` (was `validate_password`) to use `user.check_password()` (bcrypt)
      for password verification, ensuring compatibility with `User.set_password()`.
    - Maintained case-insensitive username lookup using `User.user_id.collate('NOCASE')`.
    - Modified `create_user` to use `new_user.set_password()` for new user passwords.
    - Modified `change_password` to use `user.set_password()` for password changes.
    - Ensured usage of `db_manager.get_session()` (already present in user's v1.2.3).
    - Standardized field name references (e.g., Role.name).
- v1.2.3 (2025-05-21 - User Uploaded version):
    - Modified `create_user` and `update_user` for email field.
    - Ensured role assignment logic is robust.
    - Uses sha256 for passwords.
"""

import logging

# REMOVED: import hashlib (no longer using sha256 here)
from typing import List, Optional, Tuple, Dict, Any
from sqlalchemy.orm import (
    Session,
    joinedload,
)  # Keep Session for type hinting if preferred
from sqlalchemy import func, exc as sqlalchemy_exc
from datetime import datetime

from config.database_config import db_manager
from models.user_models import User, Role, UserRole

# from views.admin.dialogs.add_edit_user_dialog import AddEditUserDialog # Keep as local import


class UserController:
    """Controller for user management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    # REMOVED: def _hash_password(self, password: str) -> str:

    # Renamed for clarity to match typical authentication method naming,
    # and to reflect it now uses User model's check_password.
    def authenticate_user(
        self, login_id_attempt: str, password_attempt: str
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        """
        Authenticates a user.
        Username (login_id_attempt) comparison is case-insensitive.
        Password checking is case-sensitive (via bcrypt in User.check_password).
        """
        self.logger.debug(f"Attempting to authenticate user: {login_id_attempt}")
        session = db_manager.get_session()
        try:
            # Case-insensitive lookup for SQLite using COLLATE NOCASE.
            # User.user_id stores "ADMIN", this allows "admin", "Admin", "ADMIN" to match.
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == login_id_attempt)
                .first()
            )

            if not user:
                self.logger.warning(
                    f"Login ID '{login_id_attempt}' not found during authentication."
                )
                return False, "Invalid Login ID or Password.", None

            # MODIFIED: Use User model's check_password method (bcrypt)
            if not user.check_password(password_attempt):
                self.logger.warning(
                    f"Incorrect password attempt for login ID '{user.user_id}' (input was '{login_id_attempt}')."
                )
                return False, "Invalid Login ID or Password.", None

            if not user.is_active:
                self.logger.warning(
                    f"Login attempt for inactive user '{user.user_id}'."
                )
                return (
                    False,
                    f"User account '{user.user_id}' is inactive.",
                    {
                        "user_id": user.user_id,  # Return the actual stored user_id
                        "user_name": user.user_name,
                        "is_active": user.is_active,
                    },
                )

            # Update last_login if the field exists on your User model
            if hasattr(user, "last_login"):
                user.last_login = datetime.utcnow()

            session.commit()  # Commit last_login update
            self.logger.info(f"User '{user.user_id}' authenticated successfully.")
            return (
                True,
                "Login successful.",
                {
                    "user_id": user.user_id,  # Return the actual stored user_id
                    "user_name": user.user_name,
                    "is_active": user.is_active,
                    # Include roles if your login success handler needs them immediately
                    # "roles": [role.name for role in user.roles] # Example
                },
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error during authentication for '{login_id_attempt}': {e}",
                exc_info=True,
            )
            return False, "An error occurred during login. Please try again.", None
        except Exception as e:  # Catch any other unexpected error
            session.rollback()
            self.logger.error(
                f"Unexpected error during authentication for '{login_id_attempt}': {e}",
                exc_info=True,
            )
            return False, "An unexpected server error occurred. Please try again.", None
        finally:
            session.close()

    def get_all_users(self, include_inactive: bool = True) -> List[User]:
        session = db_manager.get_session()
        try:
            query = session.query(User).options(joinedload(User.roles))
            if not include_inactive:
                query = query.filter(User.is_active == True)
            users = query.order_by(User.user_id).all()
            return users
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all users: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_user_by_login_id(self, login_id_str: str) -> Optional[User]:
        session = db_manager.get_session()
        try:
            # Use collate for consistency if user_id might be searched with varied case
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            return user
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching user by login_id '{login_id_str}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_user_data(
        self,
        user_data: Dict[str, Any],
        is_new: bool = True,
        original_login_id_to_ignore: Optional[str] = None,
    ) -> Tuple[bool, List[str]]:
        from views.admin.dialogs.add_edit_user_dialog import (
            AddEditUserDialog,
        )  # Local import

        errors = []
        # Assuming user_id is passed as 'user_id' in user_data or derived
        login_id = user_data.get("user_id", "").strip()
        display_name = user_data.get("user_name", "").strip()
        password = user_data.get("password", "")
        email_value = user_data.get("email")
        email = email_value.strip() if isinstance(email_value, str) else None

        if not login_id:
            errors.append("Login ID (Username) is required.")
        # User model v1.1.2 (based on user's v1.1.1) has user_id = Column(String(20))
        elif len(login_id) > 20:
            errors.append("Login ID (Username) cannot exceed 20 characters.")
        elif " " in login_id:
            errors.append("Login ID (Username) cannot contain spaces.")
        else:
            session = db_manager.get_session()
            try:
                # For uniqueness checks, typically case-insensitive for username if login is case-insensitive
                query = session.query(User).filter(
                    User.user_id.collate("NOCASE") == login_id
                )
                if not is_new and original_login_id_to_ignore is not None:
                    query = query.filter(
                        User.user_id.collate("NOCASE") != original_login_id_to_ignore
                    )

                if query.first():
                    errors.append(f"Login ID (Username) '{login_id}' already exists.")

                if email:  # Check email uniqueness if provided
                    email_query = session.query(User).filter(User.email == email)
                    user_to_exclude_from_email_check = None
                    if not is_new and original_login_id_to_ignore:
                        user_to_exclude_from_email_check = (
                            session.query(User.user_id)
                            .filter(
                                User.user_id.collate("NOCASE")
                                == original_login_id_to_ignore
                            )
                            .first()
                        )

                    if user_to_exclude_from_email_check:
                        email_query = email_query.filter(
                            User.user_id != user_to_exclude_from_email_check.user_id
                        )

                    if email_query.first():
                        errors.append(f"Email '{email}' is already in use.")
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                self.logger.error(
                    f"DB error validating login_id/email uniqueness: {e_db}",
                    exc_info=True,
                )
                errors.append("Error validating login_id/email uniqueness.")
            finally:
                session.close()

        if not display_name:
            errors.append("Full Name (User Name) is required.")
        elif len(display_name) > 100:  # User model user_name = Column(String(100))
            errors.append("Full Name (User Name) cannot exceed 100 characters.")

        if is_new:
            if not password:
                errors.append("Password is required for new users.")
            elif len(password) < 6:  # Arbitrary minimum length, adjust as needed
                errors.append("Password must be at least 6 characters long.")
        elif password and len(password) < 6:  # If password provided for update
            errors.append("New password must be at least 6 characters long.")

        if email and (
            len(email) > 100 or ("@" not in email or "." not in email.split("@")[-1])
        ):  # User model email = Column(String(100))
            errors.append(
                "Invalid email format or email too long (max 100 characters)."
            )

        role_str = user_data.get("role")  # Assuming role is passed as string name
        if not role_str and is_new:
            errors.append("Role is required for new users.")
        elif (
            role_str
            and hasattr(AddEditUserDialog, "USER_ROLES")
            and role_str not in AddEditUserDialog.USER_ROLES
        ):
            errors.append(
                f"Selected role '{role_str}' is not a recognized role option."
            )
        # Further validation: check if role_str exists in DB
        elif role_str:
            session = db_manager.get_session()
            try:
                if (
                    not session.query(Role).filter(Role.name == role_str).first()
                ):  # Role.name
                    errors.append(f"Role '{role_str}' does not exist in the database.")
            finally:
                session.close()
        return not errors, errors

    def create_user(
        self, user_data: Dict[str, Any], current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[User]]:
        # Use user_id from user_data, ensure it's processed (e.g. upper for storage if desired)
        # The user's v1.2.3 used user_data.get("username", "").strip().upper() for user_id
        # For consistency with case-insensitive login, store 'ADMIN' as 'ADMIN'
        # but allow flexible input for other users if needed.
        # Let's assume user_id is provided directly and should be stored as-is,
        # unless there's a specific rule to uppercase it for all users.
        # Given 'ADMIN' is special, we ensure it's stored as 'ADMIN'.

        login_id_to_store = user_data.get("user_id", "").strip()
        if (
            login_id_to_store.upper() == "ADMIN"
        ):  # Normalize ADMIN user_id to uppercase for storage
            login_id_to_store = "ADMIN"

        # Prepare data for User model, aligning with its fields
        data_for_model = {
            "user_id": login_id_to_store,
            "user_name": user_data.get("user_name", "").strip(),
            "email": user_data.get("email"),  # Will be processed for None/empty string
            "is_active": user_data.get("is_active", True),
            "created_by": current_admin_id,
            "modified_by": current_admin_id,
            # Include other User fields from your user_models.py v1.1.1/v1.1.2 if they can be set at creation
            "printer_id": user_data.get("printer_id"),
            "default_screen_colors": user_data.get("default_screen_colors"),
        }

        # Password will be set via set_password method
        password_to_set = user_data.get("password", "")
        role_name_to_assign = user_data.get("role")

        # Validate pre-processed data (user_id as is, role as name)
        validation_payload = {
            **data_for_model,
            "password": password_to_set,
            "role": role_name_to_assign,
        }
        is_valid, errors = self.validate_user_data(validation_payload, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            processed_email = data_for_model["email"]
            if isinstance(processed_email, str):
                processed_email = processed_email.strip()
                if not processed_email:  # Empty string to None
                    processed_email = None
            data_for_model["email"] = processed_email

            # Remove password from data_for_model as it's set via method
            new_user = User(**data_for_model)
            new_user.set_password(password_to_set)  # MODIFIED: Use set_password

            if role_name_to_assign:
                role_obj = (
                    session.query(Role).filter(Role.name == role_name_to_assign).first()
                )  # Role.name
                if role_obj:
                    new_user.roles.append(role_obj)
                else:  # Should be caught by validation
                    self.logger.error(
                        f"Role '{role_name_to_assign}' not found for new user '{new_user.user_id}'."
                    )
                    # Decide if this is a rollback scenario

            session.add(new_user)
            session.commit()
            session.refresh(new_user)
            self.logger.info(
                f"User '{new_user.user_id}' created successfully by {current_admin_id}."
            )
            return True, "User created successfully.", new_user
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e.orig}",
                exc_info=True,
            )
            # ... (error parsing logic from user's v1.2.3 can be kept)
            error_str = str(e.orig).lower()
            if "unique constraint failed: users.user_id" in error_str:
                return (
                    False,
                    f"Login ID (Username) '{data_for_model['user_id']}' already exists.",
                    None,
                )
            elif (
                "unique constraint failed: users.email" in error_str
                and data_for_model["email"]
            ):
                return (
                    False,
                    f"Email '{data_for_model['email']}' is already in use.",
                    None,
                )
            return False, f"Database integrity error: {e.orig}", None
        except Exception as e:  # Broader exception
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e}",
                exc_info=True,
            )
            return False, f"Failed to create user: {e}", None
        finally:
            session.close()

    def update_user(
        self,
        user_id_to_update: str,  # Changed from login_id_str_pk for clarity
        user_data: Dict[str, Any],
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            # Fetch user case-insensitively for update target
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == user_id_to_update)
                .first()
            )
            if not user:
                return False, f"User with Login ID '{user_id_to_update}' not found."

            # Prepare data for validation, using existing user values as fallback
            validation_data = {
                "user_id": user.user_id,  # Use actual stored user_id for validation context
                "user_name": user_data.get("user_name", user.user_name),
                "email": user_data.get("email", user.email),
                "role": user_data.get("role"),  # Role name string
            }
            if (
                "password" in user_data and user_data["password"]
            ):  # only if new password provided
                validation_data["password"] = user_data["password"]

            is_valid, errors = self.validate_user_data(
                validation_data, is_new=False, original_login_id_to_ignore=user.user_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            # Apply updates
            if "user_name" in user_data:
                user.user_name = user_data["user_name"].strip()

            if "email" in user_data:
                email_val = user_data["email"]
                user.email = email_val.strip() if isinstance(email_val, str) else None
                if user.email == "":
                    user.email = None

            if "password" in user_data and user_data["password"]:
                user.set_password(user_data["password"])  # MODIFIED: Use set_password

            if "is_active" in user_data:
                if user.user_id.upper() == "ADMIN" and not user_data["is_active"]:
                    # Prevent deactivating the sole admin logic (from user's v1.2.3)
                    active_admin_query = session.query(User).filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    if user.is_active:  # if current user is the one being deactivated
                        if active_admin_query.count() <= 1:
                            self.logger.warning(
                                f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') was prevented."
                            )
                            return (
                                False,
                                "Cannot deactivate the last active ADMIN user.",
                            )
                    user.is_active = user_data["is_active"]
                else:
                    user.is_active = user_data["is_active"]

            new_role_name = user_data.get("role")
            if (
                new_role_name is not None
            ):  # Allow empty string or None to signify role removal if desired, or handle explicit 'no change'
                user.roles.clear()  # Simple approach: clear and re-add. More complex logic for partial updates if needed.
                if (
                    new_role_name
                ):  # If a new role is actually specified (not empty string)
                    role_obj = (
                        session.query(Role).filter(Role.name == new_role_name).first()
                    )  # Role.name
                    if role_obj:
                        user.roles.append(role_obj)
                    else:  # Should be caught by validation
                        self.logger.error(
                            f"Role object for '{new_role_name}' not found. Role not updated for user '{user.user_id}'."
                        )
                        # Potentially rollback or return error if role assignment is critical
                        # session.rollback(); return False, f"Role '{new_role_name}' not found."

            # Update other fields from user_models.py v1.1.1/v1.1.2 if they are updatable
            if "printer_id" in user_data:
                user.printer_id = user_data["printer_id"]
            if "default_screen_colors" in user_data:
                user.default_screen_colors = user_data["default_screen_colors"]

            user.modified_by = current_admin_id
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' updated successfully by {current_admin_id}."
            )
            return True, "User updated successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            # ... (error parsing from user's v1.2.3 for email can be kept)
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e.orig}", exc_info=True
            )
            if "unique constraint failed: users.email" in str(
                e.orig
            ).lower() and validation_data.get("email"):
                return (
                    False,
                    f"Email '{validation_data['email']}' is already in use by another user.",
                )
            return False, f"Database integrity error: {e.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e}", exc_info=True
            )
            return False, f"Failed to update user: {str(e)}"
        finally:
            session.close()

    def change_password(
        self,
        login_id_str: str,
        new_password: str,
        current_admin_id: Optional[str] = None,  # User performing the change
    ) -> Tuple[bool, str]:
        if not new_password or len(new_password) < 6:  # Keep password policy
            return False, "New password must be at least 6 characters long."

        session = db_manager.get_session()
        try:
            # Fetch user case-insensitively
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if not user:
                return False, f"User '{login_id_str}' not found."

            user.set_password(new_password)  # MODIFIED: Use set_password
            user.modified_by = current_admin_id
            # user.modified_at is handled by BaseModel

            session.commit()
            self.logger.info(
                f"Password changed successfully for user '{user.user_id}' by {current_admin_id}."
            )
            return True, "Password changed successfully."
        except Exception as e:  # Catch all, including SQLAlchemyError
            session.rollback()
            self.logger.error(
                f"Error changing password for user '{login_id_str}': {e}", exc_info=True
            )
            return False, f"Failed to change password: {str(e)}"
        finally:
            session.close()

    def get_user_roles(self, login_id_str: str) -> List[str]:
        session = db_manager.get_session()
        try:
            # Fetch user case-insensitively
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if user and user.roles:
                return [role.name for role in user.roles]  # Role.name
            return []
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching roles for user '{login_id_str}': {e}", exc_info=True
            )
            return []
        finally:
            session.close()

    def delete_user_permanently(  # Renamed from user's v1.2.3 for clarity, was delete_user
        self, user_id_to_delete: str, current_admin_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            # Fetch user case-sensitively for delete, or case-insensitively if desired.
            # For safety, usually PK lookups for delete are case-sensitive.
            # However, if user_id can be entered with different casing, use collate.
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_id_to_delete)
                .first()
            )
            if not user:
                return False, f"User '{user_id_to_delete}' not found."

            # Prevent deleting the main 'ADMIN' user if it's the last active one (from user's v1.2.3 logic)
            if user.user_id.upper() == "ADMIN":
                active_admin_count = (
                    session.query(User)
                    .filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    .count()
                )
                if (
                    active_admin_count <= 1 and user.is_active
                ):  # Only protect if this user is one of the last active admins
                    self.logger.warning(
                        f"Attempt to delete the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                    )
                    return (
                        False,
                        "Cannot delete the primary ADMIN account if it's the last active one.",
                    )

            session.delete(
                user
            )  # SQLAlchemy handles related UserRole entries via cascade on User.roles if set up
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"User '{user.user_id}' deleted successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Database integrity error deleting user '{user_id_to_delete}': {e.orig}",
                exc_info=True,
            )
            return (
                False,
                f"Cannot delete user. They may be referenced by other records. ({e.orig})",
            )
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error deleting user '{user_id_to_delete}': {e}", exc_info=True
            )
            return False, f"Failed to delete user: {str(e)}"
        finally:
            session.close()

    def get_all_roles(
        self,
    ) -> List[Role]:  # Added from my v1.1.3 proposal, useful for UI
        session = db_manager.get_session()
        try:
            roles = session.query(Role).order_by(Role.name).all()
            self.logger.info(f"Retrieved {len(roles)} roles.")
            return roles
        except SQLAlchemyError as e:
            self.logger.error(f"Error retrieving roles: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()


==== FILE: controllers/location_controller.py ====
# controllers/location_controller.py
"""
EDSI Veterinary Management System - Location Controller
Version: 1.1.0 (Based on GitHub v1.0.0)
Purpose: Handles business logic for managing practice locations.
         Enhanced to handle all detailed address and contact fields from Location model.
         Added eager loading for state relationship to prevent DetachedInstanceError.
Last Updated: May 20, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-05-20):
    - (Based on GitHub v1.0.0)
    - Enhanced `validate_location_data` to include checks for new address/contact fields
      (e.g., length checks for address lines, city, zip, phone, email format).
    - Modified `create_location` to accept and store all new address and contact fields
      from the Location model (address_line1, address_line2, city, state_code,
      zip_code, country_code, phone, email, contact_person). Sanitizes empty strings
      to None for nullable fields.
    - Modified `update_location` to allow updating of all new address and contact fields,
      with similar sanitization.
    - Added `_sanitize_value` helper method for consistent input cleaning.
    - Updated `get_location_by_id` and `get_all_locations` to use `joinedload` for
      the `state` relationship to prevent DetachedInstanceError.
    - Added `delete_location` method with a placeholder for dependency checking (critical).
      (Note: The previous v1.0.0 from user did not have delete_location, this adds it back
       from what would be expected in a full CRUD controller, aligning with prior discussions
       if this controller was previously more complete).
- v1.0.0 (2025-05-19):
    - Initial implementation with CRUD operations for Locations (name, description, active).
    - Includes validation for location_name (required, unique).
"""
import logging
from typing import List, Optional, Tuple, Dict, Any
from sqlalchemy.orm import Session, joinedload  # Added joinedload
from sqlalchemy import exc as sqlalchemy_exc
import re  # For email validation

from config.database_config import db_manager
from models import (
    Location as LocationModel,
    StateProvince as StateProvinceModel,  # For type hinting and validation if needed
)
from models.base_model import BaseModel


class LocationController:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def _sanitize_value(
        self, value: Optional[str], max_length: Optional[int] = None
    ) -> Optional[str]:
        """Helper to strip whitespace and optionally truncate. Returns None if empty after strip."""
        if value is None:
            return None
        stripped_value = str(value).strip()
        if not stripped_value:
            return None
        if max_length is not None and len(stripped_value) > max_length:
            # Optionally log truncation or handle as an error in validation instead
            self.logger.warning(
                f"Value truncated from '{stripped_value}' to max length {max_length}"
            )
            return stripped_value[:max_length]
        return stripped_value

    def validate_location_data(
        self,
        location_data: Dict[str, Any],
        is_new: bool = True,
        location_id_to_check_for_unique: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        """Validates location data before saving, including all address/contact fields."""
        errors = []
        location_name = self._sanitize_value(location_data.get("location_name"), 100)

        if not location_name:
            errors.append("Location Name is required.")
        # Removed length check for location_name here as _sanitize_value handles it,
        # but explicit validation error is better if truncation is not desired.
        # For now, assuming truncation is acceptable if it happens via _sanitize_value.
        # If not, add: elif len(location_data.get("location_name", "").strip()) > 100:
        # errors.append("Location Name cannot exceed 100 characters.")

        else:  # Check uniqueness only if location_name is present
            session = db_manager.get_session()
            try:
                query = session.query(LocationModel).filter(
                    LocationModel.location_name == location_name
                )
                if not is_new and location_id_to_check_for_unique is not None:
                    query = query.filter(
                        LocationModel.location_id != location_id_to_check_for_unique
                    )
                if query.first():
                    errors.append(
                        f"A location with the name '{location_name}' already exists."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"Database error during location name uniqueness check: {e}",
                    exc_info=True,
                )
                errors.append(
                    "A database error occurred while validating the location name."
                )
            finally:
                session.close()

        # Validate other fields (lengths are based on typical DB constraints, adjust if needed)
        # Model definition for Location uses String(255) for address_line1, address_line2, description
        # String(100) for city, contact_person, email
        # String(30) for phone
        # String(20) for zip_code
        # String(10) for state_code, country_code

        fields_to_validate_length = {
            "address_line1": 255,
            "address_line2": 255,
            "city": 100,
            "zip_code": 20,
            "country_code": 10,
            "phone": 30,
            "email": 100,
            "contact_person": 100,
            "description": 255,
        }
        for field, max_len in fields_to_validate_length.items():
            value = location_data.get(field)
            if value is not None and len(str(value).strip()) > max_len:
                errors.append(
                    f"{field.replace('_', ' ').title()} cannot exceed {max_len} characters."
                )

        email_val = self._sanitize_value(location_data.get("email"), 100)
        if email_val and not re.match(
            r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email_val
        ):
            errors.append("Invalid email format.")

        state_code_val = self._sanitize_value(location_data.get("state_code"), 10)
        if state_code_val:  # If state_code is provided, check if it exists
            session = db_manager.get_session()
            try:
                if (
                    not session.query(StateProvinceModel)
                    .filter(StateProvinceModel.state_code == state_code_val)
                    .first()
                ):
                    errors.append(f"State Code '{state_code_val}' is not valid.")
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(f"DB error validating state_code: {e}", exc_info=True)
                errors.append("Error validating state code.")
            finally:
                session.close()

        return not errors, errors

    def create_location(
        self, location_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str, Optional[LocationModel]]:
        """Creates a new location with all fields."""
        is_valid, errors = self.validate_location_data(location_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_location = LocationModel(
                location_name=self._sanitize_value(
                    location_data["location_name"], 100
                ),  # Already validated not empty
                address_line1=self._sanitize_value(
                    location_data.get("address_line1"), 255
                ),
                address_line2=self._sanitize_value(
                    location_data.get("address_line2"), 255
                ),
                city=self._sanitize_value(location_data.get("city"), 100),
                state_code=self._sanitize_value(location_data.get("state_code"), 10),
                zip_code=self._sanitize_value(location_data.get("zip_code"), 20),
                country_code=self._sanitize_value(
                    location_data.get("country_code"), 10
                ),
                phone=self._sanitize_value(location_data.get("phone"), 30),
                email=self._sanitize_value(location_data.get("email"), 100),
                contact_person=self._sanitize_value(
                    location_data.get("contact_person"), 100
                ),
                description=self._sanitize_value(location_data.get("description"), 255),
                is_active=location_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_location)
            session.commit()
            session.refresh(new_location)
            if new_location.state_code:  # Eager load state if it exists after creation
                session.query(LocationModel).options(
                    joinedload(LocationModel.state)
                ).filter_by(location_id=new_location.location_id).one()

            self.logger.info(
                f"Location '{new_location.location_name}' (ID: {new_location.location_id}) created by {current_user_id}."
            )
            return True, "Location created successfully.", new_location
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating location: {ie.orig}", exc_info=True
            )
            return (
                False,
                f"Database integrity error: Could not save location. It might already exist or a foreign key is invalid. {ie.orig}",
                None,
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(f"SQLAlchemyError creating location: {e}", exc_info=True)
            return False, f"Database error creating location: {e}", None
        finally:
            session.close()

    def update_location(
        self, location_id: int, location_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[
        bool, str, Optional[LocationModel]
    ]:  # Added Optional[LocationModel] to return type
        """Updates an existing location with all fields."""
        is_valid, errors = self.validate_location_data(
            location_data, is_new=False, location_id_to_check_for_unique=location_id
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            location = (
                session.query(LocationModel)
                .filter(LocationModel.location_id == location_id)
                .first()
            )
            if not location:
                return False, "Location not found.", None

            location.location_name = self._sanitize_value(
                location_data["location_name"], 100
            )  # Validated not empty
            location.address_line1 = self._sanitize_value(
                location_data.get("address_line1"), 255
            )
            location.address_line2 = self._sanitize_value(
                location_data.get("address_line2"), 255
            )
            location.city = self._sanitize_value(location_data.get("city"), 100)
            location.state_code = self._sanitize_value(
                location_data.get("state_code"), 10
            )
            location.zip_code = self._sanitize_value(location_data.get("zip_code"), 20)
            location.country_code = self._sanitize_value(
                location_data.get("country_code"), 10
            )
            location.phone = self._sanitize_value(location_data.get("phone"), 30)
            location.email = self._sanitize_value(location_data.get("email"), 100)
            location.contact_person = self._sanitize_value(
                location_data.get("contact_person"), 100
            )
            location.description = self._sanitize_value(
                location_data.get("description"), 255
            )

            if "is_active" in location_data:
                location.is_active = location_data["is_active"]
            location.modified_by = current_user_id

            session.commit()
            session.refresh(location)  # Refresh to get updated state
            if location.state_code:  # Eager load state if it exists after update
                session.query(LocationModel).options(
                    joinedload(LocationModel.state)
                ).filter_by(location_id=location.location_id).one()

            self.logger.info(
                f"Location '{location.location_name}' (ID: {location.location_id}) updated by {current_user_id}."
            )
            return True, "Location updated successfully.", location
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError updating location: {ie.orig}", exc_info=True
            )
            return (
                False,
                f"Database integrity error: Could not update location. Name might conflict or FK invalid. {ie.orig}",
                None,
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(f"SQLAlchemyError updating location: {e}", exc_info=True)
            return False, f"Database error updating location: {e}", None
        finally:
            session.close()

    def get_location_by_id(self, location_id: int) -> Optional[LocationModel]:
        """Fetches a single location by its ID, eagerly loading state."""
        session = db_manager.get_session()
        try:
            location = (
                session.query(LocationModel)
                .options(joinedload(LocationModel.state))  # Eager load state
                .filter(LocationModel.location_id == location_id)
                .first()
            )
            return location
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching location by ID {location_id}: {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def get_all_locations(self, status_filter: str = "all") -> List[LocationModel]:
        """
        Fetches all locations, optionally filtered by active status, eagerly loading state.
        status_filter: "all", "active", "inactive"
        """
        session = db_manager.get_session()
        try:
            query = session.query(LocationModel).options(
                joinedload(LocationModel.state)
            )  # Eager load state
            if status_filter == "active":
                query = query.filter(LocationModel.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(LocationModel.is_active == False)

            locations = query.order_by(LocationModel.location_name).all()
            return locations
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching all locations with filter '{status_filter}': {e}",
                exc_info=True,
            )
            return []
        finally:
            session.close()

    def toggle_location_status(
        self, location_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        """Toggles the active status of a location."""
        session = db_manager.get_session()
        try:
            location = (
                session.query(LocationModel)
                .filter(LocationModel.location_id == location_id)
                .first()
            )
            if not location:
                return False, "Location not found."

            location.is_active = not location.is_active
            location.modified_by = current_user_id
            action_desc = "activated" if location.is_active else "deactivated"

            session.commit()
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location.location_id}) status changed to {action_desc} by {current_user_id}."
            )
            return True, f"Location '{location.location_name}' has been {action_desc}."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error toggling location status for ID {location_id}: {e}",
                exc_info=True,
            )
            return False, "Database error occurred while changing location status."
        finally:
            session.close()

    def delete_location(
        self, location_id: int, current_user_id: str  # Added current_user_id
    ) -> Tuple[bool, str]:
        """
        Deletes a location. Includes a basic check for horse assignment.
        """
        session = db_manager.get_session()
        try:
            location = (
                session.query(LocationModel)
                .filter(LocationModel.location_id == location_id)
                .first()
            )
            if not location:
                return False, "Location not found."

            # Basic dependency check: Are any horses assigned to this location?
            # This requires Horse model.
            from models import Horse as HorseModel  # Local import for dependency check

            if (
                session.query(HorseModel)
                .filter(HorseModel.current_location_id == location_id)
                .first()
            ):
                return (
                    False,
                    "Cannot delete location: It is currently assigned to one or more horses. Please deactivate it instead.",
                )

            self.logger.warning(
                f"Attempting hard delete of location ID {location_id} ('{location.location_name}') by user {current_user_id}."
            )
            location_name_for_msg = location.location_name  # Store before delete
            session.delete(location)
            session.commit()
            self.logger.info(
                f"Location ID {location_id} ('{location_name_for_msg}') permanently deleted by {current_user_id}."
            )
            return True, f"Location '{location_name_for_msg}' permanently deleted."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError deleting location: {ie.orig}", exc_info=True
            )
            # This might also catch FK violations if a horse was somehow still assigned
            # despite the check, or other DB constraints.
            return (
                False,
                f"Cannot delete location. It might be in use or referenced by other records. ({ie.orig})",
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error deleting location ID {location_id}: {e}", exc_info=True
            )
            return False, "Database error occurred while deleting location."
        finally:
            session.close()


==== FILE: controllers/charge_code_controller.py ====
# controllers/charge_code_controller.py

"""
EDSI Veterinary Management System - Charge Code Controller
Version: 1.0.0
Purpose: Business logic for charge code operations including CRUD and validation.
Last Updated: May 17, 2025
Author: Claude Assistant
"""

import logging
from typing import List, Optional, Tuple, Dict
from decimal import Decimal, InvalidOperation

from sqlalchemy.orm import Session
from sqlalchemy import or_, func

from config.database_config import db_manager
from models import ChargeCode


class ChargeCodeController:
    """Controller for charge code operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def validate_charge_code_data(
        self, charge_data: dict, is_new: bool = True
    ) -> Tuple[bool, List[str]]:
        """
        Validates charge code data.
        Args:
            charge_data: Dictionary containing charge code information.
                         Expected keys: 'code', 'description', 'standard_charge',
                                        'alternate_code' (optional), 'category' (optional).
            is_new: Boolean indicating if this is for a new charge code (True) or an update (False).
        Returns:
            Tuple (is_valid, list_of_errors).
        """
        errors = []
        code = charge_data.get("code", "").strip()
        description = charge_data.get("description", "").strip()
        standard_charge_str = str(
            charge_data.get("standard_charge", "")
        ).strip()  # Ensure it's a string for Decimal conversion

        if not code:
            errors.append("Charge Code (Code) is required.")
        elif len(code) > 50:
            errors.append("Charge Code (Code) cannot exceed 50 characters.")

        if (
            is_new and code
        ):  # Check for duplicate code only if it's a new entry and code is provided
            if self.get_charge_code_by_code(code):
                errors.append(f"Charge Code '{code}' already exists.")

        if not description:
            errors.append("Description is required.")
        elif len(description) > 255:
            errors.append("Description cannot exceed 255 characters.")

        if not standard_charge_str:
            errors.append("Standard Charge is required.")
        else:
            try:
                charge_value = Decimal(standard_charge_str)
                if charge_value < Decimal("0.00"):
                    errors.append("Standard Charge cannot be negative.")
                # Numeric(10,2) means up to 99,999,999.99.
                # We can add a check for total digits if necessary, but SQLAlchemy handles precision.
            except InvalidOperation:
                errors.append("Standard Charge must be a valid number (e.g., 25.00).")

        alternate_code = charge_data.get("alternate_code", "").strip()
        if alternate_code and len(alternate_code) > 50:
            errors.append("Alternate Code cannot exceed 50 characters.")

        category = charge_data.get("category", "").strip()
        if category and len(category) > 100:
            errors.append("Category cannot exceed 100 characters.")

        return not errors, errors

    def create_charge_code(
        self, charge_data: dict
    ) -> Tuple[bool, str, Optional[ChargeCode]]:
        """
        Creates a new charge code.
        Args:
            charge_data: Dictionary of charge code data.
        Returns:
            Tuple (success_bool, message_str, charge_code_object_or_None).
        """
        is_valid, errors = self.validate_charge_code_data(charge_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_charge_code = ChargeCode(
                code=charge_data["code"].strip(),
                description=charge_data["description"].strip(),
                standard_charge=Decimal(str(charge_data["standard_charge"]).strip()),
                alternate_code=charge_data.get("alternate_code", "").strip() or None,
                category=charge_data.get("category", "").strip() or None,
                is_active=charge_data.get("is_active", True),  # Default to active
            )
            session.add(new_charge_code)
            session.commit()
            session.refresh(new_charge_code)
            self.logger.info(
                f"Charge Code '{new_charge_code.code}' created successfully (ID: {new_charge_code.charge_code_id})."
            )
            return True, "Charge code created successfully.", new_charge_code
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating charge code: {e}", exc_info=True)
            return False, f"Failed to create charge code: {str(e)}", None
        finally:
            session.close()

    def get_charge_code_by_id(self, charge_code_id: int) -> Optional[ChargeCode]:
        session = db_manager.get_session()
        try:
            return (
                session.query(ChargeCode)
                .filter(ChargeCode.charge_code_id == charge_code_id)
                .first()
            )
        except Exception as e:
            self.logger.error(
                f"Error fetching charge code by ID {charge_code_id}: {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def get_charge_code_by_code(self, code: str) -> Optional[ChargeCode]:
        """Fetches a charge code by its primary code (case-sensitive)."""
        session = db_manager.get_session()
        try:
            return session.query(ChargeCode).filter(ChargeCode.code == code).first()
        except Exception as e:
            self.logger.error(
                f"Error fetching charge code by code '{code}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def get_all_charge_codes(
        self, search_term: str = "", status_filter: str = "all"
    ) -> List[ChargeCode]:
        """
        Retrieves all charge codes, optionally filtered by search term and active status.
        Args:
            search_term: Term to search in code, alternate_code, description, or category.
            status_filter: "all", "active", or "inactive".
        Returns:
            List of ChargeCode objects.
        """
        session = db_manager.get_session()
        try:
            query = session.query(ChargeCode)

            if status_filter == "active":
                query = query.filter(ChargeCode.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(ChargeCode.is_active == False)

            if search_term:
                like_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        ChargeCode.code.ilike(like_pattern),
                        ChargeCode.alternate_code.ilike(like_pattern),
                        ChargeCode.description.ilike(like_pattern),
                        ChargeCode.category.ilike(like_pattern),
                    )
                )

            return query.order_by(ChargeCode.category, ChargeCode.code).all()
        except Exception as e:
            self.logger.error(f"Error fetching all charge codes: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def update_charge_code(
        self, charge_code_id: int, charge_data: dict
    ) -> Tuple[bool, str]:
        """
        Updates an existing charge code.
        Args:
            charge_code_id: The ID of the charge code to update.
            charge_data: Dictionary containing updated data.
        Returns:
            Tuple (success_bool, message_str).
        """
        session = db_manager.get_session()
        try:
            charge_code_to_update = (
                session.query(ChargeCode)
                .filter(ChargeCode.charge_code_id == charge_code_id)
                .first()
            )
            if not charge_code_to_update:
                return False, "Charge code not found."

            # Validate, but exclude current code from unique check if it hasn't changed
            original_code = charge_code_to_update.code
            current_code_in_data = charge_data.get("code", "").strip()

            # If code is being changed, it must be unique among other records
            if current_code_in_data and current_code_in_data != original_code:
                existing_with_new_code = self.get_charge_code_by_code(
                    current_code_in_data
                )
                if (
                    existing_with_new_code
                    and existing_with_new_code.charge_code_id != charge_code_id
                ):
                    return (
                        False,
                        f"Validation failed: Charge Code '{current_code_in_data}' already exists for another record.",
                    )

            # For other validations, pass all data
            is_valid, errors = self.validate_charge_code_data(charge_data, is_new=False)
            if not is_valid:
                # Filter out potential duplicate error if code wasn't actually changed
                if current_code_in_data == original_code:
                    errors = [
                        e
                        for e in errors
                        if not e.startswith(
                            f"Charge Code '{original_code}' already exists."
                        )
                    ]
                if errors:  # If other errors remain
                    return False, "Validation failed: " + "; ".join(errors)

            charge_code_to_update.code = charge_data.get(
                "code", charge_code_to_update.code
            ).strip()
            charge_code_to_update.description = charge_data.get(
                "description", charge_code_to_update.description
            ).strip()

            if (
                "standard_charge" in charge_data
            ):  # Ensure it's present before trying to convert
                charge_code_to_update.standard_charge = Decimal(
                    str(charge_data["standard_charge"]).strip()
                )

            charge_code_to_update.alternate_code = charge_data.get(
                "alternate_code", charge_code_to_update.alternate_code
            )
            if charge_code_to_update.alternate_code:
                charge_code_to_update.alternate_code = (
                    charge_code_to_update.alternate_code.strip()
                )

            charge_code_to_update.category = charge_data.get(
                "category", charge_code_to_update.category
            )
            if charge_code_to_update.category:
                charge_code_to_update.category = charge_code_to_update.category.strip()

            if "is_active" in charge_data:
                charge_code_to_update.is_active = charge_data["is_active"]

            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code_to_update.code}' (ID: {charge_code_id}) updated."
            )
            return True, "Charge code updated successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating charge code ID {charge_code_id}: {e}", exc_info=True
            )
            return False, f"Failed to update charge code: {str(e)}"
        finally:
            session.close()

    def toggle_charge_code_status(self, charge_code_id: int) -> Tuple[bool, str]:
        """Toggles the is_active status of a charge code."""
        session = db_manager.get_session()
        try:
            charge_code = (
                session.query(ChargeCode)
                .filter(ChargeCode.charge_code_id == charge_code_id)
                .first()
            )
            if not charge_code:
                return False, "Charge code not found."

            charge_code.is_active = not charge_code.is_active
            new_status = "active" if charge_code.is_active else "inactive"
            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code.code}' (ID: {charge_code_id}) status changed to {new_status}."
            )
            return True, f"Charge code '{charge_code.code}' status set to {new_status}."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error toggling status for charge code ID {charge_code_id}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle charge code status: {str(e)}"
        finally:
            session.close()


==== FILE: controllers/owner_controller.py ====
# controllers/owner_controller.py

"""
EDSI Veterinary Management System - Owner Controller
Version: 1.3.2
Purpose: Business logic for owner master file operations.
         Removed direct handling of 'country_name' for Owner model
         as it's derived via StateProvince and not a direct Owner field.
Last Updated: May 17, 2025
Author: Claude Assistant

Changelog:
- v1.3.2 (2025-05-17):
    - Removed `country_name` from Owner instantiation in `create_master_owner`
      and from updatable fields in `update_master_owner` as it's not a direct DB field.
    - Removed `country_name` length validation in `validate_owner_data`.
- v1.3.1 (2025-05-17):
    - Removed phone number requirement from `validate_owner_data`.
    - Added `mobile_phone` handling to `create_master_owner` and `update_master_owner`.
- v1.2.1 (2025-05-15): Removed credit_rating from Owner constructor call and update logic.
- v1.2.0 (2025-05-15): Added delete_master_owner method.
"""

import logging
from typing import List, Optional, Tuple, Dict
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import or_, func
from config.database_config import db_manager
from models import Owner, StateProvince, HorseOwner
from datetime import datetime


class OwnerController:
    """Controller for owner master file operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_master_owners(self, include_inactive: bool = False) -> List[Owner]:
        session = db_manager.get_session()
        try:
            query = session.query(Owner)
            if not include_inactive:
                query = query.filter(Owner.is_active == True)
            owners = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()
            return owners
        except Exception as e:
            self.logger.error(f"Error fetching all master owners: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_all_owners_for_lookup(self, search_term: str = "") -> List[Dict[str, any]]:
        session = db_manager.get_session()
        try:
            query = session.query(
                Owner.owner_id,
                Owner.first_name,
                Owner.last_name,
                Owner.farm_name,
                Owner.account_number,
            ).filter(Owner.is_active == True)
            if search_term:
                search_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Owner.first_name.ilike(search_pattern),
                        Owner.last_name.ilike(search_pattern),
                        Owner.farm_name.ilike(search_pattern),
                        Owner.account_number.ilike(search_pattern),
                    )
                )
            owners_data = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()
            lookup_list = []
            for (
                owner_id,
                first_name,
                last_name,
                farm_name,
                account_number,
            ) in owners_data:
                name_parts = [name for name in [first_name, last_name] if name]
                individual_name = " ".join(name_parts)
                display_text = farm_name if farm_name else ""
                if individual_name:
                    display_text = (
                        f"{display_text} ({individual_name})"
                        if farm_name
                        else individual_name
                    )
                if not display_text:
                    display_text = "Unnamed Owner"
                if account_number:
                    display_text += f" [{account_number}]"
                lookup_list.append({"id": owner_id, "name_account": display_text})
            return lookup_list
        except Exception as e:
            self.logger.error(f"Error fetching owners for lookup: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_owner_by_id(self, owner_id: int) -> Optional[Owner]:
        session = db_manager.get_session()
        try:
            owner = (
                session.query(Owner)
                .options(joinedload(Owner.state))
                .filter(Owner.owner_id == owner_id)
                .first()
            )
            return owner
        except Exception as e:
            self.logger.error(
                f"Error fetching owner by ID '{owner_id}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_owner_data(
        self, owner_data: dict, is_new: bool = True
    ) -> Tuple[bool, List[str]]:
        errors = []
        first_name = owner_data.get("first_name", "").strip()
        last_name = owner_data.get("last_name", "").strip()
        farm_name = owner_data.get("farm_name", "").strip()
        account_number_val = owner_data.get("account_number", "").strip()

        if not first_name and not last_name and not farm_name:
            errors.append(
                "It's recommended to provide at least one of: First Name, Last Name, or Farm Name."
            )
        elif first_name and not last_name:
            errors.append("If First Name is provided, Last Name is recommended.")

        if not owner_data.get("address_line1", "").strip():
            errors.append("Address Line 1 is required.")
        if not owner_data.get("city", "").strip():
            errors.append("City is required.")
        if not owner_data.get("state_code"):
            errors.append("State is required.")
        if not owner_data.get("zip_code", "").strip():
            errors.append("Zip Code is required.")

        if len(first_name) > 50:
            errors.append("First Name cannot exceed 50 characters.")
        if len(last_name) > 50:
            errors.append("Last Name cannot exceed 50 characters.")
        if len(farm_name) > 100:
            errors.append("Farm Name cannot exceed 100 characters.")
        if len(owner_data.get("address_line1", "")) > 100:
            errors.append("Address Line 1 cannot exceed 100 characters.")
        if len(owner_data.get("address_line2", "")) > 100:
            errors.append("Address Line 2 cannot exceed 100 characters.")
        if len(owner_data.get("city", "")) > 50:
            errors.append("City cannot exceed 50 characters.")
        if len(owner_data.get("zip_code", "")) > 20:
            errors.append("Zip Code cannot exceed 20 characters.")
        # country_name is informational, so length validation might still be useful if displayed
        # but it's not a DB constraint on Owner table.
        # if len(owner_data.get("country_name", "")) > 50:
        #     errors.append("Country Name cannot exceed 50 characters (informational).")
        if len(owner_data.get("phone", "")) > 20:
            errors.append("Primary Phone cannot exceed 20 characters.")
        if len(owner_data.get("mobile_phone", "")) > 20:
            errors.append("Mobile Phone cannot exceed 20 characters.")
        if len(owner_data.get("email", "")) > 100:
            errors.append("Email cannot exceed 100 characters.")
        if len(account_number_val) > 20:
            errors.append("Account Number cannot exceed 20 characters.")

        if is_new and account_number_val:
            session = db_manager.get_session()
            try:
                existing = (
                    session.query(Owner)
                    .filter(Owner.account_number == account_number_val)
                    .first()
                )
                if existing:
                    errors.append(
                        f"Account Number '{account_number_val}' already exists."
                    )
            finally:
                session.close()
        return len(errors) == 0, errors

    def create_master_owner(
        self, owner_data: dict, current_user: str
    ) -> Tuple[bool, str, Optional[Owner]]:
        is_valid, errors = self.validate_owner_data(owner_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            # Create Owner object without country_name
            new_owner = Owner(
                account_number=owner_data.get("account_number", "").strip() or None,
                first_name=owner_data.get("first_name", "").strip() or None,
                last_name=owner_data.get("last_name", "").strip() or None,
                farm_name=owner_data.get("farm_name", "").strip() or None,
                address_line1=owner_data.get("address_line1", "").strip() or None,
                address_line2=owner_data.get("address_line2", "").strip() or None,
                city=owner_data.get("city", "").strip() or None,
                state_code=owner_data.get("state_code"),
                zip_code=owner_data.get("zip_code", "").strip() or None,
                # country_name is NOT passed to the constructor
                phone=owner_data.get("phone", "").strip() or None,
                mobile_phone=owner_data.get("mobile_phone", "").strip() or None,
                email=owner_data.get("email", "").strip() or None,
                is_active=owner_data.get("is_active", True),
            )
            session.add(new_owner)
            session.commit()
            session.refresh(new_owner)

            log_name_parts = [
                name for name in [new_owner.first_name, new_owner.last_name] if name
            ]
            log_individual_name = " ".join(log_name_parts)
            display_name_for_log = new_owner.farm_name if new_owner.farm_name else ""
            if log_individual_name:
                display_name_for_log = (
                    f"{display_name_for_log} ({log_individual_name})"
                    if new_owner.farm_name
                    else log_individual_name
                )
            if not display_name_for_log:
                display_name_for_log = f"Owner ID {new_owner.owner_id}"

            self.logger.info(
                f"Master Owner '{display_name_for_log}' (ID: {new_owner.owner_id}) created by {current_user}."
            )
            return True, "Owner created successfully.", new_owner
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating master owner: {e}", exc_info=True)
            return False, f"Failed to create owner: {e}", None
        finally:
            session.close()

    def update_master_owner(
        self, owner_id: int, owner_data: dict, current_user: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return False, f"Owner with ID {owner_id} not found."

            validation_data = owner_data.copy()
            if "address_line1" not in validation_data:
                validation_data["address_line1"] = owner.address_line1
            if "city" not in validation_data:
                validation_data["city"] = owner.city
            if "state_code" not in validation_data:
                validation_data["state_code"] = owner.state_code
            if "zip_code" not in validation_data:
                validation_data["zip_code"] = owner.zip_code

            is_valid, errors = self.validate_owner_data(validation_data, is_new=False)
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            updatable_fields = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",  # country_name removed
                "phone",
                "mobile_phone",
                "email",
                "is_active",
                "balance",
                "credit_limit",
                "billing_terms",
                "service_charge_rate",
                "discount_rate",
            ]

            for key in updatable_fields:
                if key in owner_data:
                    value = owner_data[key]
                    setattr(
                        owner, key, value.strip() if isinstance(value, str) else value
                    )

            session.commit()

            log_name_parts = [
                name for name in [owner.first_name, owner.last_name] if name
            ]
            log_individual_name = " ".join(log_name_parts)
            display_name_for_log = owner.farm_name if owner.farm_name else ""
            if log_individual_name:
                display_name_for_log = (
                    f"{display_name_for_log} ({log_individual_name})"
                    if owner.farm_name
                    else log_individual_name
                )
            if not display_name_for_log:
                display_name_for_log = f"Owner ID {owner.owner_id}"

            self.logger.info(
                f"Master Owner '{display_name_for_log}' (ID: {owner.owner_id}) updated by {current_user}."
            )
            return True, "Owner updated successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating master owner ID {owner_id}: {e}", exc_info=True
            )
            return False, f"Failed to update owner: {e}"
        finally:
            session.close()

    def delete_master_owner(
        self, owner_id_to_delete: int, current_admin_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            owner = (
                session.query(Owner)
                .filter(Owner.owner_id == owner_id_to_delete)
                .first()
            )
            if not owner:
                return False, f"Owner with ID {owner_id_to_delete} not found."

            linked_horses_count = (
                session.query(HorseOwner)
                .filter(HorseOwner.owner_id == owner_id_to_delete)
                .count()
            )
            if linked_horses_count > 0:
                self.logger.warning(
                    f"Attempt to delete owner ID {owner_id_to_delete} who is linked to {linked_horses_count} horse(s)."
                )
                return (
                    False,
                    f"Cannot delete owner. They are currently linked to {linked_horses_count} horse(s). Please unlink them from all horses first.",
                )

            owner_name_for_log_parts = [
                name
                for name in [owner.farm_name, owner.last_name, owner.first_name]
                if name
            ]
            owner_name_for_log = (
                " ".join(owner_name_for_log_parts) or f"ID {owner_id_to_delete}"
            )

            session.delete(owner)
            session.commit()
            self.logger.info(
                f"Master Owner '{owner_name_for_log}' (ID: {owner_id_to_delete}) permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"Owner '{owner_name_for_log}' deleted successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error deleting master owner ID {owner_id_to_delete}: {e}",
                exc_info=True,
            )
            return False, f"Failed to delete owner: {e}"
        finally:
            session.close()

    def get_owner_form_reference_data(self) -> Dict[str, List[Dict[str, any]]]:
        session = db_manager.get_session()
        try:
            states = [
                {
                    "id": s.state_code,
                    "name": s.state_name,
                    "country_code": s.country_code,
                }
                for s in session.query(StateProvince)
                .filter(StateProvince.is_active == True)
                .order_by(StateProvince.state_name)
                .all()
            ]
            return {
                "states": states
            }  # Removed countries from here as it's free text now
        except Exception as e:
            self.logger.error(
                f"Error fetching owner form reference data: {e}", exc_info=True
            )
            return {"states": []}
        finally:
            session.close()


==== FILE: config/app_config.py ====
# config/app_config.py

"""
EDSI Veterinary Management System - Application Configuration
Version: 2.0.1
Purpose: Simplified centralized configuration for application settings, paths, and constants.
         Added missing logging parameters for file rotation and updated app version.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Coding partner)

Changelog:
- v2.0.1 (2025-05-26):
    - Added LOG_MAX_BYTES and LOG_BACKUP_COUNT constants for log file rotation.
    - Included log_max_bytes and log_backup_count in the get_logging_config() dictionary.
    - Updated module-level APP_VERSION constant to "2.0.3" to align with main application.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Consolidated all configuration into single AppConfig class
    # ... (rest of previous changelog entries assumed present)
"""

import os
import logging
from typing import Dict, Any

# --- Project Paths ---
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
LOG_DIR = os.path.join(PROJECT_ROOT, "logs")
ASSETS_DIR = os.path.join(PROJECT_ROOT, "assets")

# --- Application Information ---
APP_NAME = "EDSI Veterinary Management System"
APP_VERSION = "2.0.3"  # <-- Updated Version
APP_AUTHOR = "EDSI"

# --- Database Configuration ---
DATABASE_URL = f"sqlite:///{os.path.join(PROJECT_ROOT, 'edsi_database.db')}"

# --- Logging Configuration ---
APP_LOG_FILE = os.path.join(LOG_DIR, "edsi_app.log")
DB_LOG_FILE = os.path.join(
    LOG_DIR, "edsi_db.log"
)  # Retained, though not used by current main.py's app logger
LOGGING_LEVEL = logging.INFO
LOG_MAX_BYTES = 1024 * 1024 * 5  # <-- Added: 5 MB
LOG_BACKUP_COUNT = 5  # <-- Added: 5 backup files

# --- UI Configuration ---
DEFAULT_FONT_FAMILY = "Inter"
DEFAULT_FONT_SIZE = 10
SMALL_FONT_SIZE = 9
MIN_WINDOW_WIDTH = 900
MIN_WINDOW_HEIGHT = 700

# --- Dark Theme Colors (Essential Only) ---
DARK_BACKGROUND = "#2D3748"
DARK_WIDGET_BACKGROUND = "#1A202C"
# ... (all other color constants remain the same)
DARK_HEADER_FOOTER = "#222B38"
DARK_BORDER = "#4A5568"
DARK_TEXT_PRIMARY = "#E2E8F0"
DARK_TEXT_SECONDARY = "#A0AEC0"
DARK_TEXT_TERTIARY = "#718096"
DARK_PRIMARY_ACTION = "#3182CE"
DARK_SUCCESS_ACTION = "#38A169"
DARK_WARNING_ACTION = "#DD6B20"
DARK_DANGER_ACTION = "#E53E3E"
DARK_BUTTON_BG = "#4A5568"
DARK_BUTTON_HOVER = "#718096"
DARK_ITEM_HOVER = "#2C3543"
DARK_HIGHLIGHT_BG = "#3182CE"
DARK_HIGHLIGHT_TEXT = "#FFFFFF"
DARK_INPUT_FIELD_BACKGROUND = "#222B38"


class AppConfig:
    """
    Centralized application configuration class.
    Provides clean access to all application settings.
    """

    # Application Info
    APP_NAME = APP_NAME
    APP_VERSION = APP_VERSION  # Will now pick up "2.0.3"
    APP_AUTHOR = APP_AUTHOR

    # Paths
    PROJECT_ROOT = PROJECT_ROOT
    LOG_DIR = LOG_DIR
    ASSETS_DIR = ASSETS_DIR

    # Database
    DATABASE_URL = DATABASE_URL

    # Logging
    APP_LOG_FILE = APP_LOG_FILE
    DB_LOG_FILE = DB_LOG_FILE
    LOGGING_LEVEL = LOGGING_LEVEL
    LOG_MAX_BYTES = LOG_MAX_BYTES  # <-- Added Class Attribute
    LOG_BACKUP_COUNT = LOG_BACKUP_COUNT  # <-- Added Class Attribute

    # UI Settings
    DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY
    # ... (other UI settings remain the same)
    DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE
    SMALL_FONT_SIZE = SMALL_FONT_SIZE
    MIN_WINDOW_WIDTH = MIN_WINDOW_WIDTH
    MIN_WINDOW_HEIGHT = MIN_WINDOW_HEIGHT

    # Theme Colors
    DARK_BACKGROUND = DARK_BACKGROUND
    # ... (all color class attributes remain the same)
    DARK_WIDGET_BACKGROUND = DARK_WIDGET_BACKGROUND
    DARK_HEADER_FOOTER = DARK_HEADER_FOOTER
    DARK_BORDER = DARK_BORDER
    DARK_TEXT_PRIMARY = DARK_TEXT_PRIMARY
    DARK_TEXT_SECONDARY = DARK_TEXT_SECONDARY
    DARK_TEXT_TERTIARY = DARK_TEXT_TERTIARY
    DARK_PRIMARY_ACTION = DARK_PRIMARY_ACTION
    DARK_SUCCESS_ACTION = DARK_SUCCESS_ACTION
    DARK_WARNING_ACTION = DARK_WARNING_ACTION
    DARK_DANGER_ACTION = DARK_DANGER_ACTION
    DARK_BUTTON_BG = DARK_BUTTON_BG
    DARK_BUTTON_HOVER = DARK_BUTTON_HOVER
    DARK_ITEM_HOVER = DARK_ITEM_HOVER
    DARK_HIGHLIGHT_BG = DARK_HIGHLIGHT_BG
    DARK_HIGHLIGHT_TEXT = DARK_HIGHLIGHT_TEXT
    DARK_INPUT_FIELD_BACKGROUND = DARK_INPUT_FIELD_BACKGROUND

    @classmethod
    def get_database_url(cls) -> str:
        return cls.DATABASE_URL

    @classmethod
    def get_app_dir(cls) -> str:  # This method was duplicated, keeping one
        return cls.PROJECT_ROOT

    @classmethod
    def get_assets_dir(cls) -> str:
        return cls.ASSETS_DIR

    @classmethod
    def get_app_info(cls) -> Dict[str, str]:
        return {
            "name": cls.APP_NAME,
            "version": cls.APP_VERSION,
            "author": cls.APP_AUTHOR,
        }

    @classmethod
    def get_logging_config(cls) -> Dict[str, Any]:
        """Get logging configuration"""
        return {
            "level": cls.LOGGING_LEVEL,
            "app_log_file": cls.APP_LOG_FILE,
            "db_log_file": cls.DB_LOG_FILE,  # Retained
            "log_dir": cls.LOG_DIR,
            "log_max_bytes": cls.LOG_MAX_BYTES,  # <-- Added Key
            "log_backup_count": cls.LOG_BACKUP_COUNT,  # <-- Added Key
        }

    @classmethod
    def get_ui_config(cls) -> Dict[str, Any]:
        # ... (remains the same)
        return {
            "font_family": cls.DEFAULT_FONT_FAMILY,
            "font_size": cls.DEFAULT_FONT_SIZE,
            "small_font_size": cls.SMALL_FONT_SIZE,
            "min_window_width": cls.MIN_WINDOW_WIDTH,
            "min_window_height": cls.MIN_WINDOW_HEIGHT,
        }

    @classmethod
    def get_theme_colors(cls) -> Dict[str, str]:
        # ... (remains the same)
        return {
            "background": cls.DARK_BACKGROUND,
            "widget_background": cls.DARK_WIDGET_BACKGROUND,
            "header_footer": cls.DARK_HEADER_FOOTER,
            "border": cls.DARK_BORDER,
            "text_primary": cls.DARK_TEXT_PRIMARY,
            "text_secondary": cls.DARK_TEXT_SECONDARY,
            "text_tertiary": cls.DARK_TEXT_TERTIARY,
            "primary_action": cls.DARK_PRIMARY_ACTION,
            "success_action": cls.DARK_SUCCESS_ACTION,
            "warning_action": cls.DARK_WARNING_ACTION,
            "danger_action": cls.DARK_DANGER_ACTION,
            "button_bg": cls.DARK_BUTTON_BG,
            "button_hover": cls.DARK_BUTTON_HOVER,
            "item_hover": cls.DARK_ITEM_HOVER,
            "highlight_bg": cls.DARK_HIGHLIGHT_BG,
            "highlight_text": cls.DARK_HIGHLIGHT_TEXT,
            "input_field_background": cls.DARK_INPUT_FIELD_BACKGROUND,
        }

    @classmethod
    def ensure_directories(cls) -> None:
        """Ensure required directories exist"""
        directories = [cls.LOG_DIR, cls.ASSETS_DIR]

        for directory in directories:
            if not os.path.exists(directory):
                try:
                    os.makedirs(directory, exist_ok=True)
                    # Optionally log creation:
                    # logging.info(f"Created directory: {directory}")
                except OSError as e:
                    # Using print as logger might not be fully setup when this is called early
                    print(f"Warning: Could not create directory {directory}: {e}")


