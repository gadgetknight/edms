
=============== FILE: views/admin/user_management_screen.py ===============

# views/admin/user_management_screen.py
"""
EDSI Veterinary Management System - User Management Screen
Version: 1.3.22
Purpose: Admin screen for managing users, locations, charge codes, categories, and owners.
         - Aligned controller method calls with latest controller file versions.
         - Implemented category path fetching for charge codes.
         - Adjusted category loading to remove unsupported status_filter.
Last Updated: June 4, 2025
Author: Gemini (based on user's previous version)

Changelog:
- v1.3.22 (2025-06-04):
    - `load_locations_data`: Changed call to `self.location_controller.get_all_locations()`.
    - `load_categories_processes_data`: Removed unsupported `status_filter` argument from
      `get_charge_code_categories` calls. The UI filter for category status will not
      filter the data fetched from the controller with this change.
    - `load_charge_codes_data`:
        - Changed call to `self.charge_code_controller.get_all_charge_codes(status_filter=status_filter)`.
        - Added logic to fetch and display category path for each charge code using
          `self.charge_code_controller.get_category_path()`.
    - `load_owners_data`: Changed call to `self.owner_controller.get_all_master_owners()`.
- v1.3.21 (2025-06-04):
    - In `load_users_data`, ensured call is to `self.user_controller.get_all_users()`.
    - In `_edit_selected_user`, changed call to `self.user_controller.get_user_by_login_id()`
    - In `_add_user` and `_edit_selected_user`, updated `AddEditUserDialog` instantiation.
- v1.3.19 (2025-06-04):
    - Moved initialization of `_active_filters` before `super().__init__()`.
    - Ensured QTimer and window properties are set after super().__init__().
"""

import logging
from typing import Optional, List, Dict, Any, Union

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QTabWidget,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QHeaderView,
    QAbstractItemView,
    QLabel,
    QFrame,
    QMessageBox,
    QMenu,
    QTreeWidget,
    QTreeWidgetItem,
    QComboBox,
    QDialog,
)
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QAction, QColor, QFont

from views.base_view import BaseView
from config.app_config import AppConfig

from controllers.user_controller import UserController
from controllers.location_controller import LocationController
from controllers.charge_code_controller import ChargeCodeController
from controllers.owner_controller import OwnerController

from models import (
    User,
    Location,
    ChargeCode,
    Owner as OwnerModel,
    ChargeCodeCategory,
)

from .dialogs.add_edit_user_dialog import AddEditUserDialog
from .dialogs.add_edit_location_dialog import AddEditLocationDialog
from .dialogs.add_edit_charge_code_dialog import AddEditChargeCodeDialog
from .dialogs.add_edit_owner_dialog import AddEditOwnerDialog
from .dialogs.add_edit_charge_code_category_dialog import (
    AddEditChargeCodeCategoryDialog,
)


class UserManagementScreen(BaseView):
    back_to_main_menu = Signal()
    entity_updated = Signal(str)

    USER_TAB_INDEX = 0
    LOCATION_TAB_INDEX = 1
    CATEGORY_PROCESS_TAB_INDEX = 2
    CHARGE_CODE_TAB_INDEX = 3
    OWNER_TAB_INDEX = 4

    def __init__(self, current_user_id: str, parent: Optional[QWidget] = None):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(
            f"UserManagementScreen __init__ called for user: {current_user_id}"
        )

        self.current_user_id = current_user_id
        if not self.current_user_id:
            self.logger.error(
                "UserManagementScreen initialized without a current_user_id!"
            )

        self.user_controller = UserController()
        self.location_controller = LocationController()
        self.charge_code_controller = ChargeCodeController()
        self.owner_controller = OwnerController()

        self.users_table: Optional[QTableWidget] = None
        self.add_user_btn: Optional[QPushButton] = None
        self.edit_user_btn: Optional[QPushButton] = None
        self.toggle_user_active_btn: Optional[QPushButton] = None

        self.locations_table: Optional[QTableWidget] = None
        self.add_location_btn: Optional[QPushButton] = None
        self.edit_location_btn: Optional[QPushButton] = None
        self.toggle_location_active_btn: Optional[QPushButton] = None

        self.categories_tree: Optional[QTreeWidget] = None
        self.add_category_btn: Optional[QPushButton] = None
        self.add_process_btn: Optional[QPushButton] = None
        self.edit_category_process_btn: Optional[QPushButton] = None
        self.toggle_category_process_active_btn: Optional[QPushButton] = None
        self.delete_category_process_btn: Optional[QPushButton] = None
        self.category_filter_combo: Optional[QComboBox] = None

        self.charge_codes_table: Optional[QTableWidget] = None
        self.add_charge_code_btn: Optional[QPushButton] = None
        self.edit_charge_code_btn: Optional[QPushButton] = None
        self.toggle_charge_code_active_btn: Optional[QPushButton] = None
        self.charge_code_status_filter_combo: Optional[QComboBox] = None

        self.owners_table: Optional[QTableWidget] = None
        self.add_owner_btn: Optional[QPushButton] = None
        self.edit_owner_btn: Optional[QPushButton] = None
        self.toggle_owner_active_btn: Optional[QPushButton] = None

        self.tab_widget: Optional[QTabWidget] = None

        self._active_filters: Dict[int, str] = {
            self.CATEGORY_PROCESS_TAB_INDEX: "active",  # Retained for UI consistency
            self.CHARGE_CODE_TAB_INDEX: "active",
        }

        super().__init__(parent)

        self.refresh_timer = QTimer(self)
        self.refresh_timer.setSingleShot(True)
        self.refresh_timer.timeout.connect(self._refresh_current_tab_data)

        self.setWindowTitle("User and System Management")
        self.resize(1000, 700)
        self.logger.info("UserManagementScreen __init__ completed.")

    def setup_ui(self):
        self.logger.info("Setting up UserManagementScreen UI...")

        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet(self._get_tab_widget_style())

        users_tab_widget = self._create_users_tab()
        locations_tab_widget = self._create_locations_tab()
        categories_processes_tab_widget = self._create_categories_processes_tab()
        charge_codes_tab_widget = self._create_charge_codes_tab()
        owners_tab_widget = self._create_owners_tab()

        self.tab_widget.addTab(users_tab_widget, "👤 Manage Users")
        self.tab_widget.addTab(locations_tab_widget, "📍 Manage Locations")
        self.tab_widget.addTab(
            categories_processes_tab_widget, "🗂️ Manage Categories/Processes"
        )
        self.tab_widget.addTab(charge_codes_tab_widget, "💲 Manage Charge Codes")
        self.tab_widget.addTab(owners_tab_widget, "🤝 Manage Master Owners")

        main_layout.addWidget(self.tab_widget)

        self._setup_connections()
        if self.tab_widget:
            self.tab_widget.setCurrentIndex(0)
            self._refresh_current_tab_data()

        self.logger.info("UserManagementScreen UI setup complete.")

    def _get_tab_widget_style(self) -> str:
        return f"""
            QTabWidget::pane {{
                border: 1px solid {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                border-radius: 6px;
                margin-top: -1px; 
            }}
            QTabBar::tab {{
                padding: 10px 20px; 
                margin-right: 2px;
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-bottom: none; 
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                min-width: 120px; 
                font-size: 13px;
                font-weight: 500;
            }}
            QTabBar::tab:selected {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND}; 
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border-color: {AppConfig.DARK_BORDER};
                border-bottom-color: {AppConfig.DARK_WIDGET_BACKGROUND}; 
            }}
            QTabBar::tab:!selected:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QTabWidget::tab-bar {{
                alignment: left;
                border: none; 
                background-color: transparent; 
                margin-bottom: 0px; 
            }}
        """

    def _create_standard_button_layout(self) -> QHBoxLayout:
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        return button_layout

    def _apply_standard_button_style(
        self, button: QPushButton, button_type: str = "standard"
    ):
        base_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 15px;
                font-size: 12px;
                font-weight: 500;
                min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
            }}
            QPushButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
            }}
        """
        if button_type == "add":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_SUCCESS_ACTION
                )
                + "color: white;"
            )
        elif button_type == "edit":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_PRIMARY_ACTION
                )
                + "color: white;"
            )
        elif button_type == "delete" or button_type == "toggle_inactive":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_DANGER_ACTION
                )
                + "color: white;"
            )
        else:
            button.setStyleSheet(base_style)

    def get_form_input_style(self) -> str:
        return f"""
            QComboBox {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 20px;
            }}
            QComboBox:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QComboBox::drop-down {{
                border: none;
                background-color: transparent;
            }}
            QComboBox QAbstractItemView {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                selection-background-color: {AppConfig.DARK_HIGHLIGHT_BG};
                selection-color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _setup_connections(self):
        self.logger.debug("Setting up connections for UserManagementScreen.")
        if self.tab_widget:
            self.tab_widget.currentChanged.connect(self._on_tab_changed)

        if self.add_user_btn:
            self.add_user_btn.clicked.connect(self._add_user)
        if self.edit_user_btn:
            self.edit_user_btn.clicked.connect(self._edit_selected_user)
        if self.toggle_user_active_btn:
            self.toggle_user_active_btn.clicked.connect(
                self._toggle_selected_user_active_status
            )
        if self.users_table:
            self.users_table.itemSelectionChanged.connect(
                self._update_user_action_buttons_state
            )

        if self.add_location_btn:
            self.add_location_btn.clicked.connect(self._add_location)
        if self.edit_location_btn:
            self.edit_location_btn.clicked.connect(self._edit_selected_location)
        if self.toggle_location_active_btn:
            self.toggle_location_active_btn.clicked.connect(
                self._toggle_selected_location_active_status
            )
        if self.locations_table:
            self.locations_table.itemSelectionChanged.connect(
                self._update_location_action_buttons_state
            )

        if self.add_category_btn:
            self.add_category_btn.clicked.connect(self._add_category_or_process)
        if self.add_process_btn:
            self.add_process_btn.clicked.connect(
                lambda: self._add_category_or_process(is_process=True)
            )
        if self.edit_category_process_btn:
            self.edit_category_process_btn.clicked.connect(
                self._edit_selected_category_process
            )
        if self.toggle_category_process_active_btn:
            self.toggle_category_process_active_btn.clicked.connect(
                self._toggle_selected_category_process_active_status
            )
        if self.delete_category_process_btn:
            self.delete_category_process_btn.clicked.connect(
                self._delete_selected_category_process
            )
        if self.categories_tree:
            self.categories_tree.itemSelectionChanged.connect(
                self._update_category_action_buttons_state
            )
        if self.category_filter_combo:
            self.category_filter_combo.currentIndexChanged.connect(
                self._on_category_filter_changed
            )

        if self.add_charge_code_btn:
            self.add_charge_code_btn.clicked.connect(self._add_charge_code)
        if self.edit_charge_code_btn:
            self.edit_charge_code_btn.clicked.connect(self._edit_selected_charge_code)
        if self.toggle_charge_code_active_btn:
            self.toggle_charge_code_active_btn.clicked.connect(
                self._toggle_selected_charge_code_active_status
            )
        if self.charge_codes_table:
            self.charge_codes_table.itemSelectionChanged.connect(
                self._update_charge_code_action_buttons_state
            )
        if self.charge_code_status_filter_combo:
            self.charge_code_status_filter_combo.currentIndexChanged.connect(
                self._on_charge_code_filter_changed
            )

        if self.add_owner_btn:
            self.add_owner_btn.clicked.connect(self._add_owner)
        if self.edit_owner_btn:
            self.edit_owner_btn.clicked.connect(self._edit_selected_owner)
        if self.toggle_owner_active_btn:
            self.toggle_owner_active_btn.clicked.connect(
                self._toggle_selected_owner_active_status
            )
        if self.owners_table:
            self.owners_table.itemSelectionChanged.connect(
                self._update_owner_action_buttons_state
            )
        self.logger.debug("Connections setup complete.")

    def _on_tab_changed(self, index: int):
        self.logger.info(
            f"Tab changed to index: {index}, new tab title: {self.tab_widget.tabText(index) if self.tab_widget else 'N/A'}"
        )
        self._refresh_current_tab_data()

    def _refresh_current_tab_data(self, force_reload: bool = False):
        if not self.tab_widget:
            self.logger.warning("Tab widget not available for refresh.")
            return
        current_index = self.tab_widget.currentIndex()
        self.logger.debug(f"Refreshing data for tab index: {current_index}")

        if current_index == self.USER_TAB_INDEX:
            self.load_users_data()
        elif current_index == self.LOCATION_TAB_INDEX:
            self.load_locations_data()
        elif current_index == self.CATEGORY_PROCESS_TAB_INDEX:
            self.load_categories_processes_data()
        elif current_index == self.CHARGE_CODE_TAB_INDEX:
            self.load_charge_codes_data()
        elif current_index == self.OWNER_TAB_INDEX:
            self.load_owners_data()
        else:
            self.logger.warning(
                f"No data loading action defined for tab index {current_index}"
            )

    def _create_table_widget(self, headers: List[str]) -> QTableWidget:
        table = QTableWidget()
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        table.verticalHeader().setVisible(False)
        table.setShowGrid(True)
        table.setStyleSheet(
            f"""
            QTableWidget {{
                gridline-color: {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
            }}
            QHeaderView::section {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                padding: 5px;
                border: none; 
                border-bottom: 1px solid {AppConfig.DARK_BORDER};
                font-weight: 500; 
            }}
            QTableWidget::item {{ padding: 5px; }}
            QTableWidget::item:selected {{
                background-color: {AppConfig.DARK_HIGHLIGHT_BG};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """
        )
        table.horizontalHeader().setStretchLastSection(True)
        for i in range(len(headers) - 1):
            table.horizontalHeader().setSectionResizeMode(
                i, QHeaderView.ResizeMode.ResizeToContents
            )
        return table

    # --- Users Tab Methods ---
    def _create_users_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        button_layout = self._create_standard_button_layout()
        self.add_user_btn = QPushButton("➕ Add New User")
        self._apply_standard_button_style(self.add_user_btn, "add")
        self.edit_user_btn = QPushButton("✏️ Edit Selected User")
        self._apply_standard_button_style(self.edit_user_btn, "edit")
        self.toggle_user_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_user_active_btn)

        button_layout.addWidget(self.add_user_btn)
        button_layout.addWidget(self.edit_user_btn)
        button_layout.addWidget(self.toggle_user_active_btn)
        button_layout.addStretch(1)
        layout.addLayout(button_layout)

        self.users_table = self._create_table_widget(
            ["Login ID", "Full Name", "Email", "Roles", "Active", "Last Login"]
        )
        layout.addWidget(self.users_table)
        self._update_user_action_buttons_state()
        return tab

    def load_users_data(self):
        self.logger.info("Loading users data for tab...")
        if not self.users_table:
            self.logger.error("Users table not initialized.")
            return
        try:
            users = self.user_controller.get_all_users()
            self.users_table.setRowCount(0)
            for user_obj in users:
                row_position = self.users_table.rowCount()
                self.users_table.insertRow(row_position)
                self.users_table.setItem(
                    row_position, 0, QTableWidgetItem(user_obj.user_id)
                )
                self.users_table.setItem(
                    row_position, 1, QTableWidgetItem(user_obj.user_name or "")
                )
                self.users_table.setItem(
                    row_position, 2, QTableWidgetItem(user_obj.email or "")
                )
                roles_str = ", ".join([role.name for role in user_obj.roles])
                self.users_table.setItem(row_position, 3, QTableWidgetItem(roles_str))
                active_str = "Yes" if user_obj.is_active else "No"
                self.users_table.setItem(row_position, 4, QTableWidgetItem(active_str))
                last_login_str = (
                    user_obj.last_login.strftime("%Y-%m-%d %H:%M")
                    if user_obj.last_login
                    else "Never"
                )
                self.users_table.setItem(
                    row_position, 5, QTableWidgetItem(last_login_str)
                )
                self.users_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, user_obj.user_id
                )
            self.logger.info(f"Loaded {len(users)} users.")
        except Exception as e:
            self.logger.error(f"Error loading users: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load users: {e}")
        self._update_user_action_buttons_state()

    def _add_user(self):
        dialog = AddEditUserDialog(
            self,
            user_controller=self.user_controller,
            current_user_object=None,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_users_data()
            self.entity_updated.emit("user")

    def _edit_selected_user(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Edit User", "Please select a user to edit.")
            return

        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        if not user_id_item:
            self.show_error("Error", "Could not retrieve user ID for selected row.")
            return

        user_login_id = user_id_item.data(Qt.ItemDataRole.UserRole)
        if not user_login_id:
            user_login_id = user_id_item.text()

        user_to_edit = self.user_controller.get_user_by_login_id(user_login_id)

        if user_to_edit:
            dialog = AddEditUserDialog(
                self,
                user_controller=self.user_controller,
                current_user_object=user_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_users_data()
                self.entity_updated.emit("user")
        else:
            self.show_error("Error", f"User with Login ID '{user_login_id}' not found.")
            self.load_users_data()

    def _toggle_selected_user_active_status(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a user.")
            return

        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )

        user_obj = self.user_controller.get_user_by_login_id(user_login_id)

        if not user_obj:
            self.show_error("Error", f"User {user_login_id} not found.")
            return

        action = "deactivate" if user_obj.is_active else "activate"
        name_display = user_obj.user_name or user_obj.user_id

        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} user '{name_display}'?",
        ):
            if (
                user_obj.user_id.upper() == "ADMIN"
                and user_obj.user_id == self.current_user_id
                and action == "deactivate"
            ):  # Ensure comparing actual ID not just 'ADMIN' literal
                self.show_warning(
                    "Action Denied", "You cannot deactivate your own ADMIN account."
                )
                return

            success, message = self.user_controller.toggle_user_active_status(
                user_login_id,
                self.current_user_id,  # Pass login_id as it's the identifier used
            )
            if success:
                self.show_info("Success", message)
                self.load_users_data()
                self.entity_updated.emit("user")
            else:
                self.show_error("Error", message)

    def _update_user_action_buttons_state(self):
        has_selection = (
            self.users_table is not None and self.users_table.currentItem() is not None
        )
        if self.edit_user_btn:
            self.edit_user_btn.setEnabled(has_selection)
        if self.toggle_user_active_btn:
            self.toggle_user_active_btn.setEnabled(has_selection)

        if has_selection and self.toggle_user_active_btn and self.users_table:
            selected_row = self.users_table.currentRow()
            user_id_item = self.users_table.item(selected_row, 0)
            user_login_id = (
                user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
            )
            user_obj = self.user_controller.get_user_by_login_id(user_login_id)
            if user_obj:
                action_text = "Deactivate" if user_obj.is_active else "Activate"
                self.toggle_user_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_user_active_btn,
                    "toggle_inactive" if user_obj.is_active else "standard",
                )

    # --- Locations Tab Methods ---
    def _create_locations_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        button_layout = self._create_standard_button_layout()
        self.add_location_btn = QPushButton("➕ Add New Location")
        self._apply_standard_button_style(self.add_location_btn, "add")
        self.edit_location_btn = QPushButton("✏️ Edit Selected Location")
        self._apply_standard_button_style(self.edit_location_btn, "edit")
        self.toggle_location_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_location_active_btn)

        button_layout.addWidget(self.add_location_btn)
        button_layout.addWidget(self.edit_location_btn)
        button_layout.addWidget(self.toggle_location_active_btn)
        button_layout.addStretch(1)
        layout.addLayout(button_layout)

        self.locations_table = self._create_table_widget(
            ["Name", "Address", "City", "State", "Zip", "Contact", "Active"]
        )
        layout.addWidget(self.locations_table)
        self._update_location_action_buttons_state()
        return tab

    def load_locations_data(self):
        self.logger.info("Loading locations data for tab...")
        if not self.locations_table:
            self.logger.error("Locations table not initialized.")
            return
        try:
            # Corrected call to match LocationController.py
            locations = self.location_controller.get_all_locations()
            self.locations_table.setRowCount(0)
            for loc_obj in locations:  # Assuming loc_obj is a Location model instance
                row_position = self.locations_table.rowCount()
                self.locations_table.insertRow(row_position)
                self.locations_table.setItem(
                    row_position, 0, QTableWidgetItem(loc_obj.location_name)
                )
                address_parts = [loc_obj.address_line1, loc_obj.address_line2]
                self.locations_table.setItem(
                    row_position,
                    1,
                    QTableWidgetItem(" ".join(filter(None, address_parts))),
                )
                self.locations_table.setItem(
                    row_position, 2, QTableWidgetItem(loc_obj.city or "")
                )
                # Access state_code. If it's a relationship, it might be loc_obj.state.state_code
                state_display = loc_obj.state_code or ""
                if (
                    hasattr(loc_obj, "state")
                    and loc_obj.state
                    and hasattr(loc_obj.state, "state_code")
                ):
                    state_display = (
                        loc_obj.state.state_code
                    )  # If state is loaded and has state_code
                self.locations_table.setItem(
                    row_position, 3, QTableWidgetItem(state_display)
                )
                self.locations_table.setItem(
                    row_position, 4, QTableWidgetItem(loc_obj.zip_code or "")
                )
                self.locations_table.setItem(
                    row_position, 5, QTableWidgetItem(loc_obj.contact_person or "")
                )
                self.locations_table.setItem(
                    row_position,
                    6,
                    QTableWidgetItem("Yes" if loc_obj.is_active else "No"),
                )
                self.locations_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, loc_obj.location_id
                )
            self.logger.info(f"Loaded {len(locations)} locations.")
        except Exception as e:
            self.logger.error(f"Error loading locations: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load locations: {e}")
        self._update_location_action_buttons_state()

    def _add_location(self):
        dialog = AddEditLocationDialog(
            self,
            controller=self.location_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_locations_data()
            self.entity_updated.emit("location")

    def _edit_selected_location(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Edit Location", "Please select a location to edit.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        location_to_edit = self.location_controller.get_location_by_id(location_id)

        if location_to_edit:
            dialog = AddEditLocationDialog(
                self,
                controller=self.location_controller,
                location=location_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_locations_data()
                self.entity_updated.emit("location")
        else:
            self.show_error("Error", f"Location with ID '{location_id}' not found.")
            self.load_locations_data()

    def _toggle_selected_location_active_status(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a location.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        loc_obj = self.location_controller.get_location_by_id(location_id)

        if not loc_obj:
            self.show_error("Error", f"Location {location_id} not found.")
            return

        action = "deactivate" if loc_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} location '{loc_obj.location_name}'?",
        ):
            success, message = (
                self.location_controller.toggle_location_active_status(  # Corrected method name
                    location_id, self.current_user_id
                )
            )
            if success:
                self.show_info("Success", message)
                self.load_locations_data()
                self.entity_updated.emit("location")
            else:
                self.show_error("Error", message)

    def _update_location_action_buttons_state(self):
        has_selection = (
            self.locations_table is not None
            and self.locations_table.currentItem() is not None
        )
        if self.edit_location_btn:
            self.edit_location_btn.setEnabled(has_selection)
        if self.toggle_location_active_btn:
            self.toggle_location_active_btn.setEnabled(has_selection)

        if has_selection and self.toggle_location_active_btn and self.locations_table:
            selected_row = self.locations_table.currentRow()
            location_id_item = self.locations_table.item(selected_row, 0)
            loc_id = (
                location_id_item.data(Qt.ItemDataRole.UserRole)
                or location_id_item.text()
            )
            loc_obj = self.location_controller.get_location_by_id(loc_id)
            if loc_obj:
                action_text = "Deactivate" if loc_obj.is_active else "Activate"
                self.toggle_location_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_location_active_btn,
                    "toggle_inactive" if loc_obj.is_active else "standard",
                )

    # --- Categories/Processes Tab Methods ---
    def _create_categories_processes_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        top_bar_layout = QHBoxLayout()
        self.add_category_btn = QPushButton("➕ Add Category (L1)")
        self._apply_standard_button_style(self.add_category_btn, "add")
        self.add_process_btn = QPushButton("➕ Add Process (L2)")
        self._apply_standard_button_style(self.add_process_btn, "add")
        self.edit_category_process_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_category_process_btn, "edit")
        self.toggle_category_process_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_category_process_active_btn)
        self.delete_category_process_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_category_process_btn, "delete")

        top_bar_layout.addWidget(self.add_category_btn)
        top_bar_layout.addWidget(self.add_process_btn)
        top_bar_layout.addWidget(self.edit_category_process_btn)
        top_bar_layout.addWidget(self.toggle_category_process_active_btn)
        top_bar_layout.addWidget(self.delete_category_process_btn)
        top_bar_layout.addStretch(1)

        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.category_filter_combo = QComboBox()
        self.category_filter_combo.addItems(["Active", "Inactive", "All"])
        self.category_filter_combo.setCurrentText(
            self._active_filters.get(self.CATEGORY_PROCESS_TAB_INDEX, "active")
        )
        self.category_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.category_filter_combo)
        layout.addLayout(top_bar_layout)

        self.categories_tree = QTreeWidget()
        self.categories_tree.setHeaderLabels(
            ["Category/Process Name", "Level", "Status", "ID"]
        )
        self.categories_tree.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.categories_tree.setStyleSheet(
            f"""
            QTreeWidget {{ background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_BORDER}; border-radius: 4px; }}
            QHeaderView::section {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; color: {AppConfig.DARK_TEXT_SECONDARY}; padding: 5px; border: none; border-bottom: 1px solid {AppConfig.DARK_BORDER}; font-weight: 500; }}
            QTreeWidget::item:selected {{ background-color: {AppConfig.DARK_HIGHLIGHT_BG}; color: {AppConfig.DARK_HIGHLIGHT_TEXT}; }}
            QTreeWidget::item {{ padding: 3px; }}
        """
        )
        header = self.categories_tree.header()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        for i in range(1, 4):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)

        layout.addWidget(self.categories_tree)
        self._update_category_action_buttons_state()
        return tab

    def load_categories_processes_data(self):
        self.logger.info("Loading charge code categories/processes data...")
        if not self.categories_tree or not self.category_filter_combo:
            self.logger.error("Categories tree or filter combo not initialized.")
            return

        self.categories_tree.clear()
        # The status_filter from combobox is not used by the controller method get_charge_code_categories
        # If filtering is needed, it must be implemented in the controller or client-side here.
        # For now, removing status_filter from calls to match controller.
        # status_filter = self.category_filter_combo.currentText().lower()
        # self._active_filters[self.CATEGORY_PROCESS_TAB_INDEX] = status_filter
        # self.logger.info(f"Category UI filter set to: {status_filter}, but controller method doesn't use it directly.")

        try:
            level1_categories = self.charge_code_controller.get_charge_code_categories(
                level=1
            )

            ui_status_filter = self.category_filter_combo.currentText().lower()
            self._active_filters[self.CATEGORY_PROCESS_TAB_INDEX] = ui_status_filter

            for cat_l1 in level1_categories:
                # Apply UI filter for L1 categories
                if ui_status_filter != "all":
                    if (ui_status_filter == "active" and not cat_l1.is_active) or (
                        ui_status_filter == "inactive" and cat_l1.is_active
                    ):
                        continue  # Skip if it doesn't match UI filter

                l1_item = QTreeWidgetItem(self.categories_tree)
                l1_item.setText(0, cat_l1.name)
                l1_item.setText(1, str(cat_l1.level))
                l1_item.setText(2, "Active" if cat_l1.is_active else "Inactive")
                l1_item.setText(3, str(cat_l1.category_id))
                l1_item.setData(
                    0,
                    Qt.ItemDataRole.UserRole,
                    {"id": cat_l1.category_id, "level": 1, "obj": cat_l1},
                )

                level2_processes = (
                    self.charge_code_controller.get_charge_code_categories(
                        parent_id=cat_l1.category_id, level=2
                    )
                )

                has_visible_children = False
                for cat_l2 in level2_processes:
                    # Apply UI filter for L2 categories
                    if ui_status_filter != "all":
                        if (ui_status_filter == "active" and not cat_l2.is_active) or (
                            ui_status_filter == "inactive" and cat_l2.is_active
                        ):
                            continue  # Skip L2 if it doesn't match

                    l2_item = QTreeWidgetItem(l1_item)
                    l2_item.setText(0, cat_l2.name)
                    l2_item.setText(1, str(cat_l2.level))
                    l2_item.setText(2, "Active" if cat_l2.is_active else "Inactive")
                    l2_item.setText(3, str(cat_l2.category_id))
                    l2_item.setData(
                        0,
                        Qt.ItemDataRole.UserRole,
                        {"id": cat_l2.category_id, "level": 2, "obj": cat_l2},
                    )
                    has_visible_children = True

                if (
                    ui_status_filter != "all"
                    and not cat_l1.is_active
                    and not has_visible_children
                ):
                    # If L1 is inactive and has no visible active children, remove L1 item if filter is "active"
                    if ui_status_filter == "active":
                        self.categories_tree.takeTopLevelItem(
                            self.categories_tree.indexOfTopLevelItem(l1_item)
                        )

            self.categories_tree.expandAll()
            self.logger.info(
                f"Displayed categories in tree (UI filter: '{ui_status_filter}')."
            )

        except Exception as e:
            self.logger.error(f"Error loading categories/processes: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load categories: {e}")
        self._update_category_action_buttons_state()

    def _on_category_filter_changed(self, index: int):
        self.load_categories_processes_data()

    def _add_category_or_process(self, is_process: bool = False):
        parent_category_id: Optional[int] = None
        parent_category_name: Optional[str] = None
        selected_item = (
            self.categories_tree.currentItem() if self.categories_tree else None
        )

        if is_process:
            if not selected_item:
                self.show_warning(
                    "Add Process",
                    "Please select a Level 1 Category to add a Process under.",
                )
                return
            item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
            if item_data.get("level") != 1:
                self.show_warning(
                    "Add Process",
                    "Processes (Level 2) can only be added under a Level 1 Category.",
                )
                return
            parent_category_id = item_data.get("id")
            parent_category_name = selected_item.text(0)

        dialog_title = "Add New Process" if is_process else "Add New Category"
        level_to_add = 2 if is_process else 1

        dialog = AddEditChargeCodeCategoryDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
            level=level_to_add,
            parent_id=parent_category_id,
            parent_name=parent_category_name,
            category_to_edit=None,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_categories_processes_data()
            self.entity_updated.emit("charge_code_category")

    def _edit_selected_category_process(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Edit Item", "Please select a category or process to edit.")
            return

        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        category_id = item_data.get("id")
        category_to_edit = self.charge_code_controller.get_category_by_id(category_id)

        if not category_to_edit:
            self.show_error(
                "Error",
                f"Could not find category/process with ID {category_id} to edit.",
            )
            self.load_categories_processes_data()
            return

        parent_name_for_dialog: Optional[str] = None
        if category_to_edit.parent:
            parent_name_for_dialog = category_to_edit.parent.name

        dialog = AddEditChargeCodeCategoryDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
            level=category_to_edit.level,
            parent_id=category_to_edit.parent_id,
            parent_name=parent_name_for_dialog,
            category_to_edit=category_to_edit,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_categories_processes_data()
            self.entity_updated.emit("charge_code_category")

    def _toggle_selected_category_process_active_status(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Toggle Status", "Please select an item.")
            return

        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        item_id = item_data.get("id")
        item_obj: Optional[ChargeCodeCategory] = item_data.get("obj")

        if not item_obj:
            item_obj = self.charge_code_controller.get_category_by_id(item_id)

        if not item_obj:
            self.show_error("Error", f"Item with ID {item_id} not found.")
            return

        action = "deactivate" if item_obj.is_active else "activate"
        item_name_display = item_obj.name

        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} '{item_name_display}'?",
        ):
            success, message = (
                self.charge_code_controller.toggle_category_active_status(
                    item_id, self.current_user_id
                )
            )
            if success:
                self.show_info("Success", message)
                self.load_categories_processes_data()
                self.entity_updated.emit("charge_code_category")
            else:
                self.show_error("Error", message)

    def _delete_selected_category_process(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Delete Item", "Please select an item to delete.")
            return

        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        item_id = item_data.get("id")
        item_name = selected_item.text(0)

        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete '{item_name}'? This action cannot be undone.",
        ):
            success, message = self.charge_code_controller.delete_category_or_process(
                item_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_categories_processes_data()
                self.entity_updated.emit("charge_code_category_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_category_action_buttons_state(self):
        if not self.categories_tree:
            return

        has_selection = self.categories_tree.currentItem() is not None
        is_l1_selected = False
        item_obj: Optional[ChargeCodeCategory] = None

        if has_selection:
            item_data = self.categories_tree.currentItem().data(
                0, Qt.ItemDataRole.UserRole
            )
            if item_data:
                if item_data.get("level") == 1:
                    is_l1_selected = True
                item_obj = item_data.get("obj")

        if self.add_category_btn:
            self.add_category_btn.setEnabled(True)
        if self.add_process_btn:
            self.add_process_btn.setEnabled(is_l1_selected)
        if self.edit_category_process_btn:
            self.edit_category_process_btn.setEnabled(has_selection)
        if self.toggle_category_process_active_btn:
            self.toggle_category_process_active_btn.setEnabled(has_selection)
        if self.delete_category_process_btn:
            self.delete_category_process_btn.setEnabled(has_selection)

        if has_selection and self.toggle_category_process_active_btn and item_obj:
            action_text = "Deactivate" if item_obj.is_active else "Activate"
            self.toggle_category_process_active_btn.setText(
                f"🔄 {action_text} Selected"
            )
            self._apply_standard_button_style(
                self.toggle_category_process_active_btn,
                "toggle_inactive" if item_obj.is_active else "standard",
            )

    # --- Charge Codes Tab Methods ---
    def _create_charge_codes_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        top_bar_layout = QHBoxLayout()
        self.add_charge_code_btn = QPushButton("➕ Add New Charge Code")
        self._apply_standard_button_style(self.add_charge_code_btn, "add")
        self.edit_charge_code_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_charge_code_btn, "edit")
        self.toggle_charge_code_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_charge_code_active_btn)

        top_bar_layout.addWidget(self.add_charge_code_btn)
        top_bar_layout.addWidget(self.edit_charge_code_btn)
        top_bar_layout.addWidget(self.toggle_charge_code_active_btn)
        top_bar_layout.addStretch(1)

        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.charge_code_status_filter_combo = QComboBox()
        self.charge_code_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.charge_code_status_filter_combo.setCurrentText(
            self._active_filters.get(self.CHARGE_CODE_TAB_INDEX, "active")
        )
        self.charge_code_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.charge_code_status_filter_combo)
        layout.addLayout(top_bar_layout)

        self.charge_codes_table = self._create_table_widget(
            [
                "Code",
                "Alternate Code",
                "Category",
                "Description",
                "Std. Price",
                "Active",
            ]
        )
        if self.charge_codes_table:
            self.charge_codes_table.horizontalHeader().setSectionResizeMode(
                3, QHeaderView.ResizeMode.Stretch
            )
            for i in [0, 1, 2, 4, 5]:
                self.charge_codes_table.horizontalHeader().setSectionResizeMode(
                    i, QHeaderView.ResizeMode.ResizeToContents
                )

        layout.addWidget(self.charge_codes_table)
        self._update_charge_code_action_buttons_state()
        return tab

    def load_charge_codes_data(self):
        self.logger.info("Loading charge codes data for tab...")
        if not self.charge_codes_table or not self.charge_code_status_filter_combo:
            self.logger.error("Charge codes table or filter combo not initialized.")
            return
        try:
            status_filter = self.charge_code_status_filter_combo.currentText().lower()
            self.logger.info(f"Charge code status filter: {status_filter}")
            self._active_filters[self.CHARGE_CODE_TAB_INDEX] = status_filter

            # Corrected call to match ChargeCodeController.py
            charge_codes = self.charge_code_controller.get_all_charge_codes(
                status_filter=status_filter
            )
            self.charge_codes_table.setRowCount(0)
            for c_obj in charge_codes:
                row_position = self.charge_codes_table.rowCount()
                self.charge_codes_table.insertRow(row_position)
                self.charge_codes_table.setItem(
                    row_position, 0, QTableWidgetItem(c_obj.code)
                )
                self.charge_codes_table.setItem(
                    row_position, 1, QTableWidgetItem(c_obj.alternate_code or "")
                )

                # Fetch and format category path
                category_path_str = "N/A"
                if c_obj.category_id:
                    path_objects = self.charge_code_controller.get_category_path(
                        c_obj.category_id
                    )
                    if path_objects:
                        category_path_str = " > ".join([p.name for p in path_objects])

                self.charge_codes_table.setItem(
                    row_position, 2, QTableWidgetItem(category_path_str)
                )
                self.charge_codes_table.setItem(
                    row_position, 3, QTableWidgetItem(c_obj.description)
                )
                price_str = (
                    f"${c_obj.standard_charge:.2f}"
                    if c_obj.standard_charge is not None
                    else "$0.00"
                )
                price_item = QTableWidgetItem(price_str)
                price_item.setTextAlignment(
                    Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
                )
                self.charge_codes_table.setItem(row_position, 4, price_item)

                self.charge_codes_table.setItem(
                    row_position,
                    5,
                    QTableWidgetItem("Yes" if c_obj.is_active else "No"),
                )
                self.charge_codes_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, c_obj.id
                )
            self.logger.info(
                f"Loaded {len(charge_codes)} charge codes based on filter '{status_filter}'."
            )
        except AttributeError as ae:
            self.logger.error(f"Error loading charge codes: {ae}", exc_info=True)
            self.show_error("Load Error", f"Could not load charge codes: {ae}")

        except Exception as e:
            self.logger.error(f"General error loading charge codes: {e}", exc_info=True)
            self.show_error("Load Error", f"An unexpected error occurred: {e}")
        self._update_charge_code_action_buttons_state()

    def _on_charge_code_filter_changed(self, index: int):
        self.load_charge_codes_data()

    def _add_charge_code(self):
        dialog = AddEditChargeCodeDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_charge_codes_data()
            self.entity_updated.emit("charge_code")

    def _edit_selected_charge_code(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info("Edit Charge Code", "Please select a charge code to edit.")
            return

        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        charge_code_to_edit = self.charge_code_controller.get_charge_code_by_id(
            charge_code_id
        )

        if charge_code_to_edit:
            dialog = AddEditChargeCodeDialog(
                self,
                controller=self.charge_code_controller,
                charge_code=charge_code_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code")
        else:
            self.show_error(
                "Error", f"Charge code with ID '{charge_code_id}' not found."
            )
            self.load_charge_codes_data()

    def _toggle_selected_charge_code_active_status(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a charge code.")
            return

        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        cc_obj = self.charge_code_controller.get_charge_code_by_id(charge_code_id)

        if not cc_obj:
            self.show_error("Error", f"Charge code {charge_code_id} not found.")
            return

        action = "deactivate" if cc_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} charge code '{cc_obj.code} - {cc_obj.description}'?",
        ):
            success, message = (
                self.charge_code_controller.toggle_charge_code_active_status(
                    charge_code_id, self.current_user_id
                )
            )
            if success:
                self.show_info("Success", message)
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code")
            else:
                self.show_error("Error", message)

    def _update_charge_code_action_buttons_state(self):
        has_selection = (
            self.charge_codes_table is not None
            and self.charge_codes_table.currentItem() is not None
        )
        if self.edit_charge_code_btn:
            self.edit_charge_code_btn.setEnabled(has_selection)
        if self.toggle_charge_code_active_btn:
            self.toggle_charge_code_active_btn.setEnabled(has_selection)

        if (
            has_selection
            and self.toggle_charge_code_active_btn
            and self.charge_codes_table
        ):
            selected_row = self.charge_codes_table.currentRow()
            charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
                Qt.ItemDataRole.UserRole
            )
            cc_obj = self.charge_code_controller.get_charge_code_by_id(charge_code_id)
            if cc_obj:
                action_text = "Deactivate" if cc_obj.is_active else "Activate"
                self.toggle_charge_code_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_charge_code_active_btn,
                    "toggle_inactive" if cc_obj.is_active else "standard",
                )

    # --- Owners Tab Methods ---
    def _create_owners_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        button_layout = self._create_standard_button_layout()
        self.add_owner_btn = QPushButton("➕ Add New Owner")
        self._apply_standard_button_style(self.add_owner_btn, "add")
        self.edit_owner_btn = QPushButton("✏️ Edit Selected Owner")
        self._apply_standard_button_style(self.edit_owner_btn, "edit")
        self.toggle_owner_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_owner_active_btn)

        button_layout.addWidget(self.add_owner_btn)
        button_layout.addWidget(self.edit_owner_btn)
        button_layout.addWidget(self.toggle_owner_active_btn)
        button_layout.addStretch(1)
        layout.addLayout(button_layout)

        self.owners_table = self._create_table_widget(
            [
                "Account #",
                "Farm Name",
                "Last Name",
                "First Name",
                "City",
                "State",
                "Phone",
                "Active",
            ]
        )
        if self.owners_table:
            self.owners_table.horizontalHeader().setSectionResizeMode(
                1, QHeaderView.ResizeMode.Stretch
            )
            self.owners_table.horizontalHeader().setSectionResizeMode(
                2, QHeaderView.ResizeMode.Stretch
            )
        layout.addWidget(self.owners_table)
        self._update_owner_action_buttons_state()
        return tab

    def load_owners_data(self):
        self.logger.info("Loading owners data for tab...")
        if not self.owners_table:
            self.logger.error("Owners table not initialized.")
            return
        try:
            # Corrected call to match OwnerController.py
            owners = (
                self.owner_controller.get_all_master_owners()
            )  # Default status_filter is "all"
            self.owners_table.setRowCount(0)
            for owner_obj in owners:
                row_pos = self.owners_table.rowCount()
                self.owners_table.insertRow(row_pos)
                self.owners_table.setItem(
                    row_pos, 0, QTableWidgetItem(owner_obj.account_number or "")
                )
                self.owners_table.setItem(
                    row_pos, 1, QTableWidgetItem(owner_obj.farm_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 2, QTableWidgetItem(owner_obj.last_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 3, QTableWidgetItem(owner_obj.first_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 4, QTableWidgetItem(owner_obj.city or "")
                )
                state_display = owner_obj.state_code or ""
                if (
                    hasattr(owner_obj, "state")
                    and owner_obj.state
                    and hasattr(owner_obj.state, "state_code")
                ):
                    state_display = owner_obj.state.state_code
                self.owners_table.setItem(row_pos, 5, QTableWidgetItem(state_display))
                self.owners_table.setItem(
                    row_pos, 6, QTableWidgetItem(owner_obj.phone or "")
                )
                self.owners_table.setItem(
                    row_pos, 7, QTableWidgetItem("Yes" if owner_obj.is_active else "No")
                )
                self.owners_table.item(row_pos, 0).setData(
                    Qt.ItemDataRole.UserRole, owner_obj.owner_id
                )
            self.logger.info(f"Loaded {len(owners)} owners.")
        except Exception as e:
            self.logger.error(f"Error loading owners: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load owners: {e}")
        self._update_owner_action_buttons_state()

    def _add_owner(self):
        dialog = AddEditOwnerDialog(
            self,
            owner_controller=self.owner_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_owners_data()
            self.entity_updated.emit("owner")

    def _edit_selected_owner(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Edit Owner", "Please select an owner.")
            return

        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()

        owner_to_edit = self.owner_controller.get_owner_by_id(owner_id)

        if owner_to_edit:
            dialog = AddEditOwnerDialog(
                self,
                owner_controller=self.owner_controller,
                owner_object=owner_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_owners_data()
                self.entity_updated.emit("owner")
        else:
            self.show_error("Error", f"Owner ID '{owner_id}' not found.")
            self.load_owners_data()

    def _toggle_selected_owner_active_status(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Toggle Status", "Please select an owner.")
            return
        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
        owner_obj = self.owner_controller.get_owner_by_id(owner_id)

        if not owner_obj:
            self.show_error("Error", f"Owner ID {owner_id} not found.")
            return

        action = "deactivate" if owner_obj.is_active else "activate"
        name_display = (
            owner_obj.farm_name
            or f"{owner_obj.first_name or ''} {owner_obj.last_name or ''}".strip()
            or f"ID: {owner_obj.owner_id}"
        )
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} owner '{name_display}'?",
        ):
            success, message = self.owner_controller.toggle_owner_active_status(
                owner_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_owners_data()
                self.entity_updated.emit("owner")
            else:
                self.show_error("Error", message)

    def _update_owner_action_buttons_state(self):
        has_selection = (
            self.owners_table is not None
            and self.owners_table.currentItem() is not None
        )
        if self.edit_owner_btn:
            self.edit_owner_btn.setEnabled(has_selection)
        if self.toggle_owner_active_btn:
            self.toggle_owner_active_btn.setEnabled(has_selection)

        if has_selection and self.toggle_owner_active_btn and self.owners_table:
            selected_row = self.owners_table.currentRow()
            owner_id_item = self.owners_table.item(selected_row, 0)
            owner_id = (
                owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
            )
            owner_obj = self.owner_controller.get_owner_by_id(owner_id)
            if owner_obj:
                action_text = "Deactivate" if owner_obj.is_active else "Activate"
                self.toggle_owner_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_owner_active_btn,
                    "toggle_inactive" if owner_obj.is_active else "standard",
                )

    def show_info(self, title: str, message: str):
        QMessageBox.information(self, title, message)

    def show_warning(self, title: str, message: str):
        QMessageBox.warning(self, title, message)

    def show_error(self, title: str, message: str):
        QMessageBox.critical(self, title, message)

    def show_question(self, title: str, message: str) -> bool:
        reply = QMessageBox.question(
            self,
            title,
            message,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )
        return reply == QMessageBox.StandardButton.Yes


=============== END FILE: views/admin/user_management_screen.py ===============

=============== FILE: views/admin/dialogs/add_edit_user_dialog.py ===============

# views/admin/dialogs/add_edit_user_dialog.py
"""
EDSI Veterinary Management System - Add/Edit User Dialog
Version: 1.0.5
Purpose: Dialog for creating new users and editing existing user details.
         - Added current_user_id parameter to __init__ for auditing.
Last Updated: June 3, 2025
Author: Gemini (Modified by User's AI Assistant)

Changelog:
- v1.0.5 (2025-06-03):
    - Added `current_user_id: Optional[str] = None` to the `__init__`
      method signature to correctly accept the auditing user ID passed
      from UserManagementScreen. Stored as `self.audit_user_id`.
- v1.0.4 (2025-05-29):
    - Corrected attribute access in _populate_fields method:
        - Changed self.current_user_object.username to self.current_user_object.user_id.
        - Changed self.current_user_object.full_name to self.current_user_object.user_name.
- v1.0.3 (2025-05-29):
    - Modified USER_ROLES list to ["ADMIN", "VETERINARIAN"].
- v1.0.2 (2025-05-29):
    - Refactored _get_dialog_button_style() to use a triple-quoted f-string.
- v1.0.1 (2025-05-27):
    - Modified get_user_data() to return 'user_id' and 'user_name'.
    - Changed 'vet' to 'VETERINARIAN' in USER_ROLES.
- v1.0.0 (2025-05-20):
    - Initial implementation.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QComboBox,
    QCheckBox,
    QDialogButtonBox,
    QLabel,
    QMessageBox,
)
from PySide6.QtGui import QPalette, QColor, QFont  # Added QFont
from PySide6.QtCore import Qt

from controllers.user_controller import UserController
from models.user_models import User
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_BORDER,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_SUCCESS_ACTION,
    DARK_HEADER_FOOTER,
    DEFAULT_FONT_FAMILY,  # Added
)


class AddEditUserDialog(QDialog):
    """Dialog for adding or editing user information."""

    USER_ROLES = [
        "ADMIN",
        "VETERINARIAN",
        "MANAGER",
        "TECHNICIAN",
        "RECEPTIONIST",
    ]  # Restored full list for now

    def __init__(
        self,
        parent_view,
        user_controller: UserController,
        current_user_object: Optional[User] = None,
        current_user_id: Optional[
            str
        ] = None,  # MODIFIED: Added current_user_id for auditing
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.user_controller = user_controller
        self.current_user_object = current_user_object
        self.audit_user_id = current_user_id  # MODIFIED: Store the audit user ID

        self.is_edit_mode = self.current_user_object is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} User")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.current_user_object:
            self._populate_fields()

        self.logger.info(
            f"AddEditUserDialog initialized. Edit mode: {self.is_edit_mode}, Audit User: {self.audit_user_id}"
        )

    def _setup_palette(self):
        # ... (method remains unchanged from v1.0.4) ...
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(
            QPalette.ColorRole.AlternateBase, QColor(DARK_WIDGET_BACKGROUND)
        )  # Was DARK_ITEM_HOVER, check consistency
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(
            QPalette.ColorRole.Highlight, QColor(DARK_PRIMARY_ACTION)
        )  # Or DARK_HIGHLIGHT_BG
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_TEXT_PRIMARY)
        )  # Or DARK_HIGHLIGHT_TEXT
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _get_input_field_style(self) -> str:
        # ... (method remains unchanged from v1.0.4) ...
        return f"""
            QLineEdit, QComboBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {QColor(DARK_PRIMARY_ACTION).darker(130).name()}; /* Adjusted for better visibility */
            }}
            QCheckBox {{
                color: {DARK_TEXT_PRIMARY};
                background-color: transparent;
            }}
            QCheckBox::indicator {{
                width: 13px;
                height: 13px;
            }}
        """

    def _get_dialog_button_style(self) -> str:
        # ... (method remains unchanged from v1.0.4) ...
        return f"""
            QPushButton {{
                background-color: {DARK_BUTTON_BG};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px;
                font-size: 12px; font-weight: 500; min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: {DARK_BUTTON_HOVER};
            }}
            QPushButton:disabled {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
            }}
        """

    def _setup_ui(self):
        # ... (method remains unchanged from v1.0.4) ...
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        form_layout = QFormLayout()
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setFieldGrowthPolicy(
            QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow
        )

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter unique username (Login ID)")
        self.full_name_input = QLineEdit()
        self.full_name_input.setPlaceholderText("Enter user's full name (Display Name)")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Enter user's email address")
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText(
            "Enter password (leave blank to keep current)"
        )
        self.confirm_password_input = QLineEdit()
        self.confirm_password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.confirm_password_input.setPlaceholderText("Confirm new password")
        self.role_combo = QComboBox()
        self.role_combo.addItems(self.USER_ROLES)
        self.is_active_checkbox = QCheckBox("User is Active")
        self.is_active_checkbox.setChecked(True)

        input_style = self._get_input_field_style()
        for field in [
            self.username_input,
            self.full_name_input,
            self.email_input,
            self.password_input,
            self.confirm_password_input,
            self.role_combo,
            self.is_active_checkbox,
        ]:
            if field:
                field.setStyleSheet(input_style)

        form_layout.addRow(QLabel("Login ID*:"), self.username_input)
        form_layout.addRow(QLabel("Full Name*:"), self.full_name_input)
        form_layout.addRow(QLabel("Email:"), self.email_input)
        form_layout.addRow(
            QLabel("Password:" if self.is_edit_mode else "Password*:"),
            self.password_input,
        )
        form_layout.addRow(QLabel("Confirm Password:"), self.confirm_password_input)
        form_layout.addRow(QLabel("Role*:"), self.role_combo)
        form_layout.addRow(QLabel("Status:"), self.is_active_checkbox)

        for i in range(form_layout.rowCount()):
            label_widget = form_layout.labelForField(
                form_layout.itemAt(i, QFormLayout.ItemRole.FieldRole).widget()
            )
            if label_widget:
                label_widget.setStyleSheet(
                    f"color: {DARK_TEXT_SECONDARY}; background: transparent; padding-top: 3px; font-family: {DEFAULT_FONT_FAMILY};"
                )
                # label_widget.setFont(QFont(DEFAULT_FONT_FAMILY)) # Ensure font consistency

        layout.addLayout(form_layout)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Save User" if self.is_edit_mode else "Add User")
        dialog_button_style = self._get_dialog_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(dialog_button_style)
        ok_button.setStyleSheet(
            dialog_button_style
            + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
        )
        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        # ... (method remains unchanged from v1.0.4) ...
        if self.current_user_object:
            self.username_input.setText(self.current_user_object.user_id)
            self.username_input.setReadOnly(True)
            self.username_input.setStyleSheet(
                self._get_input_field_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; }}"
            )
            self.full_name_input.setText(self.current_user_object.user_name or "")
            self.email_input.setText(self.current_user_object.email or "")
            user_role_name_to_select = ""
            if self.current_user_object.roles:
                for role_obj in self.current_user_object.roles:
                    if role_obj.name in self.USER_ROLES:
                        user_role_name_to_select = role_obj.name
                        break
                if not user_role_name_to_select:
                    self.logger.warning(
                        f"User {self.current_user_object.user_id} has roles, but none match current dialog options: {[r.name for r in self.current_user_object.roles]}. Defaulting selection."
                    )
            role_index = -1
            if user_role_name_to_select:
                role_index = self.role_combo.findText(
                    user_role_name_to_select, Qt.MatchFlag.MatchExactly
                )
            if role_index >= 0:
                self.role_combo.setCurrentIndex(role_index)
            else:
                self.logger.warning(
                    f"Role '{user_role_name_to_select}' for user '{self.current_user_object.user_id}' not found in USER_ROLES dropdown. Defaulting."
                )
                if self.role_combo.count() > 0:
                    self.role_combo.setCurrentIndex(0)
                else:
                    self.logger.error(
                        "USER_ROLES is empty, cannot set default role index."
                    )
            self.is_active_checkbox.setChecked(self.current_user_object.is_active)

    def _validate_input(self) -> bool:
        # ... (method remains unchanged from v1.0.4) ...
        login_id = self.username_input.text().strip()
        user_name_val = self.full_name_input.text().strip()
        password = self.password_input.text()
        confirm_password = self.confirm_password_input.text()
        if not login_id:
            QMessageBox.warning(self, "Validation Error", "Login ID cannot be empty.")
            self.username_input.setFocus()
            return False
        if not user_name_val:
            QMessageBox.warning(self, "Validation Error", "Full Name cannot be empty.")
            self.full_name_input.setFocus()
            return False
        if not self.is_edit_mode and not password:
            QMessageBox.warning(
                self, "Validation Error", "Password cannot be empty for new users."
            )
            self.password_input.setFocus()
            return False
        if password and password != confirm_password:
            QMessageBox.warning(self, "Validation Error", "Passwords do not match.")
            self.confirm_password_input.setFocus()
            return False
        email = self.email_input.text().strip()
        if email and ("@" not in email or "." not in email.split("@")[-1]):
            QMessageBox.warning(
                self, "Validation Error", "Please enter a valid email address."
            )
            self.email_input.setFocus()
            return False
        if self.role_combo.currentIndex() == -1 and self.USER_ROLES:
            QMessageBox.warning(self, "Validation Error", "A role must be selected.")
            self.role_combo.setFocus()
            return False
        return True

    def get_user_data(self) -> Optional[Dict]:
        # ... (method remains unchanged from v1.0.4) ...
        if not self._validate_input():
            return None
        data = {
            "user_id": self.username_input.text().strip(),
            "user_name": self.full_name_input.text().strip(),
            "email": self.email_input.text().strip() or None,
            "role": self.role_combo.currentText(),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        password = self.password_input.text()
        if password:
            data["password"] = password
        return data

    def _on_accept(self):
        user_data = self.get_user_data()
        if user_data is None:
            return

        try:
            # Use self.audit_user_id for who is performing the action
            performing_user_id = self.audit_user_id

            if self.is_edit_mode and self.current_user_object:
                self.logger.info(
                    f"Attempting to update user ID: {self.current_user_object.user_id} by {performing_user_id}"
                )
                success, message = self.user_controller.update_user(
                    self.current_user_object.user_id, user_data, performing_user_id
                )
            else:
                self.logger.info(
                    f"Attempting to create new user: {user_data['user_id']} by {performing_user_id}"
                )
                success, message, _ = self.user_controller.create_user(
                    user_data, performing_user_id
                )

            if success:
                self.logger.info(f"User operation successful: {message}")
                self.accept()
            else:
                self.logger.warning(f"User operation failed: {message}")
                QMessageBox.critical(self, "Operation Failed", message)
        except Exception as e:
            self.logger.error(f"Error during user save/update: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")


=============== END FILE: views/admin/dialogs/add_edit_user_dialog.py ===============

=============== FILE: views/admin/dialogs/add_edit_location_dialog.py ===============

# views/admin/dialogs/add_edit_location_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Location Dialog
Version: 1.1.6
Purpose: Dialog for creating and editing practice locations with detailed address fields,
         phone, email, contact person, and auto-populating country code.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.1.6 (2025-06-05):
    - In `validate_and_accept`, corrected the tuple unpacking for the `update_location`
      call to expect two return values (success, message) instead of three,
      resolving a ValueError.
- v1.1.5 (2025-06-02):
    - Added QLineEdit fields for Phone, Email, and Contact Person.
    - Updated QGridLayout in _setup_ui to include new fields.
    - Updated _populate_fields to load data for new fields.
    - Updated get_data to collect data from new fields.
    - Implemented _on_state_changed slot to auto-populate Country Code.
    - Modified _load_states_into_combobox to store country_code with state_code.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.location_controller import LocationController
from models import Location as LocationModel
from models import StateProvince as StateProvinceModel

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditLocationDialog(QDialog):
    def __init__(
        self,
        parent_view,
        controller: LocationController,
        current_user_id: str,
        location: Optional[LocationModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.controller = controller
        self.current_user_id = current_user_id
        self.location = location
        self.is_edit_mode = location is not None

        self.location_name_input: Optional[QLineEdit] = None
        self.contact_person_input: Optional[QLineEdit] = None
        self.address_line1_input: Optional[QLineEdit] = None
        self.address_line2_input: Optional[QLineEdit] = None
        self.city_input: Optional[QLineEdit] = None
        self.state_combo: Optional[QComboBox] = None
        self.zip_code_input: Optional[QLineEdit] = None
        self.country_code_input: Optional[QLineEdit] = None
        self.phone_input: Optional[QLineEdit] = None
        self.email_input: Optional[QLineEdit] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Location")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_states_into_combobox()
        if self.is_edit_mode and self.location:
            self._populate_fields()

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {base_bg};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; 
                border-radius: 4px;
                padding: 6px 10px; 
                font-size: 13px; 
                min-height: 20px; 
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled {{ 
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QComboBox::drop-down {{ 
                border: none;
                background-color: transparent;
            }}
            QComboBox::down-arrow {{ 
                color: {DARK_TEXT_SECONDARY}; 
            }}
            QComboBox QAbstractItemView {{ 
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)

        self.location_name_input = QLineEdit()
        self.location_name_input.setPlaceholderText("e.g., Main Barn, Paddock A")

        self.contact_person_input = QLineEdit()
        self.contact_person_input.setPlaceholderText("Name of contact person")

        self.address_line1_input = QLineEdit()
        self.address_line1_input.setPlaceholderText("Street Address")

        self.address_line2_input = QLineEdit()
        self.address_line2_input.setPlaceholderText("Apartment, Suite, etc. (Optional)")

        self.city_input = QLineEdit()
        self.city_input.setPlaceholderText("City/Town")

        self.state_combo = QComboBox()
        self.state_combo.setPlaceholderText("Select State/Province")
        self.state_combo.currentIndexChanged.connect(self._on_state_changed)

        self.zip_code_input = QLineEdit()
        self.zip_code_input.setPlaceholderText("Zip/Postal Code")

        self.country_code_input = QLineEdit()
        self.country_code_input.setPlaceholderText("e.g., USA, CAN")
        self.country_code_input.setMaxLength(10)

        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText("Primary phone number")

        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Contact email address")

        self.is_active_checkbox = QCheckBox("Location is Active")
        self.is_active_checkbox.setChecked(True)
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        grid_layout.addWidget(
            self._create_label("Location Name*:"), 0, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.location_name_input, 0, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Contact Person:"), 1, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.contact_person_input, 1, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Address Line 1:"), 2, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line1_input, 2, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Address Line 2:"), 3, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line2_input, 3, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("City:"), 4, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.city_input, 4, 1)
        grid_layout.addWidget(
            self._create_label("State/Province:"), 4, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.state_combo, 4, 3)
        grid_layout.addWidget(
            self._create_label("Zip/Postal Code:"), 5, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.zip_code_input, 5, 1)
        grid_layout.addWidget(
            self._create_label("Country Code:"), 5, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.country_code_input, 5, 3)
        grid_layout.addWidget(
            self._create_label("Phone:"), 6, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.phone_input, 6, 1)
        grid_layout.addWidget(
            self._create_label("Email:"), 6, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.email_input, 6, 3)
        grid_layout.addWidget(
            self.is_active_checkbox, 7, 1, 1, 1, Qt.AlignmentFlag.AlignLeft
        )

        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        for field in [
            self.location_name_input,
            self.contact_person_input,
            self.address_line1_input,
            self.address_line2_input,
            self.city_input,
            self.state_combo,
            self.zip_code_input,
            self.country_code_input,
            self.phone_input,
            self.email_input,
        ]:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_button_specific_style = (
                    f"background-color: {DARK_SUCCESS_ACTION}; color: white;"
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ {ok_button_specific_style} }}"
                )

        overall_layout.addWidget(self.button_box)

    def _load_states_into_combobox(self):
        if not self.state_combo:
            return
        self.state_combo.addItem("", None)
        session = None
        try:
            from config.database_config import db_manager

            session = db_manager.get_session()
            states: List[StateProvinceModel] = (
                session.query(StateProvinceModel)
                .filter(StateProvinceModel.is_active == True)
                .order_by(
                    StateProvinceModel.country_code, StateProvinceModel.state_name
                )
                .all()
            )
            for state in states:
                display_name = f"{state.state_name} ({state.state_code})"
                self.state_combo.addItem(
                    display_name,
                    {
                        "state_code": state.state_code,
                        "country_code": state.country_code,
                    },
                )
            self.logger.info(f"Loaded {len(states)} states into combobox.")
        except Exception as e:
            self.logger.error(f"Error loading states into combobox: {e}", exc_info=True)
            QMessageBox.warning(
                self, "Data Load Error", "Could not load states for selection."
            )
        finally:
            if session:
                session.close()

    def _on_state_changed(self, index: int):
        if not self.state_combo or not self.country_code_input:
            return
        selected_data = self.state_combo.itemData(index)
        if selected_data and isinstance(selected_data, dict):
            country_code = selected_data.get("country_code", "")
            self.country_code_input.setText(country_code)
        else:
            self.country_code_input.clear()

    def _populate_fields(self):
        if self.location:
            self.location_name_input.setText(self.location.location_name or "")
            self.contact_person_input.setText(self.location.contact_person or "")
            self.address_line1_input.setText(self.location.address_line1 or "")
            self.address_line2_input.setText(self.location.address_line2 or "")
            self.city_input.setText(self.location.city or "")
            if self.location.state_code:
                for i in range(self.state_combo.count()):
                    item_data = self.state_combo.itemData(i)
                    if (
                        item_data
                        and isinstance(item_data, dict)
                        and item_data.get("state_code") == self.location.state_code
                    ):
                        self.state_combo.setCurrentIndex(i)
                        break
                else:
                    self.logger.warning(
                        f"State code '{self.location.state_code}' not found in combobox. Location: {self.location.location_name}"
                    )
            else:
                self.state_combo.setCurrentIndex(0)
            self.zip_code_input.setText(self.location.zip_code or "")
            self.country_code_input.setText(self.location.country_code or "")
            self.phone_input.setText(self.location.phone or "")
            self.email_input.setText(self.location.email or "")
            self.is_active_checkbox.setChecked(self.location.is_active)

    def get_data(self) -> Dict[str, Any]:
        selected_state_code = None
        if self.state_combo.currentIndex() > 0:
            item_data = self.state_combo.currentData()
            if item_data and isinstance(item_data, dict):
                selected_state_code = item_data.get("state_code")

        return {
            "location_name": self.location_name_input.text(),
            "contact_person": self.contact_person_input.text(),
            "address_line1": self.address_line1_input.text(),
            "address_line2": self.address_line2_input.text(),
            "city": self.city_input.text(),
            "state_code": selected_state_code,
            "zip_code": self.zip_code_input.text(),
            "country_code": self.country_code_input.text(),
            "phone": self.phone_input.text(),
            "email": self.email_input.text(),
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        data = self.get_data()
        is_valid, errors = self.controller.validate_location_data(
            data,
            is_new=(not self.is_edit_mode),
            location_id_to_check_for_unique=(
                self.location.location_id
                if self.is_edit_mode and self.location
                else None
            ),
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.location:
                # MODIFIED: Correctly unpack the two return values from update_location
                success, message = self.controller.update_location(
                    self.location.location_id, data, self.current_user_id
                )
            else:
                # create_location returns three values
                success, message, _ = self.controller.create_location(
                    data, self.current_user_id
                )

            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    self.logger.warning(
                        "parent_view does not have show_info method. Using local QMessageBox."
                    )
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during location save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== END FILE: views/admin/dialogs/add_edit_location_dialog.py ===============

=============== FILE: views/admin/dialogs/add_edit_charge_code_dialog.py ===============

# views/admin/dialogs/add_edit_charge_code_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Dialog
Version: 1.1.10
Purpose: Dialog for creating and editing charge codes.
         - Implemented auto-uppercase for the 'Alt. Code' field.
Last Updated: June 3, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.10 (2025-06-03):
    - Added a slot `_on_alt_code_text_edited` connected to the `textEdited`
      signal of `alt_code_input` to automatically convert input to uppercase
      as the user types.
    - Imported `Slot` from `PySide6.QtCore`.
- v1.1.9 (2025-06-03):
    - Added `QHBoxLayout` to imports from `PySide6.QtWidgets` to resolve
      a NameError in `_setup_ui` when creating `status_layout`.
- v1.1.8 (2025-06-03):
    - Made 'is_active_checkbox' and 'taxable_checkbox' disabled (read-only).
    - Removed 'is_active' and 'taxable' from the `get_data()` method.
- v1.1.7 (2025-06-03):
    - Removed 'detail_category_combo' for a 2-level hierarchy.
    - Updated category selection logic in `_populate_fields` and `get_data`.
- v1.1.6 (2025-06-02):
    - Added `QTimer` import.
# ... (previous changelog entries)
"""

import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QTextEdit,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QHBoxLayout,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer, Slot  # MODIFIED: Added Slot

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCode as ChargeCodeModel
from models import ChargeCodeCategory

from config.app_config import AppConfig
import os

try:
    current_script_path_for_assets = os.path.dirname(os.path.abspath(__file__))
    project_root_for_assets = os.path.abspath(
        os.path.join(current_script_path_for_assets, "..", "..", "..")
    )
    assets_path = os.path.join(project_root_for_assets, "assets", "icons")
    if not os.path.exists(
        os.path.join(assets_path, "checkmark_light.svg")
    ):  # Basic check
        assets_path = "assets/icons"
except Exception:
    assets_path = "assets/icons"


from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        charge_code: Optional[ChargeCodeModel] = None,
    ):
        # ... (__init__ remains largely unchanged from v1.1.9) ...
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.charge_code = charge_code
        self.is_edit_mode = charge_code is not None

        self.code_input: Optional[QLineEdit] = None
        self.alt_code_input: Optional[QLineEdit] = None
        self.description_input: Optional[QTextEdit] = None
        self.main_category_combo: Optional[QComboBox] = None
        self.sub_category_combo: Optional[QComboBox] = None
        self.standard_charge_input: Optional[QDoubleSpinBox] = None
        self.taxable_checkbox: Optional[QCheckBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Charge Code")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_main_categories()

        if self.is_edit_mode and self.charge_code:
            self._populate_fields()
        else:
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(True)
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(False)
            if self.sub_category_combo:
                self.sub_category_combo.setEnabled(False)

        if self.is_active_checkbox:
            self.is_active_checkbox.setEnabled(False)
        if self.taxable_checkbox:
            self.taxable_checkbox.setEnabled(False)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        # ... (method remains unchanged from v1.1.9) ...
        checkmark_path = os.path.join(assets_path, "checkmark_light.svg").replace(
            os.sep, "/"
        )
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; min-height: 20px; }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QLineEdit:disabled, QComboBox:disabled, QTextEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER}; }}
            QLineEdit[readOnly="true"] {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
            QCheckBox::indicator:disabled {{ background-color: {DARK_INPUT_FIELD_BACKGROUND}; border: 1px solid {DARK_TEXT_TERTIARY}; }}
            QCheckBox::indicator:checked:disabled {{ background-color: {DARK_PRIMARY_ACTION}; border: 1px solid {DARK_PRIMARY_ACTION}; image: url({checkmark_path}); }}
            QCheckBox:disabled {{ color: {DARK_TEXT_SECONDARY}; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        # ... (method remains unchanged from v1.1.9) ...
        return f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;}} QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"

    def _setup_palette(self):
        # ... (method remains unchanged from v1.1.9) ...
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        # ... (method remains unchanged from v1.1.9) ...
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        # ... (UI setup for other fields remains unchanged from v1.1.9) ...
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)
        self.code_input = QLineEdit()
        self.code_input.setPlaceholderText("Unique code (e.g., EXAM01)")
        self.alt_code_input = QLineEdit()
        self.alt_code_input.setPlaceholderText("Alternative code (optional)")
        # MODIFIED: Connect textEdited signal for alt_code_input
        if self.alt_code_input:
            self.alt_code_input.textEdited.connect(self._on_alt_code_text_edited)

        self.main_category_combo = QComboBox()
        self.main_category_combo.setPlaceholderText("Select Main Category")
        self.sub_category_combo = QComboBox()
        self.sub_category_combo.setPlaceholderText("Select Sub-Category")
        self.description_input = QTextEdit()
        self.description_input.setPlaceholderText("Detailed description")
        self.description_input.setFixedHeight(70)
        self.standard_charge_input = QDoubleSpinBox()
        self.standard_charge_input.setDecimals(2)
        self.standard_charge_input.setRange(0.00, 99999.99)
        self.standard_charge_input.setPrefix("$ ")
        self.standard_charge_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.taxable_checkbox = QCheckBox("Taxable")
        self.taxable_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )
        self.is_active_checkbox = QCheckBox("Active")
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Alt. Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.alt_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Main Category*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.main_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Sub-Category:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.sub_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Standard Charge*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.standard_charge_input, row, 1)
        status_layout = QHBoxLayout()
        status_layout.addWidget(self.taxable_checkbox)
        status_layout.addSpacing(20)
        status_layout.addWidget(self.is_active_checkbox)
        status_layout.addStretch()
        grid_layout.addLayout(
            status_layout,
            row,
            2,
            1,
            2,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )
        row += 1
        grid_layout.addWidget(
            self._create_label("Description*:"),
            row,
            0,
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight,
        )
        grid_layout.addWidget(self.description_input, row, 1, 1, 3)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        fields_to_style = [
            self.code_input,
            self.alt_code_input,
            self.description_input,
            self.main_category_combo,
            self.sub_category_combo,
            self.standard_charge_input,
        ]
        for field in fields_to_style:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_style = (
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
                button.setStyleSheet(ok_style)
        overall_layout.addWidget(self.button_box)
        if self.main_category_combo:
            self.main_category_combo.currentIndexChanged.connect(
                self._on_main_category_changed
            )

    @Slot(str)  # MODIFIED: Added Slot decorator and type hint for 'text' argument
    def _on_alt_code_text_edited(self, text: str):
        """Automatically converts the alt_code_input text to uppercase."""
        if self.alt_code_input:
            current_text = text  # Use the text passed by the signal
            uppercase_text = current_text.upper()
            if current_text != uppercase_text:
                # Block signals to prevent potential recursion if setText itself emitted textEdited
                self.alt_code_input.blockSignals(True)
                cursor_pos = self.alt_code_input.cursorPosition()
                self.alt_code_input.setText(uppercase_text)
                self.alt_code_input.setCursorPosition(cursor_pos)
                self.alt_code_input.blockSignals(False)

    def _load_main_categories(self):
        # ... (method remains unchanged from v1.1.9) ...
        if not self.main_category_combo:
            return
        self.main_category_combo.clear()
        self.main_category_combo.addItem("Select Main Category...", None)
        try:
            categories = self.controller.get_charge_code_categories(level=1)
            for cat in categories:
                self.main_category_combo.addItem(cat.name, cat.category_id)
        except Exception as e:
            self.logger.error(f"Error loading main categories: {e}", exc_info=True)

    def _on_main_category_changed(self, index: int):
        # ... (method remains unchanged from v1.1.9) ...
        if not self.main_category_combo or not self.sub_category_combo:
            return
        self.sub_category_combo.clear()
        self.sub_category_combo.addItem("Select Sub-Category...", None)
        parent_id = self.main_category_combo.itemData(index)
        if parent_id is not None:
            try:
                sub_categories = self.controller.get_charge_code_categories(
                    parent_id=parent_id, level=2
                )
                if sub_categories:
                    for cat in sub_categories:
                        self.sub_category_combo.addItem(cat.name, cat.category_id)
                    self.sub_category_combo.setEnabled(True)
                else:
                    self.sub_category_combo.setEnabled(False)
            except Exception as e:
                self.logger.error(
                    f"Error loading sub-categories for parent_id {parent_id}: {e}",
                    exc_info=True,
                )
                self.sub_category_combo.setEnabled(False)
        else:
            self.sub_category_combo.setEnabled(False)

    def _populate_fields(self):
        # ... (method remains unchanged from v1.1.9) ...
        if self.is_edit_mode and self.charge_code:
            self.code_input.setText(self.charge_code.code)
            self.code_input.setReadOnly(True)
            self.code_input.setStyleSheet(
                self._get_form_input_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
            )
            self.alt_code_input.setText(self.charge_code.alternate_code or "")
            self.description_input.setPlainText(self.charge_code.description)
            self.standard_charge_input.setValue(
                float(self.charge_code.standard_charge)
                if self.charge_code.standard_charge is not None
                else 0.0
            )
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(self.charge_code.taxable or False)
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(self.charge_code.is_active)
            if self.charge_code.category_id is not None:
                path = self.controller.get_category_path(self.charge_code.category_id)
                if path:
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(True)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(True)
                    if len(path) > 0 and self.main_category_combo:
                        main_cat_id = path[0].category_id
                        index = self.main_category_combo.findData(main_cat_id)
                        if index >= 0:
                            self.main_category_combo.setCurrentIndex(index)
                        self._on_main_category_changed(
                            self.main_category_combo.currentIndex()
                        )
                    if len(path) > 1 and self.sub_category_combo:
                        sub_cat_id = path[1].category_id
                        QTimer.singleShot(
                            0,
                            lambda: self._select_combo_item(
                                self.sub_category_combo, sub_cat_id, False
                            ),
                        )
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(False)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(False)
            else:
                if self.sub_category_combo:
                    self.sub_category_combo.setEnabled(False)

    def _select_combo_item(
        self, combo: QComboBox, item_id_to_select: int, trigger_next_load: bool
    ):
        # ... (method remains unchanged from v1.1.9) ...
        if not combo:
            return
        index = combo.findData(item_id_to_select)
        if index >= 0:
            combo.setCurrentIndex(index)

    def get_data(self) -> Optional[Dict[str, Any]]:
        # ... (method remains unchanged from v1.1.9 - no 'is_active' or 'taxable') ...
        code = self.code_input.text().strip().upper()
        description = self.description_input.toPlainText().strip()
        standard_charge_value = self.standard_charge_input.value()
        errors = []
        if not code:
            errors.append("Code is required.")
        if not description:
            errors.append("Description is required.")
        charge_decimal: Optional[Decimal] = None
        try:
            charge_decimal = Decimal(str(standard_charge_value))
            if charge_decimal < Decimal("0.00"):
                errors.append("Standard Charge cannot be negative.")
        except InvalidOperation:
            errors.append("Standard Charge must be a valid number (e.g., 25.00).")
        selected_category_id: Optional[int] = None
        if (
            self.sub_category_combo
            and self.sub_category_combo.currentIndex() > 0
            and self.sub_category_combo.isEnabled()
        ):
            selected_category_id = self.sub_category_combo.currentData()
        elif self.main_category_combo and self.main_category_combo.currentIndex() > 0:
            selected_category_id = self.main_category_combo.currentData()
        if selected_category_id is None:
            errors.append(
                "A category selection (Main Category, or Sub-Category if applicable) is required."
            )
        if errors:
            QMessageBox.warning(self, "Input Error", "\n".join(errors))
            return None
        return {
            "code": code,
            "alternate_code": self.alt_code_input.text().strip().upper() or None,
            "description": description,
            "category_id": selected_category_id,
            "standard_charge": charge_decimal,
        }

    def validate_and_accept(self):
        # ... (method remains unchanged from v1.1.9) ...
        data = self.get_data()
        if data is None:
            return
        validation_data_for_controller = data.copy()
        if self.is_edit_mode and self.charge_code:
            if self.is_active_checkbox:
                validation_data_for_controller["is_active"] = (
                    self.is_active_checkbox.isChecked()
                )
            if self.taxable_checkbox:
                validation_data_for_controller["taxable"] = (
                    self.taxable_checkbox.isChecked()
                )
        is_valid, errors = self.controller.validate_charge_code_data(
            validation_data_for_controller, is_new=(not self.is_edit_mode)
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return
        try:
            if self.is_edit_mode and self.charge_code:
                success, message = self.controller.update_charge_code(
                    self.charge_code.charge_code_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code(
                    data, self.current_user_id
                )
            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(
                f"Error during charge code save/update: {e}", exc_info=True
            )
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== END FILE: views/admin/dialogs/add_edit_charge_code_dialog.py ===============

=============== FILE: views/admin/dialogs/add_edit_charge_code_category_dialog.py ===============

# views/admin/dialogs/add_edit_charge_code_category_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Category/Process Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing charge code categories (Level 1)
         and processes (Level 2).
Last Updated: June 3, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCodeCategory

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeCategoryDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        category_to_edit: Optional[ChargeCodeCategory] = None,
        parent_category: Optional[
            ChargeCodeCategory
        ] = None,  # For adding a new Level 2 Process
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.category_to_edit = category_to_edit
        self.parent_category = (
            parent_category  # Will be None if adding/editing a Level 1 Category
        )

        self.is_edit_mode = self.category_to_edit is not None

        # Determine level
        if self.is_edit_mode:
            self.current_level = self.category_to_edit.level
            self.current_parent_id = self.category_to_edit.parent_id
            if (
                self.current_parent_id and not self.parent_category
            ):  # Fetch parent if editing L2 and not passed
                self.parent_category = self.controller.get_category_by_id_internal(
                    self.current_parent_id
                )

        elif self.parent_category:  # Adding a new Level 2 Process
            self.current_level = 2
            self.current_parent_id = self.parent_category.category_id
        else:  # Adding a new Level 1 Category
            self.current_level = 1
            self.current_parent_id = None

        self.item_type_name = "Process" if self.current_level == 2 else "Category"

        self.setWindowTitle(
            f"{'Edit' if self.is_edit_mode else 'Add New'} {self.item_type_name}"
        )
        self.setMinimumWidth(450)

        # Input Fields
        self.name_input: Optional[QLineEdit] = None
        self.parent_name_label: Optional[QLabel] = None  # To display parent name
        self.level_label: Optional[QLabel] = None  # To display level
        self.is_active_checkbox: Optional[QCheckBox] = None

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.category_to_edit:
            self._populate_fields()
        else:  # New item
            self.is_active_checkbox.setChecked(True)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {base_bg};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px;
                padding: 6px 10px; font-size: 13px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled {{ 
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QCheckBox::indicator {{ width: 13px; height: 13px; }}
            QCheckBox {{ color: {DARK_TEXT_PRIMARY}; background-color: transparent; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        # ... (rest of palette setup - can be copied from another dialog) ...
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str, is_field_value: bool = False) -> QLabel:
        label = QLabel(text)
        style = f"color: {DARK_TEXT_PRIMARY if is_field_value else DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        if is_field_value:
            style += f" padding-left: 5px; border: 1px solid {DARK_BORDER}; border-radius: 4px; background-color: {DARK_HEADER_FOOTER}; min-height: 20px;"

        label.setStyleSheet(style)
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText(f"Enter {self.item_type_name} Name")

        # Display Parent Category Name (if applicable)
        parent_display_name = (
            self.parent_category.name if self.parent_category else "N/A (Top Level)"
        )
        self.parent_name_label = self._create_label(
            parent_display_name, is_field_value=True
        )

        # Display Level
        self.level_label = self._create_label(
            str(self.current_level), is_field_value=True
        )

        self.is_active_checkbox = QCheckBox("Is Active")

        form_layout.addRow(
            self._create_label(f"{self.item_type_name} Name*:"), self.name_input
        )
        if self.current_level == 2:  # Only show parent for Processes (Level 2)
            form_layout.addRow(
                self._create_label("Parent Category:"), self.parent_name_label
            )
        form_layout.addRow(self._create_label("Level:"), self.level_label)
        form_layout.addRow(self._create_label("Status:"), self.is_active_checkbox)

        input_style = self._get_form_input_style()
        self.name_input.setStyleSheet(input_style)
        self.is_active_checkbox.setStyleSheet(input_style)  # For QCheckBox part

        layout.addLayout(form_layout)
        layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        if self.category_to_edit:
            self.name_input.setText(self.category_to_edit.name)
            self.is_active_checkbox.setChecked(self.category_to_edit.is_active)
            # Parent and Level are already set in __init__ and displayed by labels

    def get_data(self) -> Optional[Dict[str, Any]]:
        name = self.name_input.text().strip()
        if not name:
            QMessageBox.warning(
                self, "Input Error", f"{self.item_type_name} Name is required."
            )
            return None

        return {
            "name": name,
            "is_active": self.is_active_checkbox.isChecked(),
            "level": self.current_level,
            "parent_id": self.current_parent_id,
        }

    def validate_and_accept(self):
        data = self.get_data()
        if data is None:
            return

        # Use the controller's validation method
        is_valid, errors = self.controller.validate_charge_code_category_data(
            data,
            is_new=(not self.is_edit_mode),
            category_id=(
                self.category_to_edit.category_id if self.is_edit_mode else None
            ),
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Validation Error",
                "Please correct errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.category_to_edit:
                success, message = self.controller.update_charge_code_category(
                    self.category_to_edit.category_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code_category(
                    data, self.current_user_id
                )

            if success:
                if hasattr(
                    self.parent_view, "show_info"
                ):  # Check if parent_view has show_info
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error saving category/process: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {str(e)}"
            )


=============== END FILE: views/admin/dialogs/add_edit_charge_code_category_dialog.py ===============

=============== FILE: views/admin/dialogs/add_edit_owner_dialog.py ===============

# views/admin/dialogs/add_edit_owner_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Owner Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing Owner master file records,
         including contact, address, and financial information.
         Styled to match HorseUnifiedManagement forms, using QGridLayout.
Last Updated: June 2, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-06-02):
    - Initial implementation.
    - Includes fields for account info, name, address (with state dropdown
      and auto-populated, read-only country), contact details, and financial info
      (Balance (display-only), Credit Limit, Billing Terms dropdown).
    - Uses QGridLayout for layout.
    - Styled using _get_form_input_style (adapted from HorseUnifiedManagement)
      and _create_label helper.
    - Populates states from OwnerController and billing terms from a predefined list.
    - Implements _on_state_changed to auto-populate country code.
    - Implements _populate_fields, get_data, and validate_and_accept methods.
"""

import logging
from typing import Optional, Dict, Any, List
from decimal import Decimal, InvalidOperation

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QDoubleSpinBox,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController
from models import Owner as OwnerModel

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)

PREDEFINED_BILLING_TERMS = [
    "Net 30 Days",
    "Net 60 Days",
    "Net 90 Days",
    "Due on Receipt",
    "COD",
    "Prepay",
    "Monthly Statement",
]


class AddEditOwnerDialog(QDialog):
    def __init__(
        self,
        parent_view,
        owner_controller: OwnerController,
        current_user_id: str,
        owner_object: Optional[OwnerModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.owner_controller = owner_controller
        self.current_user_id = current_user_id
        self.owner = owner_object
        self.is_edit_mode = owner_object is not None

        self.account_number_input: Optional[QLineEdit] = None
        self.farm_name_input: Optional[QLineEdit] = None
        self.first_name_input: Optional[QLineEdit] = None
        self.last_name_input: Optional[QLineEdit] = None
        self.address_line1_input: Optional[QLineEdit] = None
        self.address_line2_input: Optional[QLineEdit] = None
        self.city_input: Optional[QLineEdit] = None
        self.state_combo: Optional[QComboBox] = None
        self.zip_code_input: Optional[QLineEdit] = None
        self.country_code_input: Optional[QLineEdit] = None
        self.phone_input: Optional[QLineEdit] = None
        self.mobile_phone_input: Optional[QLineEdit] = None
        self.email_input: Optional[QLineEdit] = None
        self.balance_display_input: Optional[QLineEdit] = None
        self.credit_limit_input: Optional[QDoubleSpinBox] = None
        self.billing_terms_combo: Optional[QComboBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Owner")
        self.setMinimumWidth(700)

        self._setup_palette()
        self._setup_ui()
        self._load_reference_data_into_combos()
        if self.is_edit_mode and self.owner:
            self._populate_fields()

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox, QDoubleSpinBox {{
                background-color: {base_bg}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px;
                padding: 6px 10px; font-size: 13px; min-height: 20px; 
            }}
            QLineEdit:focus, QComboBox:focus, QDoubleSpinBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled, QDoubleSpinBox:disabled {{ 
                background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
            }}
            QComboBox::drop-down {{ border: none; background-color: transparent; }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QComboBox QAbstractItemView {{ 
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)

        self.account_number_input = QLineEdit()
        self.account_number_input.setPlaceholderText("e.g., SMIJ01")
        self.farm_name_input = QLineEdit()
        self.farm_name_input.setPlaceholderText("Optional")
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Contact's First Name")
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Contact's Last Name")
        self.address_line1_input = QLineEdit()
        self.address_line1_input.setPlaceholderText("Street address, P.O. box")
        self.address_line2_input = QLineEdit()
        self.address_line2_input.setPlaceholderText("Apt, suite, etc. (Optional)")
        self.city_input = QLineEdit()
        self.city_input.setPlaceholderText("City/Town")
        self.state_combo = QComboBox()
        self.state_combo.setPlaceholderText("Select State/Province")
        self.zip_code_input = QLineEdit()
        self.zip_code_input.setPlaceholderText("Zip/Postal Code")
        self.country_code_input = QLineEdit()
        self.country_code_input.setPlaceholderText("Auto (e.g. USA, CAN)")
        self.country_code_input.setReadOnly(True)
        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText("(xxx) xxx-xxxx")
        self.mobile_phone_input = QLineEdit()
        self.mobile_phone_input.setPlaceholderText("Optional")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("example@domain.com")
        self.balance_display_input = QLineEdit("0.00")
        self.balance_display_input.setReadOnly(True)
        self.balance_display_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.credit_limit_input = QDoubleSpinBox()
        self.credit_limit_input.setDecimals(2)
        self.credit_limit_input.setRange(0.00, 9999999.99)
        self.credit_limit_input.setPrefix("$ ")
        self.credit_limit_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.credit_limit_input.setValue(0.00)
        self.billing_terms_combo = QComboBox()
        self.is_active_checkbox = QCheckBox("Owner is Active")
        self.is_active_checkbox.setChecked(True)
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Account #:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.account_number_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Farm Name:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.farm_name_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("First Name:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.first_name_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Last Name:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.last_name_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Address Line 1*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line1_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Address Line 2:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line2_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("City*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.city_input, row, 1)
        grid_layout.addWidget(
            self._create_label("State/Province*:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.state_combo, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Zip/Postal Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.zip_code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Country Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.country_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Phone:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.phone_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Mobile Phone:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.mobile_phone_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Email:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.email_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Balance:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.balance_display_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Credit Limit:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.credit_limit_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Billing Terms:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.billing_terms_combo, row, 1)
        grid_layout.addWidget(
            self.is_active_checkbox, row, 3, Qt.AlignmentFlag.AlignLeft
        )

        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 120)
        grid_layout.setColumnMinimumWidth(2, 120)

        form_style = self._get_form_input_style()
        all_fields = [
            self.account_number_input,
            self.farm_name_input,
            self.first_name_input,
            self.last_name_input,
            self.address_line1_input,
            self.address_line2_input,
            self.city_input,
            self.state_combo,
            self.zip_code_input,
            self.country_code_input,
            self.phone_input,
            self.mobile_phone_input,
            self.email_input,
            self.balance_display_input,
            self.credit_limit_input,
            self.billing_terms_combo,
        ]
        for field in all_fields:
            if field:
                field.setStyleSheet(form_style)

        # Special read-only style for balance and country code (as it's auto-populated)
        read_only_style_addon = f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        if self.balance_display_input:
            self.balance_display_input.setStyleSheet(form_style + read_only_style_addon)
        if self.country_code_input:
            self.country_code_input.setStyleSheet(form_style + read_only_style_addon)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_button_specific_style = (
                    f"background-color: {DARK_SUCCESS_ACTION}; color: white;"
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ {ok_button_specific_style} }}"
                )
        overall_layout.addWidget(self.button_box)

        self.state_combo.currentIndexChanged.connect(self._on_state_changed)

    def _load_reference_data_into_combos(self):
        # Load States
        if not self.state_combo:
            self.logger.error("State combo not initialized.")
            return
        self.state_combo.addItem("", None)
        try:
            ref_data = self.owner_controller.get_owner_form_reference_data()
            states = ref_data.get("states", [])
            for state_data in states:
                display_name = f"{state_data['name']} ({state_data['id']})"
                country_code = state_data.get(
                    "country_code", "USA"
                )  # Default to USA if not present
                if country_code.upper() != "USA":
                    display_name += f" - {country_code}"
                self.state_combo.addItem(
                    display_name,
                    {"state_code": state_data["id"], "country_code": country_code},
                )
            self.logger.info(f"Loaded {len(states)} states into combobox.")
        except Exception as e:
            self.logger.error(
                f"Error loading states from controller: {e}", exc_info=True
            )
            QMessageBox.warning(
                self, "Data Load Error", "Could not load states for selection."
            )

        # Load Billing Terms
        if not self.billing_terms_combo:
            self.logger.error("Billing terms combo not initialized.")
            return
        self.billing_terms_combo.addItem("", "")
        self.billing_terms_combo.addItems(PREDEFINED_BILLING_TERMS)
        self.billing_terms_combo.setCurrentIndex(0)
        self.logger.info(f"Loaded {len(PREDEFINED_BILLING_TERMS)} billing terms.")

    def _on_state_changed(self, index: int):
        if not self.state_combo or not self.country_code_input:
            return
        selected_data = self.state_combo.itemData(index)
        if selected_data and isinstance(selected_data, dict):
            country_code = selected_data.get("country_code", "")
            self.country_code_input.setText(country_code)
        else:
            self.country_code_input.clear()

    def _populate_fields(self):
        if self.owner:
            self.account_number_input.setText(self.owner.account_number or "")
            if self.is_edit_mode:
                self.account_number_input.setReadOnly(True)
                self.account_number_input.setStyleSheet(
                    self._get_form_input_style()
                    + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
                )

            self.farm_name_input.setText(self.owner.farm_name or "")
            self.first_name_input.setText(self.owner.first_name or "")
            self.last_name_input.setText(self.owner.last_name or "")
            self.address_line1_input.setText(self.owner.address_line1 or "")
            self.address_line2_input.setText(self.owner.address_line2 or "")
            self.city_input.setText(self.owner.city or "")

            current_state_code = self.owner.state_code
            if current_state_code:
                for i in range(self.state_combo.count()):
                    item_data = self.state_combo.itemData(i)
                    if (
                        item_data
                        and isinstance(item_data, dict)
                        and item_data.get("state_code") == current_state_code
                    ):
                        self.state_combo.setCurrentIndex(i)
                        # _on_state_changed will be triggered, setting country_code_input
                        break
            else:
                self.state_combo.setCurrentIndex(0)
                self.country_code_input.clear()  # Clear country if no state

            self.zip_code_input.setText(self.owner.zip_code or "")
            # self.country_code_input will be set by _on_state_changed or if state_code is initially None

            self.phone_input.setText(self.owner.phone or "")
            self.mobile_phone_input.setText(self.owner.mobile_phone or "")
            self.email_input.setText(self.owner.email or "")

            self.balance_display_input.setText(
                f"{self.owner.balance:.2f}"
                if self.owner.balance is not None
                else "0.00"
            )
            self.credit_limit_input.setValue(
                float(self.owner.credit_limit)
                if self.owner.credit_limit is not None
                else 0.00
            )

            if self.owner.billing_terms:
                index = self.billing_terms_combo.findText(
                    self.owner.billing_terms, Qt.MatchFlag.MatchExactly
                )
                if index >= 0:
                    self.billing_terms_combo.setCurrentIndex(index)
                else:
                    self.billing_terms_combo.addItem(self.owner.billing_terms)
                    self.billing_terms_combo.setCurrentText(self.owner.billing_terms)
            else:
                if self.billing_terms_combo.count() > 0:
                    self.billing_terms_combo.setCurrentIndex(0)

            self.is_active_checkbox.setChecked(self.owner.is_active)

    def get_data(self) -> Optional[Dict[str, Any]]:
        selected_state_item_data = self.state_combo.currentData()
        selected_state_code = None
        if selected_state_item_data and isinstance(selected_state_item_data, dict):
            selected_state_code = selected_state_item_data.get("state_code")

        credit_limit_val = self.credit_limit_input.value()
        credit_limit_decimal: Optional[Decimal] = None
        try:
            credit_limit_decimal = Decimal(str(credit_limit_val))
        except InvalidOperation:
            self.logger.warning(
                f"Invalid decimal value for credit limit: {credit_limit_val}, treating as None."
            )

        data = {
            "account_number": self.account_number_input.text().strip() or None,
            "farm_name": self.farm_name_input.text().strip() or None,
            "first_name": self.first_name_input.text().strip() or None,
            "last_name": self.last_name_input.text().strip() or None,
            "address_line1": self.address_line1_input.text().strip() or None,
            "address_line2": self.address_line2_input.text().strip() or None,
            "city": self.city_input.text().strip() or None,
            "state_code": selected_state_code,
            "zip_code": self.zip_code_input.text().strip() or None,
            "phone": self.phone_input.text().strip() or None,
            "mobile_phone": self.mobile_phone_input.text().strip() or None,
            "email": self.email_input.text().strip() or None,
            "credit_limit": credit_limit_decimal,
            "billing_terms": (
                self.billing_terms_combo.currentText()
                if self.billing_terms_combo.currentIndex() > 0
                else None
            ),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        return data

    def validate_and_accept(self):
        owner_data = self.get_data()
        if owner_data is None:
            return

        is_valid, errors = self.owner_controller.validate_owner_data(
            owner_data, is_new=(not self.is_edit_mode)
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.owner:
                success, message = self.owner_controller.update_master_owner(
                    self.owner.owner_id, owner_data, self.current_user_id
                )
            else:
                success, message, _ = self.owner_controller.create_master_owner(  # type: ignore
                    owner_data, self.current_user_id
                )
            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during owner save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== END FILE: views/admin/dialogs/add_edit_owner_dialog.py ===============

=============== FILE: controllers/user_controller.py ===============

# controllers/user_controller.py
"""
EDSI Veterinary Management System - User Controller
Version: 1.2.8
Purpose: Handles user authentication, CRUD operations.
         - Moved self-deactivation check into the controller.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.2.8 (2025-06-05):
    - In `toggle_user_active_status`, added a check to prevent a user from
      deactivating their own account, moving this business rule from the
      view into the controller for better enforcement.
- v1.2.7 (2025-06-05):
    - Added `toggle_user_active_status` method to handle activating and
      deactivating users, including a safeguard to prevent deactivating the
      last active ADMIN account.
"""

import logging
from typing import List, Optional, Tuple, Dict, Any
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func, exc as sqlalchemy_exc
from datetime import datetime

from config.database_config import db_manager
from models.user_models import User, Role, UserRole


class UserController:
    """Controller for user management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def authenticate_user(
        self, login_id_attempt: str, password_attempt: str
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        # ... (implementation unchanged) ...
        try:
            self.logger.info(
                f"UserController.authenticate_user received login_id: '{login_id_attempt}', "
                f"password_attempt (first 3 chars): '{password_attempt[:3] if password_attempt else ''}...'"
            )
            session = db_manager.get_session()
            try:
                user = (
                    session.query(User)
                    .filter(User.user_id.collate("NOCASE") == login_id_attempt)
                    .first()
                )
                if not user:
                    self.logger.warning(
                        f"Login ID '{login_id_attempt}' not found during authentication."
                    )
                    return False, "Invalid Login ID or Password.", None
                if not user.check_password(password_attempt):
                    self.logger.warning(
                        f"Incorrect password attempt for login ID '{user.user_id}' (input was '{login_id_attempt}')."
                    )
                    return False, "Invalid Login ID or Password.", None
                if not user.is_active:
                    self.logger.warning(
                        f"Login attempt for inactive user '{user.user_id}'."
                    )
                    return (
                        False,
                        f"User account '{user.user_id}' is inactive.",
                        {
                            "user_id": user.user_id,
                            "user_name": user.user_name,
                            "is_active": user.is_active,
                        },
                    )
                if hasattr(user, "last_login"):
                    user.last_login = datetime.utcnow()
                session.commit()
                self.logger.info(f"User '{user.user_id}' authenticated successfully.")
                return (
                    True,
                    "Login successful.",
                    {
                        "user_id": user.user_id,
                        "user_name": user.user_name,
                        "is_active": user.is_active,
                    },
                )
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                session.rollback()
                self.logger.error(
                    f"Database error during authentication for '{login_id_attempt}': {e_db}",
                    exc_info=True,
                )
                return False, "An error occurred during login. Please try again.", None
            finally:
                session.close()
        except Exception as e_outer:
            self.logger.error(
                f"Outer unexpected error during authentication for '{login_id_attempt}': {e_outer}",
                exc_info=True,
            )
            return False, "An unexpected server error occurred. Please try again.", None

    def get_all_users(self, include_inactive: bool = True) -> List[User]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            query = session.query(User).options(joinedload(User.roles))
            if not include_inactive:
                query = query.filter(User.is_active == True)
            users = query.order_by(User.user_id).all()
            return users
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all users: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_user_by_login_id(self, login_id_str: str) -> Optional[User]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            return user
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching user by login_id '{login_id_str}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_user_data(
        self,
        user_data: Dict[str, Any],
        is_new: bool = True,
        original_login_id_to_ignore: Optional[str] = None,
    ) -> Tuple[bool, List[str]]:
        # ... (implementation unchanged) ...
        try:
            from views.admin.dialogs.add_edit_user_dialog import AddEditUserDialog

            available_roles_in_dialog = AddEditUserDialog.USER_ROLES
        except ImportError:
            self.logger.warning(
                "Could not import AddEditUserDialog for role validation. Role list might be incomplete."
            )
            available_roles_in_dialog = []
        errors = []
        login_id = user_data.get("user_id", "").strip()
        display_name = user_data.get("user_name", "").strip()
        password = user_data.get("password", "")
        email_value = user_data.get("email")
        email = email_value.strip() if isinstance(email_value, str) else None
        if not login_id:
            errors.append("Login ID (Username) is required.")
        elif len(login_id) > 20:
            errors.append("Login ID (Username) cannot exceed 20 characters.")
        elif " " in login_id:
            errors.append("Login ID (Username) cannot contain spaces.")
        else:
            session = db_manager.get_session()
            try:
                query = session.query(User).filter(
                    User.user_id.collate("NOCASE") == login_id
                )
                if not is_new and original_login_id_to_ignore is not None:
                    query = query.filter(
                        User.user_id.collate("NOCASE") != original_login_id_to_ignore
                    )
                if query.first():
                    errors.append(f"Login ID (Username) '{login_id}' already exists.")
                if email:
                    email_query = session.query(User).filter(User.email == email)
                    user_to_exclude_from_email_check = None
                    if not is_new and original_login_id_to_ignore:
                        original_user = (
                            session.query(User)
                            .filter(
                                User.user_id.collate("NOCASE")
                                == original_login_id_to_ignore
                            )
                            .first()
                        )
                        if original_user:
                            user_to_exclude_from_email_check = original_user.user_id
                    if user_to_exclude_from_email_check:
                        email_query = email_query.filter(
                            User.user_id != user_to_exclude_from_email_check
                        )
                    if email_query.first():
                        errors.append(f"Email '{email}' is already in use.")
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                self.logger.error(
                    f"DB error validating login_id/email uniqueness: {e_db}",
                    exc_info=True,
                )
                errors.append("Error validating login_id/email uniqueness.")
            finally:
                session.close()
        if not display_name:
            errors.append("Full Name (User Name) is required.")
        elif len(display_name) > 100:
            errors.append("Full Name (User Name) cannot exceed 100 characters.")
        if is_new:
            if not password:
                errors.append("Password is required for new users.")
            elif len(password) < 6:
                errors.append("Password must be at least 6 characters long.")
        elif password and len(password) < 6:
            errors.append("New password must be at least 6 characters long.")
        if email and (
            len(email) > 100 or ("@" not in email or "." not in email.split("@")[-1])
        ):
            errors.append(
                "Invalid email format or email too long (max 100 characters)."
            )
        role_str = user_data.get("role")
        if not role_str and is_new:
            errors.append("Role is required for new users.")
        if role_str:
            session = db_manager.get_session()
            try:
                if not session.query(Role).filter(Role.name == role_str).first():
                    errors.append(f"Role '{role_str}' does not exist in the database.")
            finally:
                session.close()
        return not errors, errors

    def create_user(
        self, user_data: Dict[str, Any], current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[User]]:
        # ... (implementation unchanged) ...
        login_id_to_store = user_data.get("user_id", "").strip()
        if not login_id_to_store:
            return False, "Login ID (Username) cannot be empty.", None
        if login_id_to_store.upper() == "ADMIN":
            login_id_to_store = "ADMIN"
        data_for_model = {
            "user_id": login_id_to_store,
            "user_name": user_data.get("user_name", "").strip(),
            "email": user_data.get("email"),
            "is_active": user_data.get("is_active", True),
            "created_by": current_admin_id,
            "modified_by": current_admin_id,
            "printer_id": user_data.get("printer_id"),
            "default_screen_colors": user_data.get("default_screen_colors"),
        }
        password_to_set = user_data.get("password", "")
        role_name_to_assign = user_data.get("role")
        validation_payload = {
            **data_for_model,
            "password": password_to_set,
            "role": role_name_to_assign,
        }
        is_valid, errors = self.validate_user_data(validation_payload, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None
        session = db_manager.get_session()
        try:
            processed_email = data_for_model["email"]
            if isinstance(processed_email, str):
                processed_email = processed_email.strip()
                if not processed_email:
                    processed_email = None
            data_for_model["email"] = processed_email
            new_user = User(**data_for_model)
            new_user.set_password(password_to_set)
            if role_name_to_assign:
                role_obj = (
                    session.query(Role).filter(Role.name == role_name_to_assign).first()
                )
                if role_obj:
                    new_user.roles.append(role_obj)
                else:
                    self.logger.error(
                        f"Role '{role_name_to_assign}' for new user '{new_user.user_id}' not found in DB during create. Validation might have missed this."
                    )
            session.add(new_user)
            session.commit()
            session.refresh(new_user)
            self.logger.info(
                f"User '{new_user.user_id}' created successfully by {current_admin_id}."
            )
            return True, "User created successfully.", new_user
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e.orig}",
                exc_info=True,
            )
            error_str = str(e.orig).lower()
            if "unique constraint failed: users.user_id" in error_str:
                return (
                    False,
                    f"Login ID (Username) '{data_for_model['user_id']}' already exists.",
                    None,
                )
            elif (
                "unique constraint failed: users.email" in error_str
                and data_for_model["email"]
            ):
                return (
                    False,
                    f"Email '{data_for_model['email']}' is already in use.",
                    None,
                )
            return False, f"Database integrity error: {e.orig}", None
        except AttributeError as ae:
            session.rollback()
            self.logger.error(
                f"AttributeError during user creation for '{data_for_model.get('user_id')}': {ae}",
                exc_info=True,
            )
            return False, f"Failed to set user attribute during creation: {ae}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e}",
                exc_info=True,
            )
            return False, f"Failed to create user: {e}", None
        finally:
            session.close()

    def update_user(
        self,
        user_id_to_update: str,
        user_data: Dict[str, Any],
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == user_id_to_update)
                .first()
            )
            if not user:
                return False, f"User with Login ID '{user_id_to_update}' not found."
            validation_data = {
                "user_id": user.user_id,
                "user_name": user_data.get("user_name", user.user_name),
                "email": user_data.get("email", user.email),
                "role": user_data.get("role"),
            }
            if "password" in user_data and user_data["password"]:
                validation_data["password"] = user_data["password"]
            is_valid, errors = self.validate_user_data(
                validation_data, is_new=False, original_login_id_to_ignore=user.user_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)
            roles_modified = False
            if "user_name" in user_data:
                user.user_name = user_data["user_name"].strip()
            if "email" in user_data:
                email_val = user_data["email"]
                user.email = email_val.strip() if isinstance(email_val, str) else None
                if user.email == "":
                    user.email = None
            if "password" in user_data and user_data["password"]:
                user.set_password(user_data["password"])
            if "is_active" in user_data:
                if user.user_id.upper() == "ADMIN" and not user_data["is_active"]:
                    active_admin_query = session.query(User).filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    if user.is_active:
                        if active_admin_query.count() <= 1:
                            self.logger.warning(
                                f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') was prevented."
                            )
                            return (
                                False,
                                "Cannot deactivate the last active ADMIN user.",
                            )
                    user.is_active = user_data["is_active"]
                else:
                    user.is_active = user_data["is_active"]
            new_role_name_from_data = user_data.get("role")
            if new_role_name_from_data is not None:
                current_role_names = {r.name for r in user.roles}
                if not (
                    len(current_role_names) == 1
                    and new_role_name_from_data in current_role_names
                ):
                    roles_modified = True
                    user.roles.clear()
                    if new_role_name_from_data:
                        role_obj = (
                            session.query(Role)
                            .filter(Role.name == new_role_name_from_data)
                            .first()
                        )
                        if role_obj:
                            user.roles.append(role_obj)
                        else:
                            self.logger.error(
                                f"Role object for '{new_role_name_from_data}' not found during update. User '{user.user_id}' will have no roles."
                            )
            if "printer_id" in user_data:
                user.printer_id = user_data["printer_id"]
            if "default_screen_colors" in user_data:
                user.default_screen_colors = user_data["default_screen_colors"]
            user.modified_by = current_admin_id
            if roles_modified:
                session.add(user)
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' updated successfully by {current_admin_id}."
            )
            return True, "User updated successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e.orig}", exc_info=True
            )
            if "unique constraint failed: users.email" in str(
                e.orig
            ).lower() and validation_data.get("email"):
                return (
                    False,
                    f"Email '{validation_data['email']}' is already in use by another user.",
                )
            return False, f"Database integrity error: {e.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e}", exc_info=True
            )
            return False, f"Failed to update user: {str(e)}"
        finally:
            session.close()

    def change_password(
        self,
        login_id_str: str,
        new_password: str,
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        if not new_password or len(new_password) < 6:
            return False, "New password must be at least 6 characters long."
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if not user:
                return False, f"User '{login_id_str}' not found."
            user.set_password(new_password)
            user.modified_by = current_admin_id
            session.commit()
            self.logger.info(
                f"Password changed successfully for user '{user.user_id}' by {current_admin_id}."
            )
            return True, "Password changed successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error changing password for user '{login_id_str}': {e}", exc_info=True
            )
            return False, f"Failed to change password: {str(e)}"
        finally:
            session.close()

    def get_user_roles(self, login_id_str: str) -> List[str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if user and user.roles:
                return [role.name for role in user.roles]
            return []
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching roles for user '{login_id_str}': {e}", exc_info=True
            )
            return []
        finally:
            session.close()

    def delete_user_permanently(
        self, user_id_to_delete: str, current_admin_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_id_to_delete)
                .first()
            )
            if not user:
                return False, f"User '{user_id_to_delete}' not found."
            if user.user_id.upper() == "ADMIN":
                active_admin_count = (
                    session.query(User)
                    .filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    .count()
                )
                if active_admin_count <= 1 and user.is_active:
                    self.logger.warning(
                        f"Attempt to delete the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                    )
                    return (
                        False,
                        "Cannot delete the primary ADMIN account if it's the last active one.",
                    )
            session.delete(user)
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"User '{user.user_id}' deleted successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Database integrity error deleting user '{user_id_to_delete}': {e.orig}",
                exc_info=True,
            )
            return (
                False,
                f"Cannot delete user. They may be referenced by other records. ({e.orig})",
            )
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error deleting user '{user_id_to_delete}': {e}", exc_info=True
            )
            return False, f"Failed to delete user: {str(e)}"
        finally:
            session.close()

    # MODIFIED: Logic moved from view to controller
    def toggle_user_active_status(
        self, user_login_id: str, current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_login_id)
                .first()
            )
            if not user:
                return False, f"User '{user_login_id}' not found."

            is_deactivating = user.is_active
            if is_deactivating:
                # Rule 1: Cannot deactivate yourself
                if user.user_id == current_admin_id:
                    self.logger.warning(
                        f"User '{current_admin_id}' attempted to deactivate their own account. Operation prevented."
                    )
                    return False, "You cannot deactivate your own account."

                # Rule 2: Cannot deactivate the last active admin
                if user.has_role("ADMIN"):
                    active_admin_count = (
                        session.query(User)
                        .join(User.roles)
                        .filter(Role.name == "ADMIN", User.is_active == True)
                        .count()
                    )
                    if active_admin_count <= 1:
                        self.logger.warning(
                            f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                        )
                        return False, "Cannot deactivate the last active ADMIN user."

            # Toggle the status
            new_status = not user.is_active
            user.is_active = new_status
            user.modified_by = current_admin_id

            session.commit()

            status_str = "activated" if new_status else "deactivated"
            self.logger.info(
                f"User '{user.user_id}' has been {status_str} by {current_admin_id}."
            )
            return True, f"User '{user.user_id}' has been successfully {status_str}."

        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error toggling status for user '{user_login_id}': {e}",
                exc_info=True,
            )
            return False, "A database error occurred."
        finally:
            session.close()

    def get_all_roles(self) -> List[Role]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            roles = session.query(Role).order_by(Role.name).all()
            self.logger.info(f"Retrieved {len(roles)} roles.")
            return roles
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error retrieving roles: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()


=============== END FILE: controllers/user_controller.py ===============

=============== FILE: controllers/location_controller.py ===============

# controllers/location_controller.py
"""
EDSI Veterinary Management System - Location Controller
Version: 1.2.0
Purpose: Handles business logic for locations.
         - Added delete_location method with referential integrity check.
         - Modified get_all_locations to accept a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.2.0 (2025-06-05):
    - Added `delete_location` method, which checks for linked horses in
      HorseLocation before allowing deletion.
    - Modified `get_all_locations` to accept a string `status_filter` ('active',
      'inactive', or 'all') instead of a boolean for consistency.
- v1.1.7 (2025-06-05):
    - Reverted `update_location` to return a tuple of two values (bool, str).
"""
import logging
from typing import List, Optional, Tuple, Dict, Any

from sqlalchemy.orm import Session, joinedload
from sqlalchemy import exc as sqlalchemy_exc

from config.database_config import db_manager
from models import Location, StateProvince, HorseLocation


class LocationController:
    """Controller for location management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_locations(self, status_filter: str = "all") -> List[Location]:
        session = db_manager.get_session()
        try:
            query = session.query(Location).options(joinedload(Location.state))
            if status_filter == "active":
                query = query.filter(Location.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Location.is_active == False)
            locations = query.order_by(Location.location_name).all()
            return locations
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all locations: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_location_by_id(self, location_id: int) -> Optional[Location]:
        session = db_manager.get_session()
        try:
            return (
                session.query(Location)
                .options(joinedload(Location.state))
                .filter(Location.location_id == location_id)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching location by ID {location_id}: {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_location_data(
        self,
        location_data: dict,
        is_new: bool = True,
        location_id_to_check_for_unique: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        name = location_data.get("location_name", "").strip()

        if not name:
            errors.append("Location Name is required.")
        elif len(name) > 100:
            errors.append("Location Name cannot exceed 100 characters.")
        else:
            session = db_manager.get_session()
            try:
                query = session.query(Location.location_id).filter(
                    Location.location_name.collate("NOCASE") == name
                )
                if not is_new and location_id_to_check_for_unique is not None:
                    query = query.filter(
                        Location.location_id != location_id_to_check_for_unique
                    )
                if query.first():
                    errors.append(f"Location Name '{name}' already exists.")
            finally:
                session.close()
        return not errors, errors

    def create_location(
        self, location_data: dict, current_user_id: str
    ) -> Tuple[bool, str, Optional[Location]]:
        is_valid, errors = self.validate_location_data(location_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:

            def process_string(value: Any) -> Optional[str]:
                return value.strip() if isinstance(value, str) else None

            new_location = Location(
                location_name=location_data.get("location_name", "").strip(),
                address_line1=process_string(location_data.get("address_line1")),
                address_line2=process_string(location_data.get("address_line2")),
                city=process_string(location_data.get("city")),
                state_code=process_string(location_data.get("state_code")),
                zip_code=process_string(location_data.get("zip_code")),
                phone=process_string(location_data.get("phone")),
                contact_person=process_string(location_data.get("contact_person")),
                email=process_string(location_data.get("email")),
                is_active=location_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_location)
            session.commit()
            session.refresh(new_location)
            self.logger.info(
                f"Location '{new_location.location_name}' created by {current_user_id}."
            )
            return True, "Location created successfully.", new_location
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(f"Error creating location: {e.orig}", exc_info=True)
            return False, f"Database integrity error: {e.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating location: {e}", exc_info=True)
            return False, f"Failed to create location: {e}", None
        finally:
            session.close()

    def update_location(
        self, location_id: int, location_data: dict, current_user_id: str
    ) -> Tuple[bool, str]:
        is_valid, errors = self.validate_location_data(
            location_data, is_new=False, location_id_to_check_for_unique=location_id
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors)

        session = db_manager.get_session()
        try:
            location = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )
            if not location:
                return False, "Location not found."

            for key, value in location_data.items():
                if hasattr(location, key):
                    processed_value = value.strip() if isinstance(value, str) else value
                    setattr(location, key, processed_value)

            location.modified_by = current_user_id
            session.commit()
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location_id}) updated by {current_user_id}."
            )
            return True, "Location updated successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating location ID {location_id}: {e}", exc_info=True
            )
            return False, f"Failed to update location: {e}"
        finally:
            session.close()

    def toggle_location_active_status(
        self, location_id: int, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            location = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )
            if not location:
                return False, f"Location with ID {location_id} not found."

            location.is_active = not location.is_active
            location.modified_by = current_user_id

            session.commit()

            new_status = "activated" if location.is_active else "deactivated"
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location_id}) status changed to {new_status} by {current_user_id}."
            )
            return (
                True,
                f"Location '{location.location_name}' has been successfully {new_status}.",
            )

        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error toggling status for location ID {location_id}: {e}",
                exc_info=True,
            )
            return False, "A database error occurred while toggling location status."
        finally:
            if session:
                session.close()

    def delete_location(
        self, location_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            linked_horses_count = (
                session.query(HorseLocation)
                .filter(HorseLocation.location_id == location_id)
                .count()
            )

            if linked_horses_count > 0:
                message = f"Cannot delete location. It is currently or was previously assigned to {linked_horses_count} horse(s)."
                self.logger.warning(message)
                return False, message

            location_to_delete = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )

            if not location_to_delete:
                return False, "Location not found."

            location_name = location_to_delete.location_name
            session.delete(location_to_delete)
            session.commit()
            self.logger.info(
                f"Location '{location_name}' (ID: {location_id}) deleted by {current_user_id}."
            )
            return True, f"Location '{location_name}' was deleted."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting location ID {location_id}: {e}", exc_info=True
            )
            return False, f"A database error occurred: {e}"
        finally:
            session.close()


=============== END FILE: controllers/location_controller.py ===============

=============== FILE: controllers/charge_code_controller.py ===============

# controllers/charge_code_controller.py
"""
EDSI Veterinary Management System - Charge Code Controller
Version: 1.1.3
Purpose: Business logic for charge code and charge code category operations.
         - Added get_category_by_id method.
         - Corrected get_charge_code_by_id to use ChargeCode.id as primary key.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.3 (2025-06-04):
    - Added `get_category_by_id` method to fetch a single category by its ID,
      as required by UserManagementScreen.
    - Modified `get_charge_code_by_id` to filter by `ChargeCode.id` (assuming 'id'
      is the current primary key attribute on the ChargeCode model) instead of
      `ChargeCode.charge_code_id` to resolve an AttributeError.
- v1.1.2 (2025-06-03):
    - Modified `get_all_charge_code_categories_hierarchical` to remove the
      `active_filter` parameter. It now always fetches all Level 1 categories
      (active and inactive) and their children. Filtering logic is handled by the view.
- v1.1.1 (2025-06-03):
    - Added `toggle_charge_code_category_status` method to specifically handle
      activating/deactivating ChargeCodeCategory items.
- v1.1.0 (2025-06-03):
    - Added full CRUD operations and validation for ChargeCodeCategory.
# ... (previous changelog entries)
"""

import logging
import re
from datetime import datetime
from typing import List, Optional, Tuple, Dict, Any
from decimal import Decimal, InvalidOperation

from sqlalchemy.orm import Session, joinedload, aliased, selectinload
from sqlalchemy import or_, func, exc as sqlalchemy_exc, and_

from config.database_config import db_manager
from models import ChargeCode, ChargeCodeCategory  # Assuming from models package


class ChargeCodeController:
    """Controller for charge code and charge code category operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    # --- ChargeCode Methods ---
    def validate_charge_code_data(
        self,
        charge_data: dict,
        is_new: bool = True,
        charge_code_id_to_ignore: Optional[
            int
        ] = None,  # Added charge_code_id_to_ignore for updates
    ) -> Tuple[bool, List[str]]:
        errors = []
        code = charge_data.get("code", "").strip()
        description = charge_data.get("description", "").strip()
        standard_charge_str = str(charge_data.get("standard_charge", "")).strip()

        if not code:
            errors.append("Charge Code (Code) is required.")
        elif len(code) > 20:
            errors.append("Charge Code (Code) cannot exceed 20 characters.")

        # Validate code uniqueness
        if code:  # Only check if code is provided
            session = db_manager.get_session()
            try:
                query = session.query(ChargeCode).filter(
                    ChargeCode.code.collate("NOCASE") == code.upper()
                )
                if not is_new and charge_code_id_to_ignore is not None:
                    # Assuming the PK is 'id' for ChargeCode based on previous context
                    query = query.filter(
                        ChargeCode.id != charge_code_id_to_ignore
                    )  # Use .id
                if query.first():
                    errors.append(f"Charge Code '{code.upper()}' already exists.")
            finally:
                if session:
                    session.close()

        if not description:
            errors.append("Description is required.")
        elif len(description) > 255:
            errors.append("Description cannot exceed 255 characters.")

        if not standard_charge_str:
            errors.append("Standard Charge is required.")
        else:
            try:
                charge_value = Decimal(standard_charge_str)
                if charge_value < Decimal("0.00"):
                    errors.append("Standard Charge cannot be negative.")
            except InvalidOperation:
                errors.append("Standard Charge must be a valid number (e.g., 25.00).")

        alternate_code = charge_data.get("alternate_code")
        if (
            alternate_code is not None and len(str(alternate_code).strip()) > 50
        ):  # check for strip()
            errors.append("Alternate Code cannot exceed 50 characters.")

        if "taxable" in charge_data and not isinstance(
            charge_data.get("taxable"), bool
        ):
            errors.append("Taxable field must be a true/false value.")

        category_id = charge_data.get("category_id")
        if category_id is not None:
            session = db_manager.get_session()
            try:
                category_exists = (
                    session.query(ChargeCodeCategory)
                    .filter(ChargeCodeCategory.category_id == category_id)
                    .first()
                )
                if not category_exists:
                    errors.append(
                        f"Selected category ID '{category_id}' does not exist."
                    )
                # Removed active check for category here as per original v1.1.2 logic
                # Dialog might handle this if needed, or a separate business rule
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"Error validating category_id '{category_id}': {e}", exc_info=True
                )
                errors.append("Database error validating category.")
            finally:
                if session:
                    session.close()
        elif (
            "category_id" not in charge_data
        ):  # If category_id is entirely missing from data dict
            errors.append("Category selection is required.")

        return not errors, errors

    def create_charge_code(
        self, charge_data: dict, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[ChargeCode]]:
        # Pass None for charge_code_id_to_ignore as it's a new record
        is_valid, errors = self.validate_charge_code_data(
            charge_data, is_new=True, charge_code_id_to_ignore=None
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_charge_code = ChargeCode(
                code=charge_data["code"].strip().upper(),
                alternate_code=(
                    (charge_data.get("alternate_code", "").strip().upper() or None)
                    if charge_data.get("alternate_code") is not None
                    else None
                ),
                description=charge_data["description"].strip(),
                category_id=charge_data.get("category_id"),
                standard_charge=Decimal(str(charge_data["standard_charge"]).strip()),
                is_active=charge_data.get("is_active", True),
                taxable=charge_data.get("taxable", False),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_charge_code)
            session.commit()
            session.refresh(new_charge_code)
            # Assuming ChargeCode PK is 'id'
            self.logger.info(
                f"Charge Code '{new_charge_code.code}' created (ID: {new_charge_code.id}) by {current_user_id}."
            )
            return True, "Charge code created successfully.", new_charge_code
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating charge code: {str(ie.orig)}", exc_info=True
            )
            if "UNIQUE constraint failed: charge_codes.code" in str(ie.orig).lower():
                return (
                    False,
                    f"Charge Code '{charge_data['code'].strip().upper()}' already exists.",
                    None,
                )
            return False, f"Database integrity error: {str(ie.orig)}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating charge code: {e}", exc_info=True)
            return False, f"Failed to create charge code: {str(e)}", None
        finally:
            if session:
                session.close()

    def get_charge_code_by_id(
        self, charge_code_pk_value: int
    ) -> Optional[ChargeCode]:  # Parameter is the PK value
        session = db_manager.get_session()
        try:
            # MODIFIED: Filter by ChargeCode.id (assuming 'id' is the PK)
            return (
                session.query(ChargeCode)
                .options(joinedload(ChargeCode.category))
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code by ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return None
        finally:
            if session:
                session.close()

    def get_charge_code_by_code(self, code: str) -> Optional[ChargeCode]:
        session = db_manager.get_session()
        try:
            return (
                session.query(ChargeCode)
                .options(joinedload(ChargeCode.category))
                .filter(
                    ChargeCode.code.collate("NOCASE") == code.upper()
                )  # Made collate explicit & upper
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code by code '{code}': {e}", exc_info=True
            )
            return None
        finally:
            if session:
                session.close()

    def get_all_charge_codes(
        self, search_term: str = "", status_filter: str = "all"
    ) -> List[ChargeCode]:
        session = db_manager.get_session()
        try:
            category_alias = aliased(ChargeCodeCategory)
            query = session.query(ChargeCode).options(
                joinedload(ChargeCode.category)
            )  # Eager load category

            if status_filter == "active":
                query = query.filter(ChargeCode.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(ChargeCode.is_active == False)

            # Ensure outerjoin is correctly linking ChargeCode.category relationship
            query = query.outerjoin(category_alias, ChargeCode.category)

            if search_term:
                like_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        ChargeCode.code.ilike(like_pattern),
                        ChargeCode.alternate_code.ilike(like_pattern),
                        ChargeCode.description.ilike(like_pattern),
                        category_alias.name.ilike(like_pattern),
                    )
                )
            query = query.order_by(
                category_alias.name.asc().nullsfirst(), ChargeCode.code.asc()
            )
            return query.all()
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all charge codes: {e}", exc_info=True)
            return []
        finally:
            if session:
                session.close()

    def update_charge_code(
        self,
        charge_code_pk_value: int,  # PK value, likely 'id'
        charge_data: dict,
        current_user_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            charge_code_to_update = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_pk_value)  # Use .id
                .first()
            )
            if not charge_code_to_update:
                return False, "Charge code not found."

            self.logger.info(
                f"--- Updating Charge Code ID (PK): {charge_code_pk_value} ---"
            )
            self.logger.info(f"Received charge_data for update: {charge_data}")

            # Prepare data for validation, ensuring current PK is used for uniqueness check if code isn't changing
            validation_data = charge_data.copy()
            # 'code' is part of charge_data if it's being changed, otherwise use existing for validation
            if "code" not in validation_data:
                validation_data["code"] = charge_code_to_update.code

            is_valid, errors = self.validate_charge_code_data(
                validation_data,
                is_new=False,
                charge_code_id_to_ignore=charge_code_pk_value,
            )
            if not is_valid:
                self.logger.warning(
                    f"Validation failed for charge code PK {charge_code_pk_value}: {errors}"
                )
                return False, "Validation failed: " + "; ".join(errors)

            # Apply changes
            if "code" in charge_data:  # Only update if present in data
                charge_code_to_update.code = charge_data["code"].strip().upper()
            if "description" in charge_data:
                charge_code_to_update.description = charge_data["description"].strip()
            if (
                "standard_charge" in charge_data
                and charge_data["standard_charge"] is not None
            ):
                try:
                    charge_code_to_update.standard_charge = Decimal(
                        str(charge_data["standard_charge"])
                    )
                except (
                    InvalidOperation
                ):  # Should be caught by validation, but as safeguard
                    self.logger.error(
                        f"Invalid standard_charge value during update: {charge_data['standard_charge']}"
                    )
                    return False, "Invalid Standard Charge value provided for update."
            if "alternate_code" in charge_data:  # Handle if key exists
                alt_code = charge_data.get("alternate_code")
                charge_code_to_update.alternate_code = (
                    (alt_code.strip().upper() or None)
                    if isinstance(alt_code, str)
                    else None
                )

            # Allow category_id to be set to None
            if "category_id" in charge_data:
                charge_code_to_update.category_id = charge_data.get("category_id")

            # These are usually handled by toggle_charge_code_status
            if "is_active" in charge_data:
                charge_code_to_update.is_active = charge_data["is_active"]
            if "taxable" in charge_data:
                charge_code_to_update.taxable = charge_data["taxable"]

            charge_code_to_update.modified_by = current_user_id
            # charge_code_to_update.modified_date = datetime.utcnow() # BaseModel handles this

            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code_to_update.code}' (ID: {charge_code_pk_value}) updated by {current_user_id}."
            )
            return True, "Charge code updated successfully."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError updating charge code ID {charge_code_pk_value}: {str(ie.orig)}",
                exc_info=True,
            )
            if "UNIQUE constraint failed: charge_codes.code" in str(ie.orig).lower():
                return (
                    False,
                    f"Charge Code '{charge_data.get('code', '').strip().upper()}' already exists.",
                )
            return False, f"Database integrity error: {str(ie.orig)}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating charge code ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return False, f"Failed to update charge code: {str(e)}"
        finally:
            if session:
                session.close()

    def toggle_charge_code_status(
        self,
        charge_code_pk_value: int,
        current_user_id: Optional[str] = None,  # Use PK value
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            charge_code = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_pk_value)  # Use .id
                .first()
            )
            if not charge_code:
                return False, "Charge code not found."

            charge_code.is_active = not charge_code.is_active
            charge_code.modified_by = current_user_id
            # charge_code.modified_date = datetime.utcnow() # BaseModel handles this
            new_status = "active" if charge_code.is_active else "inactive"
            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code.code}' (ID: {charge_code_pk_value}) status changed to {new_status} by {current_user_id}."
            )
            return True, f"Charge code '{charge_code.code}' status set to {new_status}."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error toggling status for charge code ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle charge code status: {str(e)}"
        finally:
            if session:
                session.close()

    # --- ChargeCodeCategory Management Methods ---

    # ADDED method: get_category_by_id
    def get_category_by_id(self, category_id: int) -> Optional[ChargeCodeCategory]:
        session = db_manager.get_session()
        try:
            category = (
                session.query(ChargeCodeCategory)
                .options(
                    joinedload(ChargeCodeCategory.parent)
                )  # Optional: load parent for context
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            return category
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching category by ID {category_id}: {e}", exc_info=True
            )
            return None
        finally:
            if session:
                session.close()

    def validate_charge_code_category_data(
        self,
        category_data: dict,
        is_new: bool = True,
        category_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        name = category_data.get("name", "").strip()
        level = category_data.get("level")
        parent_id = category_data.get("parent_id")

        if not name:
            errors.append("Category/Process name is required.")
        elif len(name) > 100:
            errors.append("Category/Process name cannot exceed 100 characters.")

        if level not in [1, 2]:
            errors.append("Level must be 1 (for Category) or 2 (for Process).")

        if level == 1 and parent_id is not None:
            errors.append("A Level 1 Category cannot have a parent.")
        if level == 2 and parent_id is None:
            errors.append("A Level 2 Process must have a parent Category.")

        if name and level is not None:
            session = db_manager.get_session()
            try:
                query = session.query(ChargeCodeCategory.category_id).filter(
                    ChargeCodeCategory.name.collate("NOCASE") == name,
                    ChargeCodeCategory.level == level,
                )
                if parent_id:
                    query = query.filter(ChargeCodeCategory.parent_id == parent_id)
                else:
                    query = query.filter(ChargeCodeCategory.parent_id.is_(None))

                if not is_new and category_id_to_ignore is not None:
                    query = query.filter(
                        ChargeCodeCategory.category_id != category_id_to_ignore
                    )

                if query.first():
                    type_name = "Process" if level == 2 else "Category"
                    parent_info = f" under the selected parent" if parent_id else ""
                    errors.append(
                        f"{type_name} name '{name}' already exists{parent_info}."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"DB error validating category name uniqueness: {e}", exc_info=True
                )
                errors.append("Database error during name validation.")
            finally:
                if session:
                    session.close()
        return not errors, errors

    def create_charge_code_category(
        self, category_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str, Optional[ChargeCodeCategory]]:
        self.logger.info(
            f"Attempting to create charge code category with data: {category_data}"
        )
        is_valid, errors = self.validate_charge_code_category_data(
            category_data, is_new=True
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_category = ChargeCodeCategory(
                name=category_data["name"].strip(),
                level=category_data["level"],
                parent_id=category_data.get("parent_id"),
                is_active=category_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_category)
            session.commit()
            session.refresh(new_category)
            cat_type = "Process" if new_category.level == 2 else "Category"
            self.logger.info(
                f"Charge Code {cat_type} '{new_category.name}' (ID: {new_category.category_id}, Level: {new_category.level}, ParentID: {new_category.parent_id}) created by {current_user_id}."
            )
            return True, f"{cat_type} created successfully.", new_category
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating charge code category: {str(ie.orig)}",
                exc_info=True,
            )
            return False, f"Database integrity error: {str(ie.orig)}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error creating charge code category: {e}", exc_info=True
            )
            return False, f"Failed to create category/process: {str(e)}", None
        finally:
            if session:
                session.close()

    def update_charge_code_category(
        self, category_id: int, category_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        self.logger.info(
            f"Attempting to update category ID {category_id} with data: {category_data}"
        )
        session = db_manager.get_session()
        try:
            category_to_update = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category_to_update:
                return False, "Category/Process not found."

            # Prepare validation_data using current values if not provided in category_data for update
            validation_data = {
                "name": category_data.get("name", category_to_update.name).strip(),
                "level": category_to_update.level,  # Level and parent typically not changed in simple edit
                "parent_id": category_to_update.parent_id,
            }

            is_valid, errors = self.validate_charge_code_category_data(
                validation_data, is_new=False, category_id_to_ignore=category_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            changed = False
            if (
                "name" in category_data
                and category_to_update.name != category_data["name"].strip()
            ):
                category_to_update.name = category_data["name"].strip()
                changed = True

            # is_active is handled by toggle_charge_code_category_status
            if (
                "is_active" in category_data
                and category_to_update.is_active != category_data["is_active"]
            ):
                category_to_update.is_active = category_data["is_active"]
                changed = True

            if changed:
                category_to_update.modified_by = current_user_id
                # category_to_update.modified_date = datetime.utcnow() # BaseModel handles this
                session.commit()
                cat_type = "Process" if category_to_update.level == 2 else "Category"
                self.logger.info(
                    f"Charge Code {cat_type} '{category_to_update.name}' (ID: {category_id}) updated by {current_user_id}."
                )
                return True, f"{cat_type} updated successfully."
            else:
                return True, "No changes detected to update."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError updating category ID {category_id}: {str(ie.orig)}",
                exc_info=True,
            )
            return False, f"Database integrity error: {str(ie.orig)}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating category ID {category_id}: {e}", exc_info=True
            )
            return False, f"Failed to update category/process: {str(e)}"
        finally:
            if session:
                session.close()

    def toggle_charge_code_category_status(
        self, category_id: int, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        category = None
        try:
            category = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category:
                return False, "Category/Process not found."
            item_type = "Process" if category.level == 2 else "Category"
            original_name = category.name
            category.is_active = not category.is_active
            category.modified_by = current_user_id
            # category.modified_date = datetime.utcnow() # BaseModel handles this
            session.commit()
            new_status_str = "active" if category.is_active else "inactive"
            self.logger.info(
                f"{item_type} '{original_name}' (ID: {category.category_id}) status changed to {new_status_str} by {current_user_id}."
            )
            return (
                True,
                f"{item_type} '{original_name}' status set to {new_status_str}.",
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            if session:
                session.rollback()  # Ensure rollback on error
            err_item_type = "Category/Process"
            err_name = f"ID {category_id}"
            if category:  # Check if category object was fetched before error
                err_item_type = "Process" if category.level == 2 else "Category"
                err_name = category.name
            self.logger.error(
                f"Error toggling status for {err_item_type} {err_name}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle {err_item_type} status: {str(e)}"
        finally:
            if session:
                session.close()

    def delete_charge_code_category(
        self, category_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        category_to_delete = None
        try:
            category_to_delete = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category_to_delete:
                return False, "Category/Process not found."

            linked_charge_codes_count = (
                session.query(ChargeCode)
                .filter(ChargeCode.category_id == category_id)
                .count()
            )
            if linked_charge_codes_count > 0:
                msg = f"Cannot delete '{category_to_delete.name}'. It is assigned to {linked_charge_codes_count} charge code(s)."
                self.logger.warning(msg)
                return False, msg

            if category_to_delete.level == 1:  # If it's a Level 1 Category
                children_count = (
                    session.query(ChargeCodeCategory)
                    .filter(ChargeCodeCategory.parent_id == category_id)
                    .count()
                )
                if children_count > 0:
                    msg = f"Cannot delete Category '{category_to_delete.name}'. It has {children_count} child Process(es). Delete children first."
                    self.logger.warning(msg)
                    return False, msg

            cat_type_name = "Process" if category_to_delete.level == 2 else "Category"
            deleted_name = category_to_delete.name
            session.delete(category_to_delete)
            session.commit()
            self.logger.info(
                f"Charge Code {cat_type_name} '{deleted_name}' (ID: {category_id}) deleted by {current_user_id}."
            )
            return True, f"{cat_type_name} '{deleted_name}' deleted successfully."
        except sqlalchemy_exc.SQLAlchemyError as e:  # Broader catch for DB errors
            if session:
                session.rollback()
            self.logger.error(
                f"Error deleting category ID {category_id}: {e}", exc_info=True
            )
            name_for_error = (
                category_to_delete.name if category_to_delete else f"ID {category_id}"
            )
            # More specific check for IntegrityError which often includes foreign key issues
            if isinstance(e, sqlalchemy_exc.IntegrityError):
                return (
                    False,
                    f"Cannot delete '{name_for_error}'. It might still be referenced by other records. Details: {e.orig}",
                )
            return (
                False,
                f"Failed to delete category/process due to a database error: {str(e)}",
            )
        finally:
            if session:
                session.close()

    def get_all_charge_code_categories_hierarchical(
        self,
    ) -> List[ChargeCodeCategory]:
        """Fetches all Level 1 categories, with their Level 2 children (processes) eager-loaded."""
        session = db_manager.get_session()
        try:
            level1_categories = (
                session.query(ChargeCodeCategory)
                .filter(
                    ChargeCodeCategory.parent_id.is_(
                        None
                    ),  # Ensure it's a top-level category
                    ChargeCodeCategory.level == 1,  # Explicitly check level 1
                )
                .options(
                    selectinload(ChargeCodeCategory.children)
                )  # Eager load children
                .order_by(ChargeCodeCategory.name)
                .all()
            )
            self.logger.debug(
                f"Fetched {len(level1_categories)} top-level categories with all children for management UI."
            )
            return level1_categories
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching hierarchical charge code categories: {e}",
                exc_info=True,
            )
            return []
        finally:
            if session:
                session.close()

    def get_charge_code_categories(  # This is likely for populating dropdowns
        self,
        parent_id: Optional[int] = None,
        level: Optional[int] = None,
        active_only: bool = True,  # Added active_only filter
    ) -> List[ChargeCodeCategory]:
        session = db_manager.get_session()
        try:
            query = session.query(ChargeCodeCategory)
            if active_only:
                query = query.filter(ChargeCodeCategory.is_active == True)

            if parent_id is None and level == 1:  # Explicitly for Level 1 categories
                query = query.filter(
                    ChargeCodeCategory.parent_id.is_(None),
                    ChargeCodeCategory.level == 1,
                )
            else:  # For other cases, like fetching children or specific level
                if parent_id is not None:
                    query = query.filter(ChargeCodeCategory.parent_id == parent_id)
                if level is not None:
                    query = query.filter(ChargeCodeCategory.level == level)

            categories = query.order_by(ChargeCodeCategory.name).all()
            self.logger.debug(
                f"Fetched {len(categories)} categories for parent_id={parent_id}, level={level}, active_only={active_only}"
            )
            return categories
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code categories: {e}", exc_info=True
            )
            return []
        finally:
            if session:
                session.close()

    def get_category_path(self, category_id: Optional[int]) -> List[Dict[str, Any]]:
        """
        Retrieves the hierarchical path for a given category ID.
        Returns a list of dictionaries, each with 'id' and 'name'.
        """
        path_for_display = []
        if category_id is None:
            return path_for_display

        current_cat_id = category_id
        # Use a single session for all queries in this path lookup
        session = db_manager.get_session()
        try:
            while current_cat_id is not None:
                category = (
                    session.query(
                        ChargeCodeCategory.category_id,
                        ChargeCodeCategory.name,
                        ChargeCodeCategory.parent_id,
                    )
                    .filter(ChargeCodeCategory.category_id == current_cat_id)
                    .first()
                )
                if category:
                    path_for_display.insert(
                        0, {"id": category.category_id, "name": category.name}
                    )
                    current_cat_id = category.parent_id
                else:
                    self.logger.warning(
                        f"Could not find category part with ID: {current_cat_id} while building path for {category_id}."
                    )
                    break  # Category in path not found
            return path_for_display
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching category path for ID {category_id}: {e}", exc_info=True
            )
            return []  # Return empty path on error
        finally:
            if session:
                session.close()


=============== END FILE: controllers/charge_code_controller.py ===============

=============== FILE: controllers/owner_controller.py ===============

# controllers/owner_controller.py
"""
EDSI Veterinary Management System - Owner Controller
Version: 1.3.5
Purpose: Business logic for owner master file operations.
         - Added eager loading for Owner.state in get_all_master_owners.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.3.5 (2025-06-04):
    - In `get_all_master_owners`, added `options(joinedload(Owner.state))`
      to eagerly load the related StateProvince object, preventing
      DetachedInstanceError when accessing owner.state in views.
- v1.3.4 (2025-06-02):
    - Added `import re` to resolve NameError during email validation
      in `validate_owner_data`.
- v1.3.3 (2025-06-02):
    - Modified `validate_owner_data` to correctly handle optional fields that
      might be `None` before calling `len()` on them, preventing TypeError.
- v1.3.2 (2025-05-17):
    - Removed `country_name` from Owner instantiation/update and validation.
- v1.3.1 (2025-05-17):
    - Removed phone number requirement from `validate_owner_data`.
    - Added `mobile_phone` handling.
- v1.2.1 (2025-05-15): Removed credit_rating.
- v1.2.0 (2025-05-15): Added delete_master_owner method.
"""

import logging
import re
from typing import List, Optional, Tuple, Dict, Any
from decimal import Decimal, InvalidOperation
from sqlalchemy.orm import Session, joinedload  # Ensure joinedload is imported
from sqlalchemy import or_, func, exc as sqlalchemy_exc

from config.database_config import db_manager
from models import (
    Owner,
    StateProvince,
    HorseOwner,
)  # Assuming models are in a package 'models'
from datetime import datetime


class OwnerController:
    """Controller for owner master file operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_master_owners(self, include_inactive: bool = False) -> List[Owner]:
        session = db_manager.get_session()
        try:
            # MODIFIED: Added joinedload for Owner.state relationship
            query = session.query(Owner).options(joinedload(Owner.state))

            if not include_inactive:
                query = query.filter(Owner.is_active == True)

            owners = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()
            self.logger.info(
                f"Retrieved {len(owners)} master owners (include_inactive={include_inactive})."
            )
            return owners
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all master owners: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_all_owners_for_lookup(self, search_term: str = "") -> List[Dict[str, Any]]:
        session = db_manager.get_session()
        try:
            query = session.query(
                Owner.owner_id,
                Owner.first_name,
                Owner.last_name,
                Owner.farm_name,
                Owner.account_number,
            ).filter(Owner.is_active == True)

            if search_term:
                search_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Owner.first_name.ilike(search_pattern),
                        Owner.last_name.ilike(search_pattern),
                        Owner.farm_name.ilike(search_pattern),
                        Owner.account_number.ilike(search_pattern),
                    )
                )

            owners_data = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()

            lookup_list = []
            for (
                owner_id,
                first_name,
                last_name,
                farm_name,
                account_number,
            ) in owners_data:
                name_parts = [name for name in [first_name, last_name] if name]
                individual_name = " ".join(name_parts)
                display_text = farm_name if farm_name else ""
                if individual_name:
                    display_text = (
                        f"{display_text} ({individual_name})"
                        if farm_name
                        else individual_name
                    )
                if not display_text:
                    display_text = f"Owner ID {owner_id}"  # Fallback if no names
                if account_number:
                    display_text += f" [{account_number}]"
                lookup_list.append({"id": owner_id, "name_account": display_text})
            return lookup_list
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching owners for lookup: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_owner_by_id(self, owner_id: int) -> Optional[Owner]:
        session = db_manager.get_session()
        try:
            owner = (
                session.query(Owner)
                .options(joinedload(Owner.state))  # Eager load state here too
                .filter(Owner.owner_id == owner_id)
                .first()
            )
            return owner
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owner by ID '{owner_id}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_owner_data(
        self,
        owner_data: dict,
        is_new: bool = True,
        owner_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        first_name = owner_data.get("first_name")
        last_name = owner_data.get("last_name")
        farm_name = owner_data.get("farm_name")
        account_number_val = owner_data.get("account_number")

        # It's okay if one of them is provided, but not strictly required if others are.
        # Dialog might enforce this more strictly if needed.
        # if not first_name and not last_name and not farm_name:
        #     errors.append(
        #         "It's recommended to provide at least one of: First Name, Last Name, or Farm Name."
        #     )

        if not owner_data.get(
            "address_line1", ""
        ).strip():  # Check for empty string too
            errors.append("Address Line 1 is required.")
        if not owner_data.get("city", "").strip():
            errors.append("City is required.")
        if not owner_data.get("state_code", "").strip():
            errors.append("State is required.")
        if not owner_data.get("zip_code", "").strip():
            errors.append("Zip Code is required.")

        field_max_lengths = {
            "first_name": 50,
            "last_name": 50,
            "farm_name": 100,
            "address_line1": 100,
            "address_line2": 100,
            "city": 50,
            "zip_code": 20,
            "phone": 20,
            "mobile_phone": 20,
            "email": 100,
            "account_number": 20,
            "billing_terms": 50,
        }

        for field, max_len in field_max_lengths.items():
            value = owner_data.get(field)
            if value is not None and isinstance(value, str) and len(value) > max_len:
                errors.append(
                    f"{field.replace('_', ' ').title()} cannot exceed {max_len} characters."
                )

        email_val = owner_data.get("email")
        if email_val and email_val.strip():  # only validate if not empty
            if not re.match(
                r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email_val
            ):
                errors.append("Invalid email format.")

        if account_number_val and account_number_val.strip():
            session = db_manager.get_session()
            try:
                query = session.query(Owner).filter(
                    Owner.account_number.collate("NOCASE") == account_number_val.strip()
                )
                if not is_new and owner_id_to_ignore is not None:
                    query = query.filter(Owner.owner_id != owner_id_to_ignore)

                existing_owner_with_account = query.first()
                if existing_owner_with_account:
                    errors.append(
                        f"Account Number '{account_number_val}' already exists."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"DB error validating account_number: {e}", exc_info=True
                )
                errors.append("Error validating account number uniqueness.")
            finally:
                session.close()

        credit_limit_str = owner_data.get("credit_limit")
        if credit_limit_str is not None and str(credit_limit_str).strip() != "":
            try:
                credit_limit_decimal = Decimal(str(credit_limit_str))
                if credit_limit_decimal < Decimal("0.00"):
                    errors.append("Credit Limit cannot be negative.")
            except InvalidOperation:
                errors.append("Credit Limit must be a valid number (e.g., 1000.00).")

        return not errors, errors

    def create_master_owner(
        self, owner_data: dict, current_user: str
    ) -> Tuple[bool, str, Optional[Owner]]:
        is_valid, errors = self.validate_owner_data(owner_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_owner_params = {}
            allowed_keys = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",
                "phone",
                "mobile_phone",
                "email",
                "credit_limit",
                "billing_terms",
                "is_active",
                "balance",
                "service_charge_rate",
                "discount_rate",
                "notes",
            ]
            for key in allowed_keys:
                if key in owner_data:
                    value = owner_data[key]
                    if isinstance(value, str):
                        new_owner_params[key] = value.strip() or None
                    elif (
                        key == "credit_limit"
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            self.logger.warning(
                                f"Invalid decimal for credit_limit: {value}. Setting to None."
                            )
                            new_owner_params[key] = (
                                None  # Or raise error/return validation message
                            )
                    elif (
                        key == "balance"
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            new_owner_params[key] = Decimal("0.00")
                    elif (
                        key in ["service_charge_rate", "discount_rate"]
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            new_owner_params[key] = None
                    else:
                        new_owner_params[key] = value

            # Ensure balance defaults to 0.00 if not provided or invalid
            if new_owner_params.get("balance") is None:
                new_owner_params["balance"] = Decimal("0.00")

            # Ensure is_active defaults to True if not provided
            if new_owner_params.get("is_active") is None:
                new_owner_params["is_active"] = True

            new_owner = Owner(**new_owner_params)
            new_owner.created_by = current_user
            new_owner.modified_by = current_user

            session.add(new_owner)
            session.commit()
            session.refresh(new_owner)

            log_name_parts = [
                name for name in [new_owner.first_name, new_owner.last_name] if name
            ]
            log_individual_name = " ".join(log_name_parts)
            display_name_for_log = new_owner.farm_name if new_owner.farm_name else ""
            if log_individual_name:
                display_name_for_log = (
                    f"{display_name_for_log} ({log_individual_name})"
                    if new_owner.farm_name
                    else log_individual_name
                )
            if not display_name_for_log:
                display_name_for_log = f"Owner ID {new_owner.owner_id}"

            self.logger.info(
                f"Master Owner '{display_name_for_log}' (ID: {new_owner.owner_id}) created by {current_user}."
            )
            return True, "Owner created successfully.", new_owner
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating master owner: {ie.orig}", exc_info=True
            )
            if "UNIQUE constraint failed: owners.account_number" in str(
                ie.orig
            ).lower() and owner_data.get("account_number"):
                return (
                    False,
                    f"Account Number '{owner_data['account_number']}' already exists.",
                    None,
                )
            return False, f"Database integrity error: {ie.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating master owner: {e}", exc_info=True)
            return False, f"Failed to create owner: {e}", None
        finally:
            session.close()

    def update_master_owner(
        self, owner_id: int, owner_data: dict, current_user: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return False, f"Owner with ID {owner_id} not found."

            # Use original account number for validation if it's not being changed
            original_account_number = owner.account_number
            if (
                "account_number" in owner_data
                and owner_data["account_number"] != original_account_number
            ):
                # If account number is changing, validate it against others
                is_valid, errors = self.validate_owner_data(
                    owner_data, is_new=False, owner_id_to_ignore=owner_id
                )
            else:
                # If account number not in data or not changing, validate other fields
                # but don't re-check account uniqueness against itself
                temp_data_for_validation = owner_data.copy()
                temp_data_for_validation.pop(
                    "account_number", None
                )  # remove account number for this specific validation scenario
                is_valid, errors = self.validate_owner_data(
                    temp_data_for_validation, is_new=False, owner_id_to_ignore=owner_id
                )

            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            updatable_fields = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",
                "phone",
                "mobile_phone",
                "email",
                "is_active",
                "balance",
                "credit_limit",
                "billing_terms",
                "service_charge_rate",
                "discount_rate",
                "notes",
            ]

            for key in updatable_fields:
                if key in owner_data:
                    value = owner_data[key]
                    if isinstance(value, str):
                        # Allow setting required fields to empty if that's the intent, validation handles it
                        setattr(
                            owner,
                            key,
                            (
                                value.strip() or None
                                if key
                                not in [
                                    "last_name",
                                    "address_line1",
                                    "city",
                                    "state_code",
                                    "zip_code",
                                ]
                                else value.strip()
                            ),
                        )
                    elif (
                        key
                        in [
                            "credit_limit",
                            "balance",
                            "service_charge_rate",
                            "discount_rate",
                        ]
                        and value is not None
                    ):
                        if (
                            str(value).strip() == ""
                        ):  # Treat empty string for numerics as None or default
                            if key == "balance":
                                setattr(owner, key, Decimal("0.00"))
                            else:
                                setattr(owner, key, None)
                        else:
                            try:
                                setattr(owner, key, Decimal(str(value)))
                            except InvalidOperation:
                                self.logger.warning(
                                    f"Invalid decimal value for {key}: {value} during update. Field not updated."
                                )
                    else:
                        setattr(owner, key, value)

            owner.modified_by = current_user
            # owner.modified_date = datetime.utcnow() # Handled by SQLAlchemy onupdate in BaseModel

            session.commit()
            # ... (logging as before)
            return True, "Owner updated successfully."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError updating owner ID {owner_id}: {ie.orig}", exc_info=True
            )
            if "UNIQUE constraint failed: owners.account_number" in str(
                ie.orig
            ).lower() and owner_data.get("account_number"):
                return (
                    False,
                    f"Account Number '{owner_data['account_number']}' already exists for another owner.",
                )
            return False, f"Database integrity error: {ie.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating master owner ID {owner_id}: {e}", exc_info=True
            )
            return False, f"Failed to update owner: {e}"
        finally:
            session.close()

    def delete_master_owner(
        self, owner_id_to_delete: int, current_admin_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            owner = (
                session.query(Owner)
                .filter(Owner.owner_id == owner_id_to_delete)
                .first()
            )
            if not owner:
                return False, f"Owner with ID {owner_id_to_delete} not found."

            linked_horses_count = (
                session.query(HorseOwner)
                .filter(HorseOwner.owner_id == owner_id_to_delete)
                .count()
            )
            if linked_horses_count > 0:
                self.logger.warning(
                    f"Attempt to delete owner ID {owner_id_to_delete} who is linked to {linked_horses_count} horse(s)."
                )
                return (
                    False,
                    f"Cannot delete owner. They are currently linked to {linked_horses_count} horse(s). Please unlink them from all horses first.",
                )

            owner_name_for_log_parts = [
                name
                for name in [owner.farm_name, owner.last_name, owner.first_name]
                if name
            ]
            owner_name_for_log = (
                " ".join(owner_name_for_log_parts) or f"ID {owner_id_to_delete}"
            )

            session.delete(owner)
            session.commit()
            self.logger.info(
                f"Master Owner '{owner_name_for_log}' (ID: {owner_id_to_delete}) permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"Owner '{owner_name_for_log}' deleted successfully."
        except sqlalchemy_exc.SQLAlchemyError as e:  # Catch broader SQLAlchemy errors
            session.rollback()
            self.logger.error(
                f"Error deleting master owner ID {owner_id_to_delete}: {e}",
                exc_info=True,
            )
            # Check if it's an IntegrityError (e.g. foreign key constraint from other tables like Invoices)
            if isinstance(e, sqlalchemy_exc.IntegrityError):
                return (
                    False,
                    f"Cannot delete owner. It might be referenced by other records (e.g., invoices, payments). Details: {e.orig}",
                )
            return False, f"Failed to delete owner due to a database error: {e}"
        finally:
            session.close()

    def get_owner_form_reference_data(self) -> Dict[str, List[Dict[str, Any]]]:
        session = db_manager.get_session()
        try:
            states_query = (
                session.query(
                    StateProvince.state_code,
                    StateProvince.state_name,
                    StateProvince.country_code,
                )
                .filter(StateProvince.is_active == True)
                .order_by(StateProvince.country_code, StateProvince.state_name)
                .all()
            )
            states = [
                {
                    "id": s.state_code,
                    "name": s.state_name,
                    "country_code": s.country_code,
                }
                for s in states_query
            ]
            # Static billing terms, as they are not in the DB model explicitly
            billing_terms_list = [
                {"id": "NET30", "name": "Net 30 Days"},
                {"id": "NET15", "name": "Net 15 Days"},
                {"id": "NET60", "name": "Net 60 Days"},
                {"id": "COD", "name": "Cash on Delivery"},
                {"id": "PREPAID", "name": "Prepaid"},
                {"id": "EOM", "name": "End of Month"},
                {"id": "ONDELIVERY", "name": "Payment on Delivery"},
            ]
            return {"states": states, "billing_terms": billing_terms_list}
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owner form reference data: {e}", exc_info=True
            )
            return {"states": [], "billing_terms": []}
        finally:
            session.close()

    def toggle_owner_active_status(
        self, owner_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            owner = (
                session.query(OwnerModel)
                .filter(OwnerModel.owner_id == owner_id)
                .first()
            )
            if not owner:
                return False, "Owner not found."

            owner.is_active = not owner.is_active
            owner.modified_by = current_user_id
            # owner.modified_date = datetime.utcnow() # Should be handled by SQLAlchemy onupdate
            session.commit()
            status = "activated" if owner.is_active else "deactivated"
            self.logger.info(f"Owner ID {owner_id} {status} by {current_user_id}.")
            return True, f"Owner {status} successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error toggling active status for owner ID {owner_id}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle owner status: {e}"
        finally:
            session.close()


=============== END FILE: controllers/owner_controller.py ===============

=============== FILE: models/user_models.py ===============

# models/user_models.py

"""
EDSI Veterinary Management System - User and Authentication Models
Version: 2.0.1
Purpose: Simplified user authentication models with clean relationships.
         Added password hashing and verification methods to User model.
Last Updated: May 29, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.1 (2025-05-29):
    - Added bcrypt import for password hashing.
    - Added set_password(self, password) method to User class to hash
      and store passwords using bcrypt.
    - Added check_password(self, password) method to User class to verify
      passwords against the stored bcrypt hash.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Simplified User model with essential fields only
    - Clean Role and UserRole relationship management
    - Removed SystemConfig (deferred to future phases)
    - Fixed circular import issues
    - Clean inheritance from BaseModel and Base
    - Simplified field definitions and constraints
    - Focused on working authentication foundation
    - Consistent naming and documentation
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
import bcrypt  # Added for password hashing

from config.database_config import Base
from models.base_model import BaseModel


class Role(BaseModel):
    """
    User roles for permission management.
    """

    __tablename__ = "roles"

    role_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique role identifier",
    )

    name = Column(
        String(50),
        unique=True,
        index=True,
        nullable=False,
        doc="Role name (e.g., 'ADMIN', 'USER', 'VETERINARIAN')",  # Doc updated
    )

    description = Column(String(255), nullable=True, doc="Role description")

    # Relationships
    users = relationship(
        "User",
        secondary="user_roles",
        back_populates="roles",
        doc="Users assigned to this role",
    )

    def __repr__(self):
        return f"<Role(role_id={self.role_id}, name='{self.name}')>"


class UserRole(Base):
    """
    Association table for User-Role many-to-many relationship.
    This is a simple link table without audit fields.
    """

    __tablename__ = "user_roles"

    user_id = Column(
        String(20), ForeignKey("users.user_id"), primary_key=True, doc="User identifier"
    )

    role_id = Column(
        Integer, ForeignKey("roles.role_id"), primary_key=True, doc="Role identifier"
    )

    def __repr__(self):
        return f"<UserRole(user_id='{self.user_id}', role_id={self.role_id})>"


class User(BaseModel):
    """
    User account for authentication and system access.
    """

    __tablename__ = "users"

    user_id = Column(
        String(20), primary_key=True, index=True, doc="Unique user login identifier"
    )

    password_hash = Column(
        String(255),  # bcrypt hashes are typically 60 chars, 255 is ample
        nullable=False,
        doc="Hashed password for authentication",
    )

    user_name = Column(String(100), nullable=True, doc="Display name for the user")

    email = Column(
        String(100), unique=True, index=True, nullable=True, doc="User email address"
    )

    is_active = Column(
        Boolean,
        default=True,
        nullable=False,
        index=True,
        doc="Whether the user account is active",
    )

    last_login = Column(
        DateTime, nullable=True, doc="Timestamp of last successful login"
    )

    # Optional user preferences (simplified)
    printer_id = Column(String(20), nullable=True, doc="Default printer for this user")

    default_screen_colors = Column(
        String(100), nullable=True, doc="User's preferred screen color scheme"
    )

    # Relationships
    roles = relationship(
        "Role",
        secondary="user_roles",
        back_populates="users",
        doc="Roles assigned to this user",
    )

    def set_password(self, password: str):
        """
        Hashes the provided password and stores it.
        """
        if not password:
            # Or raise an error, depending on policy for empty passwords
            # For now, assuming controller validates non-empty password for new users.
            # If an empty password is to be disallowed universally, raise ValueError here.
            return
        # Generate a salt and hash the password
        salt = bcrypt.gensalt()
        hashed_password = bcrypt.hashpw(password.encode("utf-8"), salt)
        # Store the hash as a string
        self.password_hash = hashed_password.decode("utf-8")

    def check_password(self, password: str) -> bool:
        """
        Checks the provided password against the stored hash.
        """
        if not self.password_hash or not password:
            return False
        return bcrypt.checkpw(
            password.encode("utf-8"), self.password_hash.encode("utf-8")
        )

    def __repr__(self):
        return f"<User(user_id='{self.user_id}', user_name='{self.user_name}', active={self.is_active})>"

    def has_role(self, role_name: str) -> bool:
        """
        Check if user has a specific role.

        Args:
            role_name: Name of the role to check

        Returns:
            True if user has the role, False otherwise
        """
        return any(
            role.name.upper() == role_name.upper() for role in self.roles
        )  # Made case-insensitive for robustness

    def is_admin(self) -> bool:
        """
        Check if user has admin privileges.

        Returns:
            True if user is an admin, False otherwise
        """
        return self.has_role("ADMIN")  # Ensure "ADMIN" matches the actual role name

    def update_last_login(self) -> None:
        """
        Update the last login timestamp to current time.
        """
        self.last_login = datetime.utcnow()

    def deactivate(self) -> None:
        """
        Deactivate the user account.
        """
        self.is_active = False

    def activate(self) -> None:
        """
        Activate the user account.
        """
        self.is_active = True


=============== END FILE: models/user_models.py ===============

=============== FILE: models/reference_models.py ===============

# models/reference_models.py
"""
EDSI Veterinary Management System - Reference Data Models
Version: 1.1.22
Purpose: Defines SQLAlchemy models for various reference data entities.
         - Removed placeholder Transaction and TransactionDetail models
           to avoid conflict with definitive models in financial_models.py.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.22 (2025-06-04):
    - Removed placeholder `Transaction` and `TransactionDetail` class definitions
      as these are now fully defined in `models/financial_models.py`.
- v1.1.21 (2025-06-03):
    - In `Location` model: Uncommented the `current_horses` relationship to
      `HorseLocation` and ensured `back_populates="location"` is correct.
      This fixes the `InvalidRequestError: Mapper 'Mapper[Location(locations)]'
      has no property 'current_horses'` during mapper configuration.
# ... (rest of previous changelog)
"""
from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Text,
    ForeignKey,
    Date,
    Numeric,
    DateTime,
    Table,
)
from sqlalchemy.orm import (
    relationship,
    backref,
)
from sqlalchemy.sql import func

from .base_model import (
    Base,
    BaseModel,
)


class StateProvince(
    BaseModel, Base
):  # BaseModel already inherits Base, so just BaseModel is fine.
    # Or if Base is intended to be mixed in for some reason, it's okay.
    # For consistency, let's assume BaseModel is sufficient as it inherits Base.
    # Will correct to just BaseModel if this is the standard in your other models.
    # Re-checking your base_model.py: BaseModel(Base). So this is fine.
    __tablename__ = "state_provinces"
    state_province_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )
    state_code = Column(String(10), nullable=False, unique=True, index=True)
    state_name = Column(String(50), nullable=False)
    country_code = Column(String(10), nullable=False, default="USA")
    is_active = Column(Boolean, default=True, nullable=False)

    def __repr__(self):
        return (
            f"<StateProvince(state_code='{self.state_code}', name='{self.state_name}')>"
        )


class ChargeCodeCategory(BaseModel, Base):
    __tablename__ = "charge_code_categories"

    category_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique category identifier",
    )
    name = Column(
        String(100),
        nullable=False,
        index=True,
        doc="Name of the category level (e.g., 'Anthelmintics', 'Administered')",
    )
    parent_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
        doc="ID of the parent category, if any",
    )
    level = Column(
        Integer,
        nullable=False,
        index=True,
        doc="Hierarchy level (e.g., 1 for main Category, 2 for Process)",
    )
    is_active = Column(Boolean, default=True, nullable=False, index=True)

    parent = relationship(
        "ChargeCodeCategory", remote_side=[category_id], backref=backref("children")
    )

    charge_codes = relationship("ChargeCode", back_populates="category")

    def __repr__(self):
        return f"<ChargeCodeCategory(id={self.category_id}, name='{self.name}', level={self.level}, parent_id={self.parent_id})>"


class ChargeCode(BaseModel, Base):
    __tablename__ = "charge_codes"
    # Changed from charge_code_id to id to match financial_models.Transaction.charge_code_id ForeignKey target
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    code = Column(String(20), nullable=False, unique=True, index=True)
    alternate_code = Column(String(50), nullable=True, index=True)
    description = Column(String(255), nullable=False)

    category_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
    )

    standard_charge = Column(Numeric(10, 2), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    taxable = Column(Boolean, default=False)

    category = relationship("ChargeCodeCategory", back_populates="charge_codes")

    def __repr__(self):
        return f"<ChargeCode(code='{self.code}', description='{self.description}')>"


class Veterinarian(BaseModel, Base):
    __tablename__ = "veterinarians"
    vet_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )  # Consider renaming to 'id' for consistency if preferred
    first_name = Column(String(50), nullable=False)
    last_name = Column(String(50), nullable=False, index=True)
    license_number = Column(String(50), unique=True)
    specialty = Column(String(100))
    phone = Column(String(20))
    email = Column(String(100), unique=True)
    is_active = Column(Boolean, default=True)

    def __repr__(self):
        return f"<Veterinarian(vet_id={self.vet_id}, name='{self.first_name} {self.last_name}')>"


class Location(BaseModel, Base):
    __tablename__ = "locations"
    location_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )  # Consider renaming to 'id'
    location_name = Column(String(100), nullable=False, unique=True, index=True)
    address_line1 = Column(String(100), nullable=True)
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50), nullable=True)
    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), nullable=True, index=True
    )
    zip_code = Column(String(20), nullable=True)
    country_code = Column(String(10), default="USA", nullable=True)
    phone = Column(String(20), nullable=True)
    contact_person = Column(String(100), nullable=True)
    email = Column(String(100), nullable=True, index=True)
    is_active = Column(Boolean, default=True, nullable=False)

    state = relationship("StateProvince")
    current_horses = relationship("HorseLocation", back_populates="location")

    def __repr__(self):
        return (
            f"<Location(location_id={self.location_id}, name='{self.location_name}')>"
        )


# --- Placeholder models removed ---
# class Transaction(BaseModel, Base): # REMOVED
#     __tablename__ = "transactions"
#     transaction_id = Column(Integer, primary_key=True)
#     description = Column(String(100))

# class TransactionDetail(BaseModel, Base): # REMOVED
#     __tablename__ = "transaction_details"
#     detail_id = Column(Integer, primary_key=True)
#     transaction_id = Column(Integer, ForeignKey("transactions.transaction_id")) # This would now be an error if Transaction was removed
#     notes = Column(String(100))


class Procedure(BaseModel, Base):
    __tablename__ = "procedures"
    procedure_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class Drug(BaseModel, Base):
    __tablename__ = "drugs"
    drug_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class TreatmentLog(BaseModel, Base):
    __tablename__ = "treatment_logs"
    log_id = Column(Integer, primary_key=True)
    details = Column(String(255))


class CommunicationLog(BaseModel, Base):
    __tablename__ = "communication_logs"
    log_id = Column(Integer, primary_key=True)
    summary = Column(String(255))


class Document(BaseModel, Base):
    __tablename__ = "documents"
    document_id = Column(Integer, primary_key=True)
    file_path = Column(String(255))


class Reminder(BaseModel, Base):
    __tablename__ = "reminders"
    reminder_id = Column(Integer, primary_key=True)
    due_date = Column(Date)


class Appointment(BaseModel, Base):
    __tablename__ = "appointments"
    appointment_id = Column(Integer, primary_key=True, index=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), nullable=True)
    vet_id = Column(Integer, ForeignKey("veterinarians.vet_id"), nullable=True)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=True)
    appointment_datetime = Column(DateTime, nullable=False, server_default=func.now())
    duration_minutes = Column(Integer, default=30)
    reason = Column(String(255))
    notes = Column(Text)
    status = Column(String(50), default="Scheduled")
    is_confirmed = Column(Boolean, default=False)

    def __repr__(self):
        return f"<Appointment(id={self.appointment_id}, datetime='{self.appointment_datetime}', reason='{self.reason}')>"


=============== END FILE: models/reference_models.py ===============

=============== FILE: models/owner_models.py ===============

# models/owner_models.py
"""
EDSI Veterinary Management System - Owner Related Models
Version: 1.1.7
Purpose: Defines SQLAlchemy models for Owner and related entities.
         - Removed the placeholder Invoice model to avoid conflict with the
           definitive Invoice model in financial_models.py.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.7 (2025-06-04):
    - Removed the placeholder `Invoice` class definition. The definitive `Invoice`
      model is now in `models/financial_models.py`.
      The backref from Owner to the new Invoice model is handled in financial_models.py.
- v1.1.6 (2025-05-23):
    - Ensured the `Invoice` class is correctly defined.
    - Imported `sqlalchemy.sql.func` for `func.current_date()` default in `Invoice.invoice_date`.
# ... (rest of previous changelog)
"""

from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Numeric,
    Text,
    ForeignKey,
    Date,
    DateTime,
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import datetime

from .base_model import BaseModel


class Owner(BaseModel):
    """Model for horse owners (master list)."""

    __tablename__ = "owners"

    # Changed owner_id to id for potential consistency, but will keep owner_id if it's deeply embedded.
    # For now, keeping owner_id as per existing structure.
    # If financial_models.Transaction.owner_id refers to 'owners.id', then this needs to be 'id'.
    # Checking financial_models.py: owner_id = Column(Integer, ForeignKey("owners.owner_id") ...
    # So, owner_id is correct here.
    owner_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    account_number = Column(String(20), unique=True, nullable=True, index=True)
    farm_name = Column(String(100), nullable=True, index=True)
    first_name = Column(String(50), nullable=True)
    last_name = Column(String(50), nullable=True, index=True)

    address_line1 = Column(String(100))
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50))

    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), index=True
    )

    zip_code = Column(String(20))

    phone = Column(String(20), nullable=True)
    mobile_phone = Column(String(20), nullable=True)
    email = Column(String(100), nullable=True, index=True)

    is_active = Column(Boolean, default=True, nullable=False)

    balance = Column(Numeric(10, 2), default=0.00)
    credit_limit = Column(Numeric(10, 2), nullable=True)
    billing_terms = Column(String(50), nullable=True)
    service_charge_rate = Column(Numeric(5, 2), nullable=True)
    discount_rate = Column(Numeric(5, 2), nullable=True)

    notes = Column(Text, nullable=True)

    state = relationship("StateProvince", foreign_keys=[state_code], backref="owners")

    horse_associations = relationship(
        "HorseOwner", back_populates="owner", cascade="all, delete-orphan"
    )

    horses = relationship(
        "Horse", secondary="horse_owners", back_populates="owners", viewonly=True
    )

    billing_history = relationship(
        "OwnerBillingHistory", back_populates="owner", cascade="all, delete-orphan"
    )
    payments_made = relationship(
        "OwnerPayment", back_populates="owner", cascade="all, delete-orphan"
    )

    # The 'invoices' backref is now defined in financial_models.Invoice linking to this Owner model.
    # No need for: # invoices = relationship("Invoice", back_populates="owner")

    def __repr__(self):
        display_name = (
            self.farm_name
            or f"{self.first_name or ''} {self.last_name or ''}".strip()
            or f"ID:{self.owner_id}"
        )
        return f"<Owner(owner_id={self.owner_id}, name='{display_name}')>"


class OwnerBillingHistory(BaseModel):
    """Billing history entries for an owner."""

    __tablename__ = "owner_billing_history"

    history_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    entry_date = Column(DateTime, default=datetime.utcnow)
    description = Column(String(255), nullable=False)
    amount_change = Column(Numeric(10, 2), nullable=False)  # Made non-nullable
    new_balance = Column(Numeric(10, 2), nullable=False)  # Made non-nullable

    owner = relationship("Owner", back_populates="billing_history")

    def __repr__(self):
        return f"<OwnerBillingHistory(owner_id={self.owner_id}, date='{self.entry_date}', desc='{self.description}')>"


class OwnerPayment(BaseModel):
    """Payments made by an owner."""

    __tablename__ = "owner_payments"

    payment_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    payment_date = Column(Date, nullable=False, default=func.current_date)
    amount = Column(Numeric(10, 2), nullable=False)
    payment_method = Column(String(50), nullable=False)  # Made non-nullable
    reference_number = Column(String(100), nullable=True)
    notes = Column(Text, nullable=True)  # Nullable is fine for notes

    owner = relationship(
        "Owner", foreign_keys=[owner_id], back_populates="payments_made"
    )

    def __repr__(self):
        return f"<OwnerPayment(owner_id={self.owner_id}, date='{self.payment_date}', amount={self.amount})>"


# class Invoice(BaseModel): # REMOVED - Definitive model is in financial_models.py
#    pass


=============== END FILE: models/owner_models.py ===============

=============== FILE: models/base_model.py ===============

# models/base_model.py

"""
EDSI Veterinary Management System - Base Model Definition
Version: 2.0.0
Purpose: Simplified base model with essential audit fields and clean declarative base.
         Removed over-complexity and focused on stable foundation.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Removed circular import issues by importing Base from database_config
    - Simplified BaseModel with essential audit fields only
    - Clean datetime handling without over-engineering
    - Removed unnecessary complexity in __repr__ method
    - Clear separation between Base and BaseModel
    - Focused on stable, working foundation
    - Consistent audit field naming and types
"""

from datetime import datetime
from sqlalchemy import Column, DateTime, String
from config.database_config import Base


class BaseModel(Base):
    """
    Abstract base model providing common audit fields for all database tables.

    Provides:
    - created_date: When the record was created
    - modified_date: When the record was last modified
    - created_by: User ID who created the record
    - modified_by: User ID who last modified the record
    """

    __abstract__ = True  # This class should not be mapped to a database table

    # Audit fields
    created_date = Column(
        DateTime,
        default=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was created",
    )

    modified_date = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was last modified",
    )

    created_by = Column(
        String(50), nullable=True, doc="User ID who created this record"
    )

    modified_by = Column(
        String(50), nullable=True, doc="User ID who last modified this record"
    )

    def __repr__(self):
        """
        Simple string representation of the model instance.
        Uses the first primary key column for identification.
        """
        try:
            # Get the primary key column name and value
            primary_key = self.__mapper__.primary_key[0]
            pk_name = primary_key.name
            pk_value = getattr(self, pk_name, "Unknown")

            return f"<{self.__class__.__name__}({pk_name}={pk_value})>"

        except (IndexError, AttributeError):
            # Fallback if primary key detection fails
            return f"<{self.__class__.__name__}(id=Unknown)>"

    def update_modified_by(self, user_id: str) -> None:
        """
        Update the modified_by field with the given user_id.

        Args:
            user_id: The ID of the user making the modification
        """
        self.modified_by = user_id
        # Note: modified_date will be automatically updated by SQLAlchemy onupdate

    def set_created_by(self, user_id: str) -> None:
        """
        Set the created_by field with the given user_id.
        This should only be called when creating new records.

        Args:
            user_id: The ID of the user creating the record
        """
        self.created_by = user_id
        if not self.modified_by:
            self.modified_by = user_id


=============== END FILE: models/base_model.py ===============

=============== FILE: models/__init__.py ===============

# models/__init__.py
"""
EDSI Veterinary Management System - Models Package
Version: (Adjust version as needed)
Purpose: Initializes the models package, making all data models accessible.
         Ensures definitive Transaction and Invoice models from financial_models are primary.
Last Updated: June 4, 2025
Author: Gemini

Changelog:
- (Date): Adjusted imports to prioritize Transaction and Invoice from financial_models.
          Removed direct import of placeholder Transaction from reference_models.
          Commented out placeholder Invoice from owner_models in __all__.
"""

from .base_model import Base, BaseModel
from .user_models import User, Role, UserRole
from .horse_models import Horse, HorseOwner, HorseLocation
from .owner_models import (
    Owner,
    OwnerBillingHistory,
    OwnerPayment,
)  # Invoice placeholder removed from this file directly
from .reference_models import (
    StateProvince,
    ChargeCodeCategory,
    ChargeCode,
    Veterinarian,
    Location,
    Procedure,
    Drug,
    TreatmentLog,
    CommunicationLog,
    Document,
    Reminder,
    Appointment,
    # Placeholder Transaction and TransactionDetail removed from reference_models.py
)
from .financial_models import Transaction, Invoice  # Definitive financial models

__all__ = [
    "Base",
    "BaseModel",
    "User",
    "Role",
    "UserRole",
    "Horse",
    "HorseOwner",
    "HorseLocation",
    "Owner",
    "OwnerBillingHistory",
    "OwnerPayment",
    # Note: The placeholder Invoice from owner_models.py has been removed from that file.
    # The 'Invoice' in this list now unambiguously refers to the one from financial_models.
    "StateProvince",
    "ChargeCodeCategory",
    "ChargeCode",
    "Veterinarian",
    "Location",
    "Procedure",
    "Drug",
    "TreatmentLog",
    "CommunicationLog",
    "Document",
    "Reminder",
    "Appointment",
    # New Definitive Models
    "Transaction",
    "Invoice",
]


=============== END FILE: models/__init__.py ===============

=============== FILE: views/base_view.py ===============

# views/base_view.py

"""
EDSI Veterinary Management System - Base View Class
Version: 1.1.8
Purpose: Provides a base class for all main views/screens in the application,
         handling common UI setup like dark theme and status messages.
         Corrected missing import for DARK_TEXT_TERTIARY.
Last Updated: May 21, 2025
Author: Gemini

Changelog:
- v1.1.8 (2025-05-21):
    - Added `DARK_TEXT_TERTIARY` to the imports from `config.app_config`
      to resolve a NameError during theme application.
- v1.1.7 (2025-05-21):
    - Added `DARK_PRIMARY_ACTION` to the imports from `config.app_config`
      to resolve a NameError during theme application.
- v1.1.6 (2025-05-21):
    - Added unconditional print statements in `__init__` before and after calling
      `apply_dark_theme_palette_and_global_styles`, and at the start/end of
      `apply_dark_theme_palette_and_global_styles` itself, to check the type of
      `self.tab_widget` if the instance is `HorseUnifiedManagement`.
- v1.1.5 (2025-05-20):
    - Added detailed logging to BaseView.setup_ui to trace layout management
      and confirm if the default or overridden setup_ui is being used.
- v1.1.4 (2025-05-18):
    - Ensured central_widget always has a layout, even in default setup_ui.
- v1.1.3 (2025-05-17):
    - Added placeholder for status_bar if not created by subclass.
- v1.1.2 (2025-05-16):
    - Added show_confirmation_dialog and show_error_dialog methods.
    - Refined status message display and clearing.
- v1.1.1 (2025-05-15):
    - Standardized status message methods (show_info, show_warning, show_error).
- v1.1.0 (2025-05-14):
    - Initial implementation with dark theme palette and global styles.
    - Basic UI setup with a central widget.
    - Abstracted common UI functionalities.
"""

import logging
from PySide6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QLabel,
    QApplication,
    QMessageBox,
    QStatusBar,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer

from config.app_config import (
    DARK_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_WIDGET_BACKGROUND,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DEFAULT_FONT_FAMILY,
    DARK_HEADER_FOOTER,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
    DARK_TEXT_TERTIARY,  # ADDED THIS IMPORT
)


class BaseView(QMainWindow):
    """
    Base class for all main views/screens in the application.
    Handles common setup like dark theme, status messages, and basic layout.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} started.")

        # Set window flags if needed, e.g., to remove native title bar for custom one
        # self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)

        # Central widget and layout
        # This is crucial: ensure central_widget is created BEFORE setCentralWidget
        # and before setup_ui (which might replace its layout or add to it).
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.logger.info(
            f"BaseView __init__ for {self.__class__.__name__}: central_widget created."
        )

        # Allow subclasses to define their own UI structure
        # The `setup_ui` method in the subclass (e.g., UserManagementScreen)
        # is responsible for populating self.central_widget.
        if hasattr(self, "setup_ui") and callable(self.setup_ui):
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Calling overridden setup_ui()."
            )
            self.setup_ui()  # This will call the setup_ui of the subclass
        else:
            # Default UI setup if subclass doesn't provide one
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Using default BaseView setup_ui()."
            )
            default_layout = QVBoxLayout(
                self.central_widget
            )  # Apply layout to central_widget
            default_label = QLabel(f"Welcome to {self.__class__.__name__}")
            default_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            default_layout.addWidget(default_label)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QVBoxLayout set on central_widget."
            )

        # Apply theme and styles after the subclass's setup_ui has potentially created widgets
        # Check type of self.tab_widget if it's HorseUnifiedManagement
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: BEFORE apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        self.apply_dark_theme_palette_and_global_styles()

        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: AFTER apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        # Initialize status bar if not already done by subclass
        if not hasattr(self, "status_bar") or self.status_bar is None:
            self.status_bar = QStatusBar()
            self.setStatusBar(self.status_bar)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QStatusBar created and set."
            )
            self.update_status("Ready", 0)  # Initial status

        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} finished.")

    def set_title(self, title: str):
        self.setWindowTitle(title)

    def apply_dark_theme_palette_and_global_styles(self):
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: START. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(
            QPalette.ColorRole.AlternateBase, QColor(DARK_BACKGROUND)
        )  # For item views like QListWidget
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(
            QPalette.ColorRole.BrightText, Qt.GlobalColor.red
        )  # Often used for errors or important highlights
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(
            QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG)
        )  # Selection background
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )  # Selection text

        # Disabled states
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Text,
            QColor(DARK_TEXT_TERTIARY),
        )  # THIS LINE WAS CAUSING THE NameError
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.ButtonText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.WindowText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Base,
            QColor(DARK_HEADER_FOOTER),
        )

        QApplication.setPalette(palette)
        QApplication.instance().setPalette(palette)  # Ensure it's applied globally

        # Global stylesheet (can be overridden by more specific stylesheets)
        # Styles for common widgets to ensure consistency
        # More specific styling should be done in individual view/widget files
        # using object names or class selectors.
        QApplication.instance().setStyleSheet(
            f"""
            QMainWindow, QDialog, QWidget {{
                font-family: "{DEFAULT_FONT_FAMILY}";
                font-size: 13px;
                color: {DARK_TEXT_PRIMARY};
                background-color: {DARK_BACKGROUND};
            }}
            QToolTip {{
                color: {DARK_TEXT_PRIMARY};
                background-color: {DARK_WIDGET_BACKGROUND};
                border: 1px solid {DARK_BORDER};
                padding: 4px;
                border-radius: 3px;
            }}
            QStatusBar {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_SECONDARY};
                border-top: 1px solid {DARK_BORDER};
            }}
            QStatusBar QLabel {{ /* Ensure labels in status bar inherit color */
                color: {DARK_TEXT_SECONDARY};
                background-color: transparent; /* Important for status bar labels */
                padding: 0 2px; /* Minimal padding for status bar items */
            }}
            QMenuBar {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_PRIMARY};
                border-bottom: 1px solid {DARK_BORDER};
            }}
            QMenuBar::item {{
                spacing: 3px; /* spacing between menu bar items */
                padding: 4px 10px;
                background: transparent;
                border-radius: 4px;
            }}
            QMenuBar::item:selected {{ /* when selected using mouse or keyboard */
                background: {DARK_ITEM_HOVER};
            }}
            QMenuBar::item:pressed {{
                background: {DARK_PRIMARY_ACTION};
            }}
            QMenu {{
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                padding: 5px;
            }}
            QMenu::item {{
                padding: 5px 20px 5px 20px;
            }}
            QMenu::item:selected {{
                background-color: {DARK_HIGHLIGHT_BG};
                color: {DARK_HIGHLIGHT_TEXT};
            }}
            QMenu::separator {{
                height: 1px;
                background: {DARK_BORDER};
                margin-left: 5px;
                margin-right: 5px;
            }}
            /* Basic ScrollBar Styling */
            QScrollBar:vertical {{
                border: 1px solid {DARK_BORDER};
                background: {DARK_WIDGET_BACKGROUND};
                width: 12px;
                margin: 0px 0px 0px 0px;
            }}
            QScrollBar::handle:vertical {{
                background: {DARK_TEXT_SECONDARY};
                min-height: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                border: none;
                background: none;
                height: 0px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }}
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
                background: none;
            }}

            QScrollBar:horizontal {{
                border: 1px solid {DARK_BORDER};
                background: {DARK_WIDGET_BACKGROUND};
                height: 12px;
                margin: 0px 0px 0px 0px;
            }}
            QScrollBar::handle:horizontal {{
                background: {DARK_TEXT_SECONDARY};
                min-width: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
                border: none;
                background: none;
                width: 0px;
                subcontrol-position: left;
                subcontrol-origin: margin;
            }}
            QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {{
                background: none;
            }}
        """
        )
        self.logger.info(
            f"Dark theme palette and global styles applied for {self.__class__.__name__}."
        )
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: END. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

    def update_status(self, message: str, timeout: int = 5000):
        """Displays a message on the status bar for a specified duration."""
        if hasattr(self, "status_bar") and self.status_bar:
            self.status_bar.showMessage(message, timeout)
            self.logger.info(f"Status update: {message}")
        else:
            self.logger.warning(
                f"Attempted to update status for {self.__class__.__name__}, but no status_bar attribute found or it is None."
            )

    def show_info(self, title: str, message: str):
        self.logger.info(f"Displaying Info: {title} - {message}")
        QMessageBox.information(self, title, message)

    def show_warning(self, title: str, message: str):
        self.logger.warning(f"Displaying Warning: {title} - {message}")
        QMessageBox.warning(self, title, message)

    def show_error(self, title: str, message: str):
        self.logger.error(f"Displaying Error: {title} - {message}")
        QMessageBox.critical(self, title, message)

    def show_question(self, title: str, message: str) -> bool:
        self.logger.info(f"Asking Question: {title} - {message}")
        reply = QMessageBox.question(
            self,
            title,
            message,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )
        return reply == QMessageBox.StandardButton.Yes


=============== END FILE: views/base_view.py ===============

=============== FILE: config/app_config.py ===============

# config/app_config.py

"""
EDSI Veterinary Management System - Application Configuration
Version: 2.0.1
Purpose: Simplified centralized configuration for application settings, paths, and constants.
         Added missing logging parameters for file rotation and updated app version.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Coding partner)

Changelog:
- v2.0.1 (2025-05-26):
    - Added LOG_MAX_BYTES and LOG_BACKUP_COUNT constants for log file rotation.
    - Included log_max_bytes and log_backup_count in the get_logging_config() dictionary.
    - Updated module-level APP_VERSION constant to "2.0.3" to align with main application.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Consolidated all configuration into single AppConfig class
    # ... (rest of previous changelog entries assumed present)
"""

import os
import logging
from typing import Dict, Any

# --- Project Paths ---
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
LOG_DIR = os.path.join(PROJECT_ROOT, "logs")
ASSETS_DIR = os.path.join(PROJECT_ROOT, "assets")

# --- Application Information ---
APP_NAME = "EDSI Veterinary Management System"
APP_VERSION = "2.0.3"  # <-- Updated Version
APP_AUTHOR = "EDSI"

# --- Database Configuration ---
DATABASE_URL = f"sqlite:///{os.path.join(PROJECT_ROOT, 'edsi_database.db')}"

# --- Logging Configuration ---
APP_LOG_FILE = os.path.join(LOG_DIR, "edsi_app.log")
DB_LOG_FILE = os.path.join(
    LOG_DIR, "edsi_db.log"
)  # Retained, though not used by current main.py's app logger
LOGGING_LEVEL = logging.INFO
LOG_MAX_BYTES = 1024 * 1024 * 5  # <-- Added: 5 MB
LOG_BACKUP_COUNT = 5  # <-- Added: 5 backup files

# --- UI Configuration ---
DEFAULT_FONT_FAMILY = "Inter"
DEFAULT_FONT_SIZE = 10
SMALL_FONT_SIZE = 9
MIN_WINDOW_WIDTH = 900
MIN_WINDOW_HEIGHT = 700

# --- Dark Theme Colors (Essential Only) ---
DARK_BACKGROUND = "#2D3748"
DARK_WIDGET_BACKGROUND = "#1A202C"
# ... (all other color constants remain the same)
DARK_HEADER_FOOTER = "#222B38"
DARK_BORDER = "#4A5568"
DARK_TEXT_PRIMARY = "#E2E8F0"
DARK_TEXT_SECONDARY = "#A0AEC0"
DARK_TEXT_TERTIARY = "#718096"
DARK_PRIMARY_ACTION = "#3182CE"
DARK_SUCCESS_ACTION = "#38A169"
DARK_WARNING_ACTION = "#DD6B20"
DARK_DANGER_ACTION = "#E53E3E"
DARK_BUTTON_BG = "#4A5568"
DARK_BUTTON_HOVER = "#718096"
DARK_ITEM_HOVER = "#2C3543"
DARK_HIGHLIGHT_BG = "#3182CE"
DARK_HIGHLIGHT_TEXT = "#FFFFFF"
DARK_INPUT_FIELD_BACKGROUND = "#222B38"


class AppConfig:
    """
    Centralized application configuration class.
    Provides clean access to all application settings.
    """

    # Application Info
    APP_NAME = APP_NAME
    APP_VERSION = APP_VERSION  # Will now pick up "2.0.3"
    APP_AUTHOR = APP_AUTHOR

    # Paths
    PROJECT_ROOT = PROJECT_ROOT
    LOG_DIR = LOG_DIR
    ASSETS_DIR = ASSETS_DIR

    # Database
    DATABASE_URL = DATABASE_URL

    # Logging
    APP_LOG_FILE = APP_LOG_FILE
    DB_LOG_FILE = DB_LOG_FILE
    LOGGING_LEVEL = LOGGING_LEVEL
    LOG_MAX_BYTES = LOG_MAX_BYTES  # <-- Added Class Attribute
    LOG_BACKUP_COUNT = LOG_BACKUP_COUNT  # <-- Added Class Attribute

    # UI Settings
    DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY
    # ... (other UI settings remain the same)
    DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE
    SMALL_FONT_SIZE = SMALL_FONT_SIZE
    MIN_WINDOW_WIDTH = MIN_WINDOW_WIDTH
    MIN_WINDOW_HEIGHT = MIN_WINDOW_HEIGHT

    # Theme Colors
    DARK_BACKGROUND = DARK_BACKGROUND
    # ... (all color class attributes remain the same)
    DARK_WIDGET_BACKGROUND = DARK_WIDGET_BACKGROUND
    DARK_HEADER_FOOTER = DARK_HEADER_FOOTER
    DARK_BORDER = DARK_BORDER
    DARK_TEXT_PRIMARY = DARK_TEXT_PRIMARY
    DARK_TEXT_SECONDARY = DARK_TEXT_SECONDARY
    DARK_TEXT_TERTIARY = DARK_TEXT_TERTIARY
    DARK_PRIMARY_ACTION = DARK_PRIMARY_ACTION
    DARK_SUCCESS_ACTION = DARK_SUCCESS_ACTION
    DARK_WARNING_ACTION = DARK_WARNING_ACTION
    DARK_DANGER_ACTION = DARK_DANGER_ACTION
    DARK_BUTTON_BG = DARK_BUTTON_BG
    DARK_BUTTON_HOVER = DARK_BUTTON_HOVER
    DARK_ITEM_HOVER = DARK_ITEM_HOVER
    DARK_HIGHLIGHT_BG = DARK_HIGHLIGHT_BG
    DARK_HIGHLIGHT_TEXT = DARK_HIGHLIGHT_TEXT
    DARK_INPUT_FIELD_BACKGROUND = DARK_INPUT_FIELD_BACKGROUND

    @classmethod
    def get_database_url(cls) -> str:
        return cls.DATABASE_URL

    @classmethod
    def get_app_dir(cls) -> str:  # This method was duplicated, keeping one
        return cls.PROJECT_ROOT

    @classmethod
    def get_assets_dir(cls) -> str:
        return cls.ASSETS_DIR

    @classmethod
    def get_app_info(cls) -> Dict[str, str]:
        return {
            "name": cls.APP_NAME,
            "version": cls.APP_VERSION,
            "author": cls.APP_AUTHOR,
        }

    @classmethod
    def get_logging_config(cls) -> Dict[str, Any]:
        """Get logging configuration"""
        return {
            "level": cls.LOGGING_LEVEL,
            "app_log_file": cls.APP_LOG_FILE,
            "db_log_file": cls.DB_LOG_FILE,  # Retained
            "log_dir": cls.LOG_DIR,
            "log_max_bytes": cls.LOG_MAX_BYTES,  # <-- Added Key
            "log_backup_count": cls.LOG_BACKUP_COUNT,  # <-- Added Key
        }

    @classmethod
    def get_ui_config(cls) -> Dict[str, Any]:
        # ... (remains the same)
        return {
            "font_family": cls.DEFAULT_FONT_FAMILY,
            "font_size": cls.DEFAULT_FONT_SIZE,
            "small_font_size": cls.SMALL_FONT_SIZE,
            "min_window_width": cls.MIN_WINDOW_WIDTH,
            "min_window_height": cls.MIN_WINDOW_HEIGHT,
        }

    @classmethod
    def get_theme_colors(cls) -> Dict[str, str]:
        # ... (remains the same)
        return {
            "background": cls.DARK_BACKGROUND,
            "widget_background": cls.DARK_WIDGET_BACKGROUND,
            "header_footer": cls.DARK_HEADER_FOOTER,
            "border": cls.DARK_BORDER,
            "text_primary": cls.DARK_TEXT_PRIMARY,
            "text_secondary": cls.DARK_TEXT_SECONDARY,
            "text_tertiary": cls.DARK_TEXT_TERTIARY,
            "primary_action": cls.DARK_PRIMARY_ACTION,
            "success_action": cls.DARK_SUCCESS_ACTION,
            "warning_action": cls.DARK_WARNING_ACTION,
            "danger_action": cls.DARK_DANGER_ACTION,
            "button_bg": cls.DARK_BUTTON_BG,
            "button_hover": cls.DARK_BUTTON_HOVER,
            "item_hover": cls.DARK_ITEM_HOVER,
            "highlight_bg": cls.DARK_HIGHLIGHT_BG,
            "highlight_text": cls.DARK_HIGHLIGHT_TEXT,
            "input_field_background": cls.DARK_INPUT_FIELD_BACKGROUND,
        }

    @classmethod
    def ensure_directories(cls) -> None:
        """Ensure required directories exist"""
        directories = [cls.LOG_DIR, cls.ASSETS_DIR]

        for directory in directories:
            if not os.path.exists(directory):
                try:
                    os.makedirs(directory, exist_ok=True)
                    # Optionally log creation:
                    # logging.info(f"Created directory: {directory}")
                except OSError as e:
                    # Using print as logger might not be fully setup when this is called early
                    print(f"Warning: Could not create directory {directory}: {e}")


=============== END FILE: config/app_config.py ===============

=============== FILE: controlledai4.txt ===============

ERROR: File not found - C:\Projects\EDMS\controlledai4.txt
