EDMS Project Files Dump
Collected on: 2025-06-04 19:04:22
Project Base Path: C:\projects\edms
================================================================================

--- File: models/base_model.py ---
# models/base_model.py

"""
EDSI Veterinary Management System - Base Model Definition
Version: 2.0.0
Purpose: Simplified base model with essential audit fields and clean declarative base.
         Removed over-complexity and focused on stable foundation.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Removed circular import issues by importing Base from database_config
    - Simplified BaseModel with essential audit fields only
    - Clean datetime handling without over-engineering
    - Removed unnecessary complexity in __repr__ method
    - Clear separation between Base and BaseModel
    - Focused on stable, working foundation
    - Consistent audit field naming and types
"""

from datetime import datetime
from sqlalchemy import Column, DateTime, String
from config.database_config import Base


class BaseModel(Base):
    """
    Abstract base model providing common audit fields for all database tables.

    Provides:
    - created_date: When the record was created
    - modified_date: When the record was last modified
    - created_by: User ID who created the record
    - modified_by: User ID who last modified the record
    """

    __abstract__ = True  # This class should not be mapped to a database table

    # Audit fields
    created_date = Column(
        DateTime,
        default=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was created",
    )

    modified_date = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was last modified",
    )

    created_by = Column(
        String(50), nullable=True, doc="User ID who created this record"
    )

    modified_by = Column(
        String(50), nullable=True, doc="User ID who last modified this record"
    )

    def __repr__(self):
        """
        Simple string representation of the model instance.
        Uses the first primary key column for identification.
        """
        try:
            # Get the primary key column name and value
            primary_key = self.__mapper__.primary_key[0]
            pk_name = primary_key.name
            pk_value = getattr(self, pk_name, "Unknown")

            return f"<{self.__class__.__name__}({pk_name}={pk_value})>"

        except (IndexError, AttributeError):
            # Fallback if primary key detection fails
            return f"<{self.__class__.__name__}(id=Unknown)>"

    def update_modified_by(self, user_id: str) -> None:
        """
        Update the modified_by field with the given user_id.

        Args:
            user_id: The ID of the user making the modification
        """
        self.modified_by = user_id
        # Note: modified_date will be automatically updated by SQLAlchemy onupdate

    def set_created_by(self, user_id: str) -> None:
        """
        Set the created_by field with the given user_id.
        This should only be called when creating new records.

        Args:
            user_id: The ID of the user creating the record
        """
        self.created_by = user_id
        if not self.modified_by:
            self.modified_by = user_id

--- End File: models/base_model.py ---

--- File: models/horse_models.py ---
# models/horse_models.py
"""
EDSI Veterinary Management System - Horse Related SQLAlchemy Models
Version: 1.2.17
Purpose: Defines the data models for horses, owners, and their relationships.
         - Reverted `back_populates` on HorseLocation.location relationship
           to "current_horses" to match expected relationship name on Location model.
Last Updated: May 25, 2025
Author: Gemini

Changelog:
- v1.2.17 (2025-05-25):
    - HorseLocation model: Changed `back_populates` for the `location` relationship
      from "horse_assignments" back to "current_horses" to resolve an
      InvalidRequestError due to mismatched relationship names with the
      (unseen) Location model. This assumes "current_horses" is the correct
      corresponding attribute on the Location model.
- v1.2.16 (2025-05-25):
    - HorseLocation model: Added `is_current_location` (Boolean) column.
    - Changed `back_populates` on HorseLocation.location to "horse_assignments" (this change is being reverted in v1.2.17).
- v1.2.15 (2025-05-23):
    - Horse model: Removed `species_id` column and `species` relationship.
# ... (rest of previous changelog entries assumed present)
"""
from sqlalchemy import Column, Integer, String, Date, Boolean, ForeignKey, Numeric, Text
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property
from datetime import date

from .base_model import Base, BaseModel


class HorseOwner(Base):
    __tablename__ = "horse_owners"
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), primary_key=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), primary_key=True)
    percentage_ownership = Column(Numeric(5, 2), nullable=True)

    horse = relationship("Horse", back_populates="owner_associations")
    owner = relationship("Owner", back_populates="horse_associations")


class HorseLocation(BaseModel):
    __tablename__ = "horse_locations"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=False)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=False)
    date_arrived = Column(Date, nullable=False, default=date.today)
    date_departed = Column(Date, nullable=True)
    notes = Column(Text, nullable=True)
    is_current_location = Column(Boolean, default=False, nullable=False, index=True)

    horse = relationship("Horse", back_populates="location_history")
    # REVERTED: back_populates to "current_horses" based on previous changelog
    # and to resolve InvalidRequestError.
    # This assumes the Location model has a relationship:
    # current_horses = relationship("HorseLocation", back_populates="location")
    location = relationship("Location", back_populates="current_horses")


class Horse(BaseModel):
    __tablename__ = "horses"

    horse_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    horse_name = Column(String(255), nullable=False, index=True)
    account_number = Column(String(50), index=True, nullable=True)
    breed = Column(String(100), nullable=True)
    color = Column(String(50), nullable=True)
    sex = Column(String(20), nullable=True)
    date_of_birth = Column(Date, nullable=True)
    height_hands = Column(Numeric(4, 2), nullable=True)

    chip_number = Column(String(50), nullable=True, unique=True)
    tattoo_number = Column(String(50), nullable=True, unique=True)
    description = Column(Text, nullable=True)

    is_active = Column(Boolean, default=True, nullable=False)
    date_deceased = Column(Date, nullable=True)
    coggins_date = Column(Date, nullable=True)

    current_location_id = Column(
        Integer, ForeignKey("locations.location_id"), nullable=True
    )

    owner_associations = relationship(
        "HorseOwner", back_populates="horse", cascade="all, delete-orphan"
    )
    owners = relationship(
        "Owner",
        secondary="horse_owners",
        back_populates="horses",
        viewonly=True,
        lazy="selectin",
    )

    location_history = relationship(
        "HorseLocation",
        back_populates="horse",
        order_by="desc(HorseLocation.date_arrived)",
        cascade="all, delete-orphan",
        lazy="selectin",
    )
    location = relationship(
        "Location", foreign_keys=[current_location_id], lazy="joined"
    )

    @hybrid_property
    def age(self):
        if self.date_of_birth:
            today = date.today()
            return (
                today.year
                - self.date_of_birth.year
                - (
                    (today.month, today.day)
                    < (self.date_of_birth.month, self.date_of_birth.day)
                )
            )
        return None

    @validates("chip_number", "tattoo_number")
    def convert_empty_to_none(self, key, value):
        if isinstance(value, str) and not value.strip():
            return None
        return value

--- End File: models/horse_models.py ---

--- File: models/owner_models.py ---
# models/owner_models.py
"""
EDSI Veterinary Management System - Owner Related Models
Version: 1.1.6
Purpose: Defines SQLAlchemy models for Owner and related entities.
         - Ensured Invoice model is correctly defined and func is imported for date default.
Last Updated: May 23, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.6 (2025-05-23):
    - Ensured the `Invoice` class is correctly defined.
    - Imported `sqlalchemy.sql.func` for `func.current_date()` default in `Invoice.invoice_date`.
- v1.1.5 (2025-05-23):
    - Owner.horses (many-to-many): Added `viewonly=True` to prevent conflicts
      with other relationships managing the `horse_owners` association table,
      addressing SQLAlchemy overlap warnings.
- v1.1.4 (2025-05-23):
    - Renamed the direct relationship from Owner to HorseOwner objects
      from `horses` to `horse_associations` for clarity and consistency.
    - Added a new many-to-many relationship `Owner.horses` (linking to Horse objects)
      to correctly pair with `Horse.owners`.
"""

from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Numeric,
    Text,
    ForeignKey,
    Date,
    DateTime,
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func  # Added for func.current_date()
from datetime import (
    datetime,
)  # Keep for default values if not using sqlalchemy.sql.func

from .base_model import BaseModel


class Owner(BaseModel):
    """Model for horse owners (master list)."""

    __tablename__ = "owners"

    owner_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    account_number = Column(String(20), unique=True, nullable=True, index=True)
    farm_name = Column(String(100), nullable=True, index=True)
    first_name = Column(String(50), nullable=True)
    last_name = Column(String(50), nullable=True, index=True)

    address_line1 = Column(String(100))
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50))

    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), index=True
    )

    zip_code = Column(String(20))

    phone = Column(String(20), nullable=True)
    mobile_phone = Column(String(20), nullable=True)
    email = Column(String(100), nullable=True, index=True)

    is_active = Column(Boolean, default=True, nullable=False)

    balance = Column(Numeric(10, 2), default=0.00)
    credit_limit = Column(Numeric(10, 2), nullable=True)
    billing_terms = Column(String(50), nullable=True)
    service_charge_rate = Column(Numeric(5, 2), nullable=True)
    discount_rate = Column(Numeric(5, 2), nullable=True)

    notes = Column(Text, nullable=True)

    state = relationship("StateProvince", foreign_keys=[state_code], backref="owners")

    horse_associations = relationship(
        "HorseOwner", back_populates="owner", cascade="all, delete-orphan"
    )

    horses = relationship(
        "Horse", secondary="horse_owners", back_populates="owners", viewonly=True
    )

    billing_history = relationship(
        "OwnerBillingHistory", back_populates="owner", cascade="all, delete-orphan"
    )
    payments_made = relationship(
        "OwnerPayment", back_populates="owner", cascade="all, delete-orphan"
    )

    def __repr__(self):
        display_name = (
            self.farm_name
            or f"{self.first_name or ''} {self.last_name or ''}".strip()
            or f"ID:{self.owner_id}"
        )
        return f"<Owner(owner_id={self.owner_id}, name='{display_name}')>"


class OwnerBillingHistory(BaseModel):
    """Billing history entries for an owner."""  # Corrected docstring slightly

    __tablename__ = "owner_billing_history"

    history_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    entry_date = Column(
        DateTime, default=datetime.utcnow
    )  # sqlalchemy.sql.func.now() is better for server default
    description = Column(String(255), nullable=False)
    amount_change = Column(Numeric(10, 2))  # Should probably be nullable=False
    new_balance = Column(Numeric(10, 2))  # Should probably be nullable=False

    owner = relationship("Owner", back_populates="billing_history")

    def __repr__(self):
        return f"<OwnerBillingHistory(owner_id={self.owner_id}, date='{self.entry_date}', desc='{self.description}')>"


class OwnerPayment(BaseModel):
    """Payments made by an owner."""

    __tablename__ = "owner_payments"

    payment_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    payment_date = Column(Date, nullable=False, default=func.current_date)  # Using func
    amount = Column(Numeric(10, 2), nullable=False)
    payment_method = Column(String(50))  # Consider nullable=False if always present
    reference_number = Column(String(100), nullable=True)
    notes = Column(Text)

    owner = relationship(
        "Owner", foreign_keys=[owner_id], back_populates="payments_made"
    )

    def __repr__(self):
        return f"<OwnerPayment(owner_id={self.owner_id}, date='{self.payment_date}', amount={self.amount})>"


class Invoice(BaseModel):  # Ensured Invoice model is present
    """Invoices for an owner."""

    __tablename__ = "invoices"

    invoice_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    invoice_date = Column(Date, nullable=False, default=func.current_date)  # Using func
    due_date = Column(Date, nullable=True)
    total_amount = Column(Numeric(10, 2), nullable=False, default=0.00)
    amount_paid = Column(Numeric(10, 2), nullable=False, default=0.00)
    status = Column(
        String(50), nullable=False, default="Draft"
    )  # E.g., Draft, Sent, Paid, Void

    # If Invoice can have multiple TransactionDetails or line items, define relationship here
    # details = relationship("TransactionDetail", back_populates="invoice") # Example

    # Relationship to Owner
    # owner = relationship("Owner", back_populates="invoices") # Add 'invoices' to Owner model if needed

    def __repr__(self):
        return f"<Invoice(invoice_id={self.invoice_id}, owner_id={self.owner_id}, total={self.total_amount}, status='{self.status}')>"

--- End File: models/owner_models.py ---

--- File: models/reference_models.py ---
# models/reference_models.py
"""
EDSI Veterinary Management System - Reference Data Models
Version: 1.1.21
Purpose: Defines SQLAlchemy models for various reference data entities.
         - Uncommented and corrected 'current_horses' relationship in Location model.
Last Updated: June 3, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.21 (2025-06-03):
    - In `Location` model: Uncommented the `current_horses` relationship to
      `HorseLocation` and ensured `back_populates="location"` is correct.
      This fixes the `InvalidRequestError: Mapper 'Mapper[Location(locations)]'
      has no property 'current_horses'` during mapper configuration.
- v1.1.20 (2025-06-03):
    - In `ChargeCodeCategory` model, removed `lazy="dynamic"` from the
      `children` backref to allow `selectinload`.
- v1.1.19 (2025-06-02):
    - Added new `ChargeCodeCategory` model.
    - Modified `ChargeCode` model for FK to `ChargeCodeCategory`.
- v1.1.18 (2025-06-02):
    - Added `email` to `Location` model.
- v1.1.17 (2025-05-31):
    - Added `alternate_code` to `ChargeCode` model.
"""
from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Text,
    ForeignKey,
    Date,
    Numeric,
    DateTime,
    Table,
)
from sqlalchemy.orm import (
    relationship,
    backref,
)
from sqlalchemy.sql import func

from .base_model import (
    Base,
    BaseModel,
)  # Assuming this import path is correct from your project structure


class StateProvince(BaseModel, Base):
    __tablename__ = "state_provinces"
    state_province_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )
    state_code = Column(String(10), nullable=False, unique=True, index=True)
    state_name = Column(String(50), nullable=False)
    country_code = Column(String(10), nullable=False, default="USA")
    is_active = Column(Boolean, default=True, nullable=False)

    def __repr__(self):
        return (
            f"<StateProvince(state_code='{self.state_code}', name='{self.state_name}')>"
        )


class ChargeCodeCategory(BaseModel, Base):
    __tablename__ = "charge_code_categories"

    category_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique category identifier",
    )
    name = Column(
        String(100),
        nullable=False,
        index=True,
        doc="Name of the category level (e.g., 'Anthelmintics', 'Administered')",
    )
    parent_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
        doc="ID of the parent category, if any",
    )
    level = Column(
        Integer,
        nullable=False,
        index=True,
        doc="Hierarchy level (e.g., 1 for main Category, 2 for Process)",
    )
    is_active = Column(Boolean, default=True, nullable=False, index=True)

    parent = relationship(
        "ChargeCodeCategory", remote_side=[category_id], backref=backref("children")
    )

    def __repr__(self):
        return f"<ChargeCodeCategory(id={self.category_id}, name='{self.name}', level={self.level}, parent_id={self.parent_id})>"


class ChargeCode(BaseModel, Base):
    __tablename__ = "charge_codes"
    charge_code_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    code = Column(String(20), nullable=False, unique=True, index=True)
    alternate_code = Column(String(50), nullable=True, index=True)
    description = Column(String(255), nullable=False)

    category_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
    )

    standard_charge = Column(Numeric(10, 2), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    taxable = Column(Boolean, default=False)

    category = relationship("ChargeCodeCategory")

    def __repr__(self):
        return f"<ChargeCode(code='{self.code}', description='{self.description}')>"


class Veterinarian(BaseModel, Base):
    __tablename__ = "veterinarians"
    vet_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    first_name = Column(String(50), nullable=False)
    last_name = Column(String(50), nullable=False, index=True)
    license_number = Column(String(50), unique=True)
    specialty = Column(String(100))
    phone = Column(String(20))
    email = Column(String(100), unique=True)
    is_active = Column(Boolean, default=True)

    def __repr__(self):
        return f"<Veterinarian(vet_id={self.vet_id}, name='{self.first_name} {self.last_name}')>"


class Location(BaseModel, Base):
    __tablename__ = "locations"
    location_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    location_name = Column(String(100), nullable=False, unique=True, index=True)
    address_line1 = Column(String(100), nullable=True)
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50), nullable=True)
    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), nullable=True, index=True
    )
    zip_code = Column(String(20), nullable=True)
    country_code = Column(String(10), default="USA", nullable=True)
    phone = Column(String(20), nullable=True)
    contact_person = Column(String(100), nullable=True)
    email = Column(String(100), nullable=True, index=True)
    is_active = Column(Boolean, default=True, nullable=False)

    state = relationship("StateProvince")

    # MODIFIED: Uncommented this relationship.
    # This assumes your HorseLocation model (in horse_models.py) has a relationship:
    # location = relationship("Location", back_populates="current_horses")
    current_horses = relationship("HorseLocation", back_populates="location")

    def __repr__(self):
        return (
            f"<Location(location_id={self.location_id}, name='{self.location_name}')>"
        )


# Placeholder models
class Transaction(BaseModel, Base):
    __tablename__ = "transactions"
    transaction_id = Column(Integer, primary_key=True)
    description = Column(String(100))


class TransactionDetail(BaseModel, Base):
    __tablename__ = "transaction_details"
    detail_id = Column(Integer, primary_key=True)
    transaction_id = Column(Integer, ForeignKey("transactions.transaction_id"))
    notes = Column(String(100))


class Procedure(BaseModel, Base):
    __tablename__ = "procedures"
    procedure_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class Drug(BaseModel, Base):
    __tablename__ = "drugs"
    drug_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class TreatmentLog(BaseModel, Base):
    __tablename__ = "treatment_logs"
    log_id = Column(Integer, primary_key=True)
    details = Column(String(255))


class CommunicationLog(BaseModel, Base):
    __tablename__ = "communication_logs"
    log_id = Column(Integer, primary_key=True)
    summary = Column(String(255))


class Document(BaseModel, Base):
    __tablename__ = "documents"
    document_id = Column(Integer, primary_key=True)
    file_path = Column(String(255))


class Reminder(BaseModel, Base):
    __tablename__ = "reminders"
    reminder_id = Column(Integer, primary_key=True)
    due_date = Column(Date)


class Appointment(BaseModel, Base):
    __tablename__ = "appointments"
    appointment_id = Column(Integer, primary_key=True, index=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), nullable=True)
    vet_id = Column(Integer, ForeignKey("veterinarians.vet_id"), nullable=True)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=True)
    appointment_datetime = Column(DateTime, nullable=False, server_default=func.now())
    duration_minutes = Column(Integer, default=30)
    reason = Column(String(255))
    notes = Column(Text)
    status = Column(String(50), default="Scheduled")
    is_confirmed = Column(Boolean, default=False)

    def __repr__(self):
        return f"<Appointment(id={self.appointment_id}, datetime='{self.appointment_datetime}', reason='{self.reason}')>"

--- End File: models/reference_models.py ---

--- File: models/user_models.py ---
# models/user_models.py

"""
EDSI Veterinary Management System - User and Authentication Models
Version: 2.0.1
Purpose: Simplified user authentication models with clean relationships.
         Added password hashing and verification methods to User model.
Last Updated: May 29, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.1 (2025-05-29):
    - Added bcrypt import for password hashing.
    - Added set_password(self, password) method to User class to hash
      and store passwords using bcrypt.
    - Added check_password(self, password) method to User class to verify
      passwords against the stored bcrypt hash.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Simplified User model with essential fields only
    - Clean Role and UserRole relationship management
    - Removed SystemConfig (deferred to future phases)
    - Fixed circular import issues
    - Clean inheritance from BaseModel and Base
    - Simplified field definitions and constraints
    - Focused on working authentication foundation
    - Consistent naming and documentation
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
import bcrypt  # Added for password hashing

from config.database_config import Base
from models.base_model import BaseModel


class Role(BaseModel):
    """
    User roles for permission management.
    """

    __tablename__ = "roles"

    role_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique role identifier",
    )

    name = Column(
        String(50),
        unique=True,
        index=True,
        nullable=False,
        doc="Role name (e.g., 'ADMIN', 'USER', 'VETERINARIAN')",  # Doc updated
    )

    description = Column(String(255), nullable=True, doc="Role description")

    # Relationships
    users = relationship(
        "User",
        secondary="user_roles",
        back_populates="roles",
        doc="Users assigned to this role",
    )

    def __repr__(self):
        return f"<Role(role_id={self.role_id}, name='{self.name}')>"


class UserRole(Base):
    """
    Association table for User-Role many-to-many relationship.
    This is a simple link table without audit fields.
    """

    __tablename__ = "user_roles"

    user_id = Column(
        String(20), ForeignKey("users.user_id"), primary_key=True, doc="User identifier"
    )

    role_id = Column(
        Integer, ForeignKey("roles.role_id"), primary_key=True, doc="Role identifier"
    )

    def __repr__(self):
        return f"<UserRole(user_id='{self.user_id}', role_id={self.role_id})>"


class User(BaseModel):
    """
    User account for authentication and system access.
    """

    __tablename__ = "users"

    user_id = Column(
        String(20), primary_key=True, index=True, doc="Unique user login identifier"
    )

    password_hash = Column(
        String(255),  # bcrypt hashes are typically 60 chars, 255 is ample
        nullable=False,
        doc="Hashed password for authentication",
    )

    user_name = Column(String(100), nullable=True, doc="Display name for the user")

    email = Column(
        String(100), unique=True, index=True, nullable=True, doc="User email address"
    )

    is_active = Column(
        Boolean,
        default=True,
        nullable=False,
        index=True,
        doc="Whether the user account is active",
    )

    last_login = Column(
        DateTime, nullable=True, doc="Timestamp of last successful login"
    )

    # Optional user preferences (simplified)
    printer_id = Column(String(20), nullable=True, doc="Default printer for this user")

    default_screen_colors = Column(
        String(100), nullable=True, doc="User's preferred screen color scheme"
    )

    # Relationships
    roles = relationship(
        "Role",
        secondary="user_roles",
        back_populates="users",
        doc="Roles assigned to this user",
    )

    def set_password(self, password: str):
        """
        Hashes the provided password and stores it.
        """
        if not password:
            # Or raise an error, depending on policy for empty passwords
            # For now, assuming controller validates non-empty password for new users.
            # If an empty password is to be disallowed universally, raise ValueError here.
            return
        # Generate a salt and hash the password
        salt = bcrypt.gensalt()
        hashed_password = bcrypt.hashpw(password.encode("utf-8"), salt)
        # Store the hash as a string
        self.password_hash = hashed_password.decode("utf-8")

    def check_password(self, password: str) -> bool:
        """
        Checks the provided password against the stored hash.
        """
        if not self.password_hash or not password:
            return False
        return bcrypt.checkpw(
            password.encode("utf-8"), self.password_hash.encode("utf-8")
        )

    def __repr__(self):
        return f"<User(user_id='{self.user_id}', user_name='{self.user_name}', active={self.is_active})>"

    def has_role(self, role_name: str) -> bool:
        """
        Check if user has a specific role.

        Args:
            role_name: Name of the role to check

        Returns:
            True if user has the role, False otherwise
        """
        return any(
            role.name.upper() == role_name.upper() for role in self.roles
        )  # Made case-insensitive for robustness

    def is_admin(self) -> bool:
        """
        Check if user has admin privileges.

        Returns:
            True if user is an admin, False otherwise
        """
        return self.has_role("ADMIN")  # Ensure "ADMIN" matches the actual role name

    def update_last_login(self) -> None:
        """
        Update the last login timestamp to current time.
        """
        self.last_login = datetime.utcnow()

    def deactivate(self) -> None:
        """
        Deactivate the user account.
        """
        self.is_active = False

    def activate(self) -> None:
        """
        Activate the user account.
        """
        self.is_active = True

--- End File: models/user_models.py ---

--- File: models/invoice_model.py ---
*** File not found: models/invoice_model.py ***

--- File: models/financial_models.py ---
*** File not found: models/financial_models.py ***

--- File: controllers/horse_controller.py ---
# controllers/horse_controller.py
"""
EDSI Veterinary Management System - Horse Controller
Version: 1.2.9
Purpose: Handles business logic related to horses.
         - Modified get_horse_by_id to eagerly load 'owners' and 'location'
           relationships to prevent DetachedInstanceError in views.
Last Updated: May 25, 2025
Author: Gemini

Changelog:
- v1.2.9 (2025-05-25):
    - In `get_horse_by_id`, updated SQLAlchemy query options to use
      `selectinload(Horse.owners)` and `joinedload(Horse.location)`
      to ensure these related objects are eager-loaded. This is intended
      to prevent `DetachedInstanceError` when accessing these attributes
      on a Horse object after the session is closed.
- v1.2.8 (2025-05-23):
    - Changed session creation from `Session()` to `db_manager.get_session()`
      to align with current database configuration.
    - Removed `get_all_species` method as Species model has been removed.
    - Removed `Species` import and references in `get_horse_by_id` and `search_horses`.
- v1.2.7 (2025-05-22):
    - Updated `create_horse` and `update_horse` to use `modified_by` instead of `updated_by`
      to align with the user's current `BaseModel` definition.
- v1.2.6 (2025-05-21 - User Uploaded version):
    - Initial version with methods for CRUD, search, linking owners, locations.
"""
import logging
from typing import List, Optional, Dict, Any
from datetime import datetime, date

from sqlalchemy import (
    select,
    update,
    delete,
    and_,
    or_,
    func as sql_func,
)
from sqlalchemy.orm import joinedload, selectinload, aliased
from sqlalchemy.exc import SQLAlchemyError

from config.database_config import db_manager
from models import Horse, Owner, HorseOwner, Location, HorseLocation


class HorseController:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_locations(self) -> List[Location]:
        """Retrieves all locations from the database."""
        session = db_manager.get_session()
        try:
            locations = session.query(Location).order_by(Location.location_name).all()
            self.logger.info(f"Retrieved {len(locations)} location records.")
            return locations
        except SQLAlchemyError as e:
            self.logger.error(f"Error retrieving locations: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()

    def validate_horse_data(
        self,
        data: dict,
        is_new: bool = True,
        horse_id_to_check_for_unique: Optional[int] = None,
    ) -> tuple[bool, list]:
        # (Method content remains the same as v1.2.8)
        errors = []
        required_fields = ["horse_name"]

        for field in required_fields:
            if not data.get(field) or not str(data[field]).strip():
                errors.append(f"{field.replace('_', ' ').capitalize()} is required.")

        if data.get(
            "date_of_birth"
        ):  # Expects Python date object from BasicInfoTab v1.2.18+
            try:
                dob = data["date_of_birth"]
                if not isinstance(dob, date):  # Should already be a date object
                    # This case should ideally not happen if BasicInfoTab sends date objects
                    errors.append("Date of Birth was not a valid date object.")
                elif dob > date.today():
                    errors.append("Date of Birth cannot be in the future.")
            except Exception:  # Catch any other conversion/type issue if not a date
                errors.append("Invalid Date of Birth provided.")

        if data.get("coggins_date"):  # Expects Python date object
            try:
                coggins_dt = data["coggins_date"]
                if not isinstance(coggins_dt, date):
                    errors.append("Coggins Date was not a valid date object.")
                elif coggins_dt > date.today():
                    errors.append("Coggins Date cannot be in the future.")
            except Exception:
                errors.append("Invalid Coggins Date provided.")

        chip_number = data.get("chip_number")
        if chip_number and str(chip_number).strip():
            session = db_manager.get_session()
            try:
                query = session.query(Horse).filter(Horse.chip_number == chip_number)
                if not is_new and horse_id_to_check_for_unique:
                    query = query.filter(Horse.horse_id != horse_id_to_check_for_unique)
                if query.first():
                    errors.append(f"Chip number '{chip_number}' already exists.")
            finally:
                session.close()

        tattoo_number = data.get("tattoo_number")
        if tattoo_number and str(tattoo_number).strip():
            session = db_manager.get_session()
            try:
                query = session.query(Horse).filter(
                    Horse.tattoo_number == tattoo_number
                )
                if not is_new and horse_id_to_check_for_unique:
                    query = query.filter(Horse.horse_id != horse_id_to_check_for_unique)
                if query.first():
                    errors.append(f"Tattoo number '{tattoo_number}' already exists.")
            finally:
                session.close()
        return not errors, errors

    def create_horse(
        self, data: dict, created_by_user: str
    ) -> tuple[bool, str, Optional[Horse]]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            data["created_by"] = created_by_user
            data["modified_by"] = created_by_user
            data.pop("species_id", None)

            # Handle potential unknown attributes by filtering data against Horse model columns
            horse_columns = {col.name for col in Horse.__table__.columns}
            filtered_data = {k: v for k, v in data.items() if k in horse_columns}

            # Warn about fields in data not in Horse model (e.g. reg_number, brand, band_tag if not added to model)
            for key in data:
                if key not in horse_columns and key not in [
                    "current_location_id"
                ]:  # current_location_id handled separately
                    self.logger.warning(
                        f"HorseController.create_horse - Attribute '{key}' present in data but not in Horse model columns. It will be ignored for direct Horse instantiation."
                    )

            new_horse = Horse(**filtered_data)

            # Handle current_location_id separately if it's part of the data
            if (
                "current_location_id" in data
                and data["current_location_id"] is not None
            ):
                new_horse.current_location_id = data["current_location_id"]
                # Create a HorseLocation entry if location is being set during creation
                new_assignment = HorseLocation(
                    horse=new_horse,  # Relationship will handle horse_id
                    location_id=data["current_location_id"],
                    date_arrived=date.today(),
                    is_current_location=True,
                    created_by=created_by_user,
                    modified_by=created_by_user,
                )
                session.add(new_assignment)

            session.add(new_horse)
            session.commit()
            session.refresh(new_horse)  # To get horse_id and other db-generated values
            # If location was set, refresh new_assignment too if its ID is needed
            # if 'current_location_id' in data and data['current_location_id'] is not None:
            # session.refresh(new_assignment)

            self.logger.info(
                f"Horse '{new_horse.horse_name}' (ID: {new_horse.horse_id}) created successfully by {created_by_user}."
            )
            return (
                True,
                f"Horse '{new_horse.horse_name}' created successfully.",
                new_horse,
            )
        except TypeError as te:
            self.logger.error(
                f"TypeError during Horse creation: {te} - Data was: {data}",
                exc_info=True,
            )
            session.rollback()
            return (
                False,
                f"Failed to create horse due to invalid data field: {te}",
                None,
            )
        except SQLAlchemyError as e:
            self.logger.error(
                f"SQLAlchemyError creating horse: {e} - Data was: {data}", exc_info=True
            )
            session.rollback()
            return (
                False,
                f"A database error occurred while creating the horse: {e}",
                None,
            )
        except Exception as e:
            self.logger.error(
                f"Unexpected error creating horse: {e} - Data was: {data}",
                exc_info=True,
            )
            session.rollback()
            return (
                False,
                f"An unexpected error occurred while creating the horse: {e}",
                None,
            )
        finally:
            session.close()

    def update_horse(
        self, horse_id: int, data: dict, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains mostly same as v1.2.8, with attribute filtering)
        session = db_manager.get_session()
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return False, "Horse not found."

            data["modified_by"] = modified_by_user
            data.pop("species_id", None)

            self.logger.debug(f"HorseController.update_horse - Data for update: {data}")

            horse_columns = {col.name for col in Horse.__table__.columns}

            for key, value in data.items():
                if key == "current_location_id":  # Handled by assign_horse_to_location
                    if horse.current_location_id != value:
                        self.logger.info(
                            f"Location change detected for horse {horse_id} from {horse.current_location_id} to {value}. This should be handled via assign_horse_to_location if it involves history."
                        )
                        # Direct update of current_location_id here. assign_horse_to_location manages history.
                        horse.current_location_id = value
                elif key in horse_columns:  # Check if attribute is a direct column
                    setattr(horse, key, value)
                elif hasattr(
                    horse, key
                ):  # Check if attribute exists (e.g., a relationship not directly a column)
                    # This path is less common for direct updates from a flat data dict unless it's a specific non-column attribute
                    self.logger.info(
                        f"Setting attribute '{key}' which is not a direct column but exists on Horse model."
                    )
                    setattr(horse, key, value)
                else:
                    self.logger.warning(
                        f"HorseController.update_horse - Attempted to set unknown attribute '{key}' on Horse model."
                    )
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} updated successfully by {modified_by_user}."
            )
            return True, "Horse details updated successfully."
        except SQLAlchemyError as e:
            self.logger.error(
                f"SQLAlchemyError updating horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"A database error occurred while updating the horse: {e}"
        except Exception as e:
            self.logger.error(
                f"Unexpected error updating horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"An unexpected error occurred while updating the horse: {e}"
        finally:
            session.close()

    def get_horse_by_id(self, horse_id: int) -> Optional[Horse]:
        session = db_manager.get_session()
        try:
            # Eagerly load the 'owners' collection and the current 'location' object.
            # This assumes 'Horse.owners' is the direct relationship to Owner models (many-to-many)
            # and 'Horse.location' is the direct relationship to the current Location model.
            horse = (
                session.query(Horse)
                .options(
                    selectinload(
                        Horse.owners
                    ),  # Eager load the collection of associated Owner objects
                    joinedload(
                        Horse.location
                    ),  # Eager load the current Location object
                    # If you also need horse_owner_associations (the join table objects) or location_history:
                    # selectinload(Horse.owner_associations).selectinload(HorseOwner.owner),
                    # selectinload(Horse.location_history).selectinload(HorseLocation.location),
                )
                .filter(Horse.horse_id == horse_id)
                .first()
            )
            if horse:
                self.logger.info(f"Retrieved horse ID {horse_id}: {horse.horse_name}")
                # Accessing relationships here while session is active to confirm loading (optional for debugging)
                # if horse.owners: self.logger.debug(f"Horse {horse_id} has {len(horse.owners)} owners loaded.")
                # if horse.location: self.logger.debug(f"Horse {horse_id} location: {horse.location.location_name} loaded.")
            else:
                self.logger.warning(f"Horse ID {horse_id} not found.")
            return horse
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving horse ID {horse_id}: {e}", exc_info=True
            )
            # session.rollback() # No need to rollback on a SELECT query error usually
            return None
        finally:
            session.close()  # Session is closed here, so eager loading is crucial

    def search_horses(
        self,
        search_term: str = "",
        status: str = "active",
        owner_name_search: Optional[str] = None,
    ) -> List[Horse]:
        # (Method content largely same, but ensure options are appropriate)
        session = db_manager.get_session()
        try:
            query = session.query(Horse).options(
                selectinload(
                    Horse.owners
                ),  # Eager load owners for list display if needed
                joinedload(
                    Horse.location
                ),  # Eager load location for list display if needed
            )

            if search_term:
                search_term_like = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Horse.horse_name.ilike(search_term_like),
                        Horse.account_number.ilike(search_term_like),
                        Horse.chip_number.ilike(search_term_like),
                        Horse.tattoo_number.ilike(search_term_like),
                    )
                )

            if owner_name_search:
                OwnerAlias = aliased(Owner)
                owner_search_like = f"%{owner_name_search}%"
                # Assuming Horse.owners is the direct relationship to Owner model
                query = query.join(Horse.owners.of_type(OwnerAlias)).filter(
                    or_(
                        OwnerAlias.farm_name.ilike(owner_search_like),
                        OwnerAlias.first_name.ilike(owner_search_like),
                        OwnerAlias.last_name.ilike(owner_search_like),
                    )
                )
                query = query.distinct()  # Add distinct if join causes duplicates

            if status == "active":
                query = query.filter(Horse.is_active == True)
            elif status == "inactive":
                query = query.filter(Horse.is_active == False)

            horses = query.order_by(Horse.horse_name).all()
            self.logger.info(
                f"Search for horses (term: '{search_term}', owner: '{owner_name_search}', status: {status}) found {len(horses)} results."
            )
            return horses
        except SQLAlchemyError as e:
            self.logger.error(f"Error searching horses: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()

    def deactivate_horse(
        self, horse_id: int, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        return self._toggle_horse_status(horse_id, False, modified_by_user)

    def activate_horse(self, horse_id: int, modified_by_user: str) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        return self._toggle_horse_status(horse_id, True, modified_by_user)

    def _toggle_horse_status(
        self, horse_id: int, is_active: bool, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return False, "Horse not found."

            horse.is_active = is_active
            horse.modified_by = modified_by_user

            session.commit()
            status_text = "activated" if is_active else "deactivated"
            self.logger.info(
                f"Horse ID {horse_id} {status_text} by {modified_by_user}."
            )
            return True, f"Horse {status_text} successfully."
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error toggling horse status for ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"Database error: Could not change horse status."
        finally:
            session.close()

    def get_horse_owners(self, horse_id: int) -> List[Dict[str, Any]]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            associations = (
                session.query(HorseOwner)
                .filter(HorseOwner.horse_id == horse_id)
                .options(joinedload(HorseOwner.owner))
                .all()
            )
            owner_details = []
            for assoc in associations:
                if assoc.owner:
                    owner_name_parts = []
                    if assoc.owner.farm_name:
                        owner_name_parts.append(assoc.owner.farm_name)

                    person_name_parts = []
                    if assoc.owner.first_name:
                        person_name_parts.append(assoc.owner.first_name)
                    if assoc.owner.last_name:
                        person_name_parts.append(assoc.owner.last_name)
                    person_name_str = " ".join(person_name_parts).strip()

                    if person_name_str:
                        owner_name_parts.append(f"({person_name_str})")

                    display_name = " ".join(owner_name_parts).strip()
                    if not display_name:
                        display_name = f"Owner ID: {assoc.owner.owner_id}"

                    owner_details.append(
                        {
                            "owner_id": assoc.owner.owner_id,
                            "owner_name": display_name,
                            "percentage_ownership": assoc.percentage_ownership,
                            "phone_number": assoc.owner.phone,
                        }
                    )
            return owner_details
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owners for horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return []
        finally:
            session.close()

    def add_owner_to_horse(
        self,
        horse_id: int,
        owner_id: int,
        percentage: Optional[float],
        modified_by_user: str,
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            existing_assoc = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if existing_assoc:
                return False, "Owner is already associated with this horse."

            new_association = HorseOwner(
                horse_id=horse_id, owner_id=owner_id, percentage_ownership=percentage
            )
            session.add(new_association)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Owner ID {owner_id} added to horse ID {horse_id} by {modified_by_user}."
            )
            return True, "Owner successfully added to horse."
        except SQLAlchemyError as e:
            self.logger.error(f"Error adding owner to horse: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not add owner."
        finally:
            session.close()

    def update_horse_owner_percentage(
        self, horse_id: int, owner_id: int, percentage: float, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            association = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if not association:
                return False, "Owner association not found."
            association.percentage_ownership = percentage

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Ownership percentage updated for horse ID {horse_id}, owner ID {owner_id} by {modified_by_user}."
            )
            return True, "Ownership percentage updated."
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error updating ownership percentage: {e}", exc_info=True
            )
            session.rollback()
            return False, "Database error: Could not update ownership."
        finally:
            session.close()

    def remove_owner_from_horse(
        self, horse_id: int, owner_id: int, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            association = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if not association:
                return False, "Owner association not found."
            session.delete(association)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Owner ID {owner_id} removed from horse ID {horse_id} by {modified_by_user}."
            )
            return True, "Owner removed from horse successfully."
        except SQLAlchemyError as e:
            self.logger.error(f"Error removing owner from horse: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not remove owner."
        finally:
            session.close()

    def assign_horse_to_location(
        self,
        horse_id: int,
        location_id: int,
        notes: Optional[str],
        modified_by_user: str,
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            today = date.today()
            previous_assignments = (
                session.query(HorseLocation)
                .filter(
                    HorseLocation.horse_id == horse_id,
                    HorseLocation.is_current_location == True,
                )
                .all()
            )
            for prev_assign in previous_assignments:
                if (
                    prev_assign.location_id != location_id
                ):  # End date only if moving to a NEW location
                    prev_assign.date_departed = today
                    prev_assign.is_current_location = False
                    prev_assign.modified_by = modified_by_user

            # Check if there's an existing assignment for this exact horse and location
            # to avoid duplicate current assignments if logic allows re-assigning to same current location.
            # However, typical flow is to end previous *any* current, and start new one.

            new_assignment = HorseLocation(
                horse_id=horse_id,
                location_id=location_id,
                date_arrived=today,
                notes=notes,
                is_current_location=True,
                created_by=modified_by_user,
                modified_by=modified_by_user,
            )
            session.add(new_assignment)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.current_location_id = location_id
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} assigned to location ID {location_id} by {modified_by_user}."
            )
            return True, "Horse location assigned successfully."
        except SQLAlchemyError as e:
            self.logger.error(f"Error assigning horse to location: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not assign location."
        finally:
            session.close()

    def remove_horse_from_location(
        self,
        horse_id: int,
        location_id: Optional[
            int
        ] = None,  # If None, removes from *any* current location
        modified_by_user: str = "system",
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            query = session.query(HorseLocation).filter(
                HorseLocation.horse_id == horse_id,
                HorseLocation.is_current_location == True,
            )
            if (
                location_id is not None
            ):  # If a specific location is targeted for removal
                query = query.filter(HorseLocation.location_id == location_id)

            current_assignment = query.first()
            if not current_assignment:
                return (
                    False,
                    "No current location assignment found for this horse (or not at the specified location if one was provided).",
                )

            current_assignment.date_departed = date.today()
            current_assignment.is_current_location = False
            current_assignment.modified_by = modified_by_user

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            # Only nullify current_location_id if we are ending the assignment that matches it
            if horse and horse.current_location_id == current_assignment.location_id:
                horse.current_location_id = None
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} removed from location (assignment ID: {current_assignment.id}) by {modified_by_user}."
            )
            return True, "Horse removed from location (assignment ended)."
        except SQLAlchemyError as e:
            self.logger.error(f"Error removing horse from location: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not remove horse from location."
        finally:
            session.close()

--- End File: controllers/horse_controller.py ---

--- File: config/database_config.py ---
# config/database_config.py

"""
EDSI Veterinary Management System - Database Configuration
Version: 2.0.2
Purpose: Simplified database connection and session management using SQLAlchemy.
         Ensures ADMIN user password is set using bcrypt via User.set_password(),
         with robust handling for pre-existing non-bcrypt hashes.
Last Updated: May 29, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.2 (2025-05-29):
    - Made _ensure_default_admin_user method more robust:
        - It now tries to check the ADMIN password using bcrypt.
        - If check_password fails (returns False or raises ValueError due to
          invalid hash format like old SHA256), it then calls
          user.set_password() to ensure the password becomes "admin1234"
          hashed with bcrypt.
        - This resolves the "ValueError: Invalid salt" during startup.
- v2.0.1 (2025-05-29):
    - Modified _ensure_default_admin_user method to use user.set_password()
      (which uses bcrypt) for the ADMIN user's password ("admin1234")
      instead of directly setting a SHA-256 hash.
    - Removed hashlib import as it's no longer used.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification.
"""

import logging
import os
from typing import Optional
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, scoped_session, Session as SQLAlchemySession
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.exc import SQLAlchemyError

from config.app_config import AppConfig

# Create Base for all models
Base = declarative_base()

# Setup logger
db_logger = logging.getLogger("database_operations")


class DatabaseManager:
    """
    Simplified database manager for EDSI application.
    Handles database initialization, session creation, and table management.
    """

    def __init__(self):
        self.engine = None
        self.SessionLocal: Optional[scoped_session[SQLAlchemySession]] = None
        self.db_url: Optional[str] = None
        self.logger = logging.getLogger(self.__class__.__name__)

    def initialize_database(self, db_url: Optional[str] = None) -> None:
        """
        Initialize database connection and create tables.
        """
        if self.engine:
            self.logger.info("Database already initialized")
            return

        self.db_url = db_url or AppConfig.get_database_url()
        if not self.db_url:
            raise ValueError("DATABASE_URL is not configured")

        self.logger.info(f"Initializing database: {self.db_url}")

        try:
            self.engine = create_engine(
                self.db_url,
                echo=False,
                pool_pre_ping=True,
            )

            self.SessionLocal = scoped_session(
                sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
            )

            self.logger.info("Database engine and session factory created")
            self.create_tables()
            self._test_connection()
            self._ensure_default_admin_user()
            self.logger.info("Database initialization completed successfully")

        except SQLAlchemyError as e:
            self.logger.error(f"SQLAlchemy error during database initialization: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error during database initialization: {e}")
            raise

    def get_session(self) -> SQLAlchemySession:
        """
        Get a database session.
        """
        if not self.SessionLocal:
            raise RuntimeError(
                "Database not initialized. Call initialize_database() first."
            )
        return self.SessionLocal()

    def create_tables(self) -> None:
        """
        Create all database tables.
        """
        if not self.engine:
            raise RuntimeError("Database engine not initialized")

        try:
            self.logger.info("Creating database tables...")
            self._import_models()
            Base.metadata.create_all(bind=self.engine)
            table_names = list(Base.metadata.tables.keys())
            self.logger.info(f"Database tables created: {table_names}")

        except Exception as e:
            self.logger.error(f"Error creating database tables: {e}")
            raise

    def _import_models(self) -> None:
        """
        Import all model classes to ensure they are registered with Base.
        """
        try:
            from models.user_models import User, Role, UserRole
            from models.base_model import BaseModel
            from models.horse_models import Horse, HorseOwner, HorseLocation
            from models.owner_models import (
                Owner,
                OwnerBillingHistory,
                OwnerPayment,
                Invoice,
            )
            from models.reference_models import (
                StateProvince,
                ChargeCode,
                Veterinarian,
                Location,
            )
            from models.reference_models import (
                Transaction,
                TransactionDetail,
                Procedure,
                Drug,
            )
            from models.reference_models import (
                TreatmentLog,
                CommunicationLog,
                Document,
                Reminder,
                Appointment,
            )

            self.logger.debug("Models imported for table creation and admin user setup")
        except ImportError as e:
            self.logger.warning(f"Could not import some models for table creation: {e}")

    def _test_connection(self) -> None:
        """
        Test database connection.
        """
        try:
            with self.get_session() as session:
                session.execute(text("SELECT 1"))
            self.logger.info("Database connection test successful")
        except Exception as e:
            self.logger.error(f"Database connection test failed: {e}")
            raise

    def _ensure_default_admin_user(self) -> None:
        """
        Ensure default admin user always exists with correct credentials
        (password hashed using bcrypt via User.set_password).
        Handles pre-existing non-bcrypt hashes for ADMIN by resetting the password.
        """
        try:
            with self.get_session() as session:
                from models.user_models import (
                    User,
                    Role,
                )  # User model has set_password & check_password

                self.logger.info(
                    "Ensuring default ADMIN user exists with bcrypt password."
                )

                admin_role_name = "ADMIN"
                admin_role = (
                    session.query(Role).filter(Role.name == admin_role_name).first()
                )
                if not admin_role:
                    self.logger.warning(
                        f"Role '{admin_role_name}' not found. Creating it now. "
                        "It's recommended to run add_initial_data.py for full role setup."
                    )
                    admin_role = Role(
                        name=admin_role_name,
                        description="System Administrator (auto-created by db_config)",
                        created_by="SYSTEM_DB_CONFIG",
                        modified_by="SYSTEM_DB_CONFIG",
                    )
                    session.add(admin_role)
                    session.flush()
                    self.logger.info(f"Created '{admin_role_name}' role.")

                admin_user = session.query(User).filter(User.user_id == "ADMIN").first()
                default_password = "admin1234"
                admin_default_name = "System Administrator"
                admin_default_email = "admin@edsi.local"  # Consistent with v2.0.0

                if admin_user:
                    # User exists, check and ensure password, active status, name, and role.
                    password_reset_done = False
                    attributes_updated = False

                    try:
                        if not admin_user.check_password(default_password):
                            # Password is a valid bcrypt hash but incorrect, or other check_password failure
                            self.logger.info(
                                "ADMIN user password check failed (wrong password or other). Resetting."
                            )
                            admin_user.set_password(default_password)
                            password_reset_done = True
                    except ValueError as e:
                        # Catches "Invalid salt" if self.password_hash is not a valid bcrypt hash (e.g. old SHA256)
                        self.logger.warning(
                            f"ADMIN password hash not bcrypt/valid ({e}). Resetting password."
                        )
                        admin_user.set_password(default_password)
                        password_reset_done = True

                    if password_reset_done:
                        admin_user.modified_by = "SYSTEM_DB_CONFIG_PWD"  # Indicate password was definitely set/reset
                        self.logger.info(
                            "ADMIN user password has been set/reset to a bcrypt hash."
                        )

                    if not admin_user.is_active:
                        admin_user.is_active = True
                        self.logger.info("Activated ADMIN user.")
                        attributes_updated = True

                    if admin_user.user_name != admin_default_name:
                        admin_user.user_name = admin_default_name
                        self.logger.info(
                            f"Set ADMIN user_name to '{admin_default_name}'."
                        )
                        attributes_updated = True

                    if (
                        admin_user.email != admin_default_email
                    ):  # Ensure email is also default
                        admin_user.email = admin_default_email
                        self.logger.info(f"Set ADMIN email to '{admin_default_email}'.")
                        attributes_updated = True

                    if (
                        attributes_updated and not password_reset_done
                    ):  # If only attributes changed, set modified_by
                        admin_user.modified_by = "SYSTEM_DB_CONFIG_ATTR"
                    elif (
                        attributes_updated and password_reset_done
                    ):  # modified_by already set for password
                        pass  # no change needed to modified_by

                    if password_reset_done or attributes_updated:
                        self.logger.info("ADMIN user record updated/verified.")
                    else:
                        self.logger.info(
                            "ADMIN user credentials, status, and name are correct."
                        )

                else:
                    # Create new ADMIN user
                    self.logger.info("ADMIN user not found. Creating new ADMIN user...")
                    admin_user = User(
                        user_id="ADMIN",
                        user_name=admin_default_name,
                        email=admin_default_email,
                        is_active=True,
                        created_by="SYSTEM_DB_CONFIG",
                        modified_by="SYSTEM_DB_CONFIG",
                    )
                    admin_user.set_password(default_password)
                    session.add(admin_user)
                    session.flush()
                    self.logger.info("Created new ADMIN user with bcrypt password.")

                if admin_role and admin_role not in admin_user.roles:
                    admin_user.roles.append(admin_role)
                    self.logger.info("Linked ADMIN user to ADMIN role.")
                elif not admin_role:
                    self.logger.error(
                        f"Cannot link ADMIN user to '{admin_role_name}' role as role object is missing."
                    )

                session.commit()
                self.logger.info(
                    f"Default ADMIN user ready (Username: ADMIN, Password: {default_password})"
                )

        except Exception as e:
            self.logger.error(f"Error ensuring default admin user: {e}", exc_info=True)
            if "session" in locals() and session.is_active:
                session.rollback()

    def close(self) -> None:
        if self.SessionLocal:
            self.SessionLocal.remove()
            self.logger.info("Database sessions closed")
        if self.engine:
            self.engine.dispose()
            self.logger.info("Database engine disposed")

    def get_engine(self):
        return self.engine


db_manager = DatabaseManager()


def get_db_session() -> SQLAlchemySession:
    return db_manager.get_session()


def init_database(db_url: Optional[str] = None) -> None:
    db_manager.initialize_database(db_url)

--- End File: config/database_config.py ---

--- File: config/app_config.py ---
# config/app_config.py

"""
EDSI Veterinary Management System - Application Configuration
Version: 2.0.1
Purpose: Simplified centralized configuration for application settings, paths, and constants.
         Added missing logging parameters for file rotation and updated app version.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Coding partner)

Changelog:
- v2.0.1 (2025-05-26):
    - Added LOG_MAX_BYTES and LOG_BACKUP_COUNT constants for log file rotation.
    - Included log_max_bytes and log_backup_count in the get_logging_config() dictionary.
    - Updated module-level APP_VERSION constant to "2.0.3" to align with main application.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Consolidated all configuration into single AppConfig class
    # ... (rest of previous changelog entries assumed present)
"""

import os
import logging
from typing import Dict, Any

# --- Project Paths ---
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
LOG_DIR = os.path.join(PROJECT_ROOT, "logs")
ASSETS_DIR = os.path.join(PROJECT_ROOT, "assets")

# --- Application Information ---
APP_NAME = "EDSI Veterinary Management System"
APP_VERSION = "2.0.3"  # <-- Updated Version
APP_AUTHOR = "EDSI"

# --- Database Configuration ---
DATABASE_URL = f"sqlite:///{os.path.join(PROJECT_ROOT, 'edsi_database.db')}"

# --- Logging Configuration ---
APP_LOG_FILE = os.path.join(LOG_DIR, "edsi_app.log")
DB_LOG_FILE = os.path.join(
    LOG_DIR, "edsi_db.log"
)  # Retained, though not used by current main.py's app logger
LOGGING_LEVEL = logging.INFO
LOG_MAX_BYTES = 1024 * 1024 * 5  # <-- Added: 5 MB
LOG_BACKUP_COUNT = 5  # <-- Added: 5 backup files

# --- UI Configuration ---
DEFAULT_FONT_FAMILY = "Inter"
DEFAULT_FONT_SIZE = 10
SMALL_FONT_SIZE = 9
MIN_WINDOW_WIDTH = 900
MIN_WINDOW_HEIGHT = 700

# --- Dark Theme Colors (Essential Only) ---
DARK_BACKGROUND = "#2D3748"
DARK_WIDGET_BACKGROUND = "#1A202C"
# ... (all other color constants remain the same)
DARK_HEADER_FOOTER = "#222B38"
DARK_BORDER = "#4A5568"
DARK_TEXT_PRIMARY = "#E2E8F0"
DARK_TEXT_SECONDARY = "#A0AEC0"
DARK_TEXT_TERTIARY = "#718096"
DARK_PRIMARY_ACTION = "#3182CE"
DARK_SUCCESS_ACTION = "#38A169"
DARK_WARNING_ACTION = "#DD6B20"
DARK_DANGER_ACTION = "#E53E3E"
DARK_BUTTON_BG = "#4A5568"
DARK_BUTTON_HOVER = "#718096"
DARK_ITEM_HOVER = "#2C3543"
DARK_HIGHLIGHT_BG = "#3182CE"
DARK_HIGHLIGHT_TEXT = "#FFFFFF"
DARK_INPUT_FIELD_BACKGROUND = "#222B38"


class AppConfig:
    """
    Centralized application configuration class.
    Provides clean access to all application settings.
    """

    # Application Info
    APP_NAME = APP_NAME
    APP_VERSION = APP_VERSION  # Will now pick up "2.0.3"
    APP_AUTHOR = APP_AUTHOR

    # Paths
    PROJECT_ROOT = PROJECT_ROOT
    LOG_DIR = LOG_DIR
    ASSETS_DIR = ASSETS_DIR

    # Database
    DATABASE_URL = DATABASE_URL

    # Logging
    APP_LOG_FILE = APP_LOG_FILE
    DB_LOG_FILE = DB_LOG_FILE
    LOGGING_LEVEL = LOGGING_LEVEL
    LOG_MAX_BYTES = LOG_MAX_BYTES  # <-- Added Class Attribute
    LOG_BACKUP_COUNT = LOG_BACKUP_COUNT  # <-- Added Class Attribute

    # UI Settings
    DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY
    # ... (other UI settings remain the same)
    DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE
    SMALL_FONT_SIZE = SMALL_FONT_SIZE
    MIN_WINDOW_WIDTH = MIN_WINDOW_WIDTH
    MIN_WINDOW_HEIGHT = MIN_WINDOW_HEIGHT

    # Theme Colors
    DARK_BACKGROUND = DARK_BACKGROUND
    # ... (all color class attributes remain the same)
    DARK_WIDGET_BACKGROUND = DARK_WIDGET_BACKGROUND
    DARK_HEADER_FOOTER = DARK_HEADER_FOOTER
    DARK_BORDER = DARK_BORDER
    DARK_TEXT_PRIMARY = DARK_TEXT_PRIMARY
    DARK_TEXT_SECONDARY = DARK_TEXT_SECONDARY
    DARK_TEXT_TERTIARY = DARK_TEXT_TERTIARY
    DARK_PRIMARY_ACTION = DARK_PRIMARY_ACTION
    DARK_SUCCESS_ACTION = DARK_SUCCESS_ACTION
    DARK_WARNING_ACTION = DARK_WARNING_ACTION
    DARK_DANGER_ACTION = DARK_DANGER_ACTION
    DARK_BUTTON_BG = DARK_BUTTON_BG
    DARK_BUTTON_HOVER = DARK_BUTTON_HOVER
    DARK_ITEM_HOVER = DARK_ITEM_HOVER
    DARK_HIGHLIGHT_BG = DARK_HIGHLIGHT_BG
    DARK_HIGHLIGHT_TEXT = DARK_HIGHLIGHT_TEXT
    DARK_INPUT_FIELD_BACKGROUND = DARK_INPUT_FIELD_BACKGROUND

    @classmethod
    def get_database_url(cls) -> str:
        return cls.DATABASE_URL

    @classmethod
    def get_app_dir(cls) -> str:  # This method was duplicated, keeping one
        return cls.PROJECT_ROOT

    @classmethod
    def get_assets_dir(cls) -> str:
        return cls.ASSETS_DIR

    @classmethod
    def get_app_info(cls) -> Dict[str, str]:
        return {
            "name": cls.APP_NAME,
            "version": cls.APP_VERSION,
            "author": cls.APP_AUTHOR,
        }

    @classmethod
    def get_logging_config(cls) -> Dict[str, Any]:
        """Get logging configuration"""
        return {
            "level": cls.LOGGING_LEVEL,
            "app_log_file": cls.APP_LOG_FILE,
            "db_log_file": cls.DB_LOG_FILE,  # Retained
            "log_dir": cls.LOG_DIR,
            "log_max_bytes": cls.LOG_MAX_BYTES,  # <-- Added Key
            "log_backup_count": cls.LOG_BACKUP_COUNT,  # <-- Added Key
        }

    @classmethod
    def get_ui_config(cls) -> Dict[str, Any]:
        # ... (remains the same)
        return {
            "font_family": cls.DEFAULT_FONT_FAMILY,
            "font_size": cls.DEFAULT_FONT_SIZE,
            "small_font_size": cls.SMALL_FONT_SIZE,
            "min_window_width": cls.MIN_WINDOW_WIDTH,
            "min_window_height": cls.MIN_WINDOW_HEIGHT,
        }

    @classmethod
    def get_theme_colors(cls) -> Dict[str, str]:
        # ... (remains the same)
        return {
            "background": cls.DARK_BACKGROUND,
            "widget_background": cls.DARK_WIDGET_BACKGROUND,
            "header_footer": cls.DARK_HEADER_FOOTER,
            "border": cls.DARK_BORDER,
            "text_primary": cls.DARK_TEXT_PRIMARY,
            "text_secondary": cls.DARK_TEXT_SECONDARY,
            "text_tertiary": cls.DARK_TEXT_TERTIARY,
            "primary_action": cls.DARK_PRIMARY_ACTION,
            "success_action": cls.DARK_SUCCESS_ACTION,
            "warning_action": cls.DARK_WARNING_ACTION,
            "danger_action": cls.DARK_DANGER_ACTION,
            "button_bg": cls.DARK_BUTTON_BG,
            "button_hover": cls.DARK_BUTTON_HOVER,
            "item_hover": cls.DARK_ITEM_HOVER,
            "highlight_bg": cls.DARK_HIGHLIGHT_BG,
            "highlight_text": cls.DARK_HIGHLIGHT_TEXT,
            "input_field_background": cls.DARK_INPUT_FIELD_BACKGROUND,
        }

    @classmethod
    def ensure_directories(cls) -> None:
        """Ensure required directories exist"""
        directories = [cls.LOG_DIR, cls.ASSETS_DIR]

        for directory in directories:
            if not os.path.exists(directory):
                try:
                    os.makedirs(directory, exist_ok=True)
                    # Optionally log creation:
                    # logging.info(f"Created directory: {directory}")
                except OSError as e:
                    # Using print as logger might not be fully setup when this is called early
                    print(f"Warning: Could not create directory {directory}: {e}")

--- End File: config/app_config.py ---

--- File: views/horse/horse_unified_management.py ---
# views/horse/horse_unified_management.py

"""
EDSI Veterinary Management System - Unified Horse Management Screen (Dark Theme)
Version: 1.7.37
Purpose: Unified interface for horse management.
         - Corrected AttributeError in load_horses method based on v1.7.34.
Last Updated: May 31, 2025
Author: Gemini (Further modified by Coding partner)

Changelog:
- v1.7.37 (2025-05-31):
    - Fixed AttributeError in `load_horses` method by removing invalid
      second argument `QListWidgetItem.SelectionOption.NoUpdate` from
      `self.horse_list.setCurrentRow(i, ...)`. This fix is applied
      to the user's baseline v1.7.34.
- v1.7.34 (2025-05-26) (User's baseline):
    - Original version provided by user. Known to be mostly stable.
# ... (Original changelog from v1.7.34 if any, or previous relevant entries like v1.7.33)
"""

import logging
from datetime import datetime, date
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QFrame,
    QListWidgetItem,
    QTabWidget,
    QWidget,
    QSplitter,
    QRadioButton,
    QButtonGroup,
    QApplication,
    QMenu,
    QDialog,
    QMessageBox,
    QStatusBar,
)
from PySide6.QtCore import Qt, Signal, QTimer, QDate
from PySide6.QtGui import (
    QFont,
    QPalette,
    QColor,
    QAction,
    QKeyEvent,
    QShowEvent,
    QCloseEvent,
    QDoubleValidator,
)
from sqlalchemy.orm.exc import DetachedInstanceError

from views.base_view import BaseView
from config.app_config import (
    DARK_BACKGROUND,
    DARK_WIDGET_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_BORDER,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_ITEM_HOVER,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_INPUT_FIELD_BACKGROUND,
    DEFAULT_FONT_FAMILY,
    DARK_SUCCESS_ACTION,
    DARK_DANGER_ACTION,
)
from controllers.horse_controller import HorseController
from controllers.owner_controller import OwnerController
from controllers.location_controller import LocationController
from models import Horse, Location as LocationModel, Owner as OwnerModel

from .tabs.basic_info_tab import BasicInfoTab
from .tabs.owners_tab import OwnersTab
from .tabs.location_tab import LocationTab
from .widgets.horse_list_widget import HorseListWidget


class HorseUnifiedManagement(BaseView):
    horse_selection_changed = Signal(int)
    exit_requested = Signal()
    setup_requested = Signal()
    closing = Signal()

    def __init__(self, current_user=None):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(
            f"HorseUnifiedManagement __init__ started for user: {current_user}"
        )
        self.current_user = current_user or "ADMIN"
        self.horse_controller = HorseController()
        self.owner_controller = OwnerController()
        self.location_controller = LocationController()

        self.tab_widget: Optional[QTabWidget] = None
        self.basic_info_tab: Optional[BasicInfoTab] = None
        self.owners_tab: Optional[OwnersTab] = None
        self.location_tab: Optional[LocationTab] = None
        self.horse_list: Optional[HorseListWidget] = None
        self.empty_frame: Optional[QFrame] = None
        self.horse_details_content_widget: Optional[QWidget] = None
        self.horse_title: Optional[QLabel] = None
        self.horse_info_line: Optional[QLabel] = None
        self.add_horse_btn: Optional[QPushButton] = None
        self.edit_horse_btn: Optional[QPushButton] = None
        self.refresh_btn: Optional[QPushButton] = None
        self.help_btn: Optional[QPushButton] = None
        self.print_btn: Optional[QPushButton] = None
        self.setup_icon_btn: Optional[QPushButton] = None
        self.user_menu_button: Optional[QPushButton] = None
        self.user_menu: Optional[QMenu] = None
        self.active_only_radio: Optional[QRadioButton] = None
        self.all_horses_radio: Optional[QRadioButton] = None
        self.deactivated_radio: Optional[QRadioButton] = None
        self.filter_group: Optional[QButtonGroup] = None
        self.search_input: Optional[QLineEdit] = None
        self.splitter: Optional[QSplitter] = None
        self.list_widget_container: Optional[QWidget] = None
        self.details_widget: Optional[QWidget] = None
        self.details_layout: Optional[QVBoxLayout] = None
        self.status_bar: Optional[QStatusBar] = None
        self.status_label: Optional[QLabel] = None
        self.footer_horse_count_label: Optional[QLabel] = None
        self.shortcut_label: Optional[QLabel] = None

        super().__init__()

        self.horses_list_data: List[Horse] = []
        self.current_horse: Optional[Horse] = None
        self._has_changes_in_active_tab: bool = False
        self._is_new_mode: bool = False

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self.perform_search)

        self.logger.debug("Scheduling load_initial_data with QTimer.singleShot(0).")
        QTimer.singleShot(0, self.load_initial_data)
        self.logger.info(
            "HorseUnifiedManagement screen __init__ finished (initial data load deferred)."
        )

    def setup_ui(self):  # Structure from user's v1.7.34
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        print("!!! HORSEUNIFIEDMANAGEMENT.SETUP_UI IS BEING CALLED NOW !!!")
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        self.logger.info("HorseUnifiedManagement.setup_ui: EXECUTION CONFIRMED.")

        self.set_title("Horse Management")
        self.resize(1200, 800)

        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.setup_header(main_layout)
        self.setup_action_bar(main_layout)
        self.setup_main_content(main_layout)
        self.setup_footer(main_layout)
        self.setup_connections()

        self.logger.info("HorseUnifiedManagement.setup_ui: All components initialized.")

    def showEvent(self, event: QShowEvent):  # Structure from user's v1.7.34
        self.logger.info("HorseUnifiedManagement showEvent: START")
        super().showEvent(event)

        self.logger.debug(
            "showEvent: Checking core UI elements (empty_frame, horse_details_content_widget)..."
        )
        if (
            not hasattr(self, "empty_frame")
            or not self.empty_frame
            or not hasattr(self, "horse_details_content_widget")
            or not self.horse_details_content_widget
        ):
            self.logger.error(
                "showEvent: Core UI elements for displaying state are NOT ready. UI setup might be incomplete. Aborting showEvent further processing."
            )
            return
        self.logger.debug("showEvent: Core UI elements check PASSED.")

        if self.current_horse:
            self.logger.debug(
                "showEvent: current_horse exists. Calling display_details_state."
            )
            self.display_details_state()
            self.logger.debug("showEvent: display_details_state call completed.")
            if (
                self.basic_info_tab
                and not self._is_new_mode
                and hasattr(self.basic_info_tab, "_is_editing")
                and not self.basic_info_tab._is_editing  # type: ignore
            ):
                self.logger.debug("showEvent: Setting basic_info_tab to read-only.")
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.basic_info_tab.set_form_read_only(True)
                self.logger.debug("showEvent: basic_info_tab set to read-only.")
        else:
            self.logger.debug(
                "showEvent: No current_horse. Calling display_empty_state."
            )
            self.display_empty_state()
            self.logger.debug("showEvent: display_empty_state call completed.")

        self.logger.debug("showEvent: Calling update_main_action_buttons_state.")
        self.update_main_action_buttons_state()
        self.logger.debug("showEvent: update_main_action_buttons_state call completed.")

        self.logger.info(
            "HorseUnifiedManagement showEvent: FINISHED - screen should be visible."
        )

    def display_empty_state(self):  # Structure from user's v1.7.34
        self.logger.debug("display_empty_state: START")

        if hasattr(self, "empty_frame") and self.empty_frame:
            self.logger.debug("display_empty_state: Showing empty_frame.")
            self.empty_frame.show()
        else:
            self.logger.warning(
                "display_empty_state: empty_frame not available or not valid."
            )

        if (
            hasattr(self, "horse_details_content_widget")
            and self.horse_details_content_widget
        ):
            self.logger.debug(
                "display_empty_state: Hiding horse_details_content_widget."
            )
            self.horse_details_content_widget.hide()
        else:
            self.logger.warning(
                "display_empty_state: horse_details_content_widget not available."
            )

        self.current_horse = None
        self._is_new_mode = False
        self._has_changes_in_active_tab = False
        self.logger.debug("display_empty_state: Basic state flags reset.")

        if self.basic_info_tab:
            self.logger.debug(
                "display_empty_state: Calling basic_info_tab.clear_fields()."
            )
            try:
                self.basic_info_tab.clear_fields()
                self.logger.debug(
                    "display_empty_state: basic_info_tab.clear_fields() successful."
                )
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.logger.debug(
                        "display_empty_state: Attempting basic_info_tab.set_form_read_only(True)."
                    )
                    self.basic_info_tab.set_form_read_only(True)
                    self.logger.debug(
                        "display_empty_state: basic_info_tab.set_form_read_only(True) done."
                    )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in basic_info_tab.clear_fields or set_form_read_only: {e}",
                    exc_info=True,
                )

            if hasattr(self.basic_info_tab, "update_buttons_state"):
                self.logger.debug(
                    "display_empty_state: Calling basic_info_tab.update_buttons_state(...)."
                )
                try:
                    self.basic_info_tab.update_buttons_state(
                        is_editing_or_new=False, has_selection=False, has_changes=False
                    )
                    self.logger.debug(
                        "display_empty_state: basic_info_tab.update_buttons_state() successful."
                    )
                except Exception as e:
                    self.logger.error(
                        f"display_empty_state: Error in basic_info_tab.update_buttons_state: {e}",
                        exc_info=True,
                    )
        else:
            self.logger.error("display_empty_state: BasicInfoTab is None.")

        if self.owners_tab and hasattr(self.owners_tab, "load_owners_for_horse"):
            self.logger.debug(
                "display_empty_state: Calling owners_tab.load_owners_for_horse(None)."
            )
            try:
                self.owners_tab.load_owners_for_horse(None)
                self.logger.debug(
                    "display_empty_state: owners_tab.load_owners_for_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in owners_tab.load_owners_for_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: OwnersTab is None or missing method."
            )

        if self.location_tab and hasattr(self.location_tab, "load_location_for_horse"):
            self.logger.debug(
                "display_empty_state: Calling location_tab.load_location_for_horse(None)."
            )
            try:
                self.location_tab.load_location_for_horse(None)
                self.logger.debug(
                    "display_empty_state: location_tab.load_location_for_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in location_tab.load_location_for_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: LocationTab is None or missing method."
            )

        if hasattr(self, "horse_title") and self.horse_title:
            self.logger.debug("display_empty_state: Setting horse_title text.")
            self.horse_title.setText("No Horse Selected")
        else:
            self.logger.warning(
                "display_empty_state: horse_title QLabel not available."
            )

        self.logger.debug("display_empty_state: Calling _update_horse_info_line(None).")
        self._update_horse_info_line(None)
        self.logger.debug(
            "display_empty_state: _update_horse_info_line(None) call completed."
        )

        self.logger.debug("display_empty_state: Calling update_status.")
        self.update_status("No horse selected. Add a new horse or select from list.")
        self.logger.info("display_empty_state: FINISHED")

    def update_main_action_buttons_state(self):  # Structure from user's v1.7.34
        self.logger.debug("update_main_action_buttons_state: START")
        can_add_new = not self._is_new_mode and not self._has_changes_in_active_tab
        if hasattr(self, "add_horse_btn") and self.add_horse_btn:
            self.add_horse_btn.setEnabled(can_add_new)
            self.logger.debug(
                f"update_main_action_buttons_state: add_horse_btn enabled: {can_add_new}"
            )
        else:
            self.logger.warning(
                "add_horse_btn not initialized in update_main_action_buttons_state"
            )

        form_is_editable_by_tab = False
        if self.basic_info_tab and hasattr(self.basic_info_tab, "_is_editing"):
            form_is_editable_by_tab = self.basic_info_tab._is_editing  # type: ignore

        can_edit_selected = (
            self.current_horse is not None
            and not self._is_new_mode
            and not self._has_changes_in_active_tab
            and not form_is_editable_by_tab
        )

        if hasattr(self, "edit_horse_btn") and self.edit_horse_btn:
            self.edit_horse_btn.setEnabled(can_edit_selected)
            self.logger.debug(
                f"update_main_action_buttons_state: edit_horse_btn enabled: {can_edit_selected}"
            )
        else:
            self.logger.warning(
                "edit_horse_btn not initialized in update_main_action_buttons_state"
            )

        if self.basic_info_tab and hasattr(self.basic_info_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating basic_info_tab buttons."
            )
            try:
                is_editing_or_new_val = self._is_new_mode or form_is_editable_by_tab
                has_selection_val = self.current_horse is not None
                has_changes_val = self._has_changes_in_active_tab
                self.basic_info_tab.update_buttons_state(
                    is_editing_or_new_val, has_selection_val, has_changes_val
                )
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling basic_info_tab.update_buttons_state: {e}",
                    exc_info=True,
                )
        if self.owners_tab and hasattr(self.owners_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating owners_tab buttons."
            )
            try:
                self.owners_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling owners_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.location_tab and hasattr(self.location_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating location_tab buttons."
            )
            try:
                self.location_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling location_tab.update_buttons_state: {e}",
                    exc_info=True,
                )
        self.logger.debug("update_main_action_buttons_state: FINISHED")

    def discard_changes(self):  # Structure from user's v1.7.34
        self.logger.debug("discard_changes: START")
        if not self._is_new_mode and not self._has_changes_in_active_tab:
            if (
                self.current_horse
                and self.basic_info_tab
                and hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing  # type: ignore
            ):
                self.logger.info(
                    "discard_changes: Form in edit mode, no data changes. Reverting to read-only."
                )
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.basic_info_tab.set_form_read_only(True)
                self.update_main_action_buttons_state()
                self.update_status(
                    f"Viewing: {self.current_horse.horse_name or 'horse'}"
                )
                self.logger.debug("discard_changes: FINISHED (no actual changes)")
                return
            self.update_status("No changes to discard.")
            self.logger.debug("discard_changes: FINISHED (no changes to discard)")
            return

        if self.show_question("Confirm Discard", "Discard unsaved changes?"):
            self.logger.info("discard_changes: User confirmed discard.")
            was_in_new_mode = self._is_new_mode
            self._is_new_mode = False
            self._has_changes_in_active_tab = False
            if self.basic_info_tab:
                self.logger.debug("discard_changes: Clearing BasicInfoTab.")
                try:
                    self.basic_info_tab.clear_fields()
                    if hasattr(self.basic_info_tab, "set_form_read_only"):
                        self.basic_info_tab.set_form_read_only(True)
                except Exception as e:
                    self.logger.error(
                        f"discard_changes: Error in basic_info_tab.clear_fields/set_form_read_only: {e}",
                        exc_info=True,
                    )

            if self.current_horse and not was_in_new_mode:
                self.logger.debug(
                    f"discard_changes: Reloading horse ID {self.current_horse.horse_id}."
                )
                self.load_horse_details(self.current_horse.horse_id)
            else:
                self.logger.debug(
                    "discard_changes: Was new or no current horse. Selecting first in list or empty state."
                )
                if self.horse_list and self.horse_list.count() > 0:
                    self.horse_list.setCurrentRow(0)
                else:
                    self.display_empty_state()
            self.update_main_action_buttons_state()
            self.update_status("Changes discarded.")
        else:
            self.logger.info("discard_changes: User cancelled discard.")
        self.logger.debug("discard_changes: FINISHED")

    def load_initial_data(self):  # Structure from user's v1.7.34
        self.logger.info("load_initial_data: START - Attempting to load horses.")
        try:
            self.load_horses()
            self.logger.info(
                "load_initial_data: FINISHED - load_horses call completed."
            )
        except Exception as e:
            self.logger.error(
                f"load_initial_data: CRITICAL ERROR during load_horses: {e}",
                exc_info=True,
            )
            self.show_error(
                "Initial Data Load Failed", f"Could not load initial horse data: {e}"
            )

    def closeEvent(self, event: QCloseEvent):  # Structure from user's v1.7.34
        self.logger.warning(f"HorseUnifiedManagement closeEvent. Type: {event.type()}")  # type: ignore
        self.closing.emit()
        super().closeEvent(event)
        self.logger.warning("HorseUnifiedManagement finished processing closeEvent.")

    def get_form_input_style(
        self, base_bg=DARK_INPUT_FIELD_BACKGROUND
    ):  # Structure from user's v1.7.34
        return f"""
            QLineEdit, QComboBox, QDateEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; }}
            QLineEdit:focus, QComboBox:focus, QDateEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QLineEdit:disabled, QComboBox:disabled, QDateEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; width: 15px; }} QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QDateEdit::up-button, QDateEdit::down-button {{ width: 18px; }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
        """

    def get_generic_button_style(self):  # Structure from user's v1.7.34
        return f"""
            QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px; }} 
            QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} 
            QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}
        """

    def get_toolbar_button_style(
        self, bg_color_hex, text_color_hex="#ffffff"
    ):  # Structure from user's v1.7.34
        if len(bg_color_hex) == 4 and bg_color_hex.startswith(
            "#"
        ):  # Ensure 6-digit hex for QColor
            bg_color_hex = f"#{bg_color_hex[1]*2}{bg_color_hex[2]*2}{bg_color_hex[3]*2}"
        try:
            # Using QColor for robust color manipulation
            base_qcolor = QColor(bg_color_hex)
            hover_bg = base_qcolor.lighter(115).name()  # Standard hover lightness
            pressed_bg = base_qcolor.darker(110).name()  # Standard pressed darkness
        except ValueError:  # Fallback if color string is invalid
            hover_bg, pressed_bg = DARK_BUTTON_HOVER, DARK_BUTTON_BG
            self.logger.warning(
                f"Could not parse color: {bg_color_hex} for button style."
            )
        return f"""
            QPushButton {{ background-color: {bg_color_hex}; color: {text_color_hex}; border: none; border-radius: 4px; padding: 8px 16px; font-size: 13px; font-weight: 500; }} 
            QPushButton:hover {{ background-color: {hover_bg}; }} QPushButton:pressed {{ background-color: {pressed_bg}; }} 
            QPushButton:disabled {{ background-color: #adb5bd; color: #f8f9fa; }}
        """  # Example disabled style, adjust as needed

    def setup_header(self, parent_layout):  # Structure from user's v1.7.34
        self.logger.debug("setup_header: START")
        header_frame = QFrame()
        header_frame.setObjectName("HeaderFrame")
        header_frame.setFixedHeight(55)
        header_frame.setStyleSheet(f"""#HeaderFrame{{background-color:{DARK_HEADER_FOOTER};border:none;padding:0 20px;}} QLabel{{color:{DARK_TEXT_PRIMARY};background-color:transparent;}} QPushButton#UserMenuButton{{color:{DARK_TEXT_SECONDARY};font-size:12px;background-color:transparent;border:none;padding:5px;text-align:right;}} QPushButton#UserMenuButton::menu-indicator{{image:none;}} QPushButton#UserMenuButton:hover{{color:{DARK_TEXT_PRIMARY};background-color:{QColor(DARK_ITEM_HOVER).lighter(110).name(QColor.NameFormat.HexRgb)}33;}}""")  # type: ignore
        header_layout = QHBoxLayout(header_frame)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(15)
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setSpacing(2)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addStretch()
        title_label = QLabel("EDSI - Horse Management")
        title_label.setFont(QFont(DEFAULT_FONT_FAMILY, 15, QFont.Weight.Bold))
        left_layout.addWidget(title_label)
        breadcrumb_label = QLabel("🏠 Horse Management")
        breadcrumb_label.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:11px;background:transparent;"
        )
        left_layout.addWidget(breadcrumb_label)
        left_layout.addStretch()
        right_widget = QWidget()
        right_layout = QHBoxLayout(right_widget)
        right_layout.setSpacing(10)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.refresh_btn = QPushButton("🔄")
        self.refresh_btn.setToolTip("Refresh Data (F5)")
        self.help_btn = QPushButton("❓")
        self.help_btn.setToolTip("Help (F1)")
        self.print_btn = QPushButton("🖨️")
        self.print_btn.setToolTip("Print Options")
        self.setup_icon_btn = QPushButton("⚙️")
        self.setup_icon_btn.setToolTip("System Setup")
        header_button_style = f"""QPushButton{{background-color:{DARK_BUTTON_BG};color:{DARK_TEXT_PRIMARY};border:1px solid {DARK_BORDER};border-radius:4px;padding:5px;font-size:14px;min-width:28px;max-width:28px;min-height:28px;max-height:28px;}} QPushButton:hover{{background-color:{DARK_BUTTON_HOVER};}} QPushButton:pressed{{background-color:{DARK_BUTTON_BG};}}"""
        for btn in [
            self.refresh_btn,
            self.help_btn,
            self.print_btn,
            self.setup_icon_btn,
        ]:
            if btn:
                btn.setStyleSheet(header_button_style)
        self.user_menu_button = QPushButton(f"👤 User: {self.current_user}")
        self.user_menu_button.setObjectName("UserMenuButton")
        self.user_menu_button.setToolTip("User options")
        self.user_menu_button.setFlat(True)
        self.user_menu = QMenu(self)
        self.user_menu.setStyleSheet(
            f"""QMenu{{background-color:{DARK_WIDGET_BACKGROUND};color:{DARK_TEXT_PRIMARY};border:1px solid {DARK_BORDER};padding:5px;}} QMenu::item{{padding:5px 20px 5px 20px;min-width:100px;}} QMenu::item:selected{{background-color:{DARK_HIGHLIGHT_BG}70;color:{DARK_HIGHLIGHT_TEXT};}} QMenu::separator{{height:1px;background:{DARK_BORDER};margin-left:5px;margin-right:5px;}}"""
        )
        logout_action = QAction("Log Out", self)
        logout_action.triggered.connect(self.handle_logout_request_from_menu)
        self.user_menu.addAction(logout_action)
        self.user_menu_button.setMenu(self.user_menu)
        for btn in [
            self.refresh_btn,
            self.help_btn,
            self.print_btn,
            self.setup_icon_btn,
            self.user_menu_button,
        ]:
            if btn:
                right_layout.addWidget(btn)
        header_layout.addWidget(left_widget)
        header_layout.addStretch()
        header_layout.addWidget(right_widget)
        parent_layout.addWidget(header_frame)
        self.logger.debug("setup_header: END")

    def setup_action_bar(self, parent_layout):  # Structure from user's v1.7.34
        self.logger.debug("setup_action_bar: START")
        action_bar_frame = QFrame()
        action_bar_frame.setObjectName("ActionBarFrame")
        action_bar_frame.setFixedHeight(50)
        action_bar_frame.setStyleSheet(
            f"""#ActionBarFrame{{background-color:{DARK_BACKGROUND};border:none;border-bottom:1px solid {DARK_BORDER};padding:0 20px;}} QPushButton{{min-height:30px;}} QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;}} QRadioButton::indicator{{width:13px;height:13px;}} QRadioButton{{color:{DARK_TEXT_SECONDARY};background:transparent;padding:5px;}}"""
        )
        action_bar_layout = QHBoxLayout(action_bar_frame)
        action_bar_layout.setContentsMargins(0, 0, 0, 0)
        action_bar_layout.setSpacing(12)
        action_bar_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.add_horse_btn = QPushButton("➕ Add Horse")
        self.edit_horse_btn = QPushButton("✓ Edit Selected")
        action_button_style_str = self.get_generic_button_style()
        add_btn_bg_color = DARK_PRIMARY_ACTION
        if len(add_btn_bg_color) == 4:
            add_btn_bg_color = f"#{add_btn_bg_color[1]*2}{add_btn_bg_color[2]*2}{add_btn_bg_color[3]*2}"
        self.add_horse_btn.setStyleSheet(action_button_style_str.replace(DARK_BUTTON_BG, add_btn_bg_color + "B3").replace(f"color:{DARK_TEXT_PRIMARY}", "color:white;"))  # type: ignore
        self.edit_horse_btn.setStyleSheet(action_button_style_str)  # type: ignore
        action_bar_layout.addWidget(self.add_horse_btn)
        action_bar_layout.addWidget(self.edit_horse_btn)
        self.filter_group = QButtonGroup(self)
        self.active_only_radio = QRadioButton("Active Only")
        self.all_horses_radio = QRadioButton("All Horses")
        self.deactivated_radio = QRadioButton("Deactivated")
        for btn in [
            self.active_only_radio,
            self.all_horses_radio,
            self.deactivated_radio,
        ]:
            if btn:
                self.filter_group.addButton(btn)
                action_bar_layout.addWidget(btn)
        if self.active_only_radio:
            self.active_only_radio.setChecked(True)
        action_bar_layout.addStretch()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("🔍 Search...")
        self.search_input.setFixedHeight(30)
        self.search_input.setFixedWidth(220)
        self.search_input.setStyleSheet(
            self.get_form_input_style(base_bg=DARK_HEADER_FOOTER)
        )
        action_bar_layout.addWidget(self.search_input)
        if self.edit_horse_btn:
            self.edit_horse_btn.setEnabled(False)
        parent_layout.addWidget(action_bar_frame)
        self.logger.debug("setup_action_bar: END")

    def setup_main_content(self, parent_layout):  # Structure from user's v1.7.34
        self.logger.debug("setup_main_content: START")
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        self.splitter.setHandleWidth(1)
        self.splitter.setStyleSheet(
            f"""QSplitter{{background-color:{DARK_BACKGROUND};border:none;}} QSplitter::handle{{background-color:{DARK_BORDER};}} QSplitter::handle:horizontal{{width:1px;}} QSplitter::handle:pressed{{background-color:{DARK_TEXT_SECONDARY};}}"""
        )
        self.setup_horse_list_panel()
        self.setup_horse_details_panel()
        self.splitter.setSizes([300, 850])
        self.splitter.setStretchFactor(0, 0)
        self.splitter.setStretchFactor(1, 1)
        self.splitter.setCollapsible(0, False)
        self.splitter.setCollapsible(1, False)
        parent_layout.addWidget(self.splitter, 1)
        self.logger.debug("setup_main_content: END")

    def setup_horse_list_panel(self):  # Structure from user's v1.7.34
        self.list_widget_container = QWidget()
        self.list_widget_container.setStyleSheet(
            f"background-color:{DARK_BACKGROUND};border:none;border-right:1px solid {DARK_BORDER};"
        )
        list_layout = QVBoxLayout(self.list_widget_container)
        list_layout.setContentsMargins(0, 0, 0, 0)
        list_layout.setSpacing(0)
        self.horse_list = HorseListWidget()
        self.horse_list.setMinimumWidth(250)
        list_layout.addWidget(self.horse_list, 1)
        if self.splitter:
            self.splitter.addWidget(self.list_widget_container)

    def setup_horse_details_panel(self):  # Structure from user's v1.7.34
        self.logger.debug("setup_horse_details_panel: START")
        self.details_widget = QWidget()
        self.details_widget.setStyleSheet(
            f"background-color:{DARK_BACKGROUND};border:none;"
        )
        self.details_layout = QVBoxLayout(self.details_widget)
        self.details_layout.setContentsMargins(15, 10, 15, 10)
        self.details_layout.setSpacing(15)
        self.horse_details_content_widget = QWidget()
        details_content_layout = QVBoxLayout(self.horse_details_content_widget)
        details_content_layout.setContentsMargins(0, 0, 0, 0)
        details_content_layout.setSpacing(15)
        self.setup_horse_header_details(details_content_layout)
        self.setup_horse_tabs(details_content_layout)
        self.setup_empty_state()
        if self.details_layout and self.empty_frame:
            self.details_layout.addWidget(self.empty_frame)
        if self.details_layout and self.horse_details_content_widget:
            self.details_layout.addWidget(self.horse_details_content_widget)
        if self.horse_details_content_widget:
            self.horse_details_content_widget.hide()
        if self.splitter:
            self.splitter.addWidget(self.details_widget)
        self.logger.debug("setup_horse_details_panel: END")

    def setup_empty_state(self):  # Structure from user's v1.7.34
        self.logger.debug("setup_empty_state (frame creation): START")
        self.empty_frame = QFrame()
        self.empty_frame.setObjectName("EmptyFrame")
        self.empty_frame.setStyleSheet(
            "#EmptyFrame{background-color:transparent;border:none;}"
        )
        empty_layout = QVBoxLayout(self.empty_frame)
        empty_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        empty_layout.setSpacing(15)
        empty_label = QLabel("Select a horse from the list, or click 'Add Horse'.")
        empty_label.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:16px;background:transparent;"
        )
        empty_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        empty_layout.addWidget(empty_label)
        self.logger.debug("setup_empty_state (frame creation): FINISHED")

    def setup_horse_header_details(
        self, parent_layout
    ):  # Structure from user's v1.7.34
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(5)
        self.horse_title = QLabel("Horse Name")
        self.horse_title.setFont(QFont(DEFAULT_FONT_FAMILY, 18, QFont.Weight.Bold))
        self.horse_title.setStyleSheet(
            f"color:{DARK_TEXT_PRIMARY};background:transparent;"
        )
        self.horse_info_line = QLabel(
            "Acct: N/A | 👥 No Owner | Breed: N/A | Color: N/A | Sex: N/A | Age: N/A | 📍 N/A"
        )
        self.horse_info_line.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:12px;background:transparent;"
        )
        self.horse_info_line.setWordWrap(True)
        header_layout.addWidget(self.horse_title)
        header_layout.addWidget(self.horse_info_line)
        parent_layout.addWidget(header_widget)

    def setup_horse_tabs(self, parent_layout_for_tabs):  # Structure from user's v1.7.34
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_HORSE_TABS START ---")
        try:
            self.tab_widget = QTabWidget()
            self.tab_widget.setObjectName("DetailsTabWidget")
            self.tab_widget.setStyleSheet(
                f"""QTabWidget#DetailsTabWidget::pane{{border:1px solid {DARK_BORDER};background-color:{DARK_WIDGET_BACKGROUND};border-radius:6px;margin-top:-1px;}} QTabBar::tab{{padding:8px 15px;margin-right:2px;background-color:{DARK_BUTTON_BG};color:{DARK_TEXT_SECONDARY};border:1px solid {DARK_BORDER};border-bottom:none;border-top-left-radius:5px;border-top-right-radius:5px;min-width:90px;font-size:13px;font-weight:500;}} QTabBar::tab:selected{{background-color:{DARK_WIDGET_BACKGROUND};color:{DARK_TEXT_PRIMARY};border-color:{DARK_BORDER};border-bottom-color:{DARK_WIDGET_BACKGROUND};}} QTabBar::tab:!selected:hover{{background-color:{DARK_BUTTON_HOVER};color:{DARK_TEXT_PRIMARY};}} QTabBar{{border:none;background-color:transparent;margin-bottom:0px;}}"""
            )
            self.logger.info("QTabWidget created and styled.")
            try:
                self.basic_info_tab = BasicInfoTab(
                    horse_controller=self.horse_controller, parent=self
                )
                self.tab_widget.addTab(self.basic_info_tab, "📋 Basic Info")
                self.logger.info("BasicInfoTab created.")
            except Exception as e_basic:
                self.logger.error(f"ERROR BasicInfoTab: {e_basic}", exc_info=True)
                self.basic_info_tab = None
            try:
                self.owners_tab = OwnersTab(
                    parent_view=self,
                    horse_controller=self.horse_controller,
                    owner_controller=self.owner_controller,
                )
                self.tab_widget.addTab(self.owners_tab, "👥 Owners")
                self.logger.info("OwnersTab created.")
            except Exception as e_owners:
                self.logger.error(f"ERROR OwnersTab: {e_owners}", exc_info=True)
                self.owners_tab = None
            try:
                self.location_tab = LocationTab(
                    parent_view=self,
                    horse_controller=self.horse_controller,
                    location_controller=self.location_controller,
                )
                self.tab_widget.addTab(self.location_tab, "📍 Location")
                self.logger.info("LocationTab created.")
            except Exception as e_location:
                self.logger.error(f"ERROR LocationTab: {e_location}", exc_info=True)
                self.location_tab = None
            placeholder_tabs = ["💰 Billing", "📊 History"]
            for name in placeholder_tabs:
                placeholder_widget = QWidget(
                    objectName=f"Placeholder_{name.replace(' ','')}Tab"
                )
                layout = QVBoxLayout(placeholder_widget)
                label = QLabel(f"{name} - Coming Soon")
                label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                layout.addWidget(label)
                self.tab_widget.addTab(placeholder_widget, name)
            parent_layout_for_tabs.addWidget(self.tab_widget, 1)
            self.logger.info("Tabs added.")
        except Exception as e:
            self.logger.error(f"ERROR setup_horse_tabs: {e}", exc_info=True)
            if hasattr(self, "tab_widget") and self.tab_widget:
                self.tab_widget.deleteLater()
            self.tab_widget = None
            self.basic_info_tab = None
            self.owners_tab = None
            self.location_tab = None

    def _handle_location_assignment_change(
        self, location_data: Dict
    ):  # Structure from user's v1.7.34
        self.logger.info(f"Received location_assignment_changed: {location_data}")
        if self.current_horse and self.current_horse.horse_id is not None:
            horse_id_that_changed = self.current_horse.horse_id
            self.logger.info(
                f"Location changed for horse ID {horse_id_that_changed}. Reloading details."
            )
            self.load_horse_details(
                horse_id_that_changed
            )  # Reload to get updated horse.location
            if self.current_horse:  # Re-check current_horse after reload
                current_loc_name = "[N/A - Error]"
                try:
                    current_loc_name = (
                        self.current_horse.location.location_name
                        if self.current_horse.location
                        and hasattr(self.current_horse.location, "location_name")
                        else "N/A"
                    )
                except DetachedInstanceError:
                    current_loc_name = "[Location N/A - Session Issue]"
                self.update_status(
                    f"Location updated to '{current_loc_name}' for {self.current_horse.horse_name or 'horse'}."
                )
        else:
            self.logger.warning(
                "Location assignment changed, but no current_horse or valid horse_id to refresh."
            )

    def _get_display_owner_name(
        self, horse: Optional[Horse]
    ) -> str:  # Structure from user's v1.7.34 (Restored)
        if not horse:
            return "No Owner"

        owner_name_display = "No Owner"
        try:
            if horse.owners and len(horse.owners) > 0:
                owner_model_assoc = horse.owners[0]
                if (
                    owner_model_assoc
                    and hasattr(owner_model_assoc, "owner")
                    and owner_model_assoc.owner
                ):
                    actual_owner = owner_model_assoc.owner
                    name_parts: List[str] = []
                    if (
                        hasattr(actual_owner, "farm_name")
                        and actual_owner.farm_name
                        and actual_owner.farm_name.strip()
                    ):
                        name_parts.append(actual_owner.farm_name.strip())
                    person_name_parts: List[str] = []
                    if (
                        hasattr(actual_owner, "first_name")
                        and actual_owner.first_name
                        and actual_owner.first_name.strip()
                    ):
                        person_name_parts.append(actual_owner.first_name.strip())
                    if (
                        hasattr(actual_owner, "last_name")
                        and actual_owner.last_name
                        and actual_owner.last_name.strip()
                    ):
                        person_name_parts.append(actual_owner.last_name.strip())
                    person_name_str = " ".join(person_name_parts).strip()
                    if person_name_str:
                        if name_parts:
                            name_parts.append(f"({person_name_str})")
                        else:
                            name_parts.append(person_name_str)

                    if name_parts:
                        owner_name_display = " ".join(name_parts)
                    elif hasattr(actual_owner, "owner_id"):
                        owner_name_display = f"Owner ID: {actual_owner.owner_id}"
                    else:
                        owner_name_display = "Owner Data Incomplete"
                else:
                    owner_name_display = "Owner Data Missing"
        except DetachedInstanceError:
            logger_obj = getattr(self, "logger", logging.getLogger(__name__))
            logger_obj.warning(
                f"Detached: horse.owners or owner.owner, Horse ID {horse.horse_id if horse else 'N/A'}."
            )
            owner_name_display = "[Own N/A - Detached]"
        except Exception as e:
            self.logger.error(
                f"Error constructing owner display name: {e}", exc_info=True
            )
            owner_name_display = "[Owner Display Error]"
        return owner_name_display

    def _get_display_location_name(
        self, horse: Optional[Horse]
    ) -> str:  # Structure from user's v1.7.34 (Restored)
        if not horse:
            return "N/A"

        location_name_str = "N/A"  # Initialize with default
        try:
            if horse.location and hasattr(horse.location, "location_name"):
                location_name_str = horse.location.location_name or "N/A"
        except DetachedInstanceError:
            logger_obj = getattr(self, "logger", logging.getLogger(__name__))
            logger_obj.warning(
                f"Detached: horse.location, ID {horse.horse_id if horse else 'N/A'}."
            )
            location_name_str = "[Loc N/A - Detached]"
        except Exception as e:
            self.logger.error(f"Error getting location name: {e}", exc_info=True)
            location_name_str = "[Location Error]"
        return location_name_str

    def _update_horse_info_line(
        self, horse: Optional[Horse]
    ):  # Structure from user's v1.7.34
        if not hasattr(self, "horse_info_line") or self.horse_info_line is None:
            self.logger.error(
                "_update_horse_info_line: horse_info_line QLabel is None."
            )
            return
        if not horse:
            self.horse_info_line.setText(
                "Acct: N/A | 👥 No Owner | Breed: N/A | Color: N/A | Sex: N/A | Age: N/A | 📍 N/A"
            )
            return

        age_str = "Age N/A"
        if self.horse_list and hasattr(
            self.horse_list, "_calculate_age"
        ):  # Ensure horse_list is not None
            age_str = self.horse_list._calculate_age(horse.date_of_birth)  # type: ignore

        owner_name = self._get_display_owner_name(horse)
        location_name_val = self._get_display_location_name(
            horse
        )  # Use the corrected variable name
        self.horse_info_line.setText(
            f"Acct: {horse.account_number or 'N/A'} | 👥 {owner_name} | Breed: {horse.breed or 'N/A'} | Color: {horse.color or 'N/A'} | Sex: {horse.sex or 'N/A'} | Age: {age_str} | 📍 {location_name_val}"
        )

    def load_horse_details(self, horse_id: int):  # Structure from user's v1.7.34
        self.logger.info(f"load_horse_details: START for horse ID: {horse_id}")
        horse = self.horse_controller.get_horse_by_id(horse_id)
        self.logger.debug(
            f"load_horse_details: Fetched horse object: {'Exists' if horse else 'None'}"
        )

        # Logging details from the fetched horse object
        if horse:
            self.logger.debug(
                f"load_horse_details: Horse {horse_id} - current_location_id: {horse.current_location_id}"
            )
            if hasattr(horse, "location") and horse.location:
                self.logger.debug(
                    f"load_horse_details: Horse {horse_id} - location: ID {horse.location.location_id}, Name: {horse.location.location_name}"
                )
            if (
                hasattr(horse, "owners")
                and horse.owners
                and len(horse.owners) > 0
                and hasattr(horse.owners[0], "owner")
                and horse.owners[0].owner
            ):
                self.logger.debug(
                    f"load_horse_details: Horse {horse_id} - first owner farm: {horse.owners[0].owner.farm_name}"
                )

        if not horse:
            self.show_error("Error", f"Could not load horse ID {horse_id}.")
            self.display_empty_state()
            self.logger.info("load_horse_details: FINISHED (horse not found)")
            return

        self.current_horse = horse
        self._is_new_mode = False
        self._has_changes_in_active_tab = (
            False  # Reset this flag when a new horse is loaded
        )

        if hasattr(self, "horse_title") and self.horse_title:
            self.horse_title.setText(horse.horse_name or "Unnamed Horse")

        self._update_horse_info_line(
            horse
        )  # This should now work due to fixes in helpers

        if self.basic_info_tab:
            self.logger.debug("load_horse_details: Populating BasicInfoTab")
            self.basic_info_tab.populate_form_data(horse)
        if self.owners_tab:
            self.logger.debug("load_horse_details: Loading OwnersTab")
            self.owners_tab.load_owners_for_horse(horse)
        if self.location_tab:
            self.logger.debug("load_horse_details: Loading LocationTab")
            self.location_tab.load_location_for_horse(horse)

        self.display_details_state()
        self.update_main_action_buttons_state()
        self.update_status(f"Viewing: {horse.horse_name or 'Unnamed Horse'}")
        self.logger.info(f"load_horse_details: FINISHED for horse ID: {horse_id}")

    def add_new_horse(self):  # Structure from user's v1.7.34
        self.logger.info("add_new_horse: START")
        if self._has_changes_in_active_tab and not self.show_question(
            "Unsaved Changes", "Discard current changes and start new horse record?"
        ):
            self.logger.info("add_new_horse: Aborted due to unsaved changes.")
            return

        self._is_new_mode = True
        self._has_changes_in_active_tab = False
        self.current_horse = None

        if self.horse_list and self.horse_list.selectionModel():
            self.logger.debug("add_new_horse: Clearing horse list selection.")
            self.horse_list.blockSignals(True)
            self.horse_list.selectionModel().clear()
            self.horse_list.blockSignals(False)

        if self.basic_info_tab and hasattr(self.basic_info_tab, "set_new_mode"):
            self.logger.debug("add_new_horse: Setting BasicInfoTab to new mode.")
            self.basic_info_tab.set_new_mode(is_new=True)
        else:
            self.logger.error("add_new_horse: BasicInfoTab missing or no set_new_mode.")
            self.show_error("UI Error", "Details form unavailable.")
            self._is_new_mode = False
            return

        if self.owners_tab:
            self.logger.debug("add_new_horse: Clearing OwnersTab.")
            self.owners_tab.load_owners_for_horse(None)
        if self.location_tab:
            self.logger.debug("add_new_horse: Clearing LocationTab.")
            self.location_tab.load_location_for_horse(None)

        if hasattr(self, "horse_title") and self.horse_title:
            self.horse_title.setText("New Horse Record")
        self._update_horse_info_line(None)
        self.display_details_state()

        if self.tab_widget and self.basic_info_tab:
            self.logger.debug("add_new_horse: Setting current tab to BasicInfoTab.")
            self.tab_widget.setCurrentWidget(self.basic_info_tab)

        self.update_main_action_buttons_state()
        self.update_status("Enter details for new horse.")
        self.logger.info("add_new_horse: FINISHED")

    def _on_tab_data_modified(self):  # Structure from user's v1.7.34
        if (
            self.basic_info_tab
            and hasattr(self.basic_info_tab, "horse_name_input")
            and self.basic_info_tab.horse_name_input
            and not self.basic_info_tab.horse_name_input.isReadOnly()
        ):  # type: ignore
            if not self._has_changes_in_active_tab:
                self._has_changes_in_active_tab = True
                self.logger.debug("_on_tab_data_modified: Change detected. Flag set.")
            self.update_main_action_buttons_state()
        else:
            self.logger.debug(
                "_on_tab_data_modified: Signal received, but form read-only or input missing."
            )

    def _on_owner_association_changed(
        self, message: str
    ):  # Structure from user's v1.7.34
        self.logger.info(f"_on_owner_association_changed: {message}")
        self.update_status(message)
        if self.current_horse and self.current_horse.horse_id is not None:
            self.load_horse_details(
                self.current_horse.horse_id
            )  # Reload to reflect changes
        self.update_main_action_buttons_state()

    def handle_toggle_active_status_from_tab(
        self, new_active_status_requested: bool
    ):  # Structure from user's v1.7.34
        self.logger.info(
            f"handle_toggle_active_status_from_tab: Requested: {new_active_status_requested}"
        )
        if self.current_horse:
            self.handle_toggle_active_status()  # This method will prompt and act
        else:
            self.logger.warning(
                "handle_toggle_active_status_from_tab: No current horse."
            )

    def setup_footer(self, parent_layout):  # Structure from user's v1.7.34
        self.logger.debug("setup_footer: START")
        self.status_bar = QStatusBar()
        self.status_bar.setFixedHeight(28)
        self.status_bar.setStyleSheet(
            f"""QStatusBar{{background-color:{DARK_HEADER_FOOTER};color:{DARK_TEXT_SECONDARY};border:none;border-top:1px solid {DARK_BORDER};padding:0 15px;font-size:11px;}}QStatusBar::item{{border:none;}}QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;font-size:11px;}}"""
        )
        parent_layout.addWidget(self.status_bar)
        self.status_label = QLabel("Ready")
        self.footer_horse_count_label = QLabel("Showing 0 of 0 horses")
        self.shortcut_label = QLabel("F5=Refresh | Ctrl+N=New | Ctrl+S=Save")
        self.status_bar.addWidget(self.status_label, 1)  # Stretch factor
        self.status_bar.addPermanentWidget(self.footer_horse_count_label)
        separator_label = QLabel(" | ")
        separator_label.setStyleSheet(
            f"color:{DARK_BORDER};background:transparent;margin:0 5px;"
        )
        self.status_bar.addPermanentWidget(separator_label)
        self.status_bar.addPermanentWidget(self.shortcut_label)
        self.logger.debug("setup_footer: FINISHED")

    def save_changes(
        self,
    ):  # Structure from user's v1.7.34, with simplified reselection from v1.7.36
        self.logger.info("save_changes: START")
        if not self.basic_info_tab:
            self.logger.error("save_changes: BasicInfoTab missing.")
            self.show_error("Save Error", "UI component missing.")
            return

        if not self._has_changes_in_active_tab and not self._is_new_mode:
            self.update_status("No changes to save.")
            if (
                hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing  # type: ignore
                and hasattr(self.basic_info_tab, "set_form_read_only")
            ):
                self.basic_info_tab.set_form_read_only(True)  # type: ignore
                self.update_main_action_buttons_state()
            return

        horse_data = self.basic_info_tab.get_data_from_form()
        if (
            self.current_horse
            and self.current_horse.current_location_id is not None
            and not self._is_new_mode
        ):
            horse_data["current_location_id"] = self.current_horse.current_location_id
        elif "current_location_id" not in horse_data:
            horse_data["current_location_id"] = None

        self.logger.debug(
            f"save_changes: Validating data. New: {self._is_new_mode}. Data: {horse_data}"
        )
        is_valid, errors = self.horse_controller.validate_horse_data(
            horse_data,
            is_new=self._is_new_mode,
            horse_id_to_check_for_unique=(
                self.current_horse.horse_id
                if not self._is_new_mode and self.current_horse
                else None
            ),
        )
        if not is_valid:
            self.show_warning(
                "Validation Error", "Correct errors:\n\n- " + "\n- ".join(errors)
            )
            self.logger.info("save_changes: Validation failed.")
            return

        try:
            saved_id: Optional[int] = None
            success: bool = False
            msg: str = ""
            if not self._is_new_mode and self.current_horse:
                self.logger.debug(
                    f"save_changes: Updating horse ID {self.current_horse.horse_id}"
                )
                success, msg = self.horse_controller.update_horse(
                    self.current_horse.horse_id, horse_data, self.current_user
                )
                if success:
                    saved_id = self.current_horse.horse_id
            else:
                self.logger.debug("save_changes: Creating new horse")
                success, msg, new_horse_obj = self.horse_controller.create_horse(
                    horse_data, self.current_user
                )
                if success and new_horse_obj:
                    saved_id = new_horse_obj.horse_id
                elif success and not new_horse_obj:
                    self.logger.error(
                        f"save_changes: Horse creation success={success}, but new_horse_obj is None. Msg: {msg}"
                    )

            if success:
                self.logger.info(f"save_changes: Save successful. Message: {msg}")
                self.show_info("Success", msg)
                self._has_changes_in_active_tab = False
                if self.basic_info_tab and hasattr(
                    self.basic_info_tab, "mark_as_saved"
                ):
                    self.basic_info_tab.mark_as_saved()

                if (
                    self._is_new_mode and saved_id is not None
                ):  # If it was a new horse that was saved
                    newly_saved_horse = self.horse_controller.get_horse_by_id(saved_id)
                    if newly_saved_horse:
                        self.current_horse = (
                            newly_saved_horse  # Set current horse to the new one
                        )
                        self._is_new_mode = False  # No longer in "new mode"
                        self.logger.debug(
                            f"save_changes: New horse {saved_id} set as current."
                        )
                    else:
                        self.logger.error(
                            f"save_changes: Failed to re-fetch new horse {saved_id}."
                        )
                        self.display_empty_state()  # Go to empty state as we lost context
                        self.load_horses()  # Refresh list
                        return

                self.load_horses()  # This will repopulate and attempt reselection

                # Ensure the saved_id is actually selected, load_horses reselection logic can be complex
                if saved_id is not None and self.horse_list:
                    self.logger.debug(
                        f"save_changes: Verifying selection for horse ID {saved_id} in list after load_horses."
                    )
                    found_and_selected = False
                    for i in range(self.horse_list.count()):
                        item = self.horse_list.item(i)
                        if item and item.data(Qt.ItemDataRole.UserRole) == saved_id:
                            if (
                                self.horse_list.currentRow() != i
                            ):  # Only set if not already selected
                                self.horse_list.setCurrentRow(
                                    i
                                )  # This should trigger on_selection_changed
                            else:  # If already selected, ensure details are loaded for this ID
                                self.load_horse_details(saved_id)
                            found_and_selected = True
                            self.logger.debug(
                                f"save_changes: Verified/reselected row {i} for ID {saved_id}."
                            )
                            break
                    if not found_and_selected:
                        self.logger.debug(
                            f"save_changes: Horse ID {saved_id} not found in list after save/refresh for final reselection attempt."
                        )
                        if self.horse_list.count() > 0:
                            self.horse_list.setCurrentRow(0)  # Select first item
                        else:
                            self.display_empty_state()
                elif (
                    self.horse_list and self.horse_list.count() > 0
                ):  # No saved_id but list has items
                    self.horse_list.setCurrentRow(0)
                elif (
                    not self.horse_list or self.horse_list.count() == 0
                ):  # List is empty
                    self.display_empty_state()

            else:
                self.logger.error(f"save_changes: Save failed. Message: {msg}")
                self.show_error("Save Failed", msg or "Unknown error.")
        except Exception as e:
            self.logger.error(f"save_changes: Exception: {e}", exc_info=True)
            self.show_error("Save Error", f"Unexpected error: {e}")
        self.logger.info("save_changes: FINISHED")

    def populate_horse_list(self):  # Structure from user's v1.7.34
        self.logger.debug("populate_horse_list: START")
        if not hasattr(self, "horse_list") or not self.horse_list:
            self.logger.error("populate_horse_list: horse_list widget not ready.")
            return

        current_selected_id = None
        if self.horse_list.currentItem():
            current_selected_id = self.horse_list.currentItem().data(
                Qt.ItemDataRole.UserRole
            )

        self.logger.debug(
            f"populate_horse_list: Clearing list. Previously selected ID: {current_selected_id}"
        )
        self.horse_list.clear()

        for horse_obj in self.horses_list_data:  # Changed 'horse' to 'horse_obj'
            item = QListWidgetItem()
            item_widget = self.horse_list.create_horse_list_item_widget(horse_obj)
            item.setSizeHint(item_widget.sizeHint())
            item.setData(Qt.ItemDataRole.UserRole, horse_obj.horse_id)
            self.horse_list.addItem(item)
            self.horse_list.setItemWidget(item, item_widget)

        self.logger.debug(
            f"populate_horse_list: List populated with {len(self.horses_list_data)} items."
        )

        if hasattr(self, "footer_horse_count_label") and self.footer_horse_count_label:
            total_horses_in_db = len(
                self.horse_controller.search_horses(status="all", search_term="")
            )
            self.footer_horse_count_label.setText(
                f"Showing {self.horse_list.count()} of {total_horses_in_db} total horses"
            )

        if (
            current_selected_id is not None
        ):  # Try to reselect previous item if it still exists
            for i in range(self.horse_list.count()):
                if (
                    self.horse_list.item(i).data(Qt.ItemDataRole.UserRole)
                    == current_selected_id
                ):
                    self.horse_list.setCurrentRow(i)
                    self.logger.debug(
                        f"populate_horse_list: Reselected row {i} for ID {current_selected_id}"
                    )
                    break
        self.logger.debug("populate_horse_list: FINISHED")

    def load_horses(
        self,
    ):  # MODIFIED: Only the setCurrentRow line was changed from v1.7.34
        self.logger.debug("load_horses: START")
        try:
            if (
                not hasattr(self, "search_input")
                or self.search_input is None
                or not hasattr(self, "active_only_radio")
                or self.active_only_radio is None
                or not hasattr(self, "all_horses_radio")
                or self.all_horses_radio is None
                or not hasattr(self, "deactivated_radio")
                or self.deactivated_radio is None
            ):
                self.logger.error("load_horses: Search/filter UI elements not ready.")
                return

            search_term = self.search_input.text()
            status_filter = "active"
            if self.all_horses_radio.isChecked():
                status_filter = "all"
            elif self.deactivated_radio.isChecked():
                status_filter = "inactive"

            self.logger.info(
                f"load_horses: Filter status: '{status_filter}', Search: '{search_term}'"
            )

            previously_selected_id = None
            # Try to preserve selection across reloads
            if (
                self.current_horse and not self._is_new_mode
            ):  # If a horse is loaded and we are not in new mode
                previously_selected_id = self.current_horse.horse_id
            elif (
                self.horse_list and self.horse_list.currentItem()
            ):  # Fallback to current list selection
                current_item_data = self.horse_list.currentItem().data(
                    Qt.ItemDataRole.UserRole
                )
                if isinstance(current_item_data, int):
                    previously_selected_id = current_item_data

            self.logger.debug(
                f"load_horses: Previously selected ID to try and reselect: {previously_selected_id}"
            )

            self.horses_list_data = self.horse_controller.search_horses(
                search_term=search_term, status=status_filter
            )
            self.logger.debug(
                f"load_horses: {len(self.horses_list_data)} horses found by controller."
            )

            self.populate_horse_list()  # Clears and repopulates the QListWidget

            if not self.horses_list_data:
                self.logger.debug(
                    "load_horses: No horses found, displaying empty state."
                )
                self.display_empty_state()  # This will also update buttons via its own logic
                # self.update_main_action_buttons_state() # display_empty_state should handle this
                self.logger.debug("load_horses: FINISHED (no horses)")
                return

            reselected_successfully = False
            if previously_selected_id is not None and self.horse_list:
                for i in range(self.horse_list.count()):
                    item = self.horse_list.item(i)
                    if (
                        item
                        and item.data(Qt.ItemDataRole.UserRole)
                        == previously_selected_id
                    ):
                        self.logger.debug(
                            f"load_horses: Attempting to reselect ID {previously_selected_id} at row {i}."
                        )
                        self.horse_list.setCurrentRow(
                            i
                        )  # Corrected: removed invalid second argument
                        # on_selection_changed will be triggered if row is different or if it's the first selection
                        reselected_successfully = True
                        self.logger.debug(
                            "load_horses: Reselected row. on_selection_changed will handle details load."
                        )
                        break

            if (
                not reselected_successfully
                and self.horse_list
                and self.horse_list.count() > 0
            ):
                self.logger.debug(
                    "load_horses: No reselection or previous ID not found, selecting row 0."
                )
                self.horse_list.setCurrentRow(0)  # Trigger selection of the first item
            elif (
                not self.horse_list or self.horse_list.count() == 0
            ):  # Should be caught by earlier check
                self.logger.debug(
                    "load_horses: List is empty after populate, displaying empty state."
                )
                self.display_empty_state()

            # If after all this, no item is current (e.g. list was empty and then populated but setCurrentRow(0) failed or wasn't called)
            # ensure buttons are in a sensible state. on_selection_changed should handle most of this.
            if not (self.horse_list and self.horse_list.currentItem()):
                self.update_main_action_buttons_state()  # Ensure buttons are updated based on no selection

        except Exception as e:
            self.logger.error(f"load_horses: ERROR: {e}", exc_info=True)
            self.show_error("Load Horses Error", f"{e}")
            self.horses_list_data = []  # Clear data on error
            if hasattr(self, "horse_list") and self.horse_list:
                self.populate_horse_list()  # Show empty list
            self.display_empty_state()  # Go to empty state
        self.logger.debug("load_horses: FINISHED")

    def on_search_text_changed(self):  # Structure from user's v1.7.34
        if hasattr(self.search_timer, "isActive") and self.search_timer.isActive():  # type: ignore
            self.search_timer.stop()  # type: ignore
        self.search_timer.start(350)  # type: ignore

    def perform_search(self):  # Structure from user's v1.7.34
        self.logger.debug(
            f"perform_search: Term: '{self.search_input.text() if self.search_input else ''}'"
        )
        self.load_horses()

    def on_filter_changed(self):  # Structure from user's v1.7.34
        sender_widget = self.sender()
        if isinstance(sender_widget, QRadioButton) and sender_widget.isChecked():
            self.logger.info(f"on_filter_changed: To {sender_widget.text()}")
            self.load_horses()

    def on_selection_changed(self):  # Structure from user's v1.7.34
        self.logger.debug("on_selection_changed: START")
        if not self.horse_list:
            self.logger.warning("on_selection_changed: horse_list is None.")
            return

        selected_items = self.horse_list.selectedItems()
        if not selected_items:
            self.logger.debug("on_selection_changed: No items selected.")
            if not self._is_new_mode and not self._has_changes_in_active_tab:
                self.display_empty_state()
            return

        selected_item = selected_items[0]
        newly_selected_horse_id = selected_item.data(Qt.ItemDataRole.UserRole)
        self.logger.debug(
            f"on_selection_changed: Newly selected ID: {newly_selected_horse_id}"
        )

        current_horse_id = self.current_horse.horse_id if self.current_horse else None
        self.logger.debug(
            f"on_selection_changed: Current horse ID: {current_horse_id}, New mode: {self._is_new_mode}, Has changes: {self._has_changes_in_active_tab}"
        )

        if (self._has_changes_in_active_tab or self._is_new_mode) and (
            newly_selected_horse_id != current_horse_id
            or (self._is_new_mode and newly_selected_horse_id is not None)
        ):  # Also prompt if in new mode and any item is clicked
            self.logger.debug(
                "on_selection_changed: Unsaved changes detected. Prompting user."
            )
            if not self.show_question(
                "Unsaved Changes",
                f"Discard unsaved {'new horse record' if self._is_new_mode else 'changes to current horse'}?",
            ):
                self.logger.debug(
                    "on_selection_changed: User chose NOT to discard. Reverting selection."
                )
                self.horse_list.blockSignals(True)
                if current_horse_id is not None and not self._is_new_mode:
                    for i in range(self.horse_list.count()):
                        if (
                            self.horse_list.item(i).data(Qt.ItemDataRole.UserRole)
                            == current_horse_id
                        ):
                            self.horse_list.setCurrentRow(i)
                            break
                else:  # Was in new_mode or no current_horse_id to revert to
                    self.horse_list.clearSelection()  # Deselect the newly clicked item
                self.horse_list.blockSignals(False)
                self.logger.debug("on_selection_changed: FINISHED (reverted selection)")
                return
            # User chose to discard changes
            self.logger.debug("on_selection_changed: User chose to discard changes.")
            self._has_changes_in_active_tab = False
            self._is_new_mode = False
            self.logger.debug(
                "on_selection_changed: Flags reset (_has_changes_in_active_tab, _is_new_mode)."
            )
            # Fall through to load the newly selected horse

        if newly_selected_horse_id is not None:
            if (
                newly_selected_horse_id == current_horse_id and not self._is_new_mode
            ):  # If same horse re-selected and not after discarding a new entry
                self.logger.debug(
                    f"on_selection_changed: Same horse ID ({current_horse_id}) re-selected. Ensuring read-only state."
                )
                if (
                    self.basic_info_tab
                    and hasattr(self.basic_info_tab, "_is_editing")
                    and self.basic_info_tab._is_editing
                    and not self._has_changes_in_active_tab  # type: ignore
                    and hasattr(self.basic_info_tab, "set_form_read_only")
                ):
                    self.basic_info_tab.set_form_read_only(True)  # type: ignore
                self.update_main_action_buttons_state()
                self.logger.debug(
                    "on_selection_changed: FINISHED (same horse, no load unless it was new mode that got discarded)"
                )
                return
            self.load_horse_details(newly_selected_horse_id)
        else:  # newly_selected_horse_id is None (e.g. list cleared, no item selected)
            self.logger.debug(
                "on_selection_changed: newly_selected_horse_id is None, displaying empty state."
            )
            self.display_empty_state()
        self.logger.debug("on_selection_changed: FINISHED")

    def edit_selected_horse(self):  # Structure from user's v1.7.34
        self.logger.debug("edit_selected_horse: START")
        if self.current_horse and not self._is_new_mode:
            if not self.tab_widget:
                self.logger.error("edit_selected_horse: Tab widget missing.")
                self.show_error("UI Error", "Tabs unavailable.")
                return

            current_tab_widget = self.tab_widget.currentWidget()
            self.logger.debug(
                f"edit_selected_horse: Current tab: {current_tab_widget.objectName() if current_tab_widget else 'None'}"
            )

            if (
                current_tab_widget == self.basic_info_tab
                and self.basic_info_tab
                and hasattr(self.basic_info_tab, "set_edit_mode")
            ):
                self.logger.debug(
                    "edit_selected_horse: Setting BasicInfoTab to edit mode."
                )
                self.basic_info_tab.set_edit_mode(True)
                self._has_changes_in_active_tab = (
                    False  # Reset flag, changes will be tracked by tab
                )
            elif hasattr(
                current_tab_widget, "set_edit_mode"
            ):  # For other tabs if they implement it
                self.logger.debug(
                    f"edit_selected_horse: Setting current tab {current_tab_widget.objectName()} to edit mode."
                )
                current_tab_widget.set_edit_mode(True)  # type: ignore
                self._has_changes_in_active_tab = False
            else:  # Default to BasicInfoTab if current tab doesn't support edit_mode
                self.logger.info(
                    f"edit_selected_horse: Current tab does not support direct edit. Defaulting to BasicInfoTab edit mode."
                )
                if self.basic_info_tab and hasattr(
                    self.basic_info_tab, "set_edit_mode"
                ):
                    self.basic_info_tab.set_edit_mode(True)
                    self._has_changes_in_active_tab = False

            self.update_main_action_buttons_state()
            self.update_status(
                f"Editing details for: {self.current_horse.horse_name or 'Unnamed Horse'}"
            )
        elif self._is_new_mode:
            self.show_info(
                "Information", "Currently adding new. Save or discard first."
            )
        else:
            self.show_info("Edit Horse", "Select a horse to edit.")
        self.logger.debug("edit_selected_horse: FINISHED")

    def refresh_data(self):  # Structure from user's v1.7.34
        self.logger.debug("refresh_data: START")
        if (
            self._has_changes_in_active_tab or self._is_new_mode
        ) and not self.show_question("Unsaved Changes", "Discard and refresh?"):
            self.logger.debug("refresh_data: Aborted due to unsaved changes.")
            return

        self.logger.info("refresh_data: Proceeding with refresh.")
        self._has_changes_in_active_tab = False
        self._is_new_mode = False
        self.load_horses()  # This will reload the list and reselect or select first
        self.update_status("Data refreshed.")
        self.logger.debug("refresh_data: FINISHED")

    def show_help(self):  # Structure from user's v1.7.34
        self.logger.debug("show_help: Displaying help message.")
        QMessageBox.information(
            self,
            "EDSI Help",
            "Horse Management Screen:\n\n- Use the list on the left to select a horse.\n- Click 'Add Horse' or Ctrl+N to create a new record.\n- Click 'Edit Selected' to modify the current horse's basic info.\n- Tabs on the right show different aspects of the horse's data.\n- Use radio buttons to filter the list by status.\n- Search box filters by name, account, chip, etc.\n- F5 to refresh. Ctrl+S to save (when editing). Esc to discard (when editing).",
        )

    def display_details_state(self):  # Structure from user's v1.7.34
        self.logger.debug("display_details_state: START")
        if hasattr(self, "empty_frame") and self.empty_frame:
            self.empty_frame.hide()
        if (
            hasattr(self, "horse_details_content_widget")
            and self.horse_details_content_widget
        ):
            self.horse_details_content_widget.show()
        self.logger.debug("display_details_state: FINISHED")

    def update_status(self, message, timeout=4000):  # Structure from user's v1.7.34
        if hasattr(self, "status_label") and self.status_label:
            self.status_label.setText(message)
            if timeout > 0:
                QTimer.singleShot(
                    timeout, lambda: self.clear_status_if_matches(message)
                )

    def clear_status_if_matches(
        self, original_message
    ):  # Structure from user's v1.7.34
        if (
            hasattr(self, "status_label")
            and self.status_label
            and self.status_label.text() == original_message
        ):
            self.status_label.setText("Ready")

    def handle_toggle_active_status(self):  # Structure from user's v1.7.34
        self.logger.debug("handle_toggle_active_status: START")
        if not self.current_horse:
            self.logger.warning("handle_toggle_active_status: No current horse.")
            return

        action_verb = "activate" if not self.current_horse.is_active else "deactivate"
        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        self.logger.debug(
            f"handle_toggle_active_status: Prompting to {action_verb} '{horse_name_display}'."
        )

        if self.show_question(
            f"Confirm {action_verb.capitalize()}",
            f"Are you sure you want to {action_verb} horse '{horse_name_display}'?",
        ):
            self.logger.info(
                f"handle_toggle_active_status: User confirmed. Calling controller to {action_verb}."
            )
            controller_method = (
                self.horse_controller.activate_horse
                if not self.current_horse.is_active
                else self.horse_controller.deactivate_horse
            )
            success, message = controller_method(
                self.current_horse.horse_id, self.current_user
            )

            if success:
                self.logger.info(
                    f"handle_toggle_active_status: {action_verb.capitalize()} successful. {message}"
                )
                self.show_info("Status Changed", message)
                # Reload details for the current horse to reflect status change in tabs
                self.load_horse_details(self.current_horse.horse_id)
                self.load_horses()  # Refresh the list (might change position or filter out)
                # BasicInfoTab might also need its active status checkbox updated if it's separate
                if self.basic_info_tab and hasattr(
                    self.basic_info_tab, "populate_form_data"
                ):
                    self.basic_info_tab.populate_form_data(
                        self.current_horse
                    )  # Re-populate to show new status

            else:
                self.logger.error(
                    f"handle_toggle_active_status: {action_verb.capitalize()} failed. {message}"
                )
                self.show_error(f"{action_verb.capitalize()} Failed", message)
        else:
            self.logger.info("handle_toggle_active_status: User cancelled.")
        self.logger.debug("handle_toggle_active_status: FINISHED")

    def handle_logout_request_from_menu(self):  # Structure from user's v1.7.34
        self.logger.info(
            f"handle_logout_request_from_menu: User '{self.current_user}' logout."
        )
        self.exit_requested.emit()

    def keyPressEvent(self, event: QKeyEvent):  # Structure from user's v1.7.34
        key = event.key()
        modifiers = QApplication.keyboardModifiers()
        self.logger.debug(f"keyPressEvent: Key {key}, Modifiers {modifiers}")

        if key == Qt.Key.Key_F5:
            self.refresh_data()
        elif modifiers == Qt.KeyboardModifier.ControlModifier and key == Qt.Key.Key_N:
            if (
                hasattr(self, "add_horse_btn")
                and self.add_horse_btn
                and self.add_horse_btn.isEnabled()
            ):
                self.add_new_horse()
        elif modifiers == Qt.KeyboardModifier.ControlModifier and key == Qt.Key.Key_S:
            if (
                self.tab_widget
                and self.basic_info_tab
                and self.tab_widget.currentWidget() == self.basic_info_tab
                and hasattr(self.basic_info_tab, "save_btn")
                and self.basic_info_tab.save_btn.isEnabled()
            ):  # type: ignore
                self.logger.info("keyPressEvent: Ctrl+S triggering BasicInfoTab save.")
                self.basic_info_tab.save_requested.emit()
            else:
                self.logger.info(
                    "keyPressEvent: Ctrl+S conditions not met for BasicInfoTab save."
                )
        elif key == Qt.Key.Key_F1:
            self.show_help()
        elif key == Qt.Key.Key_Escape:
            active_modal_widget = QApplication.activeModalWidget()
            if active_modal_widget and isinstance(active_modal_widget, QDialog):
                self.logger.debug(
                    "keyPressEvent: Escape rejecting active modal dialog."
                )
                active_modal_widget.reject()
            elif self._has_changes_in_active_tab or self._is_new_mode:
                self.logger.debug("keyPressEvent: Escape triggering discard_changes.")
                self.discard_changes()
            elif (
                self.basic_info_tab
                and hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing
            ):  # type: ignore
                self.logger.debug(
                    "keyPressEvent: Escape reverting BasicInfoTab to read-only."
                )
                self.discard_changes()  # This will set form to read-only if no data changes
            else:
                super().keyPressEvent(event)
        else:
            super().keyPressEvent(event)

    def setup_connections(self):  # Structure from user's v1.7.34
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_CONNECTIONS START ---")
        if hasattr(self, "add_horse_btn") and self.add_horse_btn:
            self.add_horse_btn.clicked.connect(self.add_new_horse)
        if hasattr(self, "edit_horse_btn") and self.edit_horse_btn:
            self.edit_horse_btn.clicked.connect(self.edit_selected_horse)
        if hasattr(self, "refresh_btn") and self.refresh_btn:
            self.refresh_btn.clicked.connect(self.refresh_data)
        if hasattr(self, "help_btn") and self.help_btn:
            self.help_btn.clicked.connect(self.show_help)
        if hasattr(self, "setup_icon_btn") and self.setup_icon_btn:
            self.setup_icon_btn.clicked.connect(self.setup_requested.emit)

        if hasattr(self, "active_only_radio") and self.active_only_radio:
            self.active_only_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "all_horses_radio") and self.all_horses_radio:
            self.all_horses_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "deactivated_radio") and self.deactivated_radio:
            self.deactivated_radio.toggled.connect(self.on_filter_changed)

        if hasattr(self, "search_input") and self.search_input:
            self.search_input.textChanged.connect(self.on_search_text_changed)
        if hasattr(self, "horse_list") and self.horse_list:
            self.horse_list.itemSelectionChanged.connect(self.on_selection_changed)

        if self.basic_info_tab:
            self.logger.info("Connecting BasicInfoTab signals.")
            if hasattr(self.basic_info_tab, "data_modified"):
                self.basic_info_tab.data_modified.connect(self._on_tab_data_modified)
            if hasattr(self.basic_info_tab, "save_requested"):
                self.basic_info_tab.save_requested.connect(self.save_changes)
            if hasattr(self.basic_info_tab, "discard_requested"):
                self.basic_info_tab.discard_requested.connect(self.discard_changes)
            if hasattr(self.basic_info_tab, "toggle_active_requested"):
                self.basic_info_tab.toggle_active_requested.connect(
                    self.handle_toggle_active_status_from_tab
                )
        else:
            self.logger.warning(
                "BasicInfoTab is None, its signals cannot be connected."
            )

        if self.owners_tab:
            self.logger.info("Connecting OwnersTab signals.")
            if hasattr(self.owners_tab, "owner_association_changed"):
                self.owners_tab.owner_association_changed.connect(
                    self._on_owner_association_changed
                )
        else:
            self.logger.warning("OwnersTab is None, its signals cannot be connected.")

        if self.location_tab:
            self.logger.info("Connecting LocationTab signals.")
            if hasattr(self.location_tab, "location_assignment_changed"):
                self.location_tab.location_assignment_changed.connect(
                    self._handle_location_assignment_change
                )
        else:
            self.logger.warning("LocationTab is None, its signals cannot be connected.")

        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_CONNECTIONS END ---")

--- End File: views/horse/horse_unified_management.py ---

--- File: views/admin/dialogs/add_edit_charge_code_dialog.py ---
# views/admin/dialogs/add_edit_charge_code_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Dialog
Version: 1.1.10
Purpose: Dialog for creating and editing charge codes.
         - Implemented auto-uppercase for the 'Alt. Code' field.
Last Updated: June 3, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.10 (2025-06-03):
    - Added a slot `_on_alt_code_text_edited` connected to the `textEdited`
      signal of `alt_code_input` to automatically convert input to uppercase
      as the user types.
    - Imported `Slot` from `PySide6.QtCore`.
- v1.1.9 (2025-06-03):
    - Added `QHBoxLayout` to imports from `PySide6.QtWidgets` to resolve
      a NameError in `_setup_ui` when creating `status_layout`.
- v1.1.8 (2025-06-03):
    - Made 'is_active_checkbox' and 'taxable_checkbox' disabled (read-only).
    - Removed 'is_active' and 'taxable' from the `get_data()` method.
- v1.1.7 (2025-06-03):
    - Removed 'detail_category_combo' for a 2-level hierarchy.
    - Updated category selection logic in `_populate_fields` and `get_data`.
- v1.1.6 (2025-06-02):
    - Added `QTimer` import.
# ... (previous changelog entries)
"""

import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QTextEdit,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QHBoxLayout,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer, Slot  # MODIFIED: Added Slot

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCode as ChargeCodeModel
from models import ChargeCodeCategory

from config.app_config import AppConfig
import os

try:
    current_script_path_for_assets = os.path.dirname(os.path.abspath(__file__))
    project_root_for_assets = os.path.abspath(
        os.path.join(current_script_path_for_assets, "..", "..", "..")
    )
    assets_path = os.path.join(project_root_for_assets, "assets", "icons")
    if not os.path.exists(
        os.path.join(assets_path, "checkmark_light.svg")
    ):  # Basic check
        assets_path = "assets/icons"
except Exception:
    assets_path = "assets/icons"


from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        charge_code: Optional[ChargeCodeModel] = None,
    ):
        # ... (__init__ remains largely unchanged from v1.1.9) ...
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.charge_code = charge_code
        self.is_edit_mode = charge_code is not None

        self.code_input: Optional[QLineEdit] = None
        self.alt_code_input: Optional[QLineEdit] = None
        self.description_input: Optional[QTextEdit] = None
        self.main_category_combo: Optional[QComboBox] = None
        self.sub_category_combo: Optional[QComboBox] = None
        self.standard_charge_input: Optional[QDoubleSpinBox] = None
        self.taxable_checkbox: Optional[QCheckBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Charge Code")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_main_categories()

        if self.is_edit_mode and self.charge_code:
            self._populate_fields()
        else:
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(True)
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(False)
            if self.sub_category_combo:
                self.sub_category_combo.setEnabled(False)

        if self.is_active_checkbox:
            self.is_active_checkbox.setEnabled(False)
        if self.taxable_checkbox:
            self.taxable_checkbox.setEnabled(False)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        # ... (method remains unchanged from v1.1.9) ...
        checkmark_path = os.path.join(assets_path, "checkmark_light.svg").replace(
            os.sep, "/"
        )
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; min-height: 20px; }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QLineEdit:disabled, QComboBox:disabled, QTextEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER}; }}
            QLineEdit[readOnly="true"] {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
            QCheckBox::indicator:disabled {{ background-color: {DARK_INPUT_FIELD_BACKGROUND}; border: 1px solid {DARK_TEXT_TERTIARY}; }}
            QCheckBox::indicator:checked:disabled {{ background-color: {DARK_PRIMARY_ACTION}; border: 1px solid {DARK_PRIMARY_ACTION}; image: url({checkmark_path}); }}
            QCheckBox:disabled {{ color: {DARK_TEXT_SECONDARY}; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        # ... (method remains unchanged from v1.1.9) ...
        return f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;}} QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"

    def _setup_palette(self):
        # ... (method remains unchanged from v1.1.9) ...
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        # ... (method remains unchanged from v1.1.9) ...
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        # ... (UI setup for other fields remains unchanged from v1.1.9) ...
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)
        self.code_input = QLineEdit()
        self.code_input.setPlaceholderText("Unique code (e.g., EXAM01)")
        self.alt_code_input = QLineEdit()
        self.alt_code_input.setPlaceholderText("Alternative code (optional)")
        # MODIFIED: Connect textEdited signal for alt_code_input
        if self.alt_code_input:
            self.alt_code_input.textEdited.connect(self._on_alt_code_text_edited)

        self.main_category_combo = QComboBox()
        self.main_category_combo.setPlaceholderText("Select Main Category")
        self.sub_category_combo = QComboBox()
        self.sub_category_combo.setPlaceholderText("Select Sub-Category")
        self.description_input = QTextEdit()
        self.description_input.setPlaceholderText("Detailed description")
        self.description_input.setFixedHeight(70)
        self.standard_charge_input = QDoubleSpinBox()
        self.standard_charge_input.setDecimals(2)
        self.standard_charge_input.setRange(0.00, 99999.99)
        self.standard_charge_input.setPrefix("$ ")
        self.standard_charge_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.taxable_checkbox = QCheckBox("Taxable")
        self.taxable_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )
        self.is_active_checkbox = QCheckBox("Active")
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Alt. Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.alt_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Main Category*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.main_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Sub-Category:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.sub_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Standard Charge*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.standard_charge_input, row, 1)
        status_layout = QHBoxLayout()
        status_layout.addWidget(self.taxable_checkbox)
        status_layout.addSpacing(20)
        status_layout.addWidget(self.is_active_checkbox)
        status_layout.addStretch()
        grid_layout.addLayout(
            status_layout,
            row,
            2,
            1,
            2,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )
        row += 1
        grid_layout.addWidget(
            self._create_label("Description*:"),
            row,
            0,
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight,
        )
        grid_layout.addWidget(self.description_input, row, 1, 1, 3)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        fields_to_style = [
            self.code_input,
            self.alt_code_input,
            self.description_input,
            self.main_category_combo,
            self.sub_category_combo,
            self.standard_charge_input,
        ]
        for field in fields_to_style:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_style = (
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
                button.setStyleSheet(ok_style)
        overall_layout.addWidget(self.button_box)
        if self.main_category_combo:
            self.main_category_combo.currentIndexChanged.connect(
                self._on_main_category_changed
            )

    @Slot(str)  # MODIFIED: Added Slot decorator and type hint for 'text' argument
    def _on_alt_code_text_edited(self, text: str):
        """Automatically converts the alt_code_input text to uppercase."""
        if self.alt_code_input:
            current_text = text  # Use the text passed by the signal
            uppercase_text = current_text.upper()
            if current_text != uppercase_text:
                # Block signals to prevent potential recursion if setText itself emitted textEdited
                self.alt_code_input.blockSignals(True)
                cursor_pos = self.alt_code_input.cursorPosition()
                self.alt_code_input.setText(uppercase_text)
                self.alt_code_input.setCursorPosition(cursor_pos)
                self.alt_code_input.blockSignals(False)

    def _load_main_categories(self):
        # ... (method remains unchanged from v1.1.9) ...
        if not self.main_category_combo:
            return
        self.main_category_combo.clear()
        self.main_category_combo.addItem("Select Main Category...", None)
        try:
            categories = self.controller.get_charge_code_categories(level=1)
            for cat in categories:
                self.main_category_combo.addItem(cat.name, cat.category_id)
        except Exception as e:
            self.logger.error(f"Error loading main categories: {e}", exc_info=True)

    def _on_main_category_changed(self, index: int):
        # ... (method remains unchanged from v1.1.9) ...
        if not self.main_category_combo or not self.sub_category_combo:
            return
        self.sub_category_combo.clear()
        self.sub_category_combo.addItem("Select Sub-Category...", None)
        parent_id = self.main_category_combo.itemData(index)
        if parent_id is not None:
            try:
                sub_categories = self.controller.get_charge_code_categories(
                    parent_id=parent_id, level=2
                )
                if sub_categories:
                    for cat in sub_categories:
                        self.sub_category_combo.addItem(cat.name, cat.category_id)
                    self.sub_category_combo.setEnabled(True)
                else:
                    self.sub_category_combo.setEnabled(False)
            except Exception as e:
                self.logger.error(
                    f"Error loading sub-categories for parent_id {parent_id}: {e}",
                    exc_info=True,
                )
                self.sub_category_combo.setEnabled(False)
        else:
            self.sub_category_combo.setEnabled(False)

    def _populate_fields(self):
        # ... (method remains unchanged from v1.1.9) ...
        if self.is_edit_mode and self.charge_code:
            self.code_input.setText(self.charge_code.code)
            self.code_input.setReadOnly(True)
            self.code_input.setStyleSheet(
                self._get_form_input_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
            )
            self.alt_code_input.setText(self.charge_code.alternate_code or "")
            self.description_input.setPlainText(self.charge_code.description)
            self.standard_charge_input.setValue(
                float(self.charge_code.standard_charge)
                if self.charge_code.standard_charge is not None
                else 0.0
            )
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(self.charge_code.taxable or False)
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(self.charge_code.is_active)
            if self.charge_code.category_id is not None:
                path = self.controller.get_category_path(self.charge_code.category_id)
                if path:
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(True)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(True)
                    if len(path) > 0 and self.main_category_combo:
                        main_cat_id = path[0].category_id
                        index = self.main_category_combo.findData(main_cat_id)
                        if index >= 0:
                            self.main_category_combo.setCurrentIndex(index)
                        self._on_main_category_changed(
                            self.main_category_combo.currentIndex()
                        )
                    if len(path) > 1 and self.sub_category_combo:
                        sub_cat_id = path[1].category_id
                        QTimer.singleShot(
                            0,
                            lambda: self._select_combo_item(
                                self.sub_category_combo, sub_cat_id, False
                            ),
                        )
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(False)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(False)
            else:
                if self.sub_category_combo:
                    self.sub_category_combo.setEnabled(False)

    def _select_combo_item(
        self, combo: QComboBox, item_id_to_select: int, trigger_next_load: bool
    ):
        # ... (method remains unchanged from v1.1.9) ...
        if not combo:
            return
        index = combo.findData(item_id_to_select)
        if index >= 0:
            combo.setCurrentIndex(index)

    def get_data(self) -> Optional[Dict[str, Any]]:
        # ... (method remains unchanged from v1.1.9 - no 'is_active' or 'taxable') ...
        code = self.code_input.text().strip().upper()
        description = self.description_input.toPlainText().strip()
        standard_charge_value = self.standard_charge_input.value()
        errors = []
        if not code:
            errors.append("Code is required.")
        if not description:
            errors.append("Description is required.")
        charge_decimal: Optional[Decimal] = None
        try:
            charge_decimal = Decimal(str(standard_charge_value))
            if charge_decimal < Decimal("0.00"):
                errors.append("Standard Charge cannot be negative.")
        except InvalidOperation:
            errors.append("Standard Charge must be a valid number (e.g., 25.00).")
        selected_category_id: Optional[int] = None
        if (
            self.sub_category_combo
            and self.sub_category_combo.currentIndex() > 0
            and self.sub_category_combo.isEnabled()
        ):
            selected_category_id = self.sub_category_combo.currentData()
        elif self.main_category_combo and self.main_category_combo.currentIndex() > 0:
            selected_category_id = self.main_category_combo.currentData()
        if selected_category_id is None:
            errors.append(
                "A category selection (Main Category, or Sub-Category if applicable) is required."
            )
        if errors:
            QMessageBox.warning(self, "Input Error", "\n".join(errors))
            return None
        return {
            "code": code,
            "alternate_code": self.alt_code_input.text().strip().upper() or None,
            "description": description,
            "category_id": selected_category_id,
            "standard_charge": charge_decimal,
        }

    def validate_and_accept(self):
        # ... (method remains unchanged from v1.1.9) ...
        data = self.get_data()
        if data is None:
            return
        validation_data_for_controller = data.copy()
        if self.is_edit_mode and self.charge_code:
            if self.is_active_checkbox:
                validation_data_for_controller["is_active"] = (
                    self.is_active_checkbox.isChecked()
                )
            if self.taxable_checkbox:
                validation_data_for_controller["taxable"] = (
                    self.taxable_checkbox.isChecked()
                )
        is_valid, errors = self.controller.validate_charge_code_data(
            validation_data_for_controller, is_new=(not self.is_edit_mode)
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return
        try:
            if self.is_edit_mode and self.charge_code:
                success, message = self.controller.update_charge_code(
                    self.charge_code.charge_code_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code(
                    data, self.current_user_id
                )
            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(
                f"Error during charge code save/update: {e}", exc_info=True
            )
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )

--- End File: views/admin/dialogs/add_edit_charge_code_dialog.py ---

--- File: views/horse/dialogs/create_link_owner_dialog.py ---
# views/horse/dialogs/create_link_owner_dialog.py
"""
EDSI Veterinary Management System - Create New Owner and Link Dialog
Version: 1.0.8
Purpose: Dialog for creating a new owner and linking them to a horse with a percentage.
         - Corrected tuple unpacking error in _setup_ui by ensuring all field
           definitions in `fields_setup` list have a consistent number of elements.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.0.8 (2025-05-26):
    - In `_setup_ui`, standardized the tuples in the `fields_setup` list to consistently
      provide 8 elements (label, name, layout coordinates, widget_type_str, placeholder).
    - Updated the for-loop unpacking these tuples to match the 8 elements,
      resolving the "ValueError: not enough values to unpack".
- v1.0.7 (2025-05-26):
    - Modified `__init__` to accept an optional `total_ownership_validator` callback.
    - Updated `validate_and_accept` to call this external validator.
- v1.0.6 (2025-05-26):
    - Redesigned UI to use a two-column QGridLayout for owner detail fields.
# ... (rest of previous changelog entries assumed present)
"""

import logging
from typing import Optional, Dict, List, Callable

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QComboBox,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QWidget,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class CreateAndLinkOwnerDialog(QDialog):
    def __init__(
        self,
        parent_view,
        horse_name: str,
        current_user_login: str,
        total_ownership_validator: Optional[
            Callable[[Optional[int], float], bool]
        ] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_name = horse_name
        self.current_user_login = current_user_login
        self.owner_controller = OwnerController()
        self.total_ownership_validator = total_ownership_validator

        self.setWindowTitle(f"Create & Link New Owner to {self.horse_name}")
        self.setMinimumWidth(750)

        self._setup_palette()
        self._setup_ui()

        if "state_code" in self.form_fields and isinstance(
            self.form_fields["state_code"], QComboBox
        ):
            self._populate_states_combo(self.form_fields["state_code"])

    def _get_dialog_specific_input_field_style(self):
        # (Same as v1.0.7)
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; subcontrol-position: right center; width: 15px; }}
            QComboBox::down-arrow {{ image: url(none); }} /* Consider a Qt built-in or SVG icon for better dark theme compatibility */
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }} """

    def _get_dialog_generic_button_style(self):
        # (Same as v1.0.7)
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        # (Same as v1.0.7)
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        main_dialog_layout = QVBoxLayout(self)
        main_dialog_layout.setSpacing(15)
        main_dialog_layout.setContentsMargins(15, 15, 15, 15)

        instruction_label = QLabel(
            f"Enter details for the new owner to be linked to <b>{self.horse_name}</b>."
        )
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 5px; background-color: transparent;"
        )
        instruction_label.setWordWrap(True)
        main_dialog_layout.addWidget(instruction_label)

        grid_layout = QGridLayout()
        grid_layout.setHorizontalSpacing(20)
        grid_layout.setVerticalSpacing(10)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)

        self.form_fields = {}
        specific_input_style = self._get_dialog_specific_input_field_style()

        # Each tuple: (Label, field_name, r_lbl, c_lbl, r_fld, c_fld, widget_type_str, placeholder_or_None)
        fields_setup = [
            ("Farm Name:", "farm_name", 0, 0, 0, 1, "QLineEdit", None),
            ("Account #:", "account_number", 0, 2, 0, 3, "QLineEdit", None),
            ("First Name:", "first_name", 1, 0, 1, 1, "QLineEdit", None),
            ("Last Name*:", "last_name", 1, 2, 1, 3, "QLineEdit", None),
            ("Address 1*:", "address_line1", 2, 0, 2, 1, "QLineEdit", None),
            ("Address 2:", "address_line2", 2, 2, 2, 3, "QLineEdit", None),
            ("City*:", "city", 3, 0, 3, 1, "QLineEdit", None),
            ("State*:", "state_code", 3, 2, 3, 3, "QComboBox", None),
            ("Zip/Postal*:", "zip_code", 4, 0, 4, 1, "QLineEdit", None),
            ("Country:", "country_name", 4, 2, 4, 3, "QLineEdit", "e.g. USA"),
            ("Phone:", "phone", 5, 0, 5, 1, "QLineEdit", None),
            ("Email:", "email", 5, 2, 5, 3, "QLineEdit", None),
        ]

        for (
            label_text,
            field_name,
            r_lbl,
            c_lbl,
            r_fld,
            c_fld,
            widget_type_str,
            placeholder_text,
        ) in fields_setup:
            lbl = QLabel(label_text)
            grid_layout.addWidget(lbl, r_lbl, c_lbl, Qt.AlignmentFlag.AlignRight)

            widget: QWidget  # Type hint for clarity
            if widget_type_str == "QComboBox":
                widget = QComboBox()
            else:  # Default to QLineEdit
                widget = QLineEdit()
                if placeholder_text:  # Check if placeholder_text is not None
                    widget.setPlaceholderText(placeholder_text)

            widget.setStyleSheet(specific_input_style)
            self.form_fields[field_name] = widget
            grid_layout.addWidget(widget, r_fld, c_fld)

        # Row 6: Ownership Percentage and Active Checkbox
        self.percentage_input = QDoubleSpinBox()
        self.percentage_input.setRange(0.00, 100.00)
        self.percentage_input.setDecimals(2)
        self.percentage_input.setSuffix(" %")
        self.percentage_input.setValue(100.00)
        self.percentage_input.setStyleSheet(specific_input_style)
        grid_layout.addWidget(
            QLabel("Ownership %*:"), 6, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.percentage_input, 6, 1)

        self.form_fields["is_active"] = QCheckBox("Owner is Active")
        self.form_fields["is_active"].setChecked(True)
        self.form_fields["is_active"].setStyleSheet(
            f"QCheckBox{{color:{DARK_TEXT_SECONDARY};background:transparent;padding-top:3px;}}QCheckBox::indicator{{width:13px;height:13px;}}"
        )
        grid_layout.addWidget(
            self.form_fields["is_active"],
            6,
            3,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )  # Align left in its cell

        main_dialog_layout.addLayout(grid_layout)
        main_dialog_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(
            "Create & Link Owner"
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg = DARK_SUCCESS_ACTION
                ok_bg = (
                    f"#{ok_bg[1]*2}{ok_bg[2]*2}{ok_bg[3]*2}"
                    if len(ok_bg) == 4
                    else ok_bg
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton{{background-color:{ok_bg};color:white;}}"
                )
        main_dialog_layout.addWidget(self.button_box)
        self.setStyleSheet(
            f"QDialog{{background-color:{DARK_WIDGET_BACKGROUND};}} QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;padding-top:3px;}} QCheckBox::indicator{{width:13px;height:13px;}} QCheckBox{{color:{DARK_TEXT_SECONDARY};}}"
        )

    def _populate_states_combo(self, combo_box: QComboBox):
        # (Same as v1.0.7)
        try:
            ref_data = self.owner_controller.get_owner_form_reference_data()
            states: List[Dict[str, str]] = ref_data.get("states", [])
            combo_box.blockSignals(True)
            combo_box.clear()
            combo_box.addItem("", None)
            for state_data in states:
                combo_box.addItem(state_data["name"], state_data["id"])
            combo_box.blockSignals(False)
            self.logger.debug(f"Populated states: {len(states)}")
        except Exception as e:
            self.logger.error(f"Error populating states: {e}", exc_info=True)
            QMessageBox.warning(self, "Error", "Could not load states.")

    def validate_and_accept(self):
        # (Same as v1.0.7 - calls self.total_ownership_validator)
        owner_data = {}
        for field_name, widget in self.form_fields.items():
            if isinstance(widget, QLineEdit):
                owner_data[field_name] = widget.text().strip()
            elif isinstance(widget, QComboBox):
                owner_data[field_name] = widget.currentData()
            elif isinstance(widget, QCheckBox):
                owner_data[field_name] = widget.isChecked()
        percentage = self.percentage_input.value()

        is_valid, errors = self.owner_controller.validate_owner_data(
            owner_data, is_new=True
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct owner details:\n- " + "\n- ".join(errors),
            )
            return
        if not (0.00 <= percentage <= 100.00):
            QMessageBox.warning(
                self,
                "Input Error",
                "Ownership percentage must be between 0.00 and 100.00.",
            )
            return
        if self.total_ownership_validator:
            if not self.total_ownership_validator(
                None, percentage
            ):  # Pass None for owner_id_being_changed (new owner)
                self.logger.debug(
                    "External total ownership validation failed for new owner link."
                )
                return
        self.logger.debug("CreateAndLinkOwnerDialog validation successful, accepting.")
        super().accept()

    def get_data(self) -> Optional[Dict]:
        # (Same as v1.0.7)
        owner_details = {}
        for field_name, widget in self.form_fields.items():
            if isinstance(widget, QLineEdit):
                owner_details[field_name] = widget.text().strip()
            elif isinstance(widget, QComboBox):
                owner_details[field_name] = widget.currentData()
            elif isinstance(widget, QCheckBox):
                owner_details[field_name] = widget.isChecked()
        return {
            "owner_details": owner_details,
            "percentage": self.percentage_input.value(),
        }

--- End File: views/horse/dialogs/create_link_owner_dialog.py ---

--- File: views/horse/tabs/basic_info_tab.py ---
# views/horse/tabs/basic_info_tab.py
"""
EDSI Veterinary Management System - Horse Basic Info Tab
Version: 1.2.20
Purpose: UI for displaying and editing basic information of a horse.
         - Implemented robust owner name display logic in populate_form_data
           for the owner_display_label.
Last Updated: May 26, 2025
Author: Gemini

Changelog:
- v1.2.20 (2025-05-26):
    - Updated `populate_form_data` to use more robust logic for displaying the
      primary owner's name in `owner_display_label`. It now constructs the
      name from farm_name, first_name, and last_name attributes of the
      Owner model, similar to the logic in HorseUnifiedManagement's header.
- v1.2.19 (2025-05-26):
    - Added `owner_display_label` (QLabel) to show the primary owner's name.
    - Positioned "Owner" field in the grid layout below "Location".
    - Updated `populate_form_data` and `clear_fields`.
- v1.2.18 (2025-05-25):
    - Modified `get_data_from_form` to return Python `datetime.date` objects.
# ... (rest of previous changelog entries assumed present)
"""
import logging
from typing import Optional, Dict, Any, TYPE_CHECKING
from datetime import date

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QDateEdit,
    QLabel,
    QComboBox,
    QFrame,
    QScrollArea,
    QHBoxLayout,
    QPushButton,
    QTextEdit,
    QFormLayout,
)
from PySide6.QtCore import Qt, Signal, QDate, QSize  # QSize for icon placeholder
from PySide6.QtGui import QDoubleValidator, QIcon  # QIcon for icon placeholder

from controllers.horse_controller import HorseController

# No direct import of OwnerModel here, assuming Horse object has it via relationship

if TYPE_CHECKING:
    from models import Horse, Owner as OwnerModel  # For type hinting horse_data.owners


class BasicInfoTab(QWidget):
    data_modified = Signal()
    save_requested = Signal()
    discard_requested = Signal()
    toggle_active_requested = Signal(bool)
    edit_mode_toggled = Signal(bool)

    SEX_OPTIONS = ["Unknown", "Stallion", "Mare", "Gelding", "Colt", "Filly"]

    INPUT_FIELD_STYLE = (
        "background-color: #3E3E3E; "
        "color: white; "
        "border: 1px solid #B0B0B0; "
        "border-radius: 3px; "
        "padding: 5px;"
    )
    TEXT_AREA_STYLE = INPUT_FIELD_STYLE
    COMBO_DATE_STYLE = INPUT_FIELD_STYLE
    DEACTIVATE_BUTTON_STYLE = (
        "QPushButton {"
        "background-color: #FFC107; color: black; border: 1px solid #707070; "
        "border-radius: 3px; padding: 6px 12px; }"
        "QPushButton:hover { background-color: #FFD54F; }"
        "QPushButton:pressed { background-color: #FFA000; }"
    )
    DISCARD_BUTTON_STYLE = (
        "QPushButton {"
        "background-color: #212121; color: white; border: 1px solid #707070; "
        "border-radius: 3px; padding: 6px 12px; }"
        "QPushButton:hover { background-color: #424242; }"
        "QPushButton:pressed { background-color: #000000; }"
    )
    SAVE_BUTTON_STYLE = (
        "QPushButton {"
        "background-color: #607D8B; color: white; border: 1px solid #707070; "
        "border-radius: 3px; padding: 6px 12px; }"
        "QPushButton:hover { background-color: #78909C; }"
        "QPushButton:pressed { background-color: #546E7A; }"
    )

    def __init__(
        self,
        horse_controller: Optional[HorseController] = None,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_controller = (
            horse_controller if horse_controller else HorseController()
        )
        self.parent_view: Optional[QWidget] = parent

        self.current_horse_id: Optional[int] = None
        self._is_new_mode: bool = False
        self._is_editing: bool = False
        self._has_unsaved_changes: bool = False
        self._current_horse_is_active: bool = True

        # UI Elements
        self.horse_name_input: QLineEdit
        self.breed_input: QLineEdit
        self.sex_combo: QComboBox
        self.reg_number_input: QLineEdit
        self.tattoo_number_input: QLineEdit
        self.location_display_label: QLabel
        self.owner_display_label: QLabel  # Added in v1.2.19

        self.account_number_input: QLineEdit
        self.color_input: QLineEdit
        self.dob_input: QDateEdit
        self.microchip_id_input: QLineEdit
        self.brand_input: QLineEdit
        self.band_tag_input: QLineEdit

        self.coggins_date_input: QDateEdit
        self.height_input: QLineEdit
        self.description_input: QTextEdit

        self.save_btn: QPushButton
        self.discard_btn: QPushButton
        self.toggle_active_btn: QPushButton

        self._suppress_data_changed_signal = False
        self._setup_ui()
        self.set_form_read_only(True)
        self.update_buttons_state(
            is_editing_or_new=False, has_selection=False, has_changes=False
        )

    def _setup_ui(self):
        # (Setup for layout, scroll_area, content_widget, top_grid_layout same as v1.2.19)
        # (Rows 0-5 for Name to Band/Tag same as v1.2.19)
        # (NEW Row 6: Owner is already in v1.2.19 _setup_ui as per my last response)
        # (Coggins/Height layout, Description layout, Buttons layout same as v1.2.19)
        # For brevity, re-confirming the structure is as per previous response that added owner_display_label.
        # The only change is ensuring populate_form_data correctly fills owner_display_label.
        # All other UI setup code from v1.2.19 (which included adding the owner_display_label to the grid) remains.

        # --- Full _setup_ui from v1.2.19 (which included owner_display_label) ---
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        scroll_area = QScrollArea(self)
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        content_widget = QWidget()
        outer_layout = QVBoxLayout(content_widget)
        outer_layout.setContentsMargins(15, 15, 15, 15)
        outer_layout.setSpacing(15)
        top_grid_layout = QGridLayout()
        top_grid_layout.setSpacing(10)
        top_grid_layout.setHorizontalSpacing(20)
        top_grid_layout.setColumnStretch(1, 1)
        top_grid_layout.setColumnStretch(3, 1)

        # Row 0
        top_grid_layout.addWidget(QLabel("Name*:"), 0, 0, Qt.AlignmentFlag.AlignRight)
        self.horse_name_input = QLineEdit()
        self.horse_name_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.horse_name_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.horse_name_input, 0, 1)
        top_grid_layout.addWidget(
            QLabel("Account Number:"), 0, 2, Qt.AlignmentFlag.AlignRight
        )
        self.account_number_input = QLineEdit()
        self.account_number_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.account_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.account_number_input, 0, 3)
        # Row 1
        top_grid_layout.addWidget(QLabel("Breed:"), 1, 0, Qt.AlignmentFlag.AlignRight)
        self.breed_input = QLineEdit()
        self.breed_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.breed_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.breed_input, 1, 1)
        top_grid_layout.addWidget(QLabel("Color:"), 1, 2, Qt.AlignmentFlag.AlignRight)
        self.color_input = QLineEdit()
        self.color_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.color_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.color_input, 1, 3)
        # Row 2
        top_grid_layout.addWidget(QLabel("Sex:"), 2, 0, Qt.AlignmentFlag.AlignRight)
        self.sex_combo = QComboBox()
        self.sex_combo.addItems(self.SEX_OPTIONS)
        self.sex_combo.setStyleSheet(self.COMBO_DATE_STYLE)
        self.sex_combo.currentIndexChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.sex_combo, 2, 1)
        top_grid_layout.addWidget(
            QLabel("Date of Birth:"), 2, 2, Qt.AlignmentFlag.AlignRight
        )
        self.dob_input = QDateEdit()
        self.dob_input.setCalendarPopup(True)
        self.dob_input.setDisplayFormat("yyyy-MM-dd")
        self.dob_input.setDate(QDate(2000, 1, 1))
        self.dob_input.setMaximumDate(QDate.currentDate())
        self.dob_input.setSpecialValueText(" ")
        self.dob_input.setStyleSheet(self.COMBO_DATE_STYLE)
        self.dob_input.dateChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.dob_input, 2, 3)
        # Row 3
        top_grid_layout.addWidget(
            QLabel("Reg. Number:"), 3, 0, Qt.AlignmentFlag.AlignRight
        )
        self.reg_number_input = QLineEdit()
        self.reg_number_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.reg_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.reg_number_input, 3, 1)
        top_grid_layout.addWidget(
            QLabel("Microchip ID:"), 3, 2, Qt.AlignmentFlag.AlignRight
        )
        self.microchip_id_input = QLineEdit()
        self.microchip_id_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.microchip_id_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.microchip_id_input, 3, 3)
        # Row 4
        top_grid_layout.addWidget(QLabel("Tattoo:"), 4, 0, Qt.AlignmentFlag.AlignRight)
        self.tattoo_number_input = QLineEdit()
        self.tattoo_number_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.tattoo_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.tattoo_number_input, 4, 1)
        top_grid_layout.addWidget(QLabel("Brand:"), 4, 2, Qt.AlignmentFlag.AlignRight)
        self.brand_input = QLineEdit()
        self.brand_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.brand_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.brand_input, 4, 3)
        # Row 5
        top_grid_layout.addWidget(
            QLabel("Location:"), 5, 0, Qt.AlignmentFlag.AlignRight
        )
        self.location_display_label = QLabel("N/A")
        self.location_display_label.setStyleSheet(self.INPUT_FIELD_STYLE)
        if self.horse_name_input.sizeHint().isValid():
            self.location_display_label.setMinimumHeight(
                self.horse_name_input.sizeHint().height()
            )
        else:
            font_metrics = self.location_display_label.fontMetrics()
            padding = 5
            self.location_display_label.setMinimumHeight(
                font_metrics.height() + 2 * padding + 2
            )
        top_grid_layout.addWidget(self.location_display_label, 5, 1)
        top_grid_layout.addWidget(
            QLabel("Band/Tag:"), 5, 2, Qt.AlignmentFlag.AlignRight
        )
        self.band_tag_input = QLineEdit()
        self.band_tag_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.band_tag_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.band_tag_input, 5, 3)
        # Row 6 (Owner Display)
        top_grid_layout.addWidget(QLabel("Owner:"), 6, 0, Qt.AlignmentFlag.AlignRight)
        self.owner_display_label = QLabel("N/A")
        self.owner_display_label.setStyleSheet(self.INPUT_FIELD_STYLE)
        if self.horse_name_input.sizeHint().isValid():
            self.owner_display_label.setMinimumHeight(
                self.horse_name_input.sizeHint().height()
            )
        else:
            font_metrics = self.owner_display_label.fontMetrics()
            padding = 5
            self.owner_display_label.setMinimumHeight(
                font_metrics.height() + 2 * padding + 2
            )
        top_grid_layout.addWidget(
            self.owner_display_label, 6, 1
        )  # Spans one column for now

        outer_layout.addLayout(top_grid_layout)

        coggins_height_layout = QGridLayout()
        coggins_height_layout.setSpacing(10)
        coggins_height_layout.setHorizontalSpacing(20)
        coggins_height_layout.setColumnStretch(1, 1)
        coggins_height_layout.setColumnStretch(3, 1)
        coggins_height_layout.addWidget(
            QLabel("Coggins Date:"), 0, 0, Qt.AlignmentFlag.AlignRight
        )
        self.coggins_date_input = QDateEdit()
        self.coggins_date_input.setCalendarPopup(True)
        self.coggins_date_input.setDisplayFormat("yyyy-MM-dd")
        self.coggins_date_input.setDate(QDate(2000, 1, 1))
        self.coggins_date_input.setSpecialValueText(" ")
        self.coggins_date_input.setStyleSheet(self.COMBO_DATE_STYLE)
        self.coggins_date_input.dateChanged.connect(self._on_data_modified)
        coggins_height_layout.addWidget(self.coggins_date_input, 0, 1)
        coggins_height_layout.addWidget(
            QLabel("Height (Hands):"), 0, 2, Qt.AlignmentFlag.AlignRight
        )
        self.height_input = QLineEdit()
        double_validator = QDoubleValidator(0.00, 99.99, 2)
        double_validator.setNotation(QDoubleValidator.Notation.StandardNotation)
        self.height_input.setValidator(double_validator)
        self.height_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.height_input.textChanged.connect(self._on_data_modified)
        coggins_height_layout.addWidget(self.height_input, 0, 3)
        outer_layout.addLayout(coggins_height_layout)

        description_form_layout = QFormLayout()
        description_form_layout.setContentsMargins(0, 0, 0, 0)
        description_form_layout.setSpacing(10)
        description_form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        self.description_input = QTextEdit()
        self.description_input.setFixedHeight(80)
        self.description_input.setStyleSheet(self.TEXT_AREA_STYLE)
        self.description_input.textChanged.connect(self._on_data_modified)
        description_form_layout.addRow(
            QLabel("Description/Markings:"), self.description_input
        )
        outer_layout.addLayout(description_form_layout)

        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setSpacing(10)
        self.toggle_active_btn = QPushButton("Deactivate Horse")
        self.toggle_active_btn.setStyleSheet(self.DEACTIVATE_BUTTON_STYLE)
        self.toggle_active_btn.clicked.connect(self._request_toggle_active)
        self.toggle_active_btn.setObjectName("ToggleActiveButton")
        self.discard_btn = QPushButton("Discard Changes")
        self.discard_btn.setStyleSheet(self.DISCARD_BUTTON_STYLE)
        self.discard_btn.clicked.connect(self.discard_requested.emit)
        self.discard_btn.setObjectName("DiscardButton")
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.setStyleSheet(self.SAVE_BUTTON_STYLE)
        self.save_btn.clicked.connect(self.save_requested.emit)
        self.save_btn.setObjectName("SaveButton")
        button_layout.addWidget(self.toggle_active_btn)
        button_layout.addStretch()
        button_layout.addWidget(self.discard_btn)
        button_layout.addWidget(self.save_btn)
        outer_layout.addWidget(button_frame)
        outer_layout.addStretch(1)
        scroll_area.setWidget(content_widget)
        self.main_layout.addWidget(scroll_area)

    def _request_toggle_active(self):
        # (Same as v1.2.19)
        if self._current_horse_is_active:
            self.toggle_active_requested.emit(False)
        else:
            self.toggle_active_requested.emit(True)

    def update_toggle_active_button_text(self, is_active: bool):
        # (Same as v1.2.19)
        self.toggle_active_btn.setText(
            "Deactivate Horse" if is_active else "Activate Horse"
        )
        self._current_horse_is_active = is_active

    def populate_form_data(self, horse_data: Optional["Horse"]):
        self.logger.debug(
            f"Populating BasicInfoTab with horse_data: {horse_data.horse_name if horse_data else 'None'}"
        )
        self._suppress_data_changed_signal = True
        if horse_data:
            self.current_horse_id = horse_data.horse_id
            self.horse_name_input.setText(horse_data.horse_name or "")
            self.account_number_input.setText(horse_data.account_number or "")
            self.breed_input.setText(horse_data.breed or "")
            self.color_input.setText(horse_data.color or "")
            sex_idx = self.sex_combo.findText(
                horse_data.sex or "Unknown", Qt.MatchFlag.MatchFixedString
            )
            self.sex_combo.setCurrentIndex(sex_idx if sex_idx >= 0 else 0)
            if horse_data.date_of_birth:
                self.dob_input.setDate(
                    QDate.fromString(str(horse_data.date_of_birth), "yyyy-MM-dd")
                )
            else:
                self.dob_input.setDate(self.dob_input.minimumDate().addDays(-1))
                self.dob_input.setDate(QDate(2000, 1, 1))
            self.reg_number_input.setText(getattr(horse_data, "reg_number", "") or "")
            self.microchip_id_input.setText(horse_data.chip_number or "")
            self.tattoo_number_input.setText(horse_data.tattoo_number or "")
            self.brand_input.setText(getattr(horse_data, "brand", "") or "")
            self.band_tag_input.setText(getattr(horse_data, "band_tag", "") or "")
            self.location_display_label.setText(
                horse_data.location.location_name
                if horse_data.location and hasattr(horse_data.location, "location_name")
                else "N/A"
            )

            # Populate NEW owner field using robust name construction
            owner_name_display = "N/A"
            if (
                hasattr(horse_data, "owners")
                and horse_data.owners
                and len(horse_data.owners) > 0
            ):
                first_owner_model = horse_data.owners[
                    0
                ]  # This is an OwnerModel instance
                if first_owner_model:
                    name_parts = []
                    if (
                        hasattr(first_owner_model, "farm_name")
                        and first_owner_model.farm_name
                    ):
                        name_parts.append(first_owner_model.farm_name)

                    person_name_parts = []
                    if (
                        hasattr(first_owner_model, "first_name")
                        and first_owner_model.first_name
                    ):
                        person_name_parts.append(first_owner_model.first_name)
                    if (
                        hasattr(first_owner_model, "last_name")
                        and first_owner_model.last_name
                    ):
                        person_name_parts.append(first_owner_model.last_name)

                    person_name_str = " ".join(person_name_parts).strip()
                    if person_name_str:
                        if name_parts:
                            name_parts.append(f"({person_name_str})")
                        else:
                            name_parts.append(person_name_str)

                    if name_parts:
                        owner_name_display = " ".join(name_parts)
                    elif hasattr(first_owner_model, "owner_id"):
                        owner_name_display = f"Owner ID: {first_owner_model.owner_id}"
                    else:
                        owner_name_display = "Owner Data Incomplete"
                else:
                    owner_name_display = "Owner Data Missing"
            else:  # No owners associated
                owner_name_display = "No Owner Associated"
            self.owner_display_label.setText(owner_name_display)

            if horse_data.coggins_date:
                self.coggins_date_input.setDate(
                    QDate.fromString(str(horse_data.coggins_date), "yyyy-MM-dd")
                )
            else:
                self.coggins_date_input.setDate(
                    self.coggins_date_input.minimumDate().addDays(-1)
                )
                self.coggins_date_input.setDate(QDate(2000, 1, 1))
            self.height_input.setText(
                f"{horse_data.height_hands:.2f}"
                if horse_data.height_hands is not None
                else ""
            )
            self.description_input.setPlainText(horse_data.description or "")
            self.update_toggle_active_button_text(horse_data.is_active)
            self.set_form_read_only(True)
            self._is_new_mode = False
            self._is_editing = False
            self.update_buttons_state(
                is_editing_or_new=False, has_selection=True, has_changes=False
            )
        else:
            self.clear_fields(suppress_signal=True)
            self.set_form_read_only(True)
            self._is_new_mode = False
            self._is_editing = False
            self.update_buttons_state(
                is_editing_or_new=False, has_selection=False, has_changes=False
            )
        self._has_unsaved_changes = False
        self._suppress_data_changed_signal = False

    def _on_data_modified(self, *args):
        # (Same as v1.2.19)
        if self._suppress_data_changed_signal:
            return
        if not self.horse_name_input.isReadOnly():
            if not self._has_unsaved_changes:
                self._has_unsaved_changes = True
                self.logger.debug("Data modified.")
                self.data_modified.emit()
            self.update_buttons_state(
                is_editing_or_new=(self._is_new_mode or self._is_editing),
                has_selection=(self.current_horse_id is not None),
                has_changes=True,
            )

    def get_data_from_form(self) -> Dict[str, Any]:
        # (Same as v1.2.19 - owner is display only, not collected here)
        def get_date_object(date_edit_widget: QDateEdit) -> Optional[date]:
            q_date = date_edit_widget.date()
            if (
                date_edit_widget.text().strip() == ""
                or (
                    q_date == QDate(2000, 1, 1)
                    and date_edit_widget.text() == date_edit_widget.specialValueText()
                )
                or q_date < date_edit_widget.minimumDate()
                or not q_date.isValid()
                or q_date == date_edit_widget.minimumDate().addDays(-1)
            ):
                return None
            return date(q_date.year(), q_date.month(), q_date.day())

        data = {
            "horse_name": self.horse_name_input.text().strip() or None,
            "account_number": self.account_number_input.text().strip() or None,
            "breed": self.breed_input.text().strip() or None,
            "color": self.color_input.text().strip() or None,
            "sex": (
                self.sex_combo.currentText()
                if self.sex_combo.currentText() != "Unknown"
                else None
            ),
            "date_of_birth": get_date_object(self.dob_input),
            "chip_number": self.microchip_id_input.text().strip() or None,
            "tattoo_number": self.tattoo_number_input.text().strip() or None,
            "is_active": self._current_horse_is_active,
            "reg_number": self.reg_number_input.text().strip() or None,
            "brand": self.brand_input.text().strip() or None,
            "band_tag": self.band_tag_input.text().strip() or None,
            "coggins_date": get_date_object(self.coggins_date_input),
            "height_hands": (
                float(self.height_input.text())
                if self.height_input.text().strip()
                else None
            ),
            "description": self.description_input.toPlainText().strip() or None,
            "date_deceased": None,
        }
        for key in [
            "account_number",
            "breed",
            "color",
            "chip_number",
            "tattoo_number",
            "reg_number",
            "brand",
            "band_tag",
            "description",
        ]:
            if data[key] == "":
                data[key] = None
        if data["sex"] == "Unknown":
            data["sex"] = None
        self.logger.debug(f"Data extracted: {data}")
        return data

    def set_form_read_only(self, read_only: bool):
        # (Same as v1.2.19)
        self.logger.debug(f"BasicInfoTab.set_form_read_only: {read_only}")
        self._suppress_data_changed_signal = True
        line_edit_fields = [
            self.horse_name_input,
            self.account_number_input,
            self.breed_input,
            self.color_input,
            self.reg_number_input,
            self.microchip_id_input,
            self.tattoo_number_input,
            self.brand_input,
            self.band_tag_input,
            self.height_input,
        ]
        for field in line_edit_fields:
            field.setReadOnly(read_only)
            style_suffix = "background-color: #2E2E2E;" if read_only else ""
            field.setStyleSheet(self.INPUT_FIELD_STYLE + style_suffix)
        interactive_widgets = [self.sex_combo, self.dob_input, self.coggins_date_input]
        for widget in interactive_widgets:
            widget.setEnabled(not read_only)
            style_suffix_interactive = (
                "background-color: #2E2E2E; color: #AAAAAA;" if read_only else ""
            )
            widget.setStyleSheet(self.COMBO_DATE_STYLE + style_suffix_interactive)
        self.description_input.setReadOnly(read_only)
        style_suffix_desc = "background-color: #2E2E2E;" if read_only else ""
        self.description_input.setStyleSheet(self.TEXT_AREA_STYLE + style_suffix_desc)
        self._is_editing = not read_only
        if read_only:
            self._has_unsaved_changes = False
        self._suppress_data_changed_signal = False

    def clear_fields(self, suppress_signal: bool = False):
        if suppress_signal:
            self._suppress_data_changed_signal = True
        self.current_horse_id = None
        self.horse_name_input.clear()
        self.account_number_input.clear()
        self.breed_input.clear()
        self.color_input.clear()
        self.sex_combo.setCurrentIndex(0)
        self.dob_input.setDate(self.dob_input.minimumDate().addDays(-1))
        self.dob_input.setDate(QDate(2000, 1, 1))
        self.reg_number_input.clear()
        self.microchip_id_input.clear()
        self.tattoo_number_input.clear()
        self.brand_input.clear()
        self.band_tag_input.clear()
        self.location_display_label.setText("N/A")
        self.owner_display_label.setText("N/A")  # Clear owner display
        self.coggins_date_input.setDate(
            self.coggins_date_input.minimumDate().addDays(-1)
        )
        self.coggins_date_input.setDate(QDate(2000, 1, 1))
        self.height_input.clear()
        self.description_input.clear()
        self.update_toggle_active_button_text(True)
        if suppress_signal:
            self._suppress_data_changed_signal = False
        self._has_unsaved_changes = False
        if not suppress_signal:
            self.data_modified.emit()

    # (set_new_mode, set_edit_mode, update_buttons_state, has_unsaved_changes,
    #  mark_as_saved, update_displayed_location methods remain the same as in v1.2.19)
    def set_new_mode(self, is_new: bool):
        self.logger.info(f"BasicInfoTab set_new_mode: {is_new}")
        self._is_new_mode = is_new
        self._is_editing = True
        self.current_horse_id = None
        self.clear_fields(suppress_signal=True)
        self.set_form_read_only(False)
        self._has_unsaved_changes = False
        self.update_buttons_state(
            is_editing_or_new=True, has_selection=False, has_changes=False
        )
        self.edit_mode_toggled.emit(True)
        self.horse_name_input.setFocus()

    def set_edit_mode(self, editable: bool):
        self.logger.info(f"BasicInfoTab set_edit_mode: {editable}")
        self._is_new_mode = False
        self._is_editing = editable
        self.set_form_read_only(not editable)
        if editable:
            self._has_unsaved_changes = False
            self.horse_name_input.setFocus()
        self.update_buttons_state(
            is_editing_or_new=editable,
            has_selection=(self.current_horse_id is not None),
            has_changes=self._has_unsaved_changes,
        )
        self.edit_mode_toggled.emit(editable)

    def update_buttons_state(
        self, is_editing_or_new: bool, has_selection: bool, has_changes: bool
    ):
        can_save_discard = (is_editing_or_new or self._is_editing) and has_changes
        self.save_btn.setEnabled(can_save_discard)
        self.discard_btn.setEnabled(can_save_discard)
        can_toggle_active = (
            has_selection
            and (is_editing_or_new or self._is_editing)
            and not self._is_new_mode
        )
        self.toggle_active_btn.setEnabled(can_toggle_active)
        if not has_selection and not self._is_new_mode:
            self.update_toggle_active_button_text(True)
            self.toggle_active_btn.setEnabled(False)
        elif self._is_new_mode:
            self.update_toggle_active_button_text(True)
            self.toggle_active_btn.setEnabled(False)

    def has_unsaved_changes(self) -> bool:
        return self._has_unsaved_changes

    def mark_as_saved(self):
        self.logger.debug("BasicInfoTab.mark_as_saved.")
        self._has_unsaved_changes = False
        self._is_editing = False
        self.set_form_read_only(True)
        self.update_buttons_state(False, (self.current_horse_id is not None), False)

    def update_displayed_location(
        self, location_id: Optional[int], location_name: Optional[str]
    ):
        if hasattr(self, "location_display_label"):
            self.location_display_label.setText(location_name or "N/A")

--- End File: views/horse/tabs/basic_info_tab.py ---

--- File: views/horse/tabs/owners_tab.py ---
# views/horse/tabs/owners_tab.py
"""
EDSI Veterinary Management System - Horse Owners Tab
Version: 1.2.5
Purpose: Manages the association of owners with a specific horse.
         - Passes its own validation method to CreateAndLinkOwnerDialog and
           LinkExistingOwnerDialog to ensure total ownership validation occurs
           before the dialogs close.
Last Updated: May 26, 2025
Author: Claude Assistant (based on user's v1.2.0, modified by Gemini)

Changelog:
- v1.2.5 (2025-05-26):
    - Modified `_handle_create_and_link_owner` and `_handle_link_existing_owner`
      to pass a new method `_validate_total_ownership_for_dialog` as a callback
      to `CreateAndLinkOwnerDialog` and `LinkExistingOwnerDialog` respectively.
    - The dialogs will now call this callback to perform total ownership
      validation before closing. If validation fails, the dialog remains open.
    - Renamed internal `_validate_total_ownership` to
      `_validate_total_ownership_for_dialog` to reflect its use by dialogs.
- v1.2.4 (2025-05-26):
    - Added `_validate_total_ownership` helper method for client-side validation.
    - Integrated this validation into relevant handler methods.
# ... (rest of previous changelog entries)
"""

import logging
from typing import Optional, List, Dict
from decimal import Decimal

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFrame,
    QDoubleSpinBox,
    QMessageBox,
    QDialog,
    QListWidgetItem,
)
from PySide6.QtCore import Qt, Signal

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_BORDER,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_SUCCESS_ACTION,
    DARK_PRIMARY_ACTION,
    DARK_DANGER_ACTION,
    DARK_TEXT_SECONDARY,
    DARK_ITEM_HOVER,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
)
from models import Horse, Owner as OwnerModel
from controllers.horse_controller import HorseController
from controllers.owner_controller import OwnerController

from ..dialogs.create_link_owner_dialog import CreateAndLinkOwnerDialog
from ..dialogs.link_existing_owner_dialog import LinkExistingOwnerDialog
from ..widgets.horse_owner_list_widget import HorseOwnerListWidget


class OwnersTab(QWidget):
    owner_association_changed = Signal(str)

    def __init__(
        self,
        parent_view,
        horse_controller: HorseController,
        owner_controller: OwnerController,
    ):
        # (Same as v1.2.4)
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_controller = horse_controller
        self.owner_controller = owner_controller
        self.current_horse: Optional[Horse] = None
        self.current_horse_owners_assoc: List[Dict] = []
        self.selected_horse_owner_assoc_id: Optional[int] = None
        self.current_user_login = "UnknownUser"
        if hasattr(self.parent_view, "current_user") and self.parent_view.current_user:
            self.current_user_login = self.parent_view.current_user
        else:
            self.logger.warning(
                "Could not determine current_user for OwnersTab auditing."
            )
        self.setStyleSheet(f"background-color: {DARK_WIDGET_BACKGROUND};")
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)
        self._setup_ui(main_layout)
        self._setup_connections()
        self.update_buttons_state()

    # (_get_generic_button_style, _get_input_style, _setup_ui, _setup_connections,
    #  load_owners_for_horse, _on_horse_owner_selection_changed,
    #  _handle_remove_owner_from_horse, update_buttons_state remain IDENTICAL to v1.2.4)
    def _get_generic_button_style(self) -> str:
        if hasattr(self.parent_view, "get_generic_button_style"):
            return self.parent_view.get_generic_button_style()
        return f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;}} QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"

    def _get_input_style(self) -> str:
        return f"QDoubleSpinBox {{ background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; padding: 5px; border-radius: 4px; }}"

    def _setup_ui(self, main_layout: QVBoxLayout):
        owners_action_layout = QHBoxLayout()
        self.create_link_owner_btn = QPushButton("➕ Create New & Link Owner")
        self.link_existing_owner_btn = QPushButton("🔗 Link Existing Owner")
        self.remove_horse_owner_btn = QPushButton("➖ Remove Selected Owner Link")
        button_style = self._get_generic_button_style()
        self.create_link_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_SUCCESS_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        self.link_existing_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_PRIMARY_ACTION)
        )
        self.remove_horse_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_DANGER_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        owners_action_layout.addWidget(self.create_link_owner_btn)
        owners_action_layout.addWidget(self.link_existing_owner_btn)
        owners_action_layout.addWidget(self.remove_horse_owner_btn)
        owners_action_layout.addStretch()
        main_layout.addLayout(owners_action_layout)
        self.current_owners_list_widget = HorseOwnerListWidget()
        owners_list_label = QLabel("Current Owners & Percentages:")
        owners_list_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; background: transparent; margin-bottom: 5px; font-weight: bold;"
        )
        main_layout.addWidget(owners_list_label)
        main_layout.addWidget(self.current_owners_list_widget, 1)
        self.percentage_edit_frame = QFrame()
        self.percentage_edit_frame.setStyleSheet("background-color: transparent;")
        percentage_edit_layout = QHBoxLayout(self.percentage_edit_frame)
        percentage_edit_layout.setContentsMargins(0, 5, 0, 0)
        self.selected_owner_for_pct_label = QLabel("Edit % for:")
        self.selected_owner_for_pct_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-right: 5px;"
        )
        self.edit_owner_percentage_spinbox = QDoubleSpinBox()
        self.edit_owner_percentage_spinbox.setRange(0.00, 100.00)
        self.edit_owner_percentage_spinbox.setDecimals(2)
        self.edit_owner_percentage_spinbox.setSuffix(" %")
        self.edit_owner_percentage_spinbox.setStyleSheet(self._get_input_style())
        self.edit_owner_percentage_spinbox.setFixedWidth(100)
        self.save_owner_percentage_btn = QPushButton("💾 Save %")
        self.save_owner_percentage_btn.setStyleSheet(
            self._get_generic_button_style().replace(
                DARK_BUTTON_BG, DARK_SUCCESS_ACTION
            )
        )
        percentage_edit_layout.addWidget(self.selected_owner_for_pct_label)
        percentage_edit_layout.addWidget(self.edit_owner_percentage_spinbox)
        percentage_edit_layout.addWidget(self.save_owner_percentage_btn)
        percentage_edit_layout.addStretch()
        main_layout.addWidget(self.percentage_edit_frame)
        self.percentage_edit_frame.hide()

    def _setup_connections(self):
        self.current_owners_list_widget.itemSelectionChanged.connect(
            self._on_horse_owner_selection_changed
        )
        self.create_link_owner_btn.clicked.connect(self._handle_create_and_link_owner)
        self.link_existing_owner_btn.clicked.connect(self._handle_link_existing_owner)
        self.remove_horse_owner_btn.clicked.connect(
            self._handle_remove_owner_from_horse
        )
        self.save_owner_percentage_btn.clicked.connect(
            self._handle_save_owner_percentage
        )

    def load_owners_for_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.current_owners_list_widget.clear()
        self.selected_horse_owner_assoc_id = None
        self.current_horse_owners_assoc = []
        if self.current_horse and self.current_horse.horse_id is not None:
            self.logger.debug(
                f"Populating owners for horse ID {self.current_horse.horse_id}"
            )
            self.current_horse_owners_assoc = self.horse_controller.get_horse_owners(
                self.current_horse.horse_id
            )
            for owner_assoc_data in self.current_horse_owners_assoc:
                item_text = f"{owner_assoc_data.get('owner_name', 'N/A')} - {owner_assoc_data.get('percentage_ownership', 0.0):.2f}%"
                list_item = QListWidgetItem(item_text)
                list_item.setData(
                    Qt.ItemDataRole.UserRole, owner_assoc_data.get("owner_id")
                )
                self.current_owners_list_widget.addItem(list_item)
        else:
            self.logger.debug("No current horse or horse ID to load owners for.")
        self.percentage_edit_frame.hide()
        self.update_buttons_state()

    def _on_horse_owner_selection_changed(self):
        selected_items = self.current_owners_list_widget.selectedItems()
        if selected_items:
            list_item = selected_items[0]
            self.selected_horse_owner_assoc_id = list_item.data(
                Qt.ItemDataRole.UserRole
            )
            self.logger.info(f"Owner ID {self.selected_horse_owner_assoc_id} selected.")
            assoc_data = next(
                (
                    ho
                    for ho in self.current_horse_owners_assoc
                    if ho["owner_id"] == self.selected_horse_owner_assoc_id
                ),
                None,
            )
            if assoc_data:
                self.edit_owner_percentage_spinbox.setValue(
                    assoc_data.get("percentage_ownership", 0.0)
                )
                self.selected_owner_for_pct_label.setText(
                    f"Edit % for: {assoc_data.get('owner_name','N/A')}"
                )
                self.percentage_edit_frame.show()
            else:
                self.logger.warning(
                    f"No data for selected owner ID {self.selected_horse_owner_assoc_id}"
                )
                self.percentage_edit_frame.hide()
        else:
            self.selected_horse_owner_assoc_id = None
            self.percentage_edit_frame.hide()
            self.logger.info("Owner selection cleared.")
        self.update_buttons_state()

    def _validate_total_ownership_for_dialog(
        self,
        owner_id_being_changed: Optional[int],
        new_percentage_for_this_owner: float,
    ) -> bool:
        """Called by dialogs to validate total ownership before they accept."""
        if not self.current_horse:
            return False
        current_total_other_owners = Decimal("0.00")
        for assoc in self.current_horse_owners_assoc:
            if (
                owner_id_being_changed is not None
                and assoc.get("owner_id") == owner_id_being_changed
            ):
                continue
            current_total_other_owners += Decimal(
                str(assoc.get("percentage_ownership", 0.0))
            )

        prospective_total = current_total_other_owners + Decimal(
            str(new_percentage_for_this_owner)
        )
        self.logger.debug(
            f"Dialog validation: Others total={current_total_other_owners}, New%={new_percentage_for_this_owner}, Prospective={prospective_total}"
        )
        if prospective_total > Decimal("100.00"):
            msg = (
                f"Total ownership cannot exceed 100%.\n"
                f"Other owners: {current_total_other_owners:.2f}%\n"
                f"This owner: {new_percentage_for_this_owner:.2f}%\n"
                f"Resulting total: {prospective_total:.2f}%"
            )
            QMessageBox.warning(
                self.parent_view, "Ownership Error", msg
            )  # Show error via parent_view
            return False
        return True

    def _handle_create_and_link_owner(self):
        if not self.current_horse:
            self.parent_view.show_warning("Add Owner", "Select horse first.")
            return
        self.logger.info(
            f"Initiating Create & Link Owner for: {self.current_horse.horse_name}"
        )

        # Pass the validation method to the dialog
        dialog = CreateAndLinkOwnerDialog(
            self,
            self.current_horse.horse_name or "Selected Horse",
            self.current_user_login,
            total_ownership_validator=self._validate_total_ownership_for_dialog,  # Pass callback
        )
        if (
            dialog.exec() == QDialog.DialogCode.Accepted
        ):  # Dialog only accepts if ALL validation (incl. total %) passed
            data = dialog.get_data()
            if (
                data
                and data.get("owner_details")
                and data.get("percentage") is not None
            ):
                owner_details, percentage = data["owner_details"], data["percentage"]
                self.logger.info(
                    f"Dialog OK. Owner: {owner_details}, Percentage: {percentage}"
                )
                # Total ownership validation already done by the dialog via callback
                success_create, msg_create, new_owner_obj = (
                    self.owner_controller.create_master_owner(
                        owner_details, self.current_user_login
                    )
                )
                if (
                    success_create
                    and new_owner_obj
                    and self.current_horse
                    and self.current_horse.horse_id is not None
                ):
                    success_link, msg_link = self.horse_controller.add_owner_to_horse(
                        self.current_horse.horse_id,
                        new_owner_obj.owner_id,
                        percentage,
                        self.current_user_login,
                    )
                    if success_link:
                        self.parent_view.show_info("Owner Linked", msg_link)
                        self.load_owners_for_horse(self.current_horse)
                        self.owner_association_changed.emit(msg_link)
                    else:
                        self.parent_view.show_error("Link Error", msg_link)
                else:
                    self.parent_view.show_error(
                        "Create Error", msg_create or "Could not create owner."
                    )
            else:
                self.logger.warning("Create dialog accepted, but no valid data.")
                self.parent_view.show_warning("Data Error", "No data from form.")
        else:
            self.logger.info("Create & link owner dialog cancelled.")

    def _handle_link_existing_owner(self):
        if not self.current_horse:
            self.parent_view.show_warning("Link Owner", "Select horse first.")
            return
        self.logger.info(
            f"Initiating Link Existing Owner for: {self.current_horse.horse_name}"
        )

        # LinkExistingOwnerDialog needs similar modification to accept validator
        # For now, we'll keep its internal validation and add OwnersTab validation after it closes.
        # This means if total % validation fails, user has to re-open LinkExistingOwnerDialog.
        # Ideal solution: Modify LinkExistingOwnerDialog to also take the callback.

        dialog = LinkExistingOwnerDialog(
            self, self.current_horse.horse_name or "Selected Horse"
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_data()
            if (
                data
                and data.get("owner_id") is not None
                and data.get("percentage") is not None
                and self.current_horse
                and self.current_horse.horse_id is not None
            ):
                owner_id, percentage = data["owner_id"], data["percentage"]
                self.logger.info(
                    f"Linking owner ID {owner_id} with {percentage}% to horse ID {self.current_horse.horse_id}"
                )

                # Perform total ownership validation AFTER dialog closes for this dialog type (can be improved)
                if not self._validate_total_ownership_for_dialog(None, percentage):
                    # User has to click "Link Existing Owner" again if this fails.
                    return

                success_link, msg_link = self.horse_controller.add_owner_to_horse(
                    self.current_horse.horse_id,
                    owner_id,
                    percentage,
                    self.current_user_login,
                )
                if success_link:
                    self.parent_view.show_info("Owner Linked", msg_link)
                    self.load_owners_for_horse(self.current_horse)
                    self.owner_association_changed.emit(msg_link)
                else:
                    self.parent_view.show_error("Link Error", msg_link)
            else:
                self.logger.warning("No data from link dialog.")
                self.parent_view.show_warning("Data Error", "No selection from form.")
        else:
            self.logger.info("Link existing owner dialog cancelled.")

    def _handle_save_owner_percentage(self):
        if (
            not self.current_horse
            or self.current_horse.horse_id is None
            or self.selected_horse_owner_assoc_id is None
        ):
            self.parent_view.show_warning(
                "Save %", "Select horse and owner to update %."
            )
            return
        new_percentage = self.edit_owner_percentage_spinbox.value()

        # VALIDATION using the dialog-focused validator
        if not self._validate_total_ownership_for_dialog(
            self.selected_horse_owner_assoc_id, new_percentage
        ):
            return  # Error message already shown by validator

        self.logger.info(
            f"Updating % for owner ID {self.selected_horse_owner_assoc_id} on horse ID {self.current_horse.horse_id} to {new_percentage}%"
        )
        success, message = self.horse_controller.update_horse_owner_percentage(
            self.current_horse.horse_id,
            self.selected_horse_owner_assoc_id,
            new_percentage,
            self.current_user_login,
        )
        if success:
            self.parent_view.show_info("Percentage Updated", message)
            self.load_owners_for_horse(self.current_horse)
            self.owner_association_changed.emit(message)
        else:
            self.parent_view.show_error("Update % Error", message)

    def _handle_remove_owner_from_horse(self):
        # (Same as v1.2.4 - no percentage validation needed for removal)
        if (
            not self.current_horse
            or self.current_horse.horse_id is None
            or self.selected_horse_owner_assoc_id is None
        ):
            warn_msg = "Select horse and owner from list."
            if hasattr(self.parent_view, "show_warning"):
                self.parent_view.show_warning("Remove Owner", warn_msg)
            else:
                QMessageBox.warning(self, "Remove Owner", warn_msg)
                return
        owner_id_to_remove = self.selected_horse_owner_assoc_id
        owner_display_name = f"Owner ID {owner_id_to_remove}"
        for oa in self.current_horse_owners_assoc:
            if oa.get("owner_id") == owner_id_to_remove:
                owner_display_name = oa.get("owner_name", owner_display_name)
                break
        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        confirm_msg = (
            f"Remove owner '{owner_display_name}' from horse '{horse_name_display}'?"
        )
        proceed = False
        if hasattr(self.parent_view, "show_question"):
            proceed = self.parent_view.show_question("Confirm Removal", confirm_msg)
        else:
            proceed = (
                QMessageBox.question(
                    self,
                    "Confirm Removal",
                    confirm_msg,
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No,
                )
                == QMessageBox.StandardButton.Yes
            )
        if proceed:
            self.logger.info(
                f"Confirmed removal of owner ID {owner_id_to_remove} from horse ID {self.current_horse.horse_id}"
            )
            success, message = self.horse_controller.remove_owner_from_horse(
                self.current_horse.horse_id, owner_id_to_remove, self.current_user_login
            )
            if success:
                if hasattr(self.parent_view, "show_info"):
                    self.parent_view.show_info("Owner Removed", message)
                else:
                    QMessageBox.information(self, "Owner Removed", message)
                self.load_owners_for_horse(self.current_horse)
                self.owner_association_changed.emit(message)
            else:
                if hasattr(self.parent_view, "show_error"):
                    self.parent_view.show_error("Remove Error", message)
                else:
                    QMessageBox.critical(self, "Remove Error", message)
        else:
            self.logger.info("Owner removal cancelled.")

    def update_buttons_state(self):
        # (Same as v1.2.4)
        is_horse_selected = (
            self.current_horse is not None and self.current_horse.horse_id is not None
        )
        is_owner_in_list_selected = self.selected_horse_owner_assoc_id is not None
        self.create_link_owner_btn.setEnabled(is_horse_selected)
        self.link_existing_owner_btn.setEnabled(is_horse_selected)
        self.remove_horse_owner_btn.setEnabled(
            is_horse_selected and is_owner_in_list_selected
        )
        self.save_owner_percentage_btn.setEnabled(
            is_horse_selected and is_owner_in_list_selected
        )
        self.percentage_edit_frame.setVisible(
            is_horse_selected and is_owner_in_list_selected
        )

--- End File: views/horse/tabs/owners_tab.py ---

--- File: views/horse/tabs/location_tab.py ---
# views/horse/tabs/location_tab.py
"""
EDSI Veterinary Management System - Horse Location Tab
Version: 1.0.1
Purpose: Manages the assignment of a single location to a horse.
         - Modified assign/remove location logic to call HorseController for
           database persistence BEFORE emitting location_assignment_changed signal,
           ensuring data integrity and proper UI updates in parent views.
Last Updated: May 25, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-05-25):
    - Refactored `_assign_location_to_horse`: Now calls
      `horse_controller.assign_horse_to_location` to save the assignment
      to the database. Emits `location_assignment_changed` only on successful save.
      Updates local UI based on controller success.
    - Refactored `_handle_remove_location_link`: Now calls
      `horse_controller.remove_horse_from_location` to update the database.
      Emits `location_assignment_changed` (with None for location) only on
      successful removal. Updates local UI based on controller success.
    - Ensured user feedback (info/error messages) is provided based on the
      outcome of controller operations.
- v1.0.0 (2025-05-20):
    - Initial implementation.
    - UI with current location display (QLabel).
    - Buttons: "Create New & Link Location", "Link Existing Location", "Remove Location Link".
    - Integrates AddEditLocationDialog and SelectExistingLocationDialog.
    - Emits location_assignment_changed(location_id: Optional[int], location_name: Optional[str]) signal.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFrame,
    QDialog,
    QMessageBox,  # Explicitly imported for clarity, though parent_view might handle
)
from PySide6.QtCore import Qt, Signal

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_SUCCESS_ACTION,
    DARK_PRIMARY_ACTION,
    DARK_DANGER_ACTION,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
)
from models import (
    Horse,
)  # LocationModel not directly used here, controller returns names/ids
from controllers.horse_controller import HorseController
from controllers.location_controller import LocationController
from views.admin.dialogs.add_edit_location_dialog import AddEditLocationDialog
from views.horse.dialogs.select_existing_location_dialog import (
    SelectExistingLocationDialog,
)


class LocationTab(QWidget):
    """Tab widget for managing a horse's single assigned location."""

    location_assignment_changed = Signal(
        object
    )  # Emits a dict: {'id': Optional[int], 'name': Optional[str]}

    def __init__(
        self,
        parent_view,
        horse_controller: HorseController,
        location_controller: LocationController,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_controller = horse_controller
        self.location_controller = location_controller

        self.current_horse: Optional[Horse] = None
        self._current_location_id: Optional[int] = None
        self._current_location_name: str = "N/A"

        self.current_user_login = "UnknownUser"
        if hasattr(self.parent_view, "current_user") and self.parent_view.current_user:
            self.current_user_login = self.parent_view.current_user
        else:
            self.logger.warning(
                "Could not determine current_user for LocationTab auditing."
            )

        self.setStyleSheet(f"background-color: {DARK_WIDGET_BACKGROUND};")
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(15)

        self._setup_ui(main_layout)
        self._setup_connections()
        self.update_buttons_state()

    def _get_generic_button_style(self) -> str:
        if hasattr(self.parent_view, "get_generic_button_style"):
            return self.parent_view.get_generic_button_style()
        return (
            f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_ui(self, main_layout: QVBoxLayout):
        location_display_frame = QFrame()
        location_display_frame.setStyleSheet("background-color: transparent;")
        location_display_layout = QHBoxLayout(location_display_frame)
        location_display_layout.setContentsMargins(0, 0, 0, 10)

        current_location_title_label = QLabel("Currently Assigned Location:")
        current_location_title_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-weight: bold; background: transparent;"
        )
        self.current_location_display_label = QLabel(self._current_location_name)
        self.current_location_display_label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 14px; background-color: {DARK_INPUT_FIELD_BACKGROUND}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; min-height: 22px;"
        )
        self.current_location_display_label.setWordWrap(True)

        location_display_layout.addWidget(current_location_title_label)
        location_display_layout.addWidget(self.current_location_display_label, 1)
        main_layout.addWidget(location_display_frame)

        action_buttons_layout = QHBoxLayout()
        self.create_link_location_btn = QPushButton("➕ Create New & Assign Location")
        self.link_existing_location_btn = QPushButton("🔗 Assign Existing Location")
        self.remove_location_link_btn = QPushButton("➖ Clear Assigned Location")

        button_style = self._get_generic_button_style()
        self.create_link_location_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_SUCCESS_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        self.link_existing_location_btn.setStyleSheet(
            button_style.replace(
                DARK_BUTTON_BG, DARK_PRIMARY_ACTION
            )  # Assuming default text color is fine
        )
        self.remove_location_link_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_DANGER_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )

        action_buttons_layout.addWidget(self.create_link_location_btn)
        action_buttons_layout.addWidget(self.link_existing_location_btn)
        action_buttons_layout.addWidget(self.remove_location_link_btn)
        action_buttons_layout.addStretch()
        main_layout.addLayout(action_buttons_layout)
        main_layout.addStretch(1)

    def _setup_connections(self):
        self.create_link_location_btn.clicked.connect(
            self._handle_create_and_link_location
        )
        self.link_existing_location_btn.clicked.connect(
            self._handle_link_existing_location
        )
        self.remove_location_link_btn.clicked.connect(self._handle_remove_location_link)

    def load_location_for_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.logger.debug(
            f"LocationTab: Loading location for horse: {horse.horse_name if horse else 'None'}"
        )
        if self.current_horse and self.current_horse.horse_id is not None:
            # The horse object passed might already be eager-loaded by HorseUnifiedManagement
            # If not, self.horse_controller.get_horse_by_id() would re-fetch.
            # For consistency, let's use the passed horse object directly if its location is loaded.
            # If horse.location is not loaded, then a fresh fetch might be needed,
            # but this should ideally be handled by the caller providing a fully loaded horse.

            # Let's assume the passed 'horse' object has its .location eager-loaded
            # by HorseUnifiedManagement calling HorseController.get_horse_by_id().
            self._current_location_id = self.current_horse.current_location_id
            if self.current_horse.location and hasattr(
                self.current_horse.location, "location_name"
            ):
                self._current_location_name = (
                    self.current_horse.location.location_name or "N/A"
                )
            else:
                self._current_location_name = (
                    "N/A"  # If location object is None or no name
                )

            self.logger.debug(
                f"LocationTab: Horse ID {self.current_horse.horse_id}, "
                f"current_location_id: {self._current_location_id}, "
                f"current_location_name: '{self._current_location_name}'"
            )
        else:
            self._current_location_id = None
            self._current_location_name = "N/A (No horse selected)"
            self.logger.debug("LocationTab: No current horse, location set to N/A.")

        self.current_location_display_label.setText(self._current_location_name)
        self.update_buttons_state()

    def _handle_create_and_link_location(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Assign Location", "Please select a horse first."
            )
            return
        self.logger.info(
            f"Initiating Create & Assign New Location for horse: {self.current_horse.horse_name}"
        )

        dialog = AddEditLocationDialog(
            self.parent_view,
            self.location_controller,
            self.current_user_login,
            location=None,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # IMPORTANT: AddEditLocationDialog must be modified to return the created location's ID and name
            # For example, by adding methods like dialog.get_created_location_id() and dialog.get_created_location_name()
            created_location_id = getattr(
                dialog, "created_location_id", None
            )  # Hypothetical
            created_location_name = getattr(
                dialog, "created_location_name", None
            )  # Hypothetical

            if created_location_id is not None and created_location_name is not None:
                self.logger.info(
                    f"New location created: ID {created_location_id}, Name '{created_location_name}'. Assigning to horse."
                )
                self._assign_location_to_horse(
                    created_location_id, created_location_name
                )
            else:
                self.logger.warning(
                    "AddEditLocationDialog did not return created location details. User may need to assign manually."
                )
                self.parent_view.show_info(
                    "Location Created",
                    "New location created. If not automatically assigned, please use 'Assign Existing Location' to link it.",
                )
        else:
            self.logger.info("Create & Assign New Location dialog cancelled.")

    def _handle_link_existing_location(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Assign Location", "Please select a horse first."
            )
            return
        self.logger.info(
            f"Initiating Assign Existing Location for horse: {self.current_horse.horse_name}"
        )

        dialog = SelectExistingLocationDialog(
            self.parent_view, self.current_horse.horse_name or "Selected Horse"
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_id = dialog.get_selected_location_id()
            if selected_id is not None:
                # Fetch location details to get the name for UI update and signal
                loc_obj = self.location_controller.get_location_by_id(selected_id)
                if loc_obj and hasattr(loc_obj, "location_name"):
                    self._assign_location_to_horse(
                        loc_obj.location_id, loc_obj.location_name
                    )
                else:
                    self.parent_view.show_error(
                        "Error",
                        f"Could not retrieve details for Location ID {selected_id}.",
                    )
            else:
                self.parent_view.show_warning(
                    "Assign Location", "No location was selected."
                )
        else:
            self.logger.info("Assign Existing Location dialog cancelled.")

    def _assign_location_to_horse(self, location_id: int, location_name: str):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.logger.error("No current horse to assign location to.")
            self.parent_view.show_error(
                "Error", "No horse selected to assign location."
            )
            return

        self.logger.info(
            f"Attempting to assign Location ID {location_id} ('{location_name}') to Horse ID {self.current_horse.horse_id}"
        )

        # Call controller to persist the change
        success, message = self.horse_controller.assign_horse_to_location(
            horse_id=self.current_horse.horse_id,
            location_id=location_id,
            notes=None,  # Or add a notes field to this tab/dialog if needed
            modified_by_user=self.current_user_login,
        )

        if success:
            self._current_location_id = location_id
            self._current_location_name = location_name
            self.current_location_display_label.setText(self._current_location_name)

            self.logger.info(
                f"Successfully assigned Location ID {location_id} to Horse ID {self.current_horse.horse_id}. Emitting signal."
            )
            self.location_assignment_changed.emit(
                {"id": location_id, "name": location_name}
            )
            self.parent_view.show_info(
                "Location Assigned", message
            )  # Use message from controller
        else:
            self.logger.error(f"Failed to assign location: {message}")
            self.parent_view.show_error("Assignment Failed", message)

        self.update_buttons_state()

    def _handle_remove_location_link(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Clear Location", "Please select a horse first."
            )
            return
        if self._current_location_id is None:  # Check local state first
            self.parent_view.show_info(
                "Clear Location", "No location is currently assigned to this horse."
            )
            return

        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        if self.parent_view.show_question(
            "Confirm Clear Location",
            f"Are you sure you want to clear the location assignment for horse '{horse_name_display}'?",
        ):
            self.logger.info(
                f"Attempting to clear location for horse ID {self.current_horse.horse_id}, current loc ID: {self._current_location_id}"
            )

            success, message = self.horse_controller.remove_horse_from_location(
                horse_id=self.current_horse.horse_id,
                location_id=self._current_location_id,  # Pass current location ID to ensure correct history update
                modified_by_user=self.current_user_login,
            )

            if success:
                self._current_location_id = None
                self._current_location_name = "N/A"
                self.current_location_display_label.setText(self._current_location_name)

                self.logger.info(
                    f"Successfully cleared location for Horse ID {self.current_horse.horse_id}. Emitting signal."
                )
                self.location_assignment_changed.emit({"id": None, "name": "N/A"})
                self.parent_view.show_info(
                    "Location Cleared", message
                )  # Use message from controller
            else:
                self.logger.error(f"Failed to clear location: {message}")
                self.parent_view.show_error("Clear Location Failed", message)

            self.update_buttons_state()
        else:
            self.logger.info("Clear location assignment cancelled by user.")

    def update_buttons_state(self):
        is_horse_selected = (
            self.current_horse is not None and self.current_horse.horse_id is not None
        )
        is_location_assigned = self._current_location_id is not None

        self.create_link_location_btn.setEnabled(is_horse_selected)
        self.link_existing_location_btn.setEnabled(is_horse_selected)
        self.remove_location_link_btn.setEnabled(
            is_horse_selected and is_location_assigned
        )

--- End File: views/horse/tabs/location_tab.py ---

--- File: main.py ---
# main.py

"""
EDSI Veterinary Management System - Main Application Entry Point
Version: 2.0.5
Purpose: Simplified main application with clean Splash -> Login -> Horse Management flow.
         Corrected UserManagementScreen instantiation to pass current_user_id.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Gemini, further modified by Coding partner)

Changelog:
- v2.0.5 (2025-05-26):
    - Modified UserManagementScreen() instantiation in show_user_management_screen
      to pass 'current_user_id' as a positional argument.
- v2.0.4 (2025-05-26):
    - Removed `current_user` keyword argument from `UserManagementScreen()` instantiation.
# ... (previous changelog entries)
"""

import sys
import os
import logging
from logging.handlers import RotatingFileHandler
from typing import Optional
import traceback

from PySide6.QtWidgets import (
    QApplication,
    QMessageBox,
    QDialog,
)
from PySide6.QtCore import (
    Qt,
)
from sqlalchemy import text

project_root = os.path.abspath(os.path.join(os.path.dirname(__file__)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from config.database_config import db_manager
from config.app_config import AppConfig
from views.auth.splash_screen import SplashScreen
from views.auth.small_login_dialog import SmallLoginDialog
from views.horse.horse_unified_management import HorseUnifiedManagement
from views.admin.user_management_screen import UserManagementScreen

exception_logger = logging.getLogger("GlobalExceptionHook")


def global_exception_hook(exctype, value, tb):
    """Handle uncaught exceptions globally"""
    formatted_traceback = "".join(traceback.format_exception(exctype, value, tb))
    exception_logger.critical(
        f"Unhandled exception: {exctype.__name__}: {value}\n{formatted_traceback}",
        exc_info=(exctype, value, tb),
    )
    app_instance = QApplication.instance()
    if app_instance:
        QMessageBox.critical(
            None,
            "Critical Application Error",
            f"A critical error occurred: {value}\n\nPlease check logs for details.",
        )


class EDSIApplication(QApplication):
    def __init__(self):
        super().__init__(sys.argv)
        sys.excepthook = global_exception_hook
        self.current_user_id: Optional[str] = None  # Ensure this is set at login
        self.splash_screen: Optional[SplashScreen] = None
        self.login_dialog: Optional[SmallLoginDialog] = None
        self.horse_management_screen: Optional[HorseUnifiedManagement] = None
        self.user_management_screen: Optional[UserManagementScreen] = None
        self.active_screen_name: Optional[str] = None
        self.setup_logging()
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"Starting {AppConfig.APP_NAME} v{AppConfig.APP_VERSION}")
        self.logger.info(f"Python version: {sys.version}")  # Log Python version
        self.logger.info(
            f"PySide6 version: {self.applicationVersion()}"
        )  # Log PySide6/Qt version
        self.setApplicationName(AppConfig.APP_NAME)
        self.setApplicationVersion(AppConfig.APP_VERSION)
        self.setOrganizationName("EDSI")
        AppConfig.ensure_directories()
        self.initialize_database()
        self.show_splash_screen()

    def setup_logging(self):
        log_config = AppConfig.get_logging_config()
        if not os.path.exists(log_config["log_dir"]):
            try:
                os.makedirs(log_config["log_dir"])
            except OSError as e:
                print(f"Error creating log directory: {e}", file=sys.stderr)
                logging.basicConfig(
                    level=log_config["level"],
                    format="%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s",
                    handlers=[logging.StreamHandler(sys.stdout)],
                )
                logging.warning(
                    "Log directory creation failed. Logging to console only."
                )
                return
        root_logger = logging.getLogger()
        root_logger.setLevel(log_config["level"])
        if root_logger.hasHandlers():
            root_logger.handlers.clear()
        formatter = logging.Formatter(
            "%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s"
        )
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(formatter)
        root_logger.addHandler(console_handler)
        try:
            file_handler = RotatingFileHandler(
                log_config["app_log_file"],
                maxBytes=log_config["log_max_bytes"],
                backupCount=log_config["log_backup_count"],
                encoding="utf-8",
            )
            file_handler.setFormatter(formatter)
            root_logger.addHandler(file_handler)
            logging.info("Logging configured (Console and File)")
        except Exception as e:
            print(f"Error setting up file logger: {e}", file=sys.stderr)
            logging.info("Logging configured (Console only due to file handler error)")

    def initialize_database(self):
        self.logger.info("Initializing database...")
        try:
            db_manager.initialize_database()
            with db_manager.get_session() as session:
                session.execute(text("SELECT 1"))
            self.logger.info("Database initialized successfully")
        except Exception as e:
            self.logger.critical(f"Database initialization failed: {e}", exc_info=True)
            QMessageBox.critical(
                None,
                "Database Error",
                f"Failed to initialize database: {e}\n\nThe application will exit.",
            )
            sys.exit(1)

    def show_splash_screen(self):
        self.logger.info("Showing splash screen")
        self._cleanup_screens(keep_main=False)
        self.splash_screen = SplashScreen()
        self.splash_screen.login_requested.connect(self.show_login_dialog)
        self.splash_screen.exit_requested.connect(self.quit_application)
        self.splash_screen.show()

    def show_login_dialog(self):
        self.logger.info("Showing login dialog")
        if self.login_dialog and self.login_dialog.isVisible():
            self.login_dialog.raise_()
            self.login_dialog.activateWindow()
            return
        parent_widget = (
            self.splash_screen
            if self.splash_screen and self.splash_screen.isVisible()
            else None
        )
        self.login_dialog = SmallLoginDialog(parent=parent_widget)
        self.login_dialog.login_successful.connect(self.handle_login_success)
        self.login_dialog.dialog_closed.connect(self.handle_login_dialog_closed)
        self.login_dialog.setModal(True)
        self.login_dialog.show()

    def handle_login_success(self, user_id: str):  # user_id here is typically username
        self.current_user_id = user_id  # Store the logged-in user's identifier
        self.logger.info(f"User '{user_id}' logged in successfully")
        if self.login_dialog:
            try:
                self.login_dialog.login_successful.disconnect(self.handle_login_success)
                self.login_dialog.dialog_closed.disconnect(
                    self.handle_login_dialog_closed
                )
            except RuntimeError:
                self.logger.debug("Slots already disconnected from login_dialog.")
            self.login_dialog.close()
            self.login_dialog.deleteLater()
            self.login_dialog = None
        if self.splash_screen:
            self.splash_screen.close()
            self.splash_screen.deleteLater()
            self.splash_screen = None
        self.show_horse_management_screen()

    def handle_login_dialog_closed(self):
        self.logger.debug("Login dialog closed signal received.")
        if not self.current_user_id:
            if self.login_dialog:
                self.login_dialog.deleteLater()
                self.login_dialog = None
            if not (self.splash_screen and self.splash_screen.isVisible()):
                self.logger.info("Login dialog closed, no splash. Returning to splash.")
                self.show_splash_screen()
            else:
                self.logger.info("Login dialog closed. Splash screen remains active.")

    def show_horse_management_screen(self):
        if not self.current_user_id:
            self.logger.warning("Attempted to show Horse Management without login.")
            self.show_splash_screen()
            return
        self.logger.info(
            f"Showing Horse Management screen for user: {self.current_user_id}"
        )
        self._cleanup_screens(keep_main=False)
        self.horse_management_screen = HorseUnifiedManagement(
            current_user=self.current_user_id
        )  # Pass user_id
        self.active_screen_name = "Horse Management"
        self.horse_management_screen.exit_requested.connect(self.handle_logout)
        self.horse_management_screen.closing.connect(self.on_main_screen_closing)
        self.horse_management_screen.setup_requested.connect(
            self.show_user_management_screen
        )
        self.horse_management_screen.show()
        self.logger.info("Horse Management Screen shown.")

    def show_user_management_screen(self):
        self.logger.info(
            "Setup icon clicked, attempting to show User Management Screen."
        )
        if not self.current_user_id:
            self.logger.error("Cannot show User Management Screen: No user logged in.")
            QMessageBox.warning(
                None,
                "Authentication Error",
                "No user is currently logged in. Please log in to access setup.",
            )
            return

        if self.user_management_screen and self.user_management_screen.isVisible():
            self.logger.info(
                "User Management Screen is already visible. Activating and raising."
            )
            self.user_management_screen.activateWindow()
            self.user_management_screen.raise_()
            return
        if self.user_management_screen:
            self.logger.info("Re-showing existing User Management Screen instance.")
            self.user_management_screen.show()
            self.user_management_screen.activateWindow()
            self.user_management_screen.raise_()
            return

        self.logger.info("Creating new User Management Screen instance.")
        # MODIFIED: Pass current_user_id as the first positional argument
        self.user_management_screen = UserManagementScreen(self.current_user_id)

        self.user_management_screen.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose)
        self.user_management_screen.destroyed.connect(
            self.handle_user_management_destroyed
        )

        self.user_management_screen.show()
        self.logger.info("User Management Screen shown.")

    def handle_user_management_destroyed(self):
        self.logger.info(
            "User Management Screen was closed and its instance destroyed."
        )
        self.user_management_screen = None

    def handle_logout(self):
        active_user = self.current_user_id or "Unknown user"
        screen_name = self.active_screen_name or "current screen"
        self.logger.info(f"User '{active_user}' logging out from {screen_name}.")
        self.current_user_id = None
        self.active_screen_name = None
        self.logger.info("Logout requested. Application will now exit.")
        self.quit_application()

    def on_main_screen_closing(self):
        self.logger.info("Main application screen (Horse Management) is closing.")
        if self.current_user_id:
            self.logger.info("Main screen closed by user; initiating application quit.")
            self.quit_application()

    def quit_application(self):
        self.logger.info("Application quit requested.")
        self._cleanup_screens(keep_main=False)
        self.quit()

    def _cleanup_screens(self, keep_main: bool = False):
        self.logger.debug(f"Cleanup screens called. Keep main: {keep_main}")
        if self.user_management_screen:
            self.logger.debug("Cleaning up User Management Screen.")
            try:
                self.user_management_screen.destroyed.disconnect(
                    self.handle_user_management_destroyed
                )
            except RuntimeError:
                pass
            self.user_management_screen.close()
            self.user_management_screen = None
        if self.splash_screen:
            try:
                self.splash_screen.login_requested.disconnect(self.show_login_dialog)
                self.splash_screen.exit_requested.disconnect(self.quit_application)
            except RuntimeError:
                pass
            self.splash_screen.close()
            self.splash_screen.deleteLater()
            self.splash_screen = None
            self.logger.debug("Splash screen cleaned up.")
        if self.login_dialog:
            try:
                self.login_dialog.login_successful.disconnect(self.handle_login_success)
                self.login_dialog.dialog_closed.disconnect(
                    self.handle_login_dialog_closed
                )
            except RuntimeError:
                pass
            self.login_dialog.close()
            self.login_dialog.deleteLater()
            self.login_dialog = None
            self.logger.debug("Login dialog cleaned up.")
        if not keep_main and self.horse_management_screen:
            self.logger.debug("Cleaning up Horse Management Screen.")
            try:
                self.horse_management_screen.exit_requested.disconnect(
                    self.handle_logout
                )
                self.horse_management_screen.closing.disconnect(
                    self.on_main_screen_closing
                )
                self.horse_management_screen.setup_requested.disconnect(
                    self.show_user_management_screen
                )
            except RuntimeError:
                pass
            self.horse_management_screen.close()
            self.horse_management_screen.deleteLater()
            self.horse_management_screen = None
            self.logger.debug("Horse management screen cleaned up.")
        self.logger.debug("Screens cleanup finished.")

    def run(self):
        self.logger.info(f"Starting {AppConfig.APP_NAME} event loop")
        try:
            exit_code = self.exec()
            self.logger.info(f"Application finished with exit code: {exit_code}")
            return exit_code
        except Exception as e:
            self.logger.critical(f"Critical error in event loop: {e}", exc_info=True)
            QMessageBox.critical(
                None,
                "Fatal Error",
                f"A fatal error occurred in the application event loop: {e}\nPlease check logs.",
            )
            return 1


def main():
    if not os.path.exists(AppConfig.LOG_DIR):
        try:
            os.makedirs(AppConfig.LOG_DIR)
        except OSError as e:
            print(
                f"Could not create log directory: {AppConfig.LOG_DIR}. Error: {e}",
                file=sys.stderr,
            )
    try:
        app = EDSIApplication()
        exit_code = app.run()
        logging.info(f"Application exiting with code {exit_code}")
        sys.exit(exit_code)
    except Exception as e:
        critical_logger = logging.getLogger("main_entry_point")
        critical_logger.critical(
            f"Fatal error starting or running application: {e}", exc_info=True
        )
        try:
            if not QApplication.instance():
                QApplication(sys.argv)
            QMessageBox.critical(
                None,
                "Fatal Application Error",
                f"A fatal error occurred: {e}\nApplication will exit. Check logs.",
            )
        except Exception as mb_error:
            print(
                f"Could not display fatal error message box: {mb_error}",
                file=sys.stderr,
            )
        sys.exit(1)


if __name__ == "__main__":
    if not os.path.exists(AppConfig.LOG_DIR):
        try:
            os.makedirs(AppConfig.LOG_DIR)
        except:
            pass
    logging.basicConfig(
        level=AppConfig.LOGGING_LEVEL,
        format="%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)],
    )
    main_logger = logging.getLogger(__name__)
    main_logger.info("Application main script started.")
    main()
    main_logger.info("Application main script finished.")

--- End File: main.py ---

