=============== FILE: config\__init__.py ===============

# config/__init__.py

"""Configuration package"""


=============== FILE: config\app_config.py ===============

# config/app_config.py

"""
EDSI Veterinary Management System - Application Configuration
Version: 2.0.1
Purpose: Simplified centralized configuration for application settings, paths, and constants.
         Added missing logging parameters for file rotation and updated app version.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Coding partner)

Changelog:
- v2.0.1 (2025-05-26):
    - Added LOG_MAX_BYTES and LOG_BACKUP_COUNT constants for log file rotation.
    - Included log_max_bytes and log_backup_count in the get_logging_config() dictionary.
    - Updated module-level APP_VERSION constant to "2.0.3" to align with main application.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Consolidated all configuration into single AppConfig class
    # ... (rest of previous changelog entries assumed present)
"""

import os
import logging
from typing import Dict, Any

# --- Project Paths ---
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
LOG_DIR = os.path.join(PROJECT_ROOT, "logs")
ASSETS_DIR = os.path.join(PROJECT_ROOT, "assets")

# --- Application Information ---
APP_NAME = "EDSI Veterinary Management System"
APP_VERSION = "2.0.3"  # <-- Updated Version
APP_AUTHOR = "EDSI"

# --- Database Configuration ---
DATABASE_URL = f"sqlite:///{os.path.join(PROJECT_ROOT, 'edsi_database.db')}"

# --- Logging Configuration ---
APP_LOG_FILE = os.path.join(LOG_DIR, "edsi_app.log")
DB_LOG_FILE = os.path.join(
    LOG_DIR, "edsi_db.log"
)  # Retained, though not used by current main.py's app logger
LOGGING_LEVEL = logging.INFO
LOG_MAX_BYTES = 1024 * 1024 * 5  # <-- Added: 5 MB
LOG_BACKUP_COUNT = 5  # <-- Added: 5 backup files

# --- UI Configuration ---
DEFAULT_FONT_FAMILY = "Inter"
DEFAULT_FONT_SIZE = 10
SMALL_FONT_SIZE = 9
MIN_WINDOW_WIDTH = 900
MIN_WINDOW_HEIGHT = 700

# --- Dark Theme Colors (Essential Only) ---
DARK_BACKGROUND = "#2D3748"
DARK_WIDGET_BACKGROUND = "#1A202C"
# ... (all other color constants remain the same)
DARK_HEADER_FOOTER = "#222B38"
DARK_BORDER = "#4A5568"
DARK_TEXT_PRIMARY = "#E2E8F0"
DARK_TEXT_SECONDARY = "#A0AEC0"
DARK_TEXT_TERTIARY = "#718096"
DARK_PRIMARY_ACTION = "#3182CE"
DARK_SUCCESS_ACTION = "#38A169"
DARK_WARNING_ACTION = "#DD6B20"
DARK_DANGER_ACTION = "#E53E3E"
DARK_BUTTON_BG = "#4A5568"
DARK_BUTTON_HOVER = "#718096"
DARK_ITEM_HOVER = "#2C3543"
DARK_HIGHLIGHT_BG = "#3182CE"
DARK_HIGHLIGHT_TEXT = "#FFFFFF"
DARK_INPUT_FIELD_BACKGROUND = "#222B38"


class AppConfig:
    """
    Centralized application configuration class.
    Provides clean access to all application settings.
    """

    # Application Info
    APP_NAME = APP_NAME
    APP_VERSION = APP_VERSION  # Will now pick up "2.0.3"
    APP_AUTHOR = APP_AUTHOR

    # Paths
    PROJECT_ROOT = PROJECT_ROOT
    LOG_DIR = LOG_DIR
    ASSETS_DIR = ASSETS_DIR

    # Database
    DATABASE_URL = DATABASE_URL

    # Logging
    APP_LOG_FILE = APP_LOG_FILE
    DB_LOG_FILE = DB_LOG_FILE
    LOGGING_LEVEL = LOGGING_LEVEL
    LOG_MAX_BYTES = LOG_MAX_BYTES  # <-- Added Class Attribute
    LOG_BACKUP_COUNT = LOG_BACKUP_COUNT  # <-- Added Class Attribute

    # UI Settings
    DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY
    # ... (other UI settings remain the same)
    DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE
    SMALL_FONT_SIZE = SMALL_FONT_SIZE
    MIN_WINDOW_WIDTH = MIN_WINDOW_WIDTH
    MIN_WINDOW_HEIGHT = MIN_WINDOW_HEIGHT

    # Theme Colors
    DARK_BACKGROUND = DARK_BACKGROUND
    # ... (all color class attributes remain the same)
    DARK_WIDGET_BACKGROUND = DARK_WIDGET_BACKGROUND
    DARK_HEADER_FOOTER = DARK_HEADER_FOOTER
    DARK_BORDER = DARK_BORDER
    DARK_TEXT_PRIMARY = DARK_TEXT_PRIMARY
    DARK_TEXT_SECONDARY = DARK_TEXT_SECONDARY
    DARK_TEXT_TERTIARY = DARK_TEXT_TERTIARY
    DARK_PRIMARY_ACTION = DARK_PRIMARY_ACTION
    DARK_SUCCESS_ACTION = DARK_SUCCESS_ACTION
    DARK_WARNING_ACTION = DARK_WARNING_ACTION
    DARK_DANGER_ACTION = DARK_DANGER_ACTION
    DARK_BUTTON_BG = DARK_BUTTON_BG
    DARK_BUTTON_HOVER = DARK_BUTTON_HOVER
    DARK_ITEM_HOVER = DARK_ITEM_HOVER
    DARK_HIGHLIGHT_BG = DARK_HIGHLIGHT_BG
    DARK_HIGHLIGHT_TEXT = DARK_HIGHLIGHT_TEXT
    DARK_INPUT_FIELD_BACKGROUND = DARK_INPUT_FIELD_BACKGROUND

    @classmethod
    def get_database_url(cls) -> str:
        return cls.DATABASE_URL

    @classmethod
    def get_app_dir(cls) -> str:  # This method was duplicated, keeping one
        return cls.PROJECT_ROOT

    @classmethod
    def get_assets_dir(cls) -> str:
        return cls.ASSETS_DIR

    @classmethod
    def get_app_info(cls) -> Dict[str, str]:
        return {
            "name": cls.APP_NAME,
            "version": cls.APP_VERSION,
            "author": cls.APP_AUTHOR,
        }

    @classmethod
    def get_logging_config(cls) -> Dict[str, Any]:
        """Get logging configuration"""
        return {
            "level": cls.LOGGING_LEVEL,
            "app_log_file": cls.APP_LOG_FILE,
            "db_log_file": cls.DB_LOG_FILE,  # Retained
            "log_dir": cls.LOG_DIR,
            "log_max_bytes": cls.LOG_MAX_BYTES,  # <-- Added Key
            "log_backup_count": cls.LOG_BACKUP_COUNT,  # <-- Added Key
        }

    @classmethod
    def get_ui_config(cls) -> Dict[str, Any]:
        # ... (remains the same)
        return {
            "font_family": cls.DEFAULT_FONT_FAMILY,
            "font_size": cls.DEFAULT_FONT_SIZE,
            "small_font_size": cls.SMALL_FONT_SIZE,
            "min_window_width": cls.MIN_WINDOW_WIDTH,
            "min_window_height": cls.MIN_WINDOW_HEIGHT,
        }

    @classmethod
    def get_theme_colors(cls) -> Dict[str, str]:
        # ... (remains the same)
        return {
            "background": cls.DARK_BACKGROUND,
            "widget_background": cls.DARK_WIDGET_BACKGROUND,
            "header_footer": cls.DARK_HEADER_FOOTER,
            "border": cls.DARK_BORDER,
            "text_primary": cls.DARK_TEXT_PRIMARY,
            "text_secondary": cls.DARK_TEXT_SECONDARY,
            "text_tertiary": cls.DARK_TEXT_TERTIARY,
            "primary_action": cls.DARK_PRIMARY_ACTION,
            "success_action": cls.DARK_SUCCESS_ACTION,
            "warning_action": cls.DARK_WARNING_ACTION,
            "danger_action": cls.DARK_DANGER_ACTION,
            "button_bg": cls.DARK_BUTTON_BG,
            "button_hover": cls.DARK_BUTTON_HOVER,
            "item_hover": cls.DARK_ITEM_HOVER,
            "highlight_bg": cls.DARK_HIGHLIGHT_BG,
            "highlight_text": cls.DARK_HIGHLIGHT_TEXT,
            "input_field_background": cls.DARK_INPUT_FIELD_BACKGROUND,
        }

    @classmethod
    def ensure_directories(cls) -> None:
        """Ensure required directories exist"""
        directories = [cls.LOG_DIR, cls.ASSETS_DIR]

        for directory in directories:
            if not os.path.exists(directory):
                try:
                    os.makedirs(directory, exist_ok=True)
                    # Optionally log creation:
                    # logging.info(f"Created directory: {directory}")
                except OSError as e:
                    # Using print as logger might not be fully setup when this is called early
                    print(f"Warning: Could not create directory {directory}: {e}")


=============== FILE: config\database_config.py ===============

# config/database_config.py

"""
EDSI Veterinary Management System - Database Configuration
Version: 2.0.3 (Example version, update as needed)
Purpose: Simplified database connection and session management using SQLAlchemy.
         Ensures ADMIN user password is set using bcrypt via User.set_password(),
         with robust handling for pre-existing non-bcrypt hashes.
         Added new financial models to _import_models.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.3 (2025-06-04):
    - Added Transaction and Invoice from financial_models to _import_models method
      to ensure their tables are created by Base.metadata.create_all.
- v2.0.2 (2025-05-29):
    - Made _ensure_default_admin_user method more robust:
        - It now tries to check the ADMIN password using bcrypt.
        - If check_password fails (returns False or raises ValueError due to
          invalid hash format like old SHA256), it then calls
          user.set_password() to ensure the password becomes "admin1234"
          hashed with bcrypt.
        - This resolves the "ValueError: Invalid salt" during startup.
- v2.0.1 (2025-05-29):
    - Modified _ensure_default_admin_user method to use user.set_password()
      (which uses bcrypt) for the ADMIN user's password ("admin1234")
      instead of directly setting a SHA-256 hash.
    - Removed hashlib import as it's no longer used.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification.
"""

import logging
import os
from typing import Optional
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, scoped_session, Session as SQLAlchemySession
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.exc import SQLAlchemyError

from config.app_config import AppConfig

# Create Base for all models
Base = declarative_base()

# Setup logger
db_logger = logging.getLogger("database_operations")


class DatabaseManager:
    """
    Simplified database manager for EDSI application.
    Handles database initialization, session creation, and table management.
    """

    def __init__(self):
        self.engine = None
        self.SessionLocal: Optional[scoped_session[SQLAlchemySession]] = None
        self.db_url: Optional[str] = None
        self.logger = logging.getLogger(self.__class__.__name__)

    def initialize_database(self, db_url: Optional[str] = None) -> None:
        """
        Initialize database connection and create tables.
        """
        if self.engine:
            self.logger.info("Database already initialized")
            return

        self.db_url = db_url or AppConfig.get_database_url()
        if not self.db_url:
            raise ValueError("DATABASE_URL is not configured")

        self.logger.info(f"Initializing database: {self.db_url}")

        try:
            self.engine = create_engine(
                self.db_url,
                echo=False,  # Set to True for SQL logging, False for production
                pool_pre_ping=True,
            )

            self.SessionLocal = scoped_session(
                sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
            )

            self.logger.info("Database engine and session factory created")
            self.create_tables()
            self._test_connection()
            self._ensure_default_admin_user()
            self.logger.info("Database initialization completed successfully")

        except SQLAlchemyError as e:
            self.logger.error(f"SQLAlchemy error during database initialization: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error during database initialization: {e}")
            raise

    def get_session(self) -> SQLAlchemySession:
        """
        Get a database session.
        """
        if not self.SessionLocal:
            raise RuntimeError(
                "Database not initialized. Call initialize_database() first."
            )
        return self.SessionLocal()

    def create_tables(self) -> None:
        """
        Create all database tables.
        """
        if not self.engine:
            raise RuntimeError("Database engine not initialized")

        try:
            self.logger.info("Creating database tables...")
            self._import_models()  # This ensures all models are known to Base
            Base.metadata.create_all(bind=self.engine)
            table_names = list(Base.metadata.tables.keys())
            self.logger.info(f"Database tables created/verified: {table_names}")

        except Exception as e:
            self.logger.error(f"Error creating database tables: {e}")
            raise

    def _import_models(self) -> None:
        """
        Import all model classes to ensure they are registered with Base.
        This is crucial for Base.metadata.create_all() to work correctly.
        """
        try:
            from models.base_model import BaseModel  # Already imported by other models
            from models.user_models import User, Role, UserRole
            from models.horse_models import Horse, HorseOwner, HorseLocation
            from models.owner_models import Owner, OwnerBillingHistory, OwnerPayment

            # The placeholder Invoice from owner_models is implicitly imported if not removed from its __init__ or owner_models.py
            from models.reference_models import (
                StateProvince,
                ChargeCodeCategory,
                ChargeCode,
                Veterinarian,
                Location,
                Procedure,  # Placeholder
                Drug,  # Placeholder
                TreatmentLog,  # Placeholder
                CommunicationLog,  # Placeholder
                Document,  # Placeholder
                Reminder,  # Placeholder
                Appointment,  # Placeholder
                # The placeholder Transaction & TransactionDetail from reference_models might also be imported
                # if not removed from its __init__ or reference_models.py
            )

            # Import new financial models
            from models.financial_models import Transaction, Invoice

            self.logger.debug(
                "Models imported for table creation, including new financial models."
            )
        except ImportError as e:
            self.logger.error(
                f"Critical error: Could not import core models for table creation: {e}",
                exc_info=True,
            )
            # Depending on severity, you might want to raise this error
            # raise ImportError(f"Failed to import essential models: {e}") from e
        except Exception as e:
            self.logger.error(
                f"Unexpected error during model imports for table creation: {e}",
                exc_info=True,
            )

    def _test_connection(self) -> None:
        """
        Test database connection.
        """
        try:
            with self.get_session() as session:
                session.execute(text("SELECT 1"))
            self.logger.info("Database connection test successful")
        except Exception as e:
            self.logger.error(f"Database connection test failed: {e}")
            raise

    def _ensure_default_admin_user(self) -> None:
        """
        Ensure default admin user always exists with correct credentials
        (password hashed using bcrypt via User.set_password).
        Handles pre-existing non-bcrypt hashes for ADMIN by resetting the password.
        """
        try:
            with self.get_session() as session:
                from models.user_models import (
                    User,
                    Role,
                )

                self.logger.info(
                    "Ensuring default ADMIN user exists with bcrypt password."
                )

                admin_role_name = "ADMIN"
                admin_role = (
                    session.query(Role).filter(Role.name == admin_role_name).first()
                )
                if not admin_role:
                    self.logger.warning(
                        f"Role '{admin_role_name}' not found. Creating it now. "
                        "It's recommended to run add_initial_data.py for full role setup."
                    )
                    admin_role = Role(
                        name=admin_role_name,
                        description="System Administrator (auto-created by db_config)",
                        created_by="SYSTEM_DB_CONFIG",
                        modified_by="SYSTEM_DB_CONFIG",
                    )
                    session.add(admin_role)
                    session.flush()
                    self.logger.info(f"Created '{admin_role_name}' role.")

                admin_user = session.query(User).filter(User.user_id == "ADMIN").first()
                default_password = "admin1234"
                admin_default_name = "System Administrator"
                admin_default_email = "admin@edsi.local"

                if admin_user:
                    password_reset_done = False
                    attributes_updated = False

                    try:
                        if not admin_user.check_password(default_password):
                            self.logger.info(
                                "ADMIN user password check failed. Resetting."
                            )
                            admin_user.set_password(default_password)
                            password_reset_done = True
                    except ValueError as e:
                        self.logger.warning(
                            f"ADMIN password hash not bcrypt/valid ({e}). Resetting password."
                        )
                        admin_user.set_password(default_password)
                        password_reset_done = True

                    if password_reset_done:
                        admin_user.modified_by = "SYSTEM_DB_CONFIG_PWD"
                        self.logger.info(
                            "ADMIN user password has been set/reset to a bcrypt hash."
                        )

                    if not admin_user.is_active:
                        admin_user.is_active = True
                        self.logger.info("Activated ADMIN user.")
                        attributes_updated = True

                    if admin_user.user_name != admin_default_name:
                        admin_user.user_name = admin_default_name
                        self.logger.info(
                            f"Set ADMIN user_name to '{admin_default_name}'."
                        )
                        attributes_updated = True

                    if admin_user.email != admin_default_email:
                        admin_user.email = admin_default_email
                        self.logger.info(f"Set ADMIN email to '{admin_default_email}'.")
                        attributes_updated = True

                    if attributes_updated and not password_reset_done:
                        admin_user.modified_by = "SYSTEM_DB_CONFIG_ATTR"

                    if password_reset_done or attributes_updated:
                        self.logger.info("ADMIN user record updated/verified.")
                    else:
                        self.logger.info(
                            "ADMIN user credentials, status, and name are correct."
                        )

                else:
                    self.logger.info("ADMIN user not found. Creating new ADMIN user...")
                    admin_user = User(
                        user_id="ADMIN",
                        user_name=admin_default_name,
                        email=admin_default_email,
                        is_active=True,
                        created_by="SYSTEM_DB_CONFIG",
                        modified_by="SYSTEM_DB_CONFIG",
                    )
                    admin_user.set_password(default_password)
                    session.add(admin_user)
                    session.flush()
                    self.logger.info("Created new ADMIN user with bcrypt password.")

                if admin_role and admin_role not in admin_user.roles:
                    admin_user.roles.append(admin_role)
                    self.logger.info("Linked ADMIN user to ADMIN role.")
                elif not admin_role:
                    self.logger.error(
                        f"Cannot link ADMIN user to '{admin_role_name}' role as role object is missing."
                    )

                session.commit()
                self.logger.info(
                    f"Default ADMIN user ready (Username: ADMIN, Password: {default_password})"
                )

        except Exception as e:
            self.logger.error(f"Error ensuring default admin user: {e}", exc_info=True)
            if "session" in locals() and session.is_active:
                session.rollback()

    def close(self) -> None:
        if self.SessionLocal:
            self.SessionLocal.remove()
            self.logger.info("Database sessions closed")
        if self.engine:
            self.engine.dispose()
            self.logger.info("Database engine disposed")

    def get_engine(self):
        return self.engine


db_manager = DatabaseManager()


def get_db_session() -> SQLAlchemySession:
    return db_manager.get_session()


def init_database(db_url: Optional[str] = None) -> None:
    db_manager.initialize_database(db_url)


=============== FILE: controllers\__init__.py ===============

# controllers/__init__.py
"""
EDSI Veterinary Management System - Controllers Package
"""
from .user_controller import UserController
from .location_controller import LocationController
from .charge_code_controller import ChargeCodeController
from .owner_controller import OwnerController
from .financial_controller import FinancialController
from .horse_controller import HorseController

__all__ = [
    "UserController",
    "Location_Controller",
    "ChargeCodeController",
    "OwnerController",
    "FinancialController",
    "HorseController",
]


=============== FILE: controllers\charge_code_controller.py ===============

# controllers/charge_code_controller.py
"""
EDSI Veterinary Management System - Charge Code Controller
Version: 1.2.0
Purpose: Business logic for charge code and charge code category operations.
         - Added delete_charge_code method.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.2.0 (2025-06-05):
    - Added `delete_charge_code` method to permanently delete a charge code.
    - The method checks for linked records in the `Transaction` model to prevent deletion if the charge code is in use.
    - Added `Transaction` to the model imports.
- v1.1.3 (2025-06-04):
    - Added `get_category_by_id` method to fetch a single category by its ID,
      as required by UserManagementScreen.
    - Modified `get_charge_code_by_id` to filter by `ChargeCode.id` (assuming 'id'
      is the current primary key attribute on the ChargeCode model) instead of
      `ChargeCode.charge_code_id` to resolve an AttributeError.
- v1.1.2 (2025-06-03):
    - Modified `get_all_charge_code_categories_hierarchical` to remove the
      `active_filter` parameter. It now always fetches all Level 1 categories
      (active and inactive) and their children. Filtering logic is handled by the view.
- v1.1.1 (2025-06-03):
    - Added `toggle_charge_code_category_status` method to specifically handle
      activating/deactivating ChargeCodeCategory items.
- v1.1.0 (2025-06-03):
    - Added full CRUD operations and validation for ChargeCodeCategory.
# ... (previous changelog entries)
"""

import logging
import re
from datetime import datetime
from typing import List, Optional, Tuple, Dict, Any
from decimal import Decimal, InvalidOperation

from sqlalchemy.orm import Session, joinedload, aliased, selectinload
from sqlalchemy import or_, func, exc as sqlalchemy_exc, and_

from config.database_config import db_manager
from models import ChargeCode, ChargeCodeCategory, Transaction


class ChargeCodeController:
    """Controller for charge code and charge code category operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    # --- ChargeCode Methods ---
    def validate_charge_code_data(
        self,
        charge_data: dict,
        is_new: bool = True,
        charge_code_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        code = charge_data.get("code", "").strip()
        description = charge_data.get("description", "").strip()
        standard_charge_str = str(charge_data.get("standard_charge", "")).strip()

        if not code:
            errors.append("Charge Code (Code) is required.")
        elif len(code) > 20:
            errors.append("Charge Code (Code) cannot exceed 20 characters.")

        # Validate code uniqueness
        if code:  # Only check if code is provided
            session = db_manager.get_session()
            try:
                query = session.query(ChargeCode).filter(
                    ChargeCode.code.collate("NOCASE") == code.upper()
                )
                if not is_new and charge_code_id_to_ignore is not None:
                    query = query.filter(ChargeCode.id != charge_code_id_to_ignore)
                if query.first():
                    errors.append(f"Charge Code '{code.upper()}' already exists.")
            finally:
                if session:
                    session.close()

        if not description:
            errors.append("Description is required.")
        elif len(description) > 255:
            errors.append("Description cannot exceed 255 characters.")

        if not standard_charge_str:
            errors.append("Standard Charge is required.")
        else:
            try:
                charge_value = Decimal(standard_charge_str)
                if charge_value < Decimal("0.00"):
                    errors.append("Standard Charge cannot be negative.")
            except InvalidOperation:
                errors.append("Standard Charge must be a valid number (e.g., 25.00).")

        alternate_code = charge_data.get("alternate_code")
        if alternate_code is not None and len(str(alternate_code).strip()) > 50:
            errors.append("Alternate Code cannot exceed 50 characters.")

        if "taxable" in charge_data and not isinstance(
            charge_data.get("taxable"), bool
        ):
            errors.append("Taxable field must be a true/false value.")

        category_id = charge_data.get("category_id")
        if category_id is not None:
            session = db_manager.get_session()
            try:
                category_exists = (
                    session.query(ChargeCodeCategory)
                    .filter(ChargeCodeCategory.category_id == category_id)
                    .first()
                )
                if not category_exists:
                    errors.append(
                        f"Selected category ID '{category_id}' does not exist."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"Error validating category_id '{category_id}': {e}", exc_info=True
                )
                errors.append("Database error validating category.")
            finally:
                if session:
                    session.close()
        elif "category_id" not in charge_data:
            errors.append("Category selection is required.")

        return not errors, errors

    def create_charge_code(
        self, charge_data: dict, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[ChargeCode]]:
        is_valid, errors = self.validate_charge_code_data(
            charge_data, is_new=True, charge_code_id_to_ignore=None
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_charge_code = ChargeCode(
                code=charge_data["code"].strip().upper(),
                alternate_code=(
                    (charge_data.get("alternate_code", "").strip().upper() or None)
                    if charge_data.get("alternate_code") is not None
                    else None
                ),
                description=charge_data["description"].strip(),
                category_id=charge_data.get("category_id"),
                standard_charge=Decimal(str(charge_data["standard_charge"]).strip()),
                is_active=charge_data.get("is_active", True),
                taxable=charge_data.get("taxable", False),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_charge_code)
            session.commit()
            session.refresh(new_charge_code)
            self.logger.info(
                f"Charge Code '{new_charge_code.code}' created (ID: {new_charge_code.id}) by {current_user_id}."
            )
            return True, "Charge code created successfully.", new_charge_code
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating charge code: {str(ie.orig)}", exc_info=True
            )
            if "UNIQUE constraint failed: charge_codes.code" in str(ie.orig).lower():
                return (
                    False,
                    f"Charge Code '{charge_data['code'].strip().upper()}' already exists.",
                    None,
                )
            return False, f"Database integrity error: {str(ie.orig)}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating charge code: {e}", exc_info=True)
            return False, f"Failed to create charge code: {str(e)}", None
        finally:
            if session:
                session.close()

    def get_charge_code_by_id(self, charge_code_pk_value: int) -> Optional[ChargeCode]:
        session = db_manager.get_session()
        try:
            return (
                session.query(ChargeCode)
                .options(joinedload(ChargeCode.category))
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code by ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return None
        finally:
            if session:
                session.close()

    def get_charge_code_by_code(self, code: str) -> Optional[ChargeCode]:
        session = db_manager.get_session()
        try:
            return (
                session.query(ChargeCode)
                .options(joinedload(ChargeCode.category))
                .filter(ChargeCode.code.collate("NOCASE") == code.upper())
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code by code '{code}': {e}", exc_info=True
            )
            return None
        finally:
            if session:
                session.close()

    def get_all_charge_codes(
        self, search_term: str = "", status_filter: str = "all"
    ) -> List[ChargeCode]:
        session = db_manager.get_session()
        try:
            category_alias = aliased(ChargeCodeCategory)
            query = session.query(ChargeCode).options(joinedload(ChargeCode.category))

            if status_filter == "active":
                query = query.filter(ChargeCode.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(ChargeCode.is_active == False)

            query = query.outerjoin(category_alias, ChargeCode.category)

            if search_term:
                like_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        ChargeCode.code.ilike(like_pattern),
                        ChargeCode.alternate_code.ilike(like_pattern),
                        ChargeCode.description.ilike(like_pattern),
                        category_alias.name.ilike(like_pattern),
                    )
                )
            query = query.order_by(
                category_alias.name.asc().nullsfirst(), ChargeCode.code.asc()
            )
            return query.all()
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all charge codes: {e}", exc_info=True)
            return []
        finally:
            if session:
                session.close()

    def update_charge_code(
        self,
        charge_code_pk_value: int,
        charge_data: dict,
        current_user_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            charge_code_to_update = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
            if not charge_code_to_update:
                return False, "Charge code not found."

            validation_data = charge_data.copy()
            if "code" not in validation_data:
                validation_data["code"] = charge_code_to_update.code

            is_valid, errors = self.validate_charge_code_data(
                validation_data,
                is_new=False,
                charge_code_id_to_ignore=charge_code_pk_value,
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            if "code" in charge_data:
                charge_code_to_update.code = charge_data["code"].strip().upper()
            if "description" in charge_data:
                charge_code_to_update.description = charge_data["description"].strip()
            if (
                "standard_charge" in charge_data
                and charge_data["standard_charge"] is not None
            ):
                try:
                    charge_code_to_update.standard_charge = Decimal(
                        str(charge_data["standard_charge"])
                    )
                except InvalidOperation:
                    return False, "Invalid Standard Charge value provided for update."
            if "alternate_code" in charge_data:
                alt_code = charge_data.get("alternate_code")
                charge_code_to_update.alternate_code = (
                    (alt_code.strip().upper() or None)
                    if isinstance(alt_code, str)
                    else None
                )

            if "category_id" in charge_data:
                charge_code_to_update.category_id = charge_data.get("category_id")

            if "is_active" in charge_data:
                charge_code_to_update.is_active = charge_data["is_active"]
            if "taxable" in charge_data:
                charge_code_to_update.taxable = charge_data["taxable"]

            charge_code_to_update.modified_by = current_user_id

            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code_to_update.code}' (ID: {charge_code_pk_value}) updated by {current_user_id}."
            )
            return True, "Charge code updated successfully."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            if "UNIQUE constraint failed: charge_codes.code" in str(ie.orig).lower():
                return (
                    False,
                    f"Charge Code '{charge_data.get('code', '').strip().upper()}' already exists.",
                )
            return False, f"Database integrity error: {str(ie.orig)}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating charge code ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return False, f"Failed to update charge code: {str(e)}"
        finally:
            if session:
                session.close()

    def toggle_charge_code_status(
        self,
        charge_code_pk_value: int,
        current_user_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            charge_code = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
            if not charge_code:
                return False, "Charge code not found."

            charge_code.is_active = not charge_code.is_active
            charge_code.modified_by = current_user_id
            new_status = "active" if charge_code.is_active else "inactive"
            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code.code}' (ID: {charge_code_pk_value}) status changed to {new_status} by {current_user_id}."
            )
            return True, f"Charge code '{charge_code.code}' status set to {new_status}."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error toggling status for charge code ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle charge code status: {str(e)}"
        finally:
            if session:
                session.close()

    def delete_charge_code(
        self, charge_code_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        """Permanently deletes a charge code after checking for dependencies."""
        session = db_manager.get_session()
        try:
            # Check for linked transactions before deleting
            linked_transactions_count = (
                session.query(Transaction)
                .filter(Transaction.charge_code_id == charge_code_id)
                .count()
            )

            if linked_transactions_count > 0:
                message = f"Cannot delete charge code. It is used in {linked_transactions_count} financial transaction(s)."
                self.logger.warning(
                    f"Attempt to delete charge code ID {charge_code_id} failed: {message}"
                )
                return False, message

            # Proceed with deletion if no links are found
            charge_code_to_delete = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_id)
                .first()
            )

            if not charge_code_to_delete:
                return False, "Charge code not found."

            code = charge_code_to_delete.code
            session.delete(charge_code_to_delete)
            session.commit()
            self.logger.info(
                f"Charge Code '{code}' (ID: {charge_code_id}) deleted by {current_user_id}."
            )
            return True, f"Charge Code '{code}' was successfully deleted."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting charge code ID {charge_code_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred: {e}"
        finally:
            session.close()

    # --- ChargeCodeCategory Management Methods ---

    def get_category_by_id(self, category_id: int) -> Optional[ChargeCodeCategory]:
        session = db_manager.get_session()
        try:
            category = (
                session.query(ChargeCodeCategory)
                .options(joinedload(ChargeCodeCategory.parent))
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            return category
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching category by ID {category_id}: {e}", exc_info=True
            )
            return None
        finally:
            if session:
                session.close()

    def validate_charge_code_category_data(
        self,
        category_data: dict,
        is_new: bool = True,
        category_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        name = category_data.get("name", "").strip()
        level = category_data.get("level")
        parent_id = category_data.get("parent_id")

        if not name:
            errors.append("Category/Process name is required.")
        elif len(name) > 100:
            errors.append("Category/Process name cannot exceed 100 characters.")

        if level not in [1, 2]:
            errors.append("Level must be 1 (for Category) or 2 (for Process).")

        if level == 1 and parent_id is not None:
            errors.append("A Level 1 Category cannot have a parent.")
        if level == 2 and parent_id is None:
            errors.append("A Level 2 Process must have a parent Category.")

        if name and level is not None:
            session = db_manager.get_session()
            try:
                query = session.query(ChargeCodeCategory.category_id).filter(
                    ChargeCodeCategory.name.collate("NOCASE") == name,
                    ChargeCodeCategory.level == level,
                )
                if parent_id:
                    query = query.filter(ChargeCodeCategory.parent_id == parent_id)
                else:
                    query = query.filter(ChargeCodeCategory.parent_id.is_(None))

                if not is_new and category_id_to_ignore is not None:
                    query = query.filter(
                        ChargeCodeCategory.category_id != category_id_to_ignore
                    )

                if query.first():
                    type_name = "Process" if level == 2 else "Category"
                    parent_info = f" under the selected parent" if parent_id else ""
                    errors.append(
                        f"{type_name} name '{name}' already exists{parent_info}."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"DB error validating category name uniqueness: {e}", exc_info=True
                )
                errors.append("Database error during name validation.")
            finally:
                if session:
                    session.close()
        return not errors, errors

    def create_charge_code_category(
        self, category_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str, Optional[ChargeCodeCategory]]:
        is_valid, errors = self.validate_charge_code_category_data(
            category_data, is_new=True
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_category = ChargeCodeCategory(
                name=category_data["name"].strip(),
                level=category_data["level"],
                parent_id=category_data.get("parent_id"),
                is_active=category_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_category)
            session.commit()
            session.refresh(new_category)
            cat_type = "Process" if new_category.level == 2 else "Category"
            self.logger.info(
                f"Charge Code {cat_type} '{new_category.name}' (ID: {new_category.category_id}, Level: {new_category.level}, ParentID: {new_category.parent_id}) created by {current_user_id}."
            )
            return True, f"{cat_type} created successfully.", new_category
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating charge code category: {str(ie.orig)}",
                exc_info=True,
            )
            return False, f"Database integrity error: {str(ie.orig)}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error creating charge code category: {e}", exc_info=True
            )
            return False, f"Failed to create category/process: {str(e)}", None
        finally:
            if session:
                session.close()

    def update_charge_code_category(
        self, category_id: int, category_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            category_to_update = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category_to_update:
                return False, "Category/Process not found."

            validation_data = {
                "name": category_data.get("name", category_to_update.name).strip(),
                "level": category_to_update.level,
                "parent_id": category_to_update.parent_id,
            }

            is_valid, errors = self.validate_charge_code_category_data(
                validation_data, is_new=False, category_id_to_ignore=category_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            changed = False
            if (
                "name" in category_data
                and category_to_update.name != category_data["name"].strip()
            ):
                category_to_update.name = category_data["name"].strip()
                changed = True

            if (
                "is_active" in category_data
                and category_to_update.is_active != category_data["is_active"]
            ):
                category_to_update.is_active = category_data["is_active"]
                changed = True

            if changed:
                category_to_update.modified_by = current_user_id
                session.commit()
                cat_type = "Process" if category_to_update.level == 2 else "Category"
                self.logger.info(
                    f"Charge Code {cat_type} '{category_to_update.name}' (ID: {category_id}) updated by {current_user_id}."
                )
                return True, f"{cat_type} updated successfully."
            else:
                return True, "No changes detected to update."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            return False, f"Database integrity error: {str(ie.orig)}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating category ID {category_id}: {e}", exc_info=True
            )
            return False, f"Failed to update category/process: {str(e)}"
        finally:
            if session:
                session.close()

    def toggle_charge_code_category_status(
        self, category_id: int, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        category = None
        try:
            category = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category:
                return False, "Category/Process not found."
            item_type = "Process" if category.level == 2 else "Category"
            original_name = category.name
            category.is_active = not category.is_active
            category.modified_by = current_user_id
            session.commit()
            new_status_str = "active" if category.is_active else "inactive"
            self.logger.info(
                f"{item_type} '{original_name}' (ID: {category.category_id}) status changed to {new_status_str} by {current_user_id}."
            )
            return (
                True,
                f"{item_type} '{original_name}' status set to {new_status_str}.",
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            if session:
                session.rollback()
            err_item_type = "Category/Process"
            err_name = f"ID {category_id}"
            if category:
                err_item_type = "Process" if category.level == 2 else "Category"
                err_name = category.name
            self.logger.error(
                f"Error toggling status for {err_item_type} {err_name}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle {err_item_type} status: {str(e)}"
        finally:
            if session:
                session.close()

    def delete_charge_code_category(
        self, category_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        category_to_delete = None
        try:
            category_to_delete = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category_to_delete:
                return False, "Category/Process not found."

            linked_charge_codes_count = (
                session.query(ChargeCode)
                .filter(ChargeCode.category_id == category_id)
                .count()
            )
            if linked_charge_codes_count > 0:
                msg = f"Cannot delete '{category_to_delete.name}'. It is assigned to {linked_charge_codes_count} charge code(s)."
                self.logger.warning(msg)
                return False, msg

            if category_to_delete.level == 1:
                children_count = (
                    session.query(ChargeCodeCategory)
                    .filter(ChargeCodeCategory.parent_id == category_id)
                    .count()
                )
                if children_count > 0:
                    msg = f"Cannot delete Category '{category_to_delete.name}'. It has {children_count} child Process(es). Delete children first."
                    self.logger.warning(msg)
                    return False, msg

            cat_type_name = "Process" if category_to_delete.level == 2 else "Category"
            deleted_name = category_to_delete.name
            session.delete(category_to_delete)
            session.commit()
            self.logger.info(
                f"Charge Code {cat_type_name} '{deleted_name}' (ID: {category_id}) deleted by {current_user_id}."
            )
            return True, f"{cat_type_name} '{deleted_name}' deleted successfully."
        except sqlalchemy_exc.SQLAlchemyError as e:
            if session:
                session.rollback()
            self.logger.error(
                f"Error deleting category ID {category_id}: {e}", exc_info=True
            )
            name_for_error = (
                category_to_delete.name if category_to_delete else f"ID {category_id}"
            )
            if isinstance(e, sqlalchemy_exc.IntegrityError):
                return (
                    False,
                    f"Cannot delete '{name_for_error}'. It might still be referenced by other records. Details: {e.orig}",
                )
            return (
                False,
                f"Failed to delete category/process due to a database error: {str(e)}",
            )
        finally:
            if session:
                session.close()

    def get_all_charge_code_categories_hierarchical(
        self,
    ) -> List[ChargeCodeCategory]:
        """Fetches all Level 1 categories, with their Level 2 children (processes) eager-loaded."""
        session = db_manager.get_session()
        try:
            level1_categories = (
                session.query(ChargeCodeCategory)
                .filter(
                    ChargeCodeCategory.parent_id.is_(None),
                    ChargeCodeCategory.level == 1,
                )
                .options(selectinload(ChargeCodeCategory.children))
                .order_by(ChargeCodeCategory.name)
                .all()
            )
            return level1_categories
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching hierarchical charge code categories: {e}",
                exc_info=True,
            )
            return []
        finally:
            if session:
                session.close()

    def get_charge_code_categories(
        self,
        parent_id: Optional[int] = None,
        level: Optional[int] = None,
        active_only: bool = True,
    ) -> List[ChargeCodeCategory]:
        session = db_manager.get_session()
        try:
            query = session.query(ChargeCodeCategory)
            if active_only:
                query = query.filter(ChargeCodeCategory.is_active == True)

            if parent_id is None and level == 1:
                query = query.filter(
                    ChargeCodeCategory.parent_id.is_(None),
                    ChargeCodeCategory.level == 1,
                )
            else:
                if parent_id is not None:
                    query = query.filter(ChargeCodeCategory.parent_id == parent_id)
                if level is not None:
                    query = query.filter(ChargeCodeCategory.level == level)

            categories = query.order_by(ChargeCodeCategory.name).all()
            return categories
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code categories: {e}", exc_info=True
            )
            return []
        finally:
            if session:
                session.close()

    def get_category_path(self, category_id: Optional[int]) -> List[Dict[str, Any]]:
        """
        Retrieves the hierarchical path for a given category ID.
        Returns a list of dictionaries, each with 'id' and 'name'.
        """
        path_for_display = []
        if category_id is None:
            return path_for_display

        current_cat_id = category_id
        session = db_manager.get_session()
        try:
            while current_cat_id is not None:
                category = (
                    session.query(
                        ChargeCodeCategory.category_id,
                        ChargeCodeCategory.name,
                        ChargeCodeCategory.parent_id,
                    )
                    .filter(ChargeCodeCategory.category_id == current_cat_id)
                    .first()
                )
                if category:
                    path_for_display.insert(
                        0, {"id": category.category_id, "name": category.name}
                    )
                    current_cat_id = category.parent_id
                else:
                    break
            return path_for_display
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching category path for ID {category_id}: {e}", exc_info=True
            )
            return []
        finally:
            if session:
                session.close()


=============== FILE: controllers\financial_controller.py ===============

# controllers/financial_controller.py
"""
EDSI Veterinary Management System - Financial Controller
Version: 1.2.3
Purpose: Handles business logic for financial operations like creating charges.
         - Corrected return type for charge code lookup on error.
Last Updated: June 6, 2025
Author: Gemini

Changelog:
- v1.2.3 (2025-06-06):
    - Bug Fix: Ensured `get_charge_codes_for_lookup` always returns a list `[]` on
      error instead of `None` to prevent downstream `TypeError`.
- v1.2.2 (2025-06-06):
    - Bug Fix: Replaced all instances of `service_date` with `transaction_date`
      to match the model and resolve the final `AttributeError`.
- v1.2.1 (2025-06-06):
    - Bug Fix: In `get_transactions_for_horse`, corrected the `joinedload`
      relationship from `Transaction.administered_by_user` to
      `Transaction.administered_by` to match the model definition.
- v1.2.0 (2025-06-06):
    - Added `get_transaction_by_id` method.
- v1.1.0 (2025-06-06):
    - Added `update_charge_transaction` and `delete_charge_transaction` methods.
"""

import logging
from typing import List, Optional, Dict, Any, Tuple
from decimal import Decimal, InvalidOperation
from datetime import date

from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm import joinedload, selectinload

from config.database_config import db_manager
from models import (
    Transaction,
    Invoice,
    Horse,
    Owner,
    ChargeCode,
    User,
    ChargeCodeCategory,
)


class FinancialController:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def validate_charge_data(
        self, charge_item: Dict[str, Any], line_number: int
    ) -> List[str]:
        # ... (implementation unchanged) ...
        pass

    def add_charge_batch_to_horse(
        self,
        horse_id: int,
        owner_id: int,
        charge_items: List[Dict[str, Any]],
        batch_transaction_date: date,
        administered_by_user_id: str,
    ) -> Tuple[bool, str, Optional[List[Transaction]]]:
        # ... (implementation unchanged) ...
        pass

    def update_charge_transaction(
        self, transaction_id: int, data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        pass

    def delete_charge_transaction(self, transaction_id: int) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        pass

    def get_transaction_by_id(self, transaction_id: int) -> Optional[Transaction]:
        # ... (implementation unchanged) ...
        pass

    def get_transactions_for_horse(
        self, horse_id: int, invoiced: Optional[bool] = None
    ) -> List[Transaction]:
        # ... (implementation unchanged) ...
        pass

    def get_charge_codes_for_lookup(self, active_only: bool = True) -> List[ChargeCode]:
        """Retrieves charge codes for dropdowns/lookups."""
        session = db_manager.get_session()
        try:
            query = session.query(ChargeCode).options(
                joinedload(ChargeCode.category).joinedload(ChargeCodeCategory.parent)
            )
            if active_only:
                query = query.filter(ChargeCode.is_active == True)

            charge_codes = query.order_by(ChargeCode.code).all()
            self.logger.info(f"Retrieved {len(charge_codes)} charge codes for lookup.")
            return charge_codes
        except SQLAlchemyError as e:
            self.logger.error(f"Error retrieving charge codes: {e}", exc_info=True)
            return []  # FIXED: Always return a list
        finally:
            session.close()

    def find_charge_code(
        self, text: str, charge_list: List[ChargeCode]
    ) -> Optional[ChargeCode]:
        # ... (implementation unchanged) ...
        pass

    def get_active_owners_for_lookup(self) -> List[Owner]:
        # ... (implementation unchanged) ...
        pass

    def get_active_users_for_lookup(self) -> List[User]:
        # ... (implementation unchanged) ...
        pass

    def create_invoice_for_owner(
        self, owner_id: int, transaction_ids: List[int]
    ) -> Tuple[bool, str, Optional[Invoice]]:
        # ... (implementation unchanged) ...
        pass

    def record_payment(
        self,
        owner_id: int,
        amount: Decimal,
        payment_date: date,
        method: str,
        notes: Optional[str],
    ) -> Tuple[bool, str, Optional[Transaction]]:
        # ... (implementation unchanged) ...
        pass

    def apply_payment_to_invoice(
        self, payment_id: int, invoice_id: int
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        pass


=============== FILE: controllers\horse_controller.py ===============

# controllers/horse_controller.py
"""
EDSI Veterinary Management System - Horse Controller
Version: 1.2.9
Purpose: Handles business logic related to horses.
         - Modified get_horse_by_id to eagerly load 'owners' and 'location'
           relationships to prevent DetachedInstanceError in views.
Last Updated: May 25, 2025
Author: Gemini

Changelog:
- v1.2.9 (2025-05-25):
    - In `get_horse_by_id`, updated SQLAlchemy query options to use
      `selectinload(Horse.owners)` and `joinedload(Horse.location)`
      to ensure these related objects are eager-loaded. This is intended
      to prevent `DetachedInstanceError` when accessing these attributes
      on a Horse object after the session is closed.
- v1.2.8 (2025-05-23):
    - Changed session creation from `Session()` to `db_manager.get_session()`
      to align with current database configuration.
    - Removed `get_all_species` method as Species model has been removed.
    - Removed `Species` import and references in `get_horse_by_id` and `search_horses`.
- v1.2.7 (2025-05-22):
    - Updated `create_horse` and `update_horse` to use `modified_by` instead of `updated_by`
      to align with the user's current `BaseModel` definition.
- v1.2.6 (2025-05-21 - User Uploaded version):
    - Initial version with methods for CRUD, search, linking owners, locations.
"""
import logging
from typing import List, Optional, Dict, Any
from datetime import datetime, date

from sqlalchemy import (
    select,
    update,
    delete,
    and_,
    or_,
    func as sql_func,
)
from sqlalchemy.orm import joinedload, selectinload, aliased
from sqlalchemy.exc import SQLAlchemyError

from config.database_config import db_manager
from models import Horse, Owner, HorseOwner, Location, HorseLocation


class HorseController:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_locations(self) -> List[Location]:
        """Retrieves all locations from the database."""
        session = db_manager.get_session()
        try:
            locations = session.query(Location).order_by(Location.location_name).all()
            self.logger.info(f"Retrieved {len(locations)} location records.")
            return locations
        except SQLAlchemyError as e:
            self.logger.error(f"Error retrieving locations: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()

    def validate_horse_data(
        self,
        data: dict,
        is_new: bool = True,
        horse_id_to_check_for_unique: Optional[int] = None,
    ) -> tuple[bool, list]:
        # (Method content remains the same as v1.2.8)
        errors = []
        required_fields = ["horse_name"]

        for field in required_fields:
            if not data.get(field) or not str(data[field]).strip():
                errors.append(f"{field.replace('_', ' ').capitalize()} is required.")

        if data.get(
            "date_of_birth"
        ):  # Expects Python date object from BasicInfoTab v1.2.18+
            try:
                dob = data["date_of_birth"]
                if not isinstance(dob, date):  # Should already be a date object
                    # This case should ideally not happen if BasicInfoTab sends date objects
                    errors.append("Date of Birth was not a valid date object.")
                elif dob > date.today():
                    errors.append("Date of Birth cannot be in the future.")
            except Exception:  # Catch any other conversion/type issue if not a date
                errors.append("Invalid Date of Birth provided.")

        if data.get("coggins_date"):  # Expects Python date object
            try:
                coggins_dt = data["coggins_date"]
                if not isinstance(coggins_dt, date):
                    errors.append("Coggins Date was not a valid date object.")
                elif coggins_dt > date.today():
                    errors.append("Coggins Date cannot be in the future.")
            except Exception:
                errors.append("Invalid Coggins Date provided.")

        chip_number = data.get("chip_number")
        if chip_number and str(chip_number).strip():
            session = db_manager.get_session()
            try:
                query = session.query(Horse).filter(Horse.chip_number == chip_number)
                if not is_new and horse_id_to_check_for_unique:
                    query = query.filter(Horse.horse_id != horse_id_to_check_for_unique)
                if query.first():
                    errors.append(f"Chip number '{chip_number}' already exists.")
            finally:
                session.close()

        tattoo_number = data.get("tattoo_number")
        if tattoo_number and str(tattoo_number).strip():
            session = db_manager.get_session()
            try:
                query = session.query(Horse).filter(
                    Horse.tattoo_number == tattoo_number
                )
                if not is_new and horse_id_to_check_for_unique:
                    query = query.filter(Horse.horse_id != horse_id_to_check_for_unique)
                if query.first():
                    errors.append(f"Tattoo number '{tattoo_number}' already exists.")
            finally:
                session.close()
        return not errors, errors

    def create_horse(
        self, data: dict, created_by_user: str
    ) -> tuple[bool, str, Optional[Horse]]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            data["created_by"] = created_by_user
            data["modified_by"] = created_by_user
            data.pop("species_id", None)

            # Handle potential unknown attributes by filtering data against Horse model columns
            horse_columns = {col.name for col in Horse.__table__.columns}
            filtered_data = {k: v for k, v in data.items() if k in horse_columns}

            # Warn about fields in data not in Horse model (e.g. reg_number, brand, band_tag if not added to model)
            for key in data:
                if key not in horse_columns and key not in [
                    "current_location_id"
                ]:  # current_location_id handled separately
                    self.logger.warning(
                        f"HorseController.create_horse - Attribute '{key}' present in data but not in Horse model columns. It will be ignored for direct Horse instantiation."
                    )

            new_horse = Horse(**filtered_data)

            # Handle current_location_id separately if it's part of the data
            if (
                "current_location_id" in data
                and data["current_location_id"] is not None
            ):
                new_horse.current_location_id = data["current_location_id"]
                # Create a HorseLocation entry if location is being set during creation
                new_assignment = HorseLocation(
                    horse=new_horse,  # Relationship will handle horse_id
                    location_id=data["current_location_id"],
                    date_arrived=date.today(),
                    is_current_location=True,
                    created_by=created_by_user,
                    modified_by=created_by_user,
                )
                session.add(new_assignment)

            session.add(new_horse)
            session.commit()
            session.refresh(new_horse)  # To get horse_id and other db-generated values
            # If location was set, refresh new_assignment too if its ID is needed
            # if 'current_location_id' in data and data['current_location_id'] is not None:
            # session.refresh(new_assignment)

            self.logger.info(
                f"Horse '{new_horse.horse_name}' (ID: {new_horse.horse_id}) created successfully by {created_by_user}."
            )
            return (
                True,
                f"Horse '{new_horse.horse_name}' created successfully.",
                new_horse,
            )
        except TypeError as te:
            self.logger.error(
                f"TypeError during Horse creation: {te} - Data was: {data}",
                exc_info=True,
            )
            session.rollback()
            return (
                False,
                f"Failed to create horse due to invalid data field: {te}",
                None,
            )
        except SQLAlchemyError as e:
            self.logger.error(
                f"SQLAlchemyError creating horse: {e} - Data was: {data}", exc_info=True
            )
            session.rollback()
            return (
                False,
                f"A database error occurred while creating the horse: {e}",
                None,
            )
        except Exception as e:
            self.logger.error(
                f"Unexpected error creating horse: {e} - Data was: {data}",
                exc_info=True,
            )
            session.rollback()
            return (
                False,
                f"An unexpected error occurred while creating the horse: {e}",
                None,
            )
        finally:
            session.close()

    def update_horse(
        self, horse_id: int, data: dict, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains mostly same as v1.2.8, with attribute filtering)
        session = db_manager.get_session()
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return False, "Horse not found."

            data["modified_by"] = modified_by_user
            data.pop("species_id", None)

            self.logger.debug(f"HorseController.update_horse - Data for update: {data}")

            horse_columns = {col.name for col in Horse.__table__.columns}

            for key, value in data.items():
                if key == "current_location_id":  # Handled by assign_horse_to_location
                    if horse.current_location_id != value:
                        self.logger.info(
                            f"Location change detected for horse {horse_id} from {horse.current_location_id} to {value}. This should be handled via assign_horse_to_location if it involves history."
                        )
                        # Direct update of current_location_id here. assign_horse_to_location manages history.
                        horse.current_location_id = value
                elif key in horse_columns:  # Check if attribute is a direct column
                    setattr(horse, key, value)
                elif hasattr(
                    horse, key
                ):  # Check if attribute exists (e.g., a relationship not directly a column)
                    # This path is less common for direct updates from a flat data dict unless it's a specific non-column attribute
                    self.logger.info(
                        f"Setting attribute '{key}' which is not a direct column but exists on Horse model."
                    )
                    setattr(horse, key, value)
                else:
                    self.logger.warning(
                        f"HorseController.update_horse - Attempted to set unknown attribute '{key}' on Horse model."
                    )
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} updated successfully by {modified_by_user}."
            )
            return True, "Horse details updated successfully."
        except SQLAlchemyError as e:
            self.logger.error(
                f"SQLAlchemyError updating horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"A database error occurred while updating the horse: {e}"
        except Exception as e:
            self.logger.error(
                f"Unexpected error updating horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"An unexpected error occurred while updating the horse: {e}"
        finally:
            session.close()

    def get_horse_by_id(self, horse_id: int) -> Optional[Horse]:
        session = db_manager.get_session()
        try:
            # Eagerly load the 'owners' collection and the current 'location' object.
            # This assumes 'Horse.owners' is the direct relationship to Owner models (many-to-many)
            # and 'Horse.location' is the direct relationship to the current Location model.
            horse = (
                session.query(Horse)
                .options(
                    selectinload(
                        Horse.owners
                    ),  # Eager load the collection of associated Owner objects
                    joinedload(
                        Horse.location
                    ),  # Eager load the current Location object
                    # If you also need horse_owner_associations (the join table objects) or location_history:
                    # selectinload(Horse.owner_associations).selectinload(HorseOwner.owner),
                    # selectinload(Horse.location_history).selectinload(HorseLocation.location),
                )
                .filter(Horse.horse_id == horse_id)
                .first()
            )
            if horse:
                self.logger.info(f"Retrieved horse ID {horse_id}: {horse.horse_name}")
                # Accessing relationships here while session is active to confirm loading (optional for debugging)
                # if horse.owners: self.logger.debug(f"Horse {horse_id} has {len(horse.owners)} owners loaded.")
                # if horse.location: self.logger.debug(f"Horse {horse_id} location: {horse.location.location_name} loaded.")
            else:
                self.logger.warning(f"Horse ID {horse_id} not found.")
            return horse
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving horse ID {horse_id}: {e}", exc_info=True
            )
            # session.rollback() # No need to rollback on a SELECT query error usually
            return None
        finally:
            session.close()  # Session is closed here, so eager loading is crucial

    def search_horses(
        self,
        search_term: str = "",
        status: str = "active",
        owner_name_search: Optional[str] = None,
    ) -> List[Horse]:
        # (Method content largely same, but ensure options are appropriate)
        session = db_manager.get_session()
        try:
            query = session.query(Horse).options(
                selectinload(
                    Horse.owners
                ),  # Eager load owners for list display if needed
                joinedload(
                    Horse.location
                ),  # Eager load location for list display if needed
            )

            if search_term:
                search_term_like = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Horse.horse_name.ilike(search_term_like),
                        Horse.account_number.ilike(search_term_like),
                        Horse.chip_number.ilike(search_term_like),
                        Horse.tattoo_number.ilike(search_term_like),
                    )
                )

            if owner_name_search:
                OwnerAlias = aliased(Owner)
                owner_search_like = f"%{owner_name_search}%"
                # Assuming Horse.owners is the direct relationship to Owner model
                query = query.join(Horse.owners.of_type(OwnerAlias)).filter(
                    or_(
                        OwnerAlias.farm_name.ilike(owner_search_like),
                        OwnerAlias.first_name.ilike(owner_search_like),
                        OwnerAlias.last_name.ilike(owner_search_like),
                    )
                )
                query = query.distinct()  # Add distinct if join causes duplicates

            if status == "active":
                query = query.filter(Horse.is_active == True)
            elif status == "inactive":
                query = query.filter(Horse.is_active == False)

            horses = query.order_by(Horse.horse_name).all()
            self.logger.info(
                f"Search for horses (term: '{search_term}', owner: '{owner_name_search}', status: {status}) found {len(horses)} results."
            )
            return horses
        except SQLAlchemyError as e:
            self.logger.error(f"Error searching horses: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()

    def deactivate_horse(
        self, horse_id: int, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        return self._toggle_horse_status(horse_id, False, modified_by_user)

    def activate_horse(self, horse_id: int, modified_by_user: str) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        return self._toggle_horse_status(horse_id, True, modified_by_user)

    def _toggle_horse_status(
        self, horse_id: int, is_active: bool, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return False, "Horse not found."

            horse.is_active = is_active
            horse.modified_by = modified_by_user

            session.commit()
            status_text = "activated" if is_active else "deactivated"
            self.logger.info(
                f"Horse ID {horse_id} {status_text} by {modified_by_user}."
            )
            return True, f"Horse {status_text} successfully."
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error toggling horse status for ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"Database error: Could not change horse status."
        finally:
            session.close()

    def get_horse_owners(self, horse_id: int) -> List[Dict[str, Any]]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            associations = (
                session.query(HorseOwner)
                .filter(HorseOwner.horse_id == horse_id)
                .options(joinedload(HorseOwner.owner))
                .all()
            )
            owner_details = []
            for assoc in associations:
                if assoc.owner:
                    owner_name_parts = []
                    if assoc.owner.farm_name:
                        owner_name_parts.append(assoc.owner.farm_name)

                    person_name_parts = []
                    if assoc.owner.first_name:
                        person_name_parts.append(assoc.owner.first_name)
                    if assoc.owner.last_name:
                        person_name_parts.append(assoc.owner.last_name)
                    person_name_str = " ".join(person_name_parts).strip()

                    if person_name_str:
                        owner_name_parts.append(f"({person_name_str})")

                    display_name = " ".join(owner_name_parts).strip()
                    if not display_name:
                        display_name = f"Owner ID: {assoc.owner.owner_id}"

                    owner_details.append(
                        {
                            "owner_id": assoc.owner.owner_id,
                            "owner_name": display_name,
                            "percentage_ownership": assoc.percentage_ownership,
                            "phone_number": assoc.owner.phone,
                        }
                    )
            return owner_details
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owners for horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return []
        finally:
            session.close()

    def add_owner_to_horse(
        self,
        horse_id: int,
        owner_id: int,
        percentage: Optional[float],
        modified_by_user: str,
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            existing_assoc = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if existing_assoc:
                return False, "Owner is already associated with this horse."

            new_association = HorseOwner(
                horse_id=horse_id, owner_id=owner_id, percentage_ownership=percentage
            )
            session.add(new_association)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Owner ID {owner_id} added to horse ID {horse_id} by {modified_by_user}."
            )
            return True, "Owner successfully added to horse."
        except SQLAlchemyError as e:
            self.logger.error(f"Error adding owner to horse: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not add owner."
        finally:
            session.close()

    def update_horse_owner_percentage(
        self, horse_id: int, owner_id: int, percentage: float, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            association = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if not association:
                return False, "Owner association not found."
            association.percentage_ownership = percentage

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Ownership percentage updated for horse ID {horse_id}, owner ID {owner_id} by {modified_by_user}."
            )
            return True, "Ownership percentage updated."
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error updating ownership percentage: {e}", exc_info=True
            )
            session.rollback()
            return False, "Database error: Could not update ownership."
        finally:
            session.close()

    def remove_owner_from_horse(
        self, horse_id: int, owner_id: int, modified_by_user: str
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            association = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if not association:
                return False, "Owner association not found."
            session.delete(association)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Owner ID {owner_id} removed from horse ID {horse_id} by {modified_by_user}."
            )
            return True, "Owner removed from horse successfully."
        except SQLAlchemyError as e:
            self.logger.error(f"Error removing owner from horse: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not remove owner."
        finally:
            session.close()

    def assign_horse_to_location(
        self,
        horse_id: int,
        location_id: int,
        notes: Optional[str],
        modified_by_user: str,
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            today = date.today()
            previous_assignments = (
                session.query(HorseLocation)
                .filter(
                    HorseLocation.horse_id == horse_id,
                    HorseLocation.is_current_location == True,
                )
                .all()
            )
            for prev_assign in previous_assignments:
                if (
                    prev_assign.location_id != location_id
                ):  # End date only if moving to a NEW location
                    prev_assign.date_departed = today
                    prev_assign.is_current_location = False
                    prev_assign.modified_by = modified_by_user

            # Check if there's an existing assignment for this exact horse and location
            # to avoid duplicate current assignments if logic allows re-assigning to same current location.
            # However, typical flow is to end previous *any* current, and start new one.

            new_assignment = HorseLocation(
                horse_id=horse_id,
                location_id=location_id,
                date_arrived=today,
                notes=notes,
                is_current_location=True,
                created_by=modified_by_user,
                modified_by=modified_by_user,
            )
            session.add(new_assignment)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.current_location_id = location_id
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} assigned to location ID {location_id} by {modified_by_user}."
            )
            return True, "Horse location assigned successfully."
        except SQLAlchemyError as e:
            self.logger.error(f"Error assigning horse to location: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not assign location."
        finally:
            session.close()

    def remove_horse_from_location(
        self,
        horse_id: int,
        location_id: Optional[
            int
        ] = None,  # If None, removes from *any* current location
        modified_by_user: str = "system",
    ) -> tuple[bool, str]:
        # (Method content remains the same as v1.2.8)
        session = db_manager.get_session()
        try:
            query = session.query(HorseLocation).filter(
                HorseLocation.horse_id == horse_id,
                HorseLocation.is_current_location == True,
            )
            if (
                location_id is not None
            ):  # If a specific location is targeted for removal
                query = query.filter(HorseLocation.location_id == location_id)

            current_assignment = query.first()
            if not current_assignment:
                return (
                    False,
                    "No current location assignment found for this horse (or not at the specified location if one was provided).",
                )

            current_assignment.date_departed = date.today()
            current_assignment.is_current_location = False
            current_assignment.modified_by = modified_by_user

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            # Only nullify current_location_id if we are ending the assignment that matches it
            if horse and horse.current_location_id == current_assignment.location_id:
                horse.current_location_id = None
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} removed from location (assignment ID: {current_assignment.id}) by {modified_by_user}."
            )
            return True, "Horse removed from location (assignment ended)."
        except SQLAlchemyError as e:
            self.logger.error(f"Error removing horse from location: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not remove horse from location."
        finally:
            session.close()


=============== FILE: controllers\location_controller.py ===============

# controllers/location_controller.py
"""
EDSI Veterinary Management System - Location Controller
Version: 1.2.0
Purpose: Handles business logic for locations.
         - Added delete_location method with referential integrity check.
         - Modified get_all_locations to accept a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.2.0 (2025-06-05):
    - Added `delete_location` method, which checks for linked horses in
      HorseLocation before allowing deletion.
    - Modified `get_all_locations` to accept a string `status_filter` ('active',
      'inactive', or 'all') instead of a boolean for consistency.
- v1.1.7 (2025-06-05):
    - Reverted `update_location` to return a tuple of two values (bool, str).
"""
import logging
from typing import List, Optional, Tuple, Dict, Any

from sqlalchemy.orm import Session, joinedload
from sqlalchemy import exc as sqlalchemy_exc

from config.database_config import db_manager
from models import Location, StateProvince, HorseLocation


class LocationController:
    """Controller for location management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_locations(self, status_filter: str = "all") -> List[Location]:
        session = db_manager.get_session()
        try:
            query = session.query(Location).options(joinedload(Location.state))
            if status_filter == "active":
                query = query.filter(Location.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Location.is_active == False)
            locations = query.order_by(Location.location_name).all()
            return locations
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all locations: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_location_by_id(self, location_id: int) -> Optional[Location]:
        session = db_manager.get_session()
        try:
            return (
                session.query(Location)
                .options(joinedload(Location.state))
                .filter(Location.location_id == location_id)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching location by ID {location_id}: {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_location_data(
        self,
        location_data: dict,
        is_new: bool = True,
        location_id_to_check_for_unique: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        name = location_data.get("location_name", "").strip()

        if not name:
            errors.append("Location Name is required.")
        elif len(name) > 100:
            errors.append("Location Name cannot exceed 100 characters.")
        else:
            session = db_manager.get_session()
            try:
                query = session.query(Location.location_id).filter(
                    Location.location_name.collate("NOCASE") == name
                )
                if not is_new and location_id_to_check_for_unique is not None:
                    query = query.filter(
                        Location.location_id != location_id_to_check_for_unique
                    )
                if query.first():
                    errors.append(f"Location Name '{name}' already exists.")
            finally:
                session.close()
        return not errors, errors

    def create_location(
        self, location_data: dict, current_user_id: str
    ) -> Tuple[bool, str, Optional[Location]]:
        is_valid, errors = self.validate_location_data(location_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:

            def process_string(value: Any) -> Optional[str]:
                return value.strip() if isinstance(value, str) else None

            new_location = Location(
                location_name=location_data.get("location_name", "").strip(),
                address_line1=process_string(location_data.get("address_line1")),
                address_line2=process_string(location_data.get("address_line2")),
                city=process_string(location_data.get("city")),
                state_code=process_string(location_data.get("state_code")),
                zip_code=process_string(location_data.get("zip_code")),
                phone=process_string(location_data.get("phone")),
                contact_person=process_string(location_data.get("contact_person")),
                email=process_string(location_data.get("email")),
                is_active=location_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_location)
            session.commit()
            session.refresh(new_location)
            self.logger.info(
                f"Location '{new_location.location_name}' created by {current_user_id}."
            )
            return True, "Location created successfully.", new_location
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(f"Error creating location: {e.orig}", exc_info=True)
            return False, f"Database integrity error: {e.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating location: {e}", exc_info=True)
            return False, f"Failed to create location: {e}", None
        finally:
            session.close()

    def update_location(
        self, location_id: int, location_data: dict, current_user_id: str
    ) -> Tuple[bool, str]:
        is_valid, errors = self.validate_location_data(
            location_data, is_new=False, location_id_to_check_for_unique=location_id
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors)

        session = db_manager.get_session()
        try:
            location = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )
            if not location:
                return False, "Location not found."

            for key, value in location_data.items():
                if hasattr(location, key):
                    processed_value = value.strip() if isinstance(value, str) else value
                    setattr(location, key, processed_value)

            location.modified_by = current_user_id
            session.commit()
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location_id}) updated by {current_user_id}."
            )
            return True, "Location updated successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating location ID {location_id}: {e}", exc_info=True
            )
            return False, f"Failed to update location: {e}"
        finally:
            session.close()

    def toggle_location_active_status(
        self, location_id: int, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            location = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )
            if not location:
                return False, f"Location with ID {location_id} not found."

            location.is_active = not location.is_active
            location.modified_by = current_user_id

            session.commit()

            new_status = "activated" if location.is_active else "deactivated"
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location_id}) status changed to {new_status} by {current_user_id}."
            )
            return (
                True,
                f"Location '{location.location_name}' has been successfully {new_status}.",
            )

        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error toggling status for location ID {location_id}: {e}",
                exc_info=True,
            )
            return False, "A database error occurred while toggling location status."
        finally:
            if session:
                session.close()

    def delete_location(
        self, location_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            linked_horses_count = (
                session.query(HorseLocation)
                .filter(HorseLocation.location_id == location_id)
                .count()
            )

            if linked_horses_count > 0:
                message = f"Cannot delete location. It is currently or was previously assigned to {linked_horses_count} horse(s)."
                self.logger.warning(message)
                return False, message

            location_to_delete = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )

            if not location_to_delete:
                return False, "Location not found."

            location_name = location_to_delete.location_name
            session.delete(location_to_delete)
            session.commit()
            self.logger.info(
                f"Location '{location_name}' (ID: {location_id}) deleted by {current_user_id}."
            )
            return True, f"Location '{location_name}' was deleted."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting location ID {location_id}: {e}", exc_info=True
            )
            return False, f"A database error occurred: {e}"
        finally:
            session.close()


=============== FILE: controllers\owner_controller.py ===============

# controllers/owner_controller.py
"""
EDSI Veterinary Management System - Owner Controller
Version: 1.4.0
Purpose: Business logic for owner master file operations.
         - Standardized get_all_master_owners filter to use a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.4.0 (2025-06-05):
    - Modified `get_all_master_owners` to accept a string `status_filter` ('active',
      'inactive', 'all') for consistency.
- v1.3.5 (2025-06-04):
    - In `get_all_master_owners`, added `options(joinedload(Owner.state))`
      to eagerly load the related StateProvince object, preventing
      DetachedInstanceError when accessing owner.state in views.
- v1.3.4 (2025-06-02):
    - Added `import re` to resolve NameError during email validation
      in `validate_owner_data`.
- v1.3.3 (2025-06-02):
    - Modified `validate_owner_data` to correctly handle optional fields that
      might be `None` before calling `len()` on them, preventing TypeError.
- v1.3.2 (2025-05-17):
    - Removed `country_name` from Owner instantiation/update and validation.
- v1.3.1 (2025-05-17):
    - Removed phone number requirement from `validate_owner_data`.
    - Added `mobile_phone` handling.
- v1.2.1 (2025-05-15): Removed credit_rating.
- v1.2.0 (2025-05-15): Added delete_master_owner method.
"""

import logging
import re
from typing import List, Optional, Tuple, Dict, Any
from decimal import Decimal, InvalidOperation
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import or_, func, exc as sqlalchemy_exc

from config.database_config import db_manager
from models import (
    Owner,
    StateProvince,
    HorseOwner,
)
from datetime import datetime


class OwnerController:
    """Controller for owner master file operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_master_owners(self, status_filter: str = "all") -> List[Owner]:
        session = db_manager.get_session()
        try:
            query = session.query(Owner).options(joinedload(Owner.state))

            if status_filter == "active":
                query = query.filter(Owner.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Owner.is_active == False)

            owners = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()
            self.logger.info(
                f"Retrieved {len(owners)} master owners (status_filter={status_filter})."
            )
            return owners
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all master owners: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_all_owners_for_lookup(self, search_term: str = "") -> List[Dict[str, Any]]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            query = session.query(
                Owner.owner_id,
                Owner.first_name,
                Owner.last_name,
                Owner.farm_name,
                Owner.account_number,
            ).filter(Owner.is_active == True)

            if search_term:
                search_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Owner.first_name.ilike(search_pattern),
                        Owner.last_name.ilike(search_pattern),
                        Owner.farm_name.ilike(search_pattern),
                        Owner.account_number.ilike(search_pattern),
                    )
                )

            owners_data = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()

            lookup_list = []
            for (
                owner_id,
                first_name,
                last_name,
                farm_name,
                account_number,
            ) in owners_data:
                name_parts = [name for name in [first_name, last_name] if name]
                individual_name = " ".join(name_parts)
                display_text = farm_name if farm_name else ""
                if individual_name:
                    display_text = (
                        f"{display_text} ({individual_name})"
                        if farm_name
                        else individual_name
                    )
                if not display_text:
                    display_text = f"Owner ID {owner_id}"  # Fallback if no names
                if account_number:
                    display_text += f" [{account_number}]"
                lookup_list.append({"id": owner_id, "name_account": display_text})
            return lookup_list
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching owners for lookup: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_owner_by_id(self, owner_id: int) -> Optional[Owner]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            owner = (
                session.query(Owner)
                .options(joinedload(Owner.state))  # Eager load state here too
                .filter(Owner.owner_id == owner_id)
                .first()
            )
            return owner
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owner by ID '{owner_id}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_owner_data(
        self,
        owner_data: dict,
        is_new: bool = True,
        owner_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        # ... (implementation unchanged) ...
        errors = []
        first_name = owner_data.get("first_name")
        last_name = owner_data.get("last_name")
        farm_name = owner_data.get("farm_name")
        account_number_val = owner_data.get("account_number")

        if not owner_data.get("address_line1", "").strip():
            errors.append("Address Line 1 is required.")
        if not owner_data.get("city", "").strip():
            errors.append("City is required.")
        if not owner_data.get("state_code", "").strip():
            errors.append("State is required.")
        if not owner_data.get("zip_code", "").strip():
            errors.append("Zip Code is required.")

        field_max_lengths = {
            "first_name": 50,
            "last_name": 50,
            "farm_name": 100,
            "address_line1": 100,
            "address_line2": 100,
            "city": 50,
            "zip_code": 20,
            "phone": 20,
            "mobile_phone": 20,
            "email": 100,
            "account_number": 20,
            "billing_terms": 50,
        }

        for field, max_len in field_max_lengths.items():
            value = owner_data.get(field)
            if value is not None and isinstance(value, str) and len(value) > max_len:
                errors.append(
                    f"{field.replace('_', ' ').title()} cannot exceed {max_len} characters."
                )

        email_val = owner_data.get("email")
        if email_val and email_val.strip():
            if not re.match(
                r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email_val
            ):
                errors.append("Invalid email format.")

        if account_number_val and account_number_val.strip():
            session = db_manager.get_session()
            try:
                query = session.query(Owner).filter(
                    Owner.account_number.collate("NOCASE") == account_number_val.strip()
                )
                if not is_new and owner_id_to_ignore is not None:
                    query = query.filter(Owner.owner_id != owner_id_to_ignore)

                existing_owner_with_account = query.first()
                if existing_owner_with_account:
                    errors.append(
                        f"Account Number '{account_number_val}' already exists."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"DB error validating account_number: {e}", exc_info=True
                )
                errors.append("Error validating account number uniqueness.")
            finally:
                session.close()

        credit_limit_str = owner_data.get("credit_limit")
        if credit_limit_str is not None and str(credit_limit_str).strip() != "":
            try:
                credit_limit_decimal = Decimal(str(credit_limit_str))
                if credit_limit_decimal < Decimal("0.00"):
                    errors.append("Credit Limit cannot be negative.")
            except InvalidOperation:
                errors.append("Credit Limit must be a valid number (e.g., 1000.00).")

        return not errors, errors

    def create_master_owner(
        self, owner_data: dict, current_user: str
    ) -> Tuple[bool, str, Optional[Owner]]:
        # ... (implementation unchanged) ...
        is_valid, errors = self.validate_owner_data(owner_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_owner_params = {}
            allowed_keys = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",
                "phone",
                "mobile_phone",
                "email",
                "credit_limit",
                "billing_terms",
                "is_active",
                "balance",
                "service_charge_rate",
                "discount_rate",
                "notes",
            ]
            for key in allowed_keys:
                if key in owner_data:
                    value = owner_data[key]
                    if isinstance(value, str):
                        new_owner_params[key] = value.strip() or None
                    elif (
                        key == "credit_limit"
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            self.logger.warning(
                                f"Invalid decimal for credit_limit: {value}. Setting to None."
                            )
                            new_owner_params[key] = None
                    elif (
                        key == "balance"
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            new_owner_params[key] = Decimal("0.00")
                    elif (
                        key in ["service_charge_rate", "discount_rate"]
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            new_owner_params[key] = None
                    else:
                        new_owner_params[key] = value

            if new_owner_params.get("balance") is None:
                new_owner_params["balance"] = Decimal("0.00")

            if new_owner_params.get("is_active") is None:
                new_owner_params["is_active"] = True

            new_owner = Owner(**new_owner_params)
            new_owner.created_by = current_user
            new_owner.modified_by = current_user

            session.add(new_owner)
            session.commit()
            session.refresh(new_owner)

            log_name_parts = [
                name for name in [new_owner.first_name, new_owner.last_name] if name
            ]
            log_individual_name = " ".join(log_name_parts)
            display_name_for_log = new_owner.farm_name if new_owner.farm_name else ""
            if log_individual_name:
                display_name_for_log = (
                    f"{display_name_for_log} ({log_individual_name})"
                    if new_owner.farm_name
                    else log_individual_name
                )
            if not display_name_for_log:
                display_name_for_log = f"Owner ID {new_owner.owner_id}"

            self.logger.info(
                f"Master Owner '{display_name_for_log}' (ID: {new_owner.owner_id}) created by {current_user}."
            )
            return True, "Owner created successfully.", new_owner
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating master owner: {ie.orig}", exc_info=True
            )
            if "UNIQUE constraint failed: owners.account_number" in str(
                ie.orig
            ).lower() and owner_data.get("account_number"):
                return (
                    False,
                    f"Account Number '{owner_data['account_number']}' already exists.",
                    None,
                )
            return False, f"Database integrity error: {ie.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating master owner: {e}", exc_info=True)
            return False, f"Failed to create owner: {e}", None
        finally:
            session.close()

    def update_master_owner(
        self, owner_id: int, owner_data: dict, current_user: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return False, f"Owner with ID {owner_id} not found."

            original_account_number = owner.account_number
            if (
                "account_number" in owner_data
                and owner_data["account_number"] != original_account_number
            ):
                is_valid, errors = self.validate_owner_data(
                    owner_data, is_new=False, owner_id_to_ignore=owner_id
                )
            else:
                temp_data_for_validation = owner_data.copy()
                temp_data_for_validation.pop("account_number", None)
                is_valid, errors = self.validate_owner_data(
                    temp_data_for_validation, is_new=False, owner_id_to_ignore=owner_id
                )

            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            updatable_fields = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",
                "phone",
                "mobile_phone",
                "email",
                "is_active",
                "balance",
                "credit_limit",
                "billing_terms",
                "service_charge_rate",
                "discount_rate",
                "notes",
            ]

            for key in updatable_fields:
                if key in owner_data:
                    value = owner_data[key]
                    if isinstance(value, str):
                        setattr(
                            owner,
                            key,
                            (
                                value.strip() or None
                                if key
                                not in [
                                    "last_name",
                                    "address_line1",
                                    "city",
                                    "state_code",
                                    "zip_code",
                                ]
                                else value.strip()
                            ),
                        )
                    elif (
                        key
                        in [
                            "credit_limit",
                            "balance",
                            "service_charge_rate",
                            "discount_rate",
                        ]
                        and value is not None
                    ):
                        if str(value).strip() == "":
                            if key == "balance":
                                setattr(owner, key, Decimal("0.00"))
                            else:
                                setattr(owner, key, None)
                        else:
                            try:
                                setattr(owner, key, Decimal(str(value)))
                            except InvalidOperation:
                                self.logger.warning(
                                    f"Invalid decimal value for {key}: {value} during update. Field not updated."
                                )
                    else:
                        setattr(owner, key, value)

            owner.modified_by = current_user

            session.commit()
            return True, "Owner updated successfully."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError updating owner ID {owner_id}: {ie.orig}", exc_info=True
            )
            if "UNIQUE constraint failed: owners.account_number" in str(
                ie.orig
            ).lower() and owner_data.get("account_number"):
                return (
                    False,
                    f"Account Number '{owner_data['account_number']}' already exists for another owner.",
                )
            return False, f"Database integrity error: {ie.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating master owner ID {owner_id}: {e}", exc_info=True
            )
            return False, f"Failed to update owner: {e}"
        finally:
            session.close()

    def delete_master_owner(
        self, owner_id_to_delete: int, current_admin_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            owner = (
                session.query(Owner)
                .filter(Owner.owner_id == owner_id_to_delete)
                .first()
            )
            if not owner:
                return False, f"Owner with ID {owner_id_to_delete} not found."

            linked_horses_count = (
                session.query(HorseOwner)
                .filter(HorseOwner.owner_id == owner_id_to_delete)
                .count()
            )
            if linked_horses_count > 0:
                self.logger.warning(
                    f"Attempt to delete owner ID {owner_id_to_delete} who is linked to {linked_horses_count} horse(s)."
                )
                return (
                    False,
                    f"Cannot delete owner. They are currently linked to {linked_horses_count} horse(s). Please unlink them from all horses first.",
                )

            owner_name_for_log_parts = [
                name
                for name in [owner.farm_name, owner.last_name, owner.first_name]
                if name
            ]
            owner_name_for_log = (
                " ".join(owner_name_for_log_parts) or f"ID {owner_id_to_delete}"
            )

            session.delete(owner)
            session.commit()
            self.logger.info(
                f"Master Owner '{owner_name_for_log}' (ID: {owner_id_to_delete}) permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"Owner '{owner_name_for_log}' deleted successfully."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error deleting master owner ID {owner_id_to_delete}: {e}",
                exc_info=True,
            )
            if isinstance(e, sqlalchemy_exc.IntegrityError):
                return (
                    False,
                    f"Cannot delete owner. It might be referenced by other records (e.g., invoices, payments). Details: {e.orig}",
                )
            return False, f"Failed to delete owner due to a database error: {e}"
        finally:
            session.close()

    def get_owner_form_reference_data(self) -> Dict[str, List[Dict[str, Any]]]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            states_query = (
                session.query(
                    StateProvince.state_code,
                    StateProvince.state_name,
                    StateProvince.country_code,
                )
                .filter(StateProvince.is_active == True)
                .order_by(StateProvince.country_code, StateProvince.state_name)
                .all()
            )
            states = [
                {
                    "id": s.state_code,
                    "name": s.state_name,
                    "country_code": s.country_code,
                }
                for s in states_query
            ]
            billing_terms_list = [
                {"id": "NET30", "name": "Net 30 Days"},
                {"id": "NET15", "name": "Net 15 Days"},
                {"id": "NET60", "name": "Net 60 Days"},
                {"id": "COD", "name": "Cash on Delivery"},
                {"id": "PREPAID", "name": "Prepaid"},
                {"id": "EOM", "name": "End of Month"},
                {"id": "ONDELIVERY", "name": "Payment on Delivery"},
            ]
            return {"states": states, "billing_terms": billing_terms_list}
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owner form reference data: {e}", exc_info=True
            )
            return {"states": [], "billing_terms": []}
        finally:
            session.close()

    def toggle_owner_active_status(
        self, owner_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return False, "Owner not found."
            owner.is_active = not owner.is_active
            owner.modified_by = current_user_id
            session.commit()
            status = "activated" if owner.is_active else "deactivated"
            self.logger.info(f"Owner ID {owner_id} {status} by {current_user_id}.")
            return True, f"Owner {status} successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error toggling active status for owner ID {owner_id}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle owner status: {e}"
        finally:
            session.close()


=============== FILE: controllers\user_controller.py ===============

# controllers/user_controller.py
"""
EDSI Veterinary Management System - User Controller
Version: 1.3.0
Purpose: Handles user authentication, CRUD operations.
         - Standardized get_all_users filter to use a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-05):
    - Modified `get_all_users` to accept a string `status_filter` ('active',
      'inactive', 'all') for consistency with other controllers.
- v1.2.8 (2025-06-05):
    - In `toggle_user_active_status`, added a check to prevent a user from
      deactivating their own account, moving this business rule from the
      view into the controller for better enforcement.
- v1.2.7 (2025-06-05):
    - Added `toggle_user_active_status` method to handle activating and
      deactivating users, including a safeguard to prevent deactivating the
      last active ADMIN account.
"""

import logging
from typing import List, Optional, Tuple, Dict, Any
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func, exc as sqlalchemy_exc
from datetime import datetime

from config.database_config import db_manager
from models.user_models import User, Role, UserRole


class UserController:
    """Controller for user management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def authenticate_user(
        self, login_id_attempt: str, password_attempt: str
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        # ... (implementation unchanged) ...
        try:
            self.logger.info(
                f"UserController.authenticate_user received login_id: '{login_id_attempt}', "
                f"password_attempt (first 3 chars): '{password_attempt[:3] if password_attempt else ''}...'"
            )
            session = db_manager.get_session()
            try:
                user = (
                    session.query(User)
                    .filter(User.user_id.collate("NOCASE") == login_id_attempt)
                    .first()
                )
                if not user:
                    self.logger.warning(
                        f"Login ID '{login_id_attempt}' not found during authentication."
                    )
                    return False, "Invalid Login ID or Password.", None
                if not user.check_password(password_attempt):
                    self.logger.warning(
                        f"Incorrect password attempt for login ID '{user.user_id}' (input was '{login_id_attempt}')."
                    )
                    return False, "Invalid Login ID or Password.", None
                if not user.is_active:
                    self.logger.warning(
                        f"Login attempt for inactive user '{user.user_id}'."
                    )
                    return (
                        False,
                        f"User account '{user.user_id}' is inactive.",
                        {
                            "user_id": user.user_id,
                            "user_name": user.user_name,
                            "is_active": user.is_active,
                        },
                    )
                if hasattr(user, "last_login"):
                    user.last_login = datetime.utcnow()
                session.commit()
                self.logger.info(f"User '{user.user_id}' authenticated successfully.")
                return (
                    True,
                    "Login successful.",
                    {
                        "user_id": user.user_id,
                        "user_name": user.user_name,
                        "is_active": user.is_active,
                    },
                )
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                session.rollback()
                self.logger.error(
                    f"Database error during authentication for '{login_id_attempt}': {e_db}",
                    exc_info=True,
                )
                return False, "An error occurred during login. Please try again.", None
            finally:
                session.close()
        except Exception as e_outer:
            self.logger.error(
                f"Outer unexpected error during authentication for '{login_id_attempt}': {e_outer}",
                exc_info=True,
            )
            return False, "An unexpected server error occurred. Please try again.", None

    def get_all_users(self, status_filter: str = "all") -> List[User]:
        session = db_manager.get_session()
        try:
            query = session.query(User).options(joinedload(User.roles))
            if status_filter == "active":
                query = query.filter(User.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(User.is_active == False)

            users = query.order_by(User.user_id).all()
            return users
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all users: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_user_by_login_id(self, login_id_str: str) -> Optional[User]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            return user
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching user by login_id '{login_id_str}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_user_data(
        self,
        user_data: Dict[str, Any],
        is_new: bool = True,
        original_login_id_to_ignore: Optional[str] = None,
    ) -> Tuple[bool, List[str]]:
        # ... (implementation unchanged) ...
        try:
            from views.admin.dialogs.add_edit_user_dialog import AddEditUserDialog

            available_roles_in_dialog = AddEditUserDialog.USER_ROLES
        except ImportError:
            self.logger.warning(
                "Could not import AddEditUserDialog for role validation. Role list might be incomplete."
            )
            available_roles_in_dialog = []
        errors = []
        login_id = user_data.get("user_id", "").strip()
        display_name = user_data.get("user_name", "").strip()
        password = user_data.get("password", "")
        email_value = user_data.get("email")
        email = email_value.strip() if isinstance(email_value, str) else None
        if not login_id:
            errors.append("Login ID (Username) is required.")
        elif len(login_id) > 20:
            errors.append("Login ID (Username) cannot exceed 20 characters.")
        elif " " in login_id:
            errors.append("Login ID (Username) cannot contain spaces.")
        else:
            session = db_manager.get_session()
            try:
                query = session.query(User).filter(
                    User.user_id.collate("NOCASE") == login_id
                )
                if not is_new and original_login_id_to_ignore is not None:
                    query = query.filter(
                        User.user_id.collate("NOCASE") != original_login_id_to_ignore
                    )
                if query.first():
                    errors.append(f"Login ID (Username) '{login_id}' already exists.")
                if email:
                    email_query = session.query(User).filter(User.email == email)
                    user_to_exclude_from_email_check = None
                    if not is_new and original_login_id_to_ignore:
                        original_user = (
                            session.query(User)
                            .filter(
                                User.user_id.collate("NOCASE")
                                == original_login_id_to_ignore
                            )
                            .first()
                        )
                        if original_user:
                            user_to_exclude_from_email_check = original_user.user_id
                    if user_to_exclude_from_email_check:
                        email_query = email_query.filter(
                            User.user_id != user_to_exclude_from_email_check
                        )
                    if email_query.first():
                        errors.append(f"Email '{email}' is already in use.")
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                self.logger.error(
                    f"DB error validating login_id/email uniqueness: {e_db}",
                    exc_info=True,
                )
                errors.append("Error validating login_id/email uniqueness.")
            finally:
                session.close()
        if not display_name:
            errors.append("Full Name (User Name) is required.")
        elif len(display_name) > 100:
            errors.append("Full Name (User Name) cannot exceed 100 characters.")
        if is_new:
            if not password:
                errors.append("Password is required for new users.")
            elif len(password) < 6:
                errors.append("Password must be at least 6 characters long.")
        elif password and len(password) < 6:
            errors.append("New password must be at least 6 characters long.")
        if email and (
            len(email) > 100 or ("@" not in email or "." not in email.split("@")[-1])
        ):
            errors.append(
                "Invalid email format or email too long (max 100 characters)."
            )
        role_str = user_data.get("role")
        if not role_str and is_new:
            errors.append("Role is required for new users.")
        if role_str:
            session = db_manager.get_session()
            try:
                if not session.query(Role).filter(Role.name == role_str).first():
                    errors.append(f"Role '{role_str}' does not exist in the database.")
            finally:
                session.close()
        return not errors, errors

    def create_user(
        self, user_data: Dict[str, Any], current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[User]]:
        # ... (implementation unchanged) ...
        login_id_to_store = user_data.get("user_id", "").strip()
        if not login_id_to_store:
            return False, "Login ID (Username) cannot be empty.", None
        if login_id_to_store.upper() == "ADMIN":
            login_id_to_store = "ADMIN"
        data_for_model = {
            "user_id": login_id_to_store,
            "user_name": user_data.get("user_name", "").strip(),
            "email": user_data.get("email"),
            "is_active": user_data.get("is_active", True),
            "created_by": current_admin_id,
            "modified_by": current_admin_id,
            "printer_id": user_data.get("printer_id"),
            "default_screen_colors": user_data.get("default_screen_colors"),
        }
        password_to_set = user_data.get("password", "")
        role_name_to_assign = user_data.get("role")
        validation_payload = {
            **data_for_model,
            "password": password_to_set,
            "role": role_name_to_assign,
        }
        is_valid, errors = self.validate_user_data(validation_payload, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None
        session = db_manager.get_session()
        try:
            processed_email = data_for_model["email"]
            if isinstance(processed_email, str):
                processed_email = processed_email.strip()
                if not processed_email:
                    processed_email = None
            data_for_model["email"] = processed_email
            new_user = User(**data_for_model)
            new_user.set_password(password_to_set)
            if role_name_to_assign:
                role_obj = (
                    session.query(Role).filter(Role.name == role_name_to_assign).first()
                )
                if role_obj:
                    new_user.roles.append(role_obj)
                else:
                    self.logger.error(
                        f"Role '{role_name_to_assign}' for new user '{new_user.user_id}' not found in DB during create. Validation might have missed this."
                    )
            session.add(new_user)
            session.commit()
            session.refresh(new_user)
            self.logger.info(
                f"User '{new_user.user_id}' created successfully by {current_admin_id}."
            )
            return True, "User created successfully.", new_user
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e.orig}",
                exc_info=True,
            )
            error_str = str(e.orig).lower()
            if "unique constraint failed: users.user_id" in error_str:
                return (
                    False,
                    f"Login ID (Username) '{data_for_model['user_id']}' already exists.",
                    None,
                )
            elif (
                "unique constraint failed: users.email" in error_str
                and data_for_model["email"]
            ):
                return (
                    False,
                    f"Email '{data_for_model['email']}' is already in use.",
                    None,
                )
            return False, f"Database integrity error: {e.orig}", None
        except AttributeError as ae:
            session.rollback()
            self.logger.error(
                f"AttributeError during user creation for '{data_for_model.get('user_id')}': {ae}",
                exc_info=True,
            )
            return False, f"Failed to set user attribute during creation: {ae}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e}",
                exc_info=True,
            )
            return False, f"Failed to create user: {e}", None
        finally:
            session.close()

    def update_user(
        self,
        user_id_to_update: str,
        user_data: Dict[str, Any],
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == user_id_to_update)
                .first()
            )
            if not user:
                return False, f"User with Login ID '{user_id_to_update}' not found."
            validation_data = {
                "user_id": user.user_id,
                "user_name": user_data.get("user_name", user.user_name),
                "email": user_data.get("email", user.email),
                "role": user_data.get("role"),
            }
            if "password" in user_data and user_data["password"]:
                validation_data["password"] = user_data["password"]
            is_valid, errors = self.validate_user_data(
                validation_data, is_new=False, original_login_id_to_ignore=user.user_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)
            roles_modified = False
            if "user_name" in user_data:
                user.user_name = user_data["user_name"].strip()
            if "email" in user_data:
                email_val = user_data["email"]
                user.email = email_val.strip() if isinstance(email_val, str) else None
                if user.email == "":
                    user.email = None
            if "password" in user_data and user_data["password"]:
                user.set_password(user_data["password"])
            if "is_active" in user_data:
                if user.user_id.upper() == "ADMIN" and not user_data["is_active"]:
                    active_admin_query = session.query(User).filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    if user.is_active:
                        if active_admin_query.count() <= 1:
                            self.logger.warning(
                                f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') was prevented."
                            )
                            return (
                                False,
                                "Cannot deactivate the last active ADMIN user.",
                            )
                    user.is_active = user_data["is_active"]
                else:
                    user.is_active = user_data["is_active"]
            new_role_name_from_data = user_data.get("role")
            if new_role_name_from_data is not None:
                current_role_names = {r.name for r in user.roles}
                if not (
                    len(current_role_names) == 1
                    and new_role_name_from_data in current_role_names
                ):
                    roles_modified = True
                    user.roles.clear()
                    if new_role_name_from_data:
                        role_obj = (
                            session.query(Role)
                            .filter(Role.name == new_role_name_from_data)
                            .first()
                        )
                        if role_obj:
                            user.roles.append(role_obj)
                        else:
                            self.logger.error(
                                f"Role object for '{new_role_name_from_data}' not found during update. User '{user.user_id}' will have no roles."
                            )
            if "printer_id" in user_data:
                user.printer_id = user_data["printer_id"]
            if "default_screen_colors" in user_data:
                user.default_screen_colors = user_data["default_screen_colors"]
            user.modified_by = current_admin_id
            if roles_modified:
                session.add(user)
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' updated successfully by {current_admin_id}."
            )
            return True, "User updated successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e.orig}", exc_info=True
            )
            if "unique constraint failed: users.email" in str(
                e.orig
            ).lower() and validation_data.get("email"):
                return (
                    False,
                    f"Email '{validation_data['email']}' is already in use by another user.",
                )
            return False, f"Database integrity error: {e.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e}", exc_info=True
            )
            return False, f"Failed to update user: {str(e)}"
        finally:
            session.close()

    def change_password(
        self,
        login_id_str: str,
        new_password: str,
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        if not new_password or len(new_password) < 6:
            return False, "New password must be at least 6 characters long."
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if not user:
                return False, f"User '{login_id_str}' not found."
            user.set_password(new_password)
            user.modified_by = current_admin_id
            session.commit()
            self.logger.info(
                f"Password changed successfully for user '{user.user_id}' by {current_admin_id}."
            )
            return True, "Password changed successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error changing password for user '{login_id_str}': {e}", exc_info=True
            )
            return False, f"Failed to change password: {str(e)}"
        finally:
            session.close()

    def get_user_roles(self, login_id_str: str) -> List[str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if user and user.roles:
                return [role.name for role in user.roles]
            return []
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching roles for user '{login_id_str}': {e}", exc_info=True
            )
            return []
        finally:
            session.close()

    def delete_user_permanently(
        self, user_id_to_delete: str, current_admin_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_id_to_delete)
                .first()
            )
            if not user:
                return False, f"User '{user_id_to_delete}' not found."
            if user.user_id.upper() == "ADMIN":
                active_admin_count = (
                    session.query(User)
                    .filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    .count()
                )
                if active_admin_count <= 1 and user.is_active:
                    self.logger.warning(
                        f"Attempt to delete the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                    )
                    return (
                        False,
                        "Cannot delete the primary ADMIN account if it's the last active one.",
                    )
            session.delete(user)
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"User '{user.user_id}' deleted successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Database integrity error deleting user '{user_id_to_delete}': {e.orig}",
                exc_info=True,
            )
            return (
                False,
                f"Cannot delete user. They may be referenced by other records. ({e.orig})",
            )
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error deleting user '{user_id_to_delete}': {e}", exc_info=True
            )
            return False, f"Failed to delete user: {str(e)}"
        finally:
            session.close()

    def toggle_user_active_status(
        self, user_login_id: str, current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_login_id)
                .first()
            )
            if not user:
                return False, f"User '{user_login_id}' not found."

            is_deactivating = user.is_active
            if is_deactivating:
                # Rule 1: Cannot deactivate yourself
                if user.user_id == current_admin_id:
                    self.logger.warning(
                        f"User '{current_admin_id}' attempted to deactivate their own account. Operation prevented."
                    )
                    return False, "You cannot deactivate your own account."

                # Rule 2: Cannot deactivate the last active admin
                if user.has_role("ADMIN"):
                    active_admin_count = (
                        session.query(User)
                        .join(User.roles)
                        .filter(Role.name == "ADMIN", User.is_active == True)
                        .count()
                    )
                    if active_admin_count <= 1:
                        self.logger.warning(
                            f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                        )
                        return False, "Cannot deactivate the last active ADMIN user."

            # Toggle the status
            new_status = not user.is_active
            user.is_active = new_status
            user.modified_by = current_admin_id

            session.commit()

            status_str = "activated" if new_status else "deactivated"
            self.logger.info(
                f"User '{user.user_id}' has been {status_str} by {current_admin_id}."
            )
            return True, f"User '{user.user_id}' has been successfully {status_str}."

        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error toggling status for user '{user_login_id}': {e}",
                exc_info=True,
            )
            return False, "A database error occurred."
        finally:
            session.close()

    def get_all_roles(self) -> List[Role]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            roles = session.query(Role).order_by(Role.name).all()
            self.logger.info(f"Retrieved {len(roles)} roles.")
            return roles
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error retrieving roles: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()


=============== FILE: models\__init__.py ===============

# models/__init__.py
"""
EDSI Veterinary Management System - Models Package
Version: (Adjust version as needed)
Purpose: Initializes the models package, making all data models accessible.
         Ensures definitive Transaction and Invoice models from financial_models are primary.
Last Updated: June 4, 2025
Author: Gemini

Changelog:
- (Date): Adjusted imports to prioritize Transaction and Invoice from financial_models.
          Removed direct import of placeholder Transaction from reference_models.
          Commented out placeholder Invoice from owner_models in __all__.
"""

from .base_model import Base, BaseModel
from .user_models import User, Role, UserRole
from .horse_models import Horse, HorseOwner, HorseLocation
from .owner_models import (
    Owner,
    OwnerBillingHistory,
    OwnerPayment,
)  # Invoice placeholder removed from this file directly
from .reference_models import (
    StateProvince,
    ChargeCodeCategory,
    ChargeCode,
    Veterinarian,
    Location,
    Procedure,
    Drug,
    TreatmentLog,
    CommunicationLog,
    Document,
    Reminder,
    Appointment,
    # Placeholder Transaction and TransactionDetail removed from reference_models.py
)
from .financial_models import Transaction, Invoice  # Definitive financial models

__all__ = [
    "Base",
    "BaseModel",
    "User",
    "Role",
    "UserRole",
    "Horse",
    "HorseOwner",
    "HorseLocation",
    "Owner",
    "OwnerBillingHistory",
    "OwnerPayment",
    # Note: The placeholder Invoice from owner_models.py has been removed from that file.
    # The 'Invoice' in this list now unambiguously refers to the one from financial_models.
    "StateProvince",
    "ChargeCodeCategory",
    "ChargeCode",
    "Veterinarian",
    "Location",
    "Procedure",
    "Drug",
    "TreatmentLog",
    "CommunicationLog",
    "Document",
    "Reminder",
    "Appointment",
    # New Definitive Models
    "Transaction",
    "Invoice",
]


=============== FILE: models\base_model.py ===============

# models/base_model.py

"""
EDSI Veterinary Management System - Base Model Definition
Version: 2.0.0
Purpose: Simplified base model with essential audit fields and clean declarative base.
         Removed over-complexity and focused on stable foundation.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Removed circular import issues by importing Base from database_config
    - Simplified BaseModel with essential audit fields only
    - Clean datetime handling without over-engineering
    - Removed unnecessary complexity in __repr__ method
    - Clear separation between Base and BaseModel
    - Focused on stable, working foundation
    - Consistent audit field naming and types
"""

from datetime import datetime
from sqlalchemy import Column, DateTime, String
from config.database_config import Base


class BaseModel(Base):
    """
    Abstract base model providing common audit fields for all database tables.

    Provides:
    - created_date: When the record was created
    - modified_date: When the record was last modified
    - created_by: User ID who created the record
    - modified_by: User ID who last modified the record
    """

    __abstract__ = True  # This class should not be mapped to a database table

    # Audit fields
    created_date = Column(
        DateTime,
        default=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was created",
    )

    modified_date = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was last modified",
    )

    created_by = Column(
        String(50), nullable=True, doc="User ID who created this record"
    )

    modified_by = Column(
        String(50), nullable=True, doc="User ID who last modified this record"
    )

    def __repr__(self):
        """
        Simple string representation of the model instance.
        Uses the first primary key column for identification.
        """
        try:
            # Get the primary key column name and value
            primary_key = self.__mapper__.primary_key[0]
            pk_name = primary_key.name
            pk_value = getattr(self, pk_name, "Unknown")

            return f"<{self.__class__.__name__}({pk_name}={pk_value})>"

        except (IndexError, AttributeError):
            # Fallback if primary key detection fails
            return f"<{self.__class__.__name__}(id=Unknown)>"

    def update_modified_by(self, user_id: str) -> None:
        """
        Update the modified_by field with the given user_id.

        Args:
            user_id: The ID of the user making the modification
        """
        self.modified_by = user_id
        # Note: modified_date will be automatically updated by SQLAlchemy onupdate

    def set_created_by(self, user_id: str) -> None:
        """
        Set the created_by field with the given user_id.
        This should only be called when creating new records.

        Args:
            user_id: The ID of the user creating the record
        """
        self.created_by = user_id
        if not self.modified_by:
            self.modified_by = user_id


=============== FILE: models\financial_models.py ===============

# models/financial_models.py
"""
EDSI Veterinary Management System - Financial Data Models
Version: 1.1.0
Purpose: Defines SQLAlchemy models for financial records like Transactions and Invoices.
         - Added fields for per-line taxable flag, item notes, and total invoice tax.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-05):
    - Added `taxable` (Boolean) and `item_notes` (Text) columns to the `Transaction`
      model to support per-item tax flagging and notes.
    - Added `tax_total` (Numeric) column to the `Invoice` model to store the
      manually entered total tax amount for an invoice.
- v1.0.0 (2025-06-04):
    - Initial creation of definitive Transaction and Invoice models.
"""

from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Text,
    ForeignKey,
    Date,
    Numeric,
    DateTime,
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import date

from .base_model import BaseModel


class Transaction(BaseModel):
    """
    Represents a single billable line item for a horse.
    This is the core of all financial activity.
    """

    __tablename__ = "transactions"

    transaction_id = Column(Integer, primary_key=True, index=True)
    horse_id = Column(
        Integer, ForeignKey("horses.horse_id"), nullable=False, index=True
    )
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    invoice_id = Column(
        Integer, ForeignKey("invoices.invoice_id"), nullable=True, index=True
    )

    # Links to the specific charge code from the reference table
    charge_code_id = Column(
        Integer, ForeignKey("charge_codes.id"), nullable=False, index=True
    )

    # Who administered or recorded the charge
    administered_by_user_id = Column(
        String(20), ForeignKey("users.user_id"), nullable=True
    )

    transaction_date = Column(Date, nullable=False, default=date.today)
    description = Column(String(255), nullable=False)
    quantity = Column(Numeric(10, 2), nullable=False, default=1)
    unit_price = Column(Numeric(10, 2), nullable=False)
    total_price = Column(Numeric(10, 2), nullable=False)

    # New fields for enhanced billing UI
    taxable = Column(Boolean, default=False, nullable=False)
    item_notes = Column(Text, nullable=True)

    # Relationships
    horse = relationship("Horse")
    owner = relationship("Owner")
    invoice = relationship("Invoice", back_populates="transactions")
    charge_code = relationship("ChargeCode")
    administered_by = relationship("User")

    def __repr__(self):
        return f"<Transaction(id={self.transaction_id}, horse_id={self.horse_id}, total={self.total_price})>"


class Invoice(BaseModel):
    """
    Represents a bill sent to an owner, grouping multiple transactions.
    """

    __tablename__ = "invoices"

    invoice_id = Column(Integer, primary_key=True, index=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )

    invoice_date = Column(Date, nullable=False, default=date.today)
    due_date = Column(Date, nullable=True)

    subtotal = Column(Numeric(10, 2), nullable=False, default=0.00)

    # New field for manually entered tax
    tax_total = Column(Numeric(10, 2), nullable=True)

    grand_total = Column(Numeric(10, 2), nullable=False, default=0.00)
    amount_paid = Column(Numeric(10, 2), nullable=False, default=0.00)
    balance_due = Column(Numeric(10, 2), nullable=False, default=0.00)

    status = Column(
        String(50), nullable=False, default="Unpaid", index=True
    )  # e.g., Unpaid, Paid, Overdue, Void

    # Relationships
    owner = relationship("Owner", backref="invoices")
    transactions = relationship(
        "Transaction", back_populates="invoice", cascade="all, delete-orphan"
    )

    def __repr__(self):
        return f"<Invoice(id={self.invoice_id}, owner_id={self.owner_id}, total={self.grand_total}, status='{self.status}')>"


=============== FILE: models\horse_models.py ===============

# models/horse_models.py
"""
EDSI Veterinary Management System - Horse Related SQLAlchemy Models
Version: 1.2.17
Purpose: Defines the data models for horses, owners, and their relationships.
         - Reverted `back_populates` on HorseLocation.location relationship
           to "current_horses" to match expected relationship name on Location model.
Last Updated: May 25, 2025
Author: Gemini

Changelog:
- v1.2.17 (2025-05-25):
    - HorseLocation model: Changed `back_populates` for the `location` relationship
      from "horse_assignments" back to "current_horses" to resolve an
      InvalidRequestError due to mismatched relationship names with the
      (unseen) Location model. This assumes "current_horses" is the correct
      corresponding attribute on the Location model.
- v1.2.16 (2025-05-25):
    - HorseLocation model: Added `is_current_location` (Boolean) column.
    - Changed `back_populates` on HorseLocation.location to "horse_assignments" (this change is being reverted in v1.2.17).
- v1.2.15 (2025-05-23):
    - Horse model: Removed `species_id` column and `species` relationship.
# ... (rest of previous changelog entries assumed present)
"""
from sqlalchemy import Column, Integer, String, Date, Boolean, ForeignKey, Numeric, Text
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property
from datetime import date

from .base_model import Base, BaseModel


class HorseOwner(Base):
    __tablename__ = "horse_owners"
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), primary_key=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), primary_key=True)
    percentage_ownership = Column(Numeric(5, 2), nullable=True)

    horse = relationship("Horse", back_populates="owner_associations")
    owner = relationship("Owner", back_populates="horse_associations")


class HorseLocation(BaseModel):
    __tablename__ = "horse_locations"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=False)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=False)
    date_arrived = Column(Date, nullable=False, default=date.today)
    date_departed = Column(Date, nullable=True)
    notes = Column(Text, nullable=True)
    is_current_location = Column(Boolean, default=False, nullable=False, index=True)

    horse = relationship("Horse", back_populates="location_history")
    # REVERTED: back_populates to "current_horses" based on previous changelog
    # and to resolve InvalidRequestError.
    # This assumes the Location model has a relationship:
    # current_horses = relationship("HorseLocation", back_populates="location")
    location = relationship("Location", back_populates="current_horses")


class Horse(BaseModel):
    __tablename__ = "horses"

    horse_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    horse_name = Column(String(255), nullable=False, index=True)
    account_number = Column(String(50), index=True, nullable=True)
    breed = Column(String(100), nullable=True)
    color = Column(String(50), nullable=True)
    sex = Column(String(20), nullable=True)
    date_of_birth = Column(Date, nullable=True)
    height_hands = Column(Numeric(4, 2), nullable=True)

    chip_number = Column(String(50), nullable=True, unique=True)
    tattoo_number = Column(String(50), nullable=True, unique=True)
    description = Column(Text, nullable=True)

    is_active = Column(Boolean, default=True, nullable=False)
    date_deceased = Column(Date, nullable=True)
    coggins_date = Column(Date, nullable=True)

    current_location_id = Column(
        Integer, ForeignKey("locations.location_id"), nullable=True
    )

    owner_associations = relationship(
        "HorseOwner", back_populates="horse", cascade="all, delete-orphan"
    )
    owners = relationship(
        "Owner",
        secondary="horse_owners",
        back_populates="horses",
        viewonly=True,
        lazy="selectin",
    )

    location_history = relationship(
        "HorseLocation",
        back_populates="horse",
        order_by="desc(HorseLocation.date_arrived)",
        cascade="all, delete-orphan",
        lazy="selectin",
    )
    location = relationship(
        "Location", foreign_keys=[current_location_id], lazy="joined"
    )

    @hybrid_property
    def age(self):
        if self.date_of_birth:
            today = date.today()
            return (
                today.year
                - self.date_of_birth.year
                - (
                    (today.month, today.day)
                    < (self.date_of_birth.month, self.date_of_birth.day)
                )
            )
        return None

    @validates("chip_number", "tattoo_number")
    def convert_empty_to_none(self, key, value):
        if isinstance(value, str) and not value.strip():
            return None
        return value


=============== FILE: models\owner_models.py ===============

# models/owner_models.py
"""
EDSI Veterinary Management System - Owner Related Models
Version: 1.1.7
Purpose: Defines SQLAlchemy models for Owner and related entities.
         - Removed the placeholder Invoice model to avoid conflict with the
           definitive Invoice model in financial_models.py.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.7 (2025-06-04):
    - Removed the placeholder `Invoice` class definition. The definitive `Invoice`
      model is now in `models/financial_models.py`.
      The backref from Owner to the new Invoice model is handled in financial_models.py.
- v1.1.6 (2025-05-23):
    - Ensured the `Invoice` class is correctly defined.
    - Imported `sqlalchemy.sql.func` for `func.current_date()` default in `Invoice.invoice_date`.
# ... (rest of previous changelog)
"""

from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Numeric,
    Text,
    ForeignKey,
    Date,
    DateTime,
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import datetime

from .base_model import BaseModel


class Owner(BaseModel):
    """Model for horse owners (master list)."""

    __tablename__ = "owners"

    # Changed owner_id to id for potential consistency, but will keep owner_id if it's deeply embedded.
    # For now, keeping owner_id as per existing structure.
    # If financial_models.Transaction.owner_id refers to 'owners.id', then this needs to be 'id'.
    # Checking financial_models.py: owner_id = Column(Integer, ForeignKey("owners.owner_id") ...
    # So, owner_id is correct here.
    owner_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    account_number = Column(String(20), unique=True, nullable=True, index=True)
    farm_name = Column(String(100), nullable=True, index=True)
    first_name = Column(String(50), nullable=True)
    last_name = Column(String(50), nullable=True, index=True)

    address_line1 = Column(String(100))
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50))

    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), index=True
    )

    zip_code = Column(String(20))

    phone = Column(String(20), nullable=True)
    mobile_phone = Column(String(20), nullable=True)
    email = Column(String(100), nullable=True, index=True)

    is_active = Column(Boolean, default=True, nullable=False)

    balance = Column(Numeric(10, 2), default=0.00)
    credit_limit = Column(Numeric(10, 2), nullable=True)
    billing_terms = Column(String(50), nullable=True)
    service_charge_rate = Column(Numeric(5, 2), nullable=True)
    discount_rate = Column(Numeric(5, 2), nullable=True)

    notes = Column(Text, nullable=True)

    state = relationship("StateProvince", foreign_keys=[state_code], backref="owners")

    horse_associations = relationship(
        "HorseOwner", back_populates="owner", cascade="all, delete-orphan"
    )

    horses = relationship(
        "Horse", secondary="horse_owners", back_populates="owners", viewonly=True
    )

    billing_history = relationship(
        "OwnerBillingHistory", back_populates="owner", cascade="all, delete-orphan"
    )
    payments_made = relationship(
        "OwnerPayment", back_populates="owner", cascade="all, delete-orphan"
    )

    # The 'invoices' backref is now defined in financial_models.Invoice linking to this Owner model.
    # No need for: # invoices = relationship("Invoice", back_populates="owner")

    def __repr__(self):
        display_name = (
            self.farm_name
            or f"{self.first_name or ''} {self.last_name or ''}".strip()
            or f"ID:{self.owner_id}"
        )
        return f"<Owner(owner_id={self.owner_id}, name='{display_name}')>"


class OwnerBillingHistory(BaseModel):
    """Billing history entries for an owner."""

    __tablename__ = "owner_billing_history"

    history_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    entry_date = Column(DateTime, default=datetime.utcnow)
    description = Column(String(255), nullable=False)
    amount_change = Column(Numeric(10, 2), nullable=False)  # Made non-nullable
    new_balance = Column(Numeric(10, 2), nullable=False)  # Made non-nullable

    owner = relationship("Owner", back_populates="billing_history")

    def __repr__(self):
        return f"<OwnerBillingHistory(owner_id={self.owner_id}, date='{self.entry_date}', desc='{self.description}')>"


class OwnerPayment(BaseModel):
    """Payments made by an owner."""

    __tablename__ = "owner_payments"

    payment_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    payment_date = Column(Date, nullable=False, default=func.current_date)
    amount = Column(Numeric(10, 2), nullable=False)
    payment_method = Column(String(50), nullable=False)  # Made non-nullable
    reference_number = Column(String(100), nullable=True)
    notes = Column(Text, nullable=True)  # Nullable is fine for notes

    owner = relationship(
        "Owner", foreign_keys=[owner_id], back_populates="payments_made"
    )

    def __repr__(self):
        return f"<OwnerPayment(owner_id={self.owner_id}, date='{self.payment_date}', amount={self.amount})>"


# class Invoice(BaseModel): # REMOVED - Definitive model is in financial_models.py
#    pass


=============== FILE: models\reference_models.py ===============

# models/reference_models.py
"""
EDSI Veterinary Management System - Reference Data Models
Version: 1.1.22
Purpose: Defines SQLAlchemy models for various reference data entities.
         - Removed placeholder Transaction and TransactionDetail models
           to avoid conflict with definitive models in financial_models.py.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.22 (2025-06-04):
    - Removed placeholder `Transaction` and `TransactionDetail` class definitions
      as these are now fully defined in `models/financial_models.py`.
- v1.1.21 (2025-06-03):
    - In `Location` model: Uncommented the `current_horses` relationship to
      `HorseLocation` and ensured `back_populates="location"` is correct.
      This fixes the `InvalidRequestError: Mapper 'Mapper[Location(locations)]'
      has no property 'current_horses'` during mapper configuration.
# ... (rest of previous changelog)
"""
from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Text,
    ForeignKey,
    Date,
    Numeric,
    DateTime,
    Table,
)
from sqlalchemy.orm import (
    relationship,
    backref,
)
from sqlalchemy.sql import func

from .base_model import (
    Base,
    BaseModel,
)


class StateProvince(
    BaseModel, Base
):  # BaseModel already inherits Base, so just BaseModel is fine.
    # Or if Base is intended to be mixed in for some reason, it's okay.
    # For consistency, let's assume BaseModel is sufficient as it inherits Base.
    # Will correct to just BaseModel if this is the standard in your other models.
    # Re-checking your base_model.py: BaseModel(Base). So this is fine.
    __tablename__ = "state_provinces"
    state_province_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )
    state_code = Column(String(10), nullable=False, unique=True, index=True)
    state_name = Column(String(50), nullable=False)
    country_code = Column(String(10), nullable=False, default="USA")
    is_active = Column(Boolean, default=True, nullable=False)

    def __repr__(self):
        return (
            f"<StateProvince(state_code='{self.state_code}', name='{self.state_name}')>"
        )


class ChargeCodeCategory(BaseModel, Base):
    __tablename__ = "charge_code_categories"

    category_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique category identifier",
    )
    name = Column(
        String(100),
        nullable=False,
        index=True,
        doc="Name of the category level (e.g., 'Anthelmintics', 'Administered')",
    )
    parent_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
        doc="ID of the parent category, if any",
    )
    level = Column(
        Integer,
        nullable=False,
        index=True,
        doc="Hierarchy level (e.g., 1 for main Category, 2 for Process)",
    )
    is_active = Column(Boolean, default=True, nullable=False, index=True)

    parent = relationship(
        "ChargeCodeCategory", remote_side=[category_id], backref=backref("children")
    )

    charge_codes = relationship("ChargeCode", back_populates="category")

    def __repr__(self):
        return f"<ChargeCodeCategory(id={self.category_id}, name='{self.name}', level={self.level}, parent_id={self.parent_id})>"


class ChargeCode(BaseModel, Base):
    __tablename__ = "charge_codes"
    # Changed from charge_code_id to id to match financial_models.Transaction.charge_code_id ForeignKey target
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    code = Column(String(20), nullable=False, unique=True, index=True)
    alternate_code = Column(String(50), nullable=True, index=True)
    description = Column(String(255), nullable=False)

    category_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
    )

    standard_charge = Column(Numeric(10, 2), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    taxable = Column(Boolean, default=False)

    category = relationship("ChargeCodeCategory", back_populates="charge_codes")

    def __repr__(self):
        return f"<ChargeCode(code='{self.code}', description='{self.description}')>"


class Veterinarian(BaseModel, Base):
    __tablename__ = "veterinarians"
    vet_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )  # Consider renaming to 'id' for consistency if preferred
    first_name = Column(String(50), nullable=False)
    last_name = Column(String(50), nullable=False, index=True)
    license_number = Column(String(50), unique=True)
    specialty = Column(String(100))
    phone = Column(String(20))
    email = Column(String(100), unique=True)
    is_active = Column(Boolean, default=True)

    def __repr__(self):
        return f"<Veterinarian(vet_id={self.vet_id}, name='{self.first_name} {self.last_name}')>"


class Location(BaseModel, Base):
    __tablename__ = "locations"
    location_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )  # Consider renaming to 'id'
    location_name = Column(String(100), nullable=False, unique=True, index=True)
    address_line1 = Column(String(100), nullable=True)
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50), nullable=True)
    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), nullable=True, index=True
    )
    zip_code = Column(String(20), nullable=True)
    country_code = Column(String(10), default="USA", nullable=True)
    phone = Column(String(20), nullable=True)
    contact_person = Column(String(100), nullable=True)
    email = Column(String(100), nullable=True, index=True)
    is_active = Column(Boolean, default=True, nullable=False)

    state = relationship("StateProvince")
    current_horses = relationship("HorseLocation", back_populates="location")

    def __repr__(self):
        return (
            f"<Location(location_id={self.location_id}, name='{self.location_name}')>"
        )


# --- Placeholder models removed ---
# class Transaction(BaseModel, Base): # REMOVED
#     __tablename__ = "transactions"
#     transaction_id = Column(Integer, primary_key=True)
#     description = Column(String(100))

# class TransactionDetail(BaseModel, Base): # REMOVED
#     __tablename__ = "transaction_details"
#     detail_id = Column(Integer, primary_key=True)
#     transaction_id = Column(Integer, ForeignKey("transactions.transaction_id")) # This would now be an error if Transaction was removed
#     notes = Column(String(100))


class Procedure(BaseModel, Base):
    __tablename__ = "procedures"
    procedure_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class Drug(BaseModel, Base):
    __tablename__ = "drugs"
    drug_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class TreatmentLog(BaseModel, Base):
    __tablename__ = "treatment_logs"
    log_id = Column(Integer, primary_key=True)
    details = Column(String(255))


class CommunicationLog(BaseModel, Base):
    __tablename__ = "communication_logs"
    log_id = Column(Integer, primary_key=True)
    summary = Column(String(255))


class Document(BaseModel, Base):
    __tablename__ = "documents"
    document_id = Column(Integer, primary_key=True)
    file_path = Column(String(255))


class Reminder(BaseModel, Base):
    __tablename__ = "reminders"
    reminder_id = Column(Integer, primary_key=True)
    due_date = Column(Date)


class Appointment(BaseModel, Base):
    __tablename__ = "appointments"
    appointment_id = Column(Integer, primary_key=True, index=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), nullable=True)
    vet_id = Column(Integer, ForeignKey("veterinarians.vet_id"), nullable=True)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=True)
    appointment_datetime = Column(DateTime, nullable=False, server_default=func.now())
    duration_minutes = Column(Integer, default=30)
    reason = Column(String(255))
    notes = Column(Text)
    status = Column(String(50), default="Scheduled")
    is_confirmed = Column(Boolean, default=False)

    def __repr__(self):
        return f"<Appointment(id={self.appointment_id}, datetime='{self.appointment_datetime}', reason='{self.reason}')>"


=============== FILE: models\user_models.py ===============

# models/user_models.py

"""
EDSI Veterinary Management System - User and Authentication Models
Version: 2.0.1
Purpose: Simplified user authentication models with clean relationships.
         Added password hashing and verification methods to User model.
Last Updated: May 29, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.1 (2025-05-29):
    - Added bcrypt import for password hashing.
    - Added set_password(self, password) method to User class to hash
      and store passwords using bcrypt.
    - Added check_password(self, password) method to User class to verify
      passwords against the stored bcrypt hash.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Simplified User model with essential fields only
    - Clean Role and UserRole relationship management
    - Removed SystemConfig (deferred to future phases)
    - Fixed circular import issues
    - Clean inheritance from BaseModel and Base
    - Simplified field definitions and constraints
    - Focused on working authentication foundation
    - Consistent naming and documentation
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
import bcrypt  # Added for password hashing

from config.database_config import Base
from models.base_model import BaseModel


class Role(BaseModel):
    """
    User roles for permission management.
    """

    __tablename__ = "roles"

    role_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique role identifier",
    )

    name = Column(
        String(50),
        unique=True,
        index=True,
        nullable=False,
        doc="Role name (e.g., 'ADMIN', 'USER', 'VETERINARIAN')",  # Doc updated
    )

    description = Column(String(255), nullable=True, doc="Role description")

    # Relationships
    users = relationship(
        "User",
        secondary="user_roles",
        back_populates="roles",
        doc="Users assigned to this role",
    )

    def __repr__(self):
        return f"<Role(role_id={self.role_id}, name='{self.name}')>"


class UserRole(Base):
    """
    Association table for User-Role many-to-many relationship.
    This is a simple link table without audit fields.
    """

    __tablename__ = "user_roles"

    user_id = Column(
        String(20), ForeignKey("users.user_id"), primary_key=True, doc="User identifier"
    )

    role_id = Column(
        Integer, ForeignKey("roles.role_id"), primary_key=True, doc="Role identifier"
    )

    def __repr__(self):
        return f"<UserRole(user_id='{self.user_id}', role_id={self.role_id})>"


class User(BaseModel):
    """
    User account for authentication and system access.
    """

    __tablename__ = "users"

    user_id = Column(
        String(20), primary_key=True, index=True, doc="Unique user login identifier"
    )

    password_hash = Column(
        String(255),  # bcrypt hashes are typically 60 chars, 255 is ample
        nullable=False,
        doc="Hashed password for authentication",
    )

    user_name = Column(String(100), nullable=True, doc="Display name for the user")

    email = Column(
        String(100), unique=True, index=True, nullable=True, doc="User email address"
    )

    is_active = Column(
        Boolean,
        default=True,
        nullable=False,
        index=True,
        doc="Whether the user account is active",
    )

    last_login = Column(
        DateTime, nullable=True, doc="Timestamp of last successful login"
    )

    # Optional user preferences (simplified)
    printer_id = Column(String(20), nullable=True, doc="Default printer for this user")

    default_screen_colors = Column(
        String(100), nullable=True, doc="User's preferred screen color scheme"
    )

    # Relationships
    roles = relationship(
        "Role",
        secondary="user_roles",
        back_populates="users",
        doc="Roles assigned to this user",
    )

    def set_password(self, password: str):
        """
        Hashes the provided password and stores it.
        """
        if not password:
            # Or raise an error, depending on policy for empty passwords
            # For now, assuming controller validates non-empty password for new users.
            # If an empty password is to be disallowed universally, raise ValueError here.
            return
        # Generate a salt and hash the password
        salt = bcrypt.gensalt()
        hashed_password = bcrypt.hashpw(password.encode("utf-8"), salt)
        # Store the hash as a string
        self.password_hash = hashed_password.decode("utf-8")

    def check_password(self, password: str) -> bool:
        """
        Checks the provided password against the stored hash.
        """
        if not self.password_hash or not password:
            return False
        return bcrypt.checkpw(
            password.encode("utf-8"), self.password_hash.encode("utf-8")
        )

    def __repr__(self):
        return f"<User(user_id='{self.user_id}', user_name='{self.user_name}', active={self.is_active})>"

    def has_role(self, role_name: str) -> bool:
        """
        Check if user has a specific role.

        Args:
            role_name: Name of the role to check

        Returns:
            True if user has the role, False otherwise
        """
        return any(
            role.name.upper() == role_name.upper() for role in self.roles
        )  # Made case-insensitive for robustness

    def is_admin(self) -> bool:
        """
        Check if user has admin privileges.

        Returns:
            True if user is an admin, False otherwise
        """
        return self.has_role("ADMIN")  # Ensure "ADMIN" matches the actual role name

    def update_last_login(self) -> None:
        """
        Update the last login timestamp to current time.
        """
        self.last_login = datetime.utcnow()

    def deactivate(self) -> None:
        """
        Deactivate the user account.
        """
        self.is_active = False

    def activate(self) -> None:
        """
        Activate the user account.
        """
        self.is_active = True


=============== FILE: views\__init__.py ===============

# views/__init__.py

"""Views package for EDSI application"""


=============== FILE: views\base_view.py ===============

# views/base_view.py

"""
EDSI Veterinary Management System - Base View Class
Version: 1.1.8
Purpose: Provides a base class for all main views/screens in the application,
         handling common UI setup like dark theme and status messages.
         Corrected missing import for DARK_TEXT_TERTIARY.
Last Updated: May 21, 2025
Author: Gemini

Changelog:
- v1.1.8 (2025-05-21):
    - Added `DARK_TEXT_TERTIARY` to the imports from `config.app_config`
      to resolve a NameError during theme application.
- v1.1.7 (2025-05-21):
    - Added `DARK_PRIMARY_ACTION` to the imports from `config.app_config`
      to resolve a NameError during theme application.
- v1.1.6 (2025-05-21):
    - Added unconditional print statements in `__init__` before and after calling
      `apply_dark_theme_palette_and_global_styles`, and at the start/end of
      `apply_dark_theme_palette_and_global_styles` itself, to check the type of
      `self.tab_widget` if the instance is `HorseUnifiedManagement`.
- v1.1.5 (2025-05-20):
    - Added detailed logging to BaseView.setup_ui to trace layout management
      and confirm if the default or overridden setup_ui is being used.
- v1.1.4 (2025-05-18):
    - Ensured central_widget always has a layout, even in default setup_ui.
- v1.1.3 (2025-05-17):
    - Added placeholder for status_bar if not created by subclass.
- v1.1.2 (2025-05-16):
    - Added show_confirmation_dialog and show_error_dialog methods.
    - Refined status message display and clearing.
- v1.1.1 (2025-05-15):
    - Standardized status message methods (show_info, show_warning, show_error).
- v1.1.0 (2025-05-14):
    - Initial implementation with dark theme palette and global styles.
    - Basic UI setup with a central widget.
    - Abstracted common UI functionalities.
"""

import logging
from PySide6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QLabel,
    QApplication,
    QMessageBox,
    QStatusBar,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer

from config.app_config import (
    DARK_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_WIDGET_BACKGROUND,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DEFAULT_FONT_FAMILY,
    DARK_HEADER_FOOTER,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
    DARK_TEXT_TERTIARY,  # ADDED THIS IMPORT
)


class BaseView(QMainWindow):
    """
    Base class for all main views/screens in the application.
    Handles common setup like dark theme, status messages, and basic layout.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} started.")

        # Set window flags if needed, e.g., to remove native title bar for custom one
        # self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)

        # Central widget and layout
        # This is crucial: ensure central_widget is created BEFORE setCentralWidget
        # and before setup_ui (which might replace its layout or add to it).
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.logger.info(
            f"BaseView __init__ for {self.__class__.__name__}: central_widget created."
        )

        # Allow subclasses to define their own UI structure
        # The `setup_ui` method in the subclass (e.g., UserManagementScreen)
        # is responsible for populating self.central_widget.
        if hasattr(self, "setup_ui") and callable(self.setup_ui):
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Calling overridden setup_ui()."
            )
            self.setup_ui()  # This will call the setup_ui of the subclass
        else:
            # Default UI setup if subclass doesn't provide one
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Using default BaseView setup_ui()."
            )
            default_layout = QVBoxLayout(
                self.central_widget
            )  # Apply layout to central_widget
            default_label = QLabel(f"Welcome to {self.__class__.__name__}")
            default_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            default_layout.addWidget(default_label)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QVBoxLayout set on central_widget."
            )

        # Apply theme and styles after the subclass's setup_ui has potentially created widgets
        # Check type of self.tab_widget if it's HorseUnifiedManagement
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: BEFORE apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        self.apply_dark_theme_palette_and_global_styles()

        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: AFTER apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        # Initialize status bar if not already done by subclass
        if not hasattr(self, "status_bar") or self.status_bar is None:
            self.status_bar = QStatusBar()
            self.setStatusBar(self.status_bar)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QStatusBar created and set."
            )
            self.update_status("Ready", 0)  # Initial status

        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} finished.")

    def set_title(self, title: str):
        self.setWindowTitle(title)

    def apply_dark_theme_palette_and_global_styles(self):
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: START. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(
            QPalette.ColorRole.AlternateBase, QColor(DARK_BACKGROUND)
        )  # For item views like QListWidget
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(
            QPalette.ColorRole.BrightText, Qt.GlobalColor.red
        )  # Often used for errors or important highlights
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(
            QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG)
        )  # Selection background
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )  # Selection text

        # Disabled states
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Text,
            QColor(DARK_TEXT_TERTIARY),
        )  # THIS LINE WAS CAUSING THE NameError
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.ButtonText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.WindowText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Base,
            QColor(DARK_HEADER_FOOTER),
        )

        QApplication.setPalette(palette)
        QApplication.instance().setPalette(palette)  # Ensure it's applied globally

        # Global stylesheet (can be overridden by more specific stylesheets)
        # Styles for common widgets to ensure consistency
        # More specific styling should be done in individual view/widget files
        # using object names or class selectors.
        QApplication.instance().setStyleSheet(
            f"""
            QMainWindow, QDialog, QWidget {{
                font-family: "{DEFAULT_FONT_FAMILY}";
                font-size: 13px;
                color: {DARK_TEXT_PRIMARY};
                background-color: {DARK_BACKGROUND};
            }}
            QToolTip {{
                color: {DARK_TEXT_PRIMARY};
                background-color: {DARK_WIDGET_BACKGROUND};
                border: 1px solid {DARK_BORDER};
                padding: 4px;
                border-radius: 3px;
            }}
            QStatusBar {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_SECONDARY};
                border-top: 1px solid {DARK_BORDER};
            }}
            QStatusBar QLabel {{ /* Ensure labels in status bar inherit color */
                color: {DARK_TEXT_SECONDARY};
                background-color: transparent; /* Important for status bar labels */
                padding: 0 2px; /* Minimal padding for status bar items */
            }}
            QMenuBar {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_PRIMARY};
                border-bottom: 1px solid {DARK_BORDER};
            }}
            QMenuBar::item {{
                spacing: 3px; /* spacing between menu bar items */
                padding: 4px 10px;
                background: transparent;
                border-radius: 4px;
            }}
            QMenuBar::item:selected {{ /* when selected using mouse or keyboard */
                background: {DARK_ITEM_HOVER};
            }}
            QMenuBar::item:pressed {{
                background: {DARK_PRIMARY_ACTION};
            }}
            QMenu {{
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                padding: 5px;
            }}
            QMenu::item {{
                padding: 5px 20px 5px 20px;
            }}
            QMenu::item:selected {{
                background-color: {DARK_HIGHLIGHT_BG};
                color: {DARK_HIGHLIGHT_TEXT};
            }}
            QMenu::separator {{
                height: 1px;
                background: {DARK_BORDER};
                margin-left: 5px;
                margin-right: 5px;
            }}
            /* Basic ScrollBar Styling */
            QScrollBar:vertical {{
                border: 1px solid {DARK_BORDER};
                background: {DARK_WIDGET_BACKGROUND};
                width: 12px;
                margin: 0px 0px 0px 0px;
            }}
            QScrollBar::handle:vertical {{
                background: {DARK_TEXT_SECONDARY};
                min-height: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                border: none;
                background: none;
                height: 0px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }}
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
                background: none;
            }}

            QScrollBar:horizontal {{
                border: 1px solid {DARK_BORDER};
                background: {DARK_WIDGET_BACKGROUND};
                height: 12px;
                margin: 0px 0px 0px 0px;
            }}
            QScrollBar::handle:horizontal {{
                background: {DARK_TEXT_SECONDARY};
                min-width: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
                border: none;
                background: none;
                width: 0px;
                subcontrol-position: left;
                subcontrol-origin: margin;
            }}
            QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {{
                background: none;
            }}
        """
        )
        self.logger.info(
            f"Dark theme palette and global styles applied for {self.__class__.__name__}."
        )
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: END. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

    def update_status(self, message: str, timeout: int = 5000):
        """Displays a message on the status bar for a specified duration."""
        if hasattr(self, "status_bar") and self.status_bar:
            self.status_bar.showMessage(message, timeout)
            self.logger.info(f"Status update: {message}")
        else:
            self.logger.warning(
                f"Attempted to update status for {self.__class__.__name__}, but no status_bar attribute found or it is None."
            )

    def show_info(self, title: str, message: str):
        self.logger.info(f"Displaying Info: {title} - {message}")
        QMessageBox.information(self, title, message)

    def show_warning(self, title: str, message: str):
        self.logger.warning(f"Displaying Warning: {title} - {message}")
        QMessageBox.warning(self, title, message)

    def show_error(self, title: str, message: str):
        self.logger.error(f"Displaying Error: {title} - {message}")
        QMessageBox.critical(self, title, message)

    def show_question(self, title: str, message: str) -> bool:
        self.logger.info(f"Asking Question: {title} - {message}")
        reply = QMessageBox.question(
            self,
            title,
            message,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )
        return reply == QMessageBox.StandardButton.Yes


=============== FILE: views\main_menu.py ===============

# views/main_menu.py

"""
EDSI Veterinary Management System - Main Menu
Version: 1.0.2
Purpose: Modern unified main menu with consolidated management screens.
         Fixed PyQt6 to PySide6 imports for consistency.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v1.0.2 (2025-05-24):
    - Fixed imports from PyQt6 to PySide6 for consistency with rest of application
    - Changed pyqtSignal to Signal from PySide6.QtCore
- v1.0.1 (2025-05-12): Updated for unified management approach
  - Replaced separate horse operations (Add, Edit, Delete) with single "Horse Management"
  - Removed horse_review_update_selected, add_new_horse_selected, delete_horse_selected signals
  - Added horse_management_selected signal for unified interface
  - Updated menu options to reflect modern management screens
  - Simplified menu structure for better user experience
- v1.0.0 (2025-05-12): Initial implementation
  - Created complete main menu matching COBOL layout
  - Implemented all menu option signals
  - Added keyboard navigation support
  - Included proper styling and layout
"""

from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QGridLayout,
    QLabel,
    QPushButton,
    QFrame,
    QSpacerItem,
    QSizePolicy,
    QGroupBox,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QFont
from views.base_view import BaseView
from config.app_config import AppConfig
import logging


class MainMenu(BaseView):
    """Primary menu screen with unified management approach"""

    # Signals for menu selections
    horse_management_selected = Signal()  # Option 1 - Unified horse operations
    table_maintenance_selected = Signal()  # Option 2
    print_reports_selected = Signal()  # Option 3
    owners_ar_selected = Signal()  # Option 4
    system_utilities_selected = Signal()  # Option 5
    mass_update_selected = Signal()  # Option 6
    logoff_exit_selected = Signal()  # Option 9
    logoff_no_exit_selected = Signal()  # Option X

    def __init__(self, current_user=None):
        self.current_user = current_user or "Unknown"
        super().__init__()
        self.setup_main_menu_ui()
        self.logger = logging.getLogger(self.__class__.__name__)

    def setup_main_menu_ui(self):
        """Setup the main menu UI"""
        self.set_title("Primary Menu")
        self.resize(700, 600)
        self.center_on_screen()

        # Header section
        self.setup_header()

        # Main menu options
        self.setup_menu_options()

        # Footer section
        self.setup_footer()

    def setup_header(self):
        """Setup header with title and user info"""
        header_frame = QFrame()
        header_layout = QVBoxLayout(header_frame)

        # Main title
        title_label = QLabel("EDSI Primary Menu")
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 24, QFont.Weight.Bold)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_PRIMARY_ACTION};
            padding: 10px;
        """
        )

        # User info
        user_info_label = QLabel(f"Current User: {self.current_user}")
        user_info_label.setAlignment(Qt.AlignmentFlag.AlignRight)
        user_info_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_TEXT_SECONDARY};
            font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
            padding: 5px;
        """
        )

        header_layout.addWidget(title_label)
        header_layout.addWidget(user_info_label)

        # Set up the main window layout instead of using the base view methods
        if not hasattr(self, "main_layout"):
            self.main_layout = QVBoxLayout(self.central_widget)
            self.main_layout.setContentsMargins(20, 20, 20, 20)

        self.main_layout.addWidget(header_frame)

    def setup_menu_options(self):
        """Setup main menu options grid"""
        # Create menu group box
        menu_group = QGroupBox("Select an option:")
        menu_group.setStyleSheet(
            f"""
            QGroupBox {{
                font-size: {AppConfig.DEFAULT_FONT_SIZE + 2}pt;
                font-weight: bold;
                color: {AppConfig.DARK_TEXT_PRIMARY};
                padding-top: 15px;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
            }}
        """
        )

        # Create grid layout for menu options
        menu_layout = QGridLayout(menu_group)
        menu_layout.setSpacing(15)
        menu_layout.setContentsMargins(20, 20, 20, 20)

        # Define menu options (number, text, signal) - Updated for unified approach
        menu_options = [
            ("1.", "Horse Management", self.horse_management_selected),
            ("2.", "Table Maintenance", self.table_maintenance_selected),
            ("3.", "Print Reports & Billing", self.print_reports_selected),
            ("4.", "Owners A/R", self.owners_ar_selected),
            ("5.", "System Utilities", self.system_utilities_selected),
            ("6.", "Mass Update", self.mass_update_selected),
            ("9.", "Logoff & Exit", self.logoff_exit_selected),
            ("X.", "Logoff, No Exit", self.logoff_no_exit_selected),
        ]

        # Create buttons for each option
        self.menu_buttons = {}
        row = 0
        col = 0
        max_cols = 2

        for number, text, signal in menu_options:
            button = self.create_menu_button(number, text, signal)
            menu_layout.addWidget(button, row, col)
            self.menu_buttons[number] = button

            col += 1
            if col >= max_cols:
                col = 0
                row += 1

        # Add the menu group to content area
        self.main_layout.addWidget(menu_group, 1)  # Take up most space

    def create_menu_button(self, number, text, signal):
        """Create a styled menu button"""
        button = QPushButton(f"{number} {text}")
        button.setMinimumHeight(50)
        button.setMinimumWidth(280)

        # Special styling for exit options
        if number in ["9.", "X."]:
            button.setStyleSheet(
                f"""
                QPushButton {{
                    background-color: {AppConfig.DARK_DANGER_ACTION};
                    color: white;
                    border: none;
                    padding: 10px;
                    text-align: left;
                    font-size: {AppConfig.DEFAULT_FONT_SIZE + 1}pt;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background-color: #5a6268;
                }}
                QPushButton:pressed {{
                    background-color: #495057;
                }}
            """
            )
        else:
            button.setStyleSheet(
                f"""
                QPushButton {{
                    background-color: {AppConfig.DARK_PRIMARY_ACTION};
                    color: white;
                    border: none;
                    padding: 10px;
                    text-align: left;
                    font-size: {AppConfig.DEFAULT_FONT_SIZE + 1}pt;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background-color: #106ebe;
                }}
                QPushButton:pressed {{
                    background-color: #005a9e;
                }}
            """
            )

        button.clicked.connect(lambda checked, s=signal: s.emit())
        return button

    def setup_footer(self):
        """Setup footer with instructions"""
        footer_frame = QFrame()
        footer_layout = QHBoxLayout(footer_frame)

        instruction_label = QLabel(
            "Select an option by clicking or pressing the corresponding number/letter"
        )
        instruction_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        instruction_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_TEXT_SECONDARY};
            font-style: italic;
            font-size: {AppConfig.SMALL_FONT_SIZE + 1}pt;
            padding: 10px;
        """
        )

        footer_layout.addWidget(instruction_label)
        self.main_layout.addWidget(footer_frame)

    def center_on_screen(self):
        """Center the main menu on the display"""
        screen = self.screen().availableGeometry()
        size = self.geometry()
        self.move(
            (screen.width() - size.width()) // 2, (screen.height() - size.height()) // 2
        )

    def keyPressEvent(self, event):
        """Handle keyboard shortcuts for menu options"""
        key = event.text().upper()

        # Map keys to signals - Updated for unified approach
        key_mappings = {
            "1": self.horse_management_selected,
            "2": self.table_maintenance_selected,
            "3": self.print_reports_selected,
            "4": self.owners_ar_selected,
            "5": self.system_utilities_selected,
            "6": self.mass_update_selected,
            "9": self.logoff_exit_selected,
            "X": self.logoff_no_exit_selected,
        }

        if key in key_mappings:
            self.logger.info(f"Menu option {key} selected via keyboard")
            key_mappings[key].emit()
        else:
            super().keyPressEvent(event)


=============== FILE: views\admin\user_management_screen.py ===============

# views/admin/user_management_screen.py
"""
EDSI Veterinary Management System - User Management Screen
Version: 1.4.2
Purpose: Admin screen for managing users, locations, charge codes, categories, and owners.
         - Adds Delete functionality and standardized ComboBox filters to all table-based tabs.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.4.2 (2025-06-05):
    - Bug Fix: In `_toggle_selected_charge_code_active_status`, corrected the method call
      from `toggle_charge_code_active_status` to `toggle_charge_code_status` to match
      the `ChargeCodeController` method name. This resolves the `AttributeError`.
- v1.4.1 (2025-06-05):
    - Bug Fix: In `load_charge_codes_data`, corrected the list comprehension to use
      dictionary key access (`p['name']`) instead of attribute access (`p.name`)
      when constructing the `category_path_str`.
- v1.4.0 (2025-06-05):
    - Feature: Added Delete Functionality to Users, Locations, Charge Codes, and Owners tabs.
    - Feature: Standardized Status Filters on all four table-based tabs.
    - Refactor: Updated Data Loading methods to use new filters.
- v1.3.22 (2025-06-04):
    - `load_locations_data`: Changed call to `self.location_controller.get_all_locations()`.
    - `load_categories_processes_data`: Removed unsupported `status_filter` argument from
      `get_charge_code_categories` calls.
    - `load_charge_codes_data`:
        - Changed call to `self.charge_code_controller.get_all_charge_codes(status_filter=status_filter)`.
        - Added logic to fetch and display category path for each charge code.
    - `load_owners_data`: Changed call to `self.owner_controller.get_all_master_owners()`.
"""

import logging
from typing import Optional, List, Dict, Any, Union

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QTabWidget,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QHeaderView,
    QAbstractItemView,
    QLabel,
    QFrame,
    QMessageBox,
    QMenu,
    QTreeWidget,
    QTreeWidgetItem,
    QComboBox,
    QDialog,
)
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QAction, QColor, QFont

from views.base_view import BaseView
from config.app_config import AppConfig

from controllers.user_controller import UserController
from controllers.location_controller import LocationController
from controllers.charge_code_controller import ChargeCodeController
from controllers.owner_controller import OwnerController

from models import (
    User,
    Location,
    ChargeCode,
    Owner as OwnerModel,
    ChargeCodeCategory,
)

from .dialogs.add_edit_user_dialog import AddEditUserDialog
from .dialogs.add_edit_location_dialog import AddEditLocationDialog
from .dialogs.add_edit_charge_code_dialog import AddEditChargeCodeDialog
from .dialogs.add_edit_owner_dialog import AddEditOwnerDialog
from .dialogs.add_edit_charge_code_category_dialog import (
    AddEditChargeCodeCategoryDialog,
)


class UserManagementScreen(BaseView):
    back_to_main_menu = Signal()
    entity_updated = Signal(str)

    USER_TAB_INDEX = 0
    LOCATION_TAB_INDEX = 1
    CATEGORY_PROCESS_TAB_INDEX = 2
    CHARGE_CODE_TAB_INDEX = 3
    OWNER_TAB_INDEX = 4

    def __init__(self, current_user_id: str, parent: Optional[QWidget] = None):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(
            f"UserManagementScreen __init__ called for user: {current_user_id}"
        )

        self.current_user_id = current_user_id
        if not self.current_user_id:
            self.logger.error(
                "UserManagementScreen initialized without a current_user_id!"
            )

        self.user_controller = UserController()
        self.location_controller = LocationController()
        self.charge_code_controller = ChargeCodeController()
        self.owner_controller = OwnerController()

        # Widget Attributes
        self.users_table: Optional[QTableWidget] = None
        self.add_user_btn: Optional[QPushButton] = None
        self.edit_user_btn: Optional[QPushButton] = None
        self.toggle_user_active_btn: Optional[QPushButton] = None
        self.delete_user_btn: Optional[QPushButton] = None
        self.user_status_filter_combo: Optional[QComboBox] = None

        self.locations_table: Optional[QTableWidget] = None
        self.add_location_btn: Optional[QPushButton] = None
        self.edit_location_btn: Optional[QPushButton] = None
        self.toggle_location_active_btn: Optional[QPushButton] = None
        self.delete_location_btn: Optional[QPushButton] = None
        self.location_status_filter_combo: Optional[QComboBox] = None

        self.categories_tree: Optional[QTreeWidget] = None
        self.add_category_btn: Optional[QPushButton] = None
        self.add_process_btn: Optional[QPushButton] = None
        self.edit_category_process_btn: Optional[QPushButton] = None
        self.toggle_category_process_active_btn: Optional[QPushButton] = None
        self.delete_category_process_btn: Optional[QPushButton] = None
        self.category_filter_combo: Optional[QComboBox] = None

        self.charge_codes_table: Optional[QTableWidget] = None
        self.add_charge_code_btn: Optional[QPushButton] = None
        self.edit_charge_code_btn: Optional[QPushButton] = None
        self.toggle_charge_code_active_btn: Optional[QPushButton] = None
        self.delete_charge_code_btn: Optional[QPushButton] = None
        self.charge_code_status_filter_combo: Optional[QComboBox] = None

        self.owners_table: Optional[QTableWidget] = None
        self.add_owner_btn: Optional[QPushButton] = None
        self.edit_owner_btn: Optional[QPushButton] = None
        self.toggle_owner_active_btn: Optional[QPushButton] = None
        self.delete_owner_btn: Optional[QPushButton] = None
        self.owner_status_filter_combo: Optional[QComboBox] = None

        self.tab_widget: Optional[QTabWidget] = None

        self._active_filters: Dict[int, str] = {
            self.USER_TAB_INDEX: "active",
            self.LOCATION_TAB_INDEX: "active",
            self.CATEGORY_PROCESS_TAB_INDEX: "active",
            self.CHARGE_CODE_TAB_INDEX: "active",
            self.OWNER_TAB_INDEX: "active",
        }

        super().__init__(parent)

        self.refresh_timer = QTimer(self)
        self.refresh_timer.setSingleShot(True)
        self.refresh_timer.timeout.connect(self._refresh_current_tab_data)

        self.setWindowTitle("User and System Management")
        self.resize(1200, 800)
        self.logger.info("UserManagementScreen __init__ completed.")

    def setup_ui(self):
        self.logger.info("Setting up UserManagementScreen UI...")

        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet(self._get_tab_widget_style())

        users_tab_widget = self._create_users_tab()
        locations_tab_widget = self._create_locations_tab()
        categories_processes_tab_widget = self._create_categories_processes_tab()
        charge_codes_tab_widget = self._create_charge_codes_tab()
        owners_tab_widget = self._create_owners_tab()

        self.tab_widget.addTab(users_tab_widget, "👤 Manage Users")
        self.tab_widget.addTab(locations_tab_widget, "📍 Manage Locations")
        self.tab_widget.addTab(
            categories_processes_tab_widget, "🗂️ Manage Categories/Processes"
        )
        self.tab_widget.addTab(charge_codes_tab_widget, "💲 Manage Charge Codes")
        self.tab_widget.addTab(owners_tab_widget, "🤝 Manage Master Owners")

        main_layout.addWidget(self.tab_widget)

        self._setup_connections()
        if self.tab_widget:
            self.tab_widget.setCurrentIndex(0)
            self._refresh_current_tab_data()

        self.logger.info("UserManagementScreen UI setup complete.")

    def _get_tab_widget_style(self) -> str:
        return f"""
            QTabWidget::pane {{
                border: 1px solid {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                border-radius: 6px;
                margin-top: -1px; 
            }}
            QTabBar::tab {{
                padding: 10px 20px;
                margin-right: 2px;
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-bottom: none; 
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                min-width: 120px; 
                font-size: 13px;
                font-weight: 500;
            }}
            QTabBar::tab:selected {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border-color: {AppConfig.DARK_BORDER};
                border-bottom-color: {AppConfig.DARK_WIDGET_BACKGROUND}; 
            }}
            QTabBar::tab:!selected:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QTabWidget::tab-bar {{
                alignment: left;
                border: none; 
                background-color: transparent; 
                margin-bottom: 0px; 
            }}
        """

    def _create_standard_button_layout(self) -> QHBoxLayout:
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        return button_layout

    def _apply_standard_button_style(
        self, button: QPushButton, button_type: str = "standard"
    ):
        base_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 15px;
                font-size: 12px;
                font-weight: 500;
                min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
            }}
            QPushButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
            }}
        """
        if button_type == "add":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_SUCCESS_ACTION
                )
                + "color: white;"
            )
        elif button_type == "edit":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_PRIMARY_ACTION
                )
                + "color: white;"
            )
        elif button_type == "delete" or button_type == "toggle_inactive":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_DANGER_ACTION
                )
                + "color: white;"
            )
        else:
            button.setStyleSheet(base_style)

    def get_form_input_style(self) -> str:
        return f"""
            QComboBox {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 20px;
            }}
            QComboBox:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QComboBox::drop-down {{
                border: none;
                background-color: transparent;
            }}
            QComboBox QAbstractItemView {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                selection-background-color: {AppConfig.DARK_HIGHLIGHT_BG};
                selection-color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _setup_connections(self):
        self.logger.debug("Setting up connections for UserManagementScreen.")
        if self.tab_widget:
            self.tab_widget.currentChanged.connect(self._on_tab_changed)

        # User Tab Connections
        if self.add_user_btn:
            self.add_user_btn.clicked.connect(self._add_user)
        if self.edit_user_btn:
            self.edit_user_btn.clicked.connect(self._edit_selected_user)
        if self.toggle_user_active_btn:
            self.toggle_user_active_btn.clicked.connect(
                self._toggle_selected_user_active_status
            )
        if self.delete_user_btn:
            self.delete_user_btn.clicked.connect(self._delete_selected_user)
        if self.users_table:
            self.users_table.itemSelectionChanged.connect(
                self._update_user_action_buttons_state
            )
        if self.user_status_filter_combo:
            self.user_status_filter_combo.currentIndexChanged.connect(
                self._on_user_filter_changed
            )

        # Location Tab Connections
        if self.add_location_btn:
            self.add_location_btn.clicked.connect(self._add_location)
        if self.edit_location_btn:
            self.edit_location_btn.clicked.connect(self._edit_selected_location)
        if self.toggle_location_active_btn:
            self.toggle_location_active_btn.clicked.connect(
                self._toggle_selected_location_active_status
            )
        if self.delete_location_btn:
            self.delete_location_btn.clicked.connect(self._delete_selected_location)
        if self.locations_table:
            self.locations_table.itemSelectionChanged.connect(
                self._update_location_action_buttons_state
            )
        if self.location_status_filter_combo:
            self.location_status_filter_combo.currentIndexChanged.connect(
                self._on_location_filter_changed
            )

        # Category/Process Tab Connections
        if self.add_category_btn:
            self.add_category_btn.clicked.connect(self._add_category_or_process)
        if self.add_process_btn:
            self.add_process_btn.clicked.connect(
                lambda: self._add_category_or_process(is_process=True)
            )
        if self.edit_category_process_btn:
            self.edit_category_process_btn.clicked.connect(
                self._edit_selected_category_process
            )
        if self.toggle_category_process_active_btn:
            self.toggle_category_process_active_btn.clicked.connect(
                self._toggle_selected_category_process_active_status
            )
        if self.delete_category_process_btn:
            self.delete_category_process_btn.clicked.connect(
                self._delete_selected_category_process
            )
        if self.categories_tree:
            self.categories_tree.itemSelectionChanged.connect(
                self._update_category_action_buttons_state
            )
        if self.category_filter_combo:
            self.category_filter_combo.currentIndexChanged.connect(
                self._on_category_filter_changed
            )

        # Charge Code Tab Connections
        if self.add_charge_code_btn:
            self.add_charge_code_btn.clicked.connect(self._add_charge_code)
        if self.edit_charge_code_btn:
            self.edit_charge_code_btn.clicked.connect(self._edit_selected_charge_code)
        if self.toggle_charge_code_active_btn:
            self.toggle_charge_code_active_btn.clicked.connect(
                self._toggle_selected_charge_code_active_status
            )
        if self.delete_charge_code_btn:
            self.delete_charge_code_btn.clicked.connect(
                self._delete_selected_charge_code
            )
        if self.charge_codes_table:
            self.charge_codes_table.itemSelectionChanged.connect(
                self._update_charge_code_action_buttons_state
            )
        if self.charge_code_status_filter_combo:
            self.charge_code_status_filter_combo.currentIndexChanged.connect(
                self._on_charge_code_filter_changed
            )

        # Owner Tab Connections
        if self.add_owner_btn:
            self.add_owner_btn.clicked.connect(self._add_owner)
        if self.edit_owner_btn:
            self.edit_owner_btn.clicked.connect(self._edit_selected_owner)
        if self.toggle_owner_active_btn:
            self.toggle_owner_active_btn.clicked.connect(
                self._toggle_selected_owner_active_status
            )
        if self.delete_owner_btn:
            self.delete_owner_btn.clicked.connect(self._delete_selected_owner)
        if self.owners_table:
            self.owners_table.itemSelectionChanged.connect(
                self._update_owner_action_buttons_state
            )
        if self.owner_status_filter_combo:
            self.owner_status_filter_combo.currentIndexChanged.connect(
                self._on_owner_filter_changed
            )

        self.logger.debug("Connections setup complete.")

    def _on_tab_changed(self, index: int):
        self.logger.info(
            f"Tab changed to index: {index}, new tab title: {self.tab_widget.tabText(index) if self.tab_widget else 'N/A'}"
        )
        self._refresh_current_tab_data()

    def _refresh_current_tab_data(self, force_reload: bool = False):
        if not self.tab_widget:
            self.logger.warning("Tab widget not available for refresh.")
            return
        current_index = self.tab_widget.currentIndex()
        self.logger.debug(f"Refreshing data for tab index: {current_index}")

        if current_index == self.USER_TAB_INDEX:
            self.load_users_data()
        elif current_index == self.LOCATION_TAB_INDEX:
            self.load_locations_data()
        elif current_index == self.CATEGORY_PROCESS_TAB_INDEX:
            self.load_categories_processes_data()
        elif current_index == self.CHARGE_CODE_TAB_INDEX:
            self.load_charge_codes_data()
        elif current_index == self.OWNER_TAB_INDEX:
            self.load_owners_data()
        else:
            self.logger.warning(
                f"No data loading action defined for tab index {current_index}"
            )

    def _create_table_widget(self, headers: List[str]) -> QTableWidget:
        table = QTableWidget()
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        table.verticalHeader().setVisible(False)
        table.setShowGrid(True)
        table.setStyleSheet(
            f"""
            QTableWidget {{
                gridline-color: {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
            }}
            QHeaderView::section {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                padding: 5px;
                border: none; 
                border-bottom: 1px solid {AppConfig.DARK_BORDER};
                font-weight: 500;
            }}
            QTableWidget::item {{
                padding: 5px;
            }}
            QTableWidget::item:selected {{
                background-color: {AppConfig.DARK_HIGHLIGHT_BG};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """
        )
        table.horizontalHeader().setStretchLastSection(True)
        for i in range(len(headers) - 1):
            table.horizontalHeader().setSectionResizeMode(
                i, QHeaderView.ResizeMode.ResizeToContents
            )
        return table

    # --- Users Tab Methods ---
    def _create_users_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()

        self.add_user_btn = QPushButton("➕ Add New User")
        self._apply_standard_button_style(self.add_user_btn, "add")
        self.edit_user_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_user_btn, "edit")
        self.toggle_user_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_user_active_btn)
        self.delete_user_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_user_btn, "delete")

        button_layout.addWidget(self.add_user_btn)
        button_layout.addWidget(self.edit_user_btn)
        button_layout.addWidget(self.toggle_user_active_btn)
        button_layout.addWidget(self.delete_user_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)

        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.user_status_filter_combo = QComboBox()
        self.user_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.user_status_filter_combo.setCurrentText(
            self._active_filters.get(self.USER_TAB_INDEX, "active")
        )
        self.user_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.user_status_filter_combo)

        layout.addLayout(top_bar_layout)

        self.users_table = self._create_table_widget(
            ["Login ID", "Full Name", "Email", "Roles", "Active", "Last Login"]
        )
        layout.addWidget(self.users_table)
        self._update_user_action_buttons_state()
        return tab

    def load_users_data(self):
        self.logger.info("Loading users data for tab...")
        if not self.users_table or not self.user_status_filter_combo:
            self.logger.error("Users table or filter combo not initialized.")
            return
        try:
            status_filter = self.user_status_filter_combo.currentText().lower()
            self._active_filters[self.USER_TAB_INDEX] = status_filter

            users = self.user_controller.get_all_users(status_filter=status_filter)
            self.users_table.setRowCount(0)
            for user_obj in users:
                row_position = self.users_table.rowCount()
                self.users_table.insertRow(row_position)
                self.users_table.setItem(
                    row_position, 0, QTableWidgetItem(user_obj.user_id)
                )
                self.users_table.setItem(
                    row_position, 1, QTableWidgetItem(user_obj.user_name or "")
                )
                self.users_table.setItem(
                    row_position, 2, QTableWidgetItem(user_obj.email or "")
                )
                roles_str = ", ".join([role.name for role in user_obj.roles])
                self.users_table.setItem(row_position, 3, QTableWidgetItem(roles_str))
                active_str = "Yes" if user_obj.is_active else "No"
                self.users_table.setItem(row_position, 4, QTableWidgetItem(active_str))
                last_login_str = (
                    user_obj.last_login.strftime("%Y-%m-%d %H:%M")
                    if user_obj.last_login
                    else "Never"
                )
                self.users_table.setItem(
                    row_position, 5, QTableWidgetItem(last_login_str)
                )
                self.users_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, user_obj.user_id
                )
            self.logger.info(f"Loaded {len(users)} users.")
        except Exception as e:
            self.logger.error(f"Error loading users: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load users: {e}")
        self._update_user_action_buttons_state()

    def _on_user_filter_changed(self, index: int):
        self.load_users_data()

    def _add_user(self):
        dialog = AddEditUserDialog(
            self,
            user_controller=self.user_controller,
            current_user_object=None,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_users_data()
            self.entity_updated.emit("user")

    def _edit_selected_user(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Edit User", "Please select a user to edit.")
            return

        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        if not user_id_item:
            self.show_error("Error", "Could not retrieve user ID for selected row.")
            return

        user_login_id = user_id_item.data(Qt.ItemDataRole.UserRole)
        if not user_login_id:
            user_login_id = user_id_item.text()

        user_to_edit = self.user_controller.get_user_by_login_id(user_login_id)

        if user_to_edit:
            dialog = AddEditUserDialog(
                self,
                user_controller=self.user_controller,
                current_user_object=user_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_users_data()
                self.entity_updated.emit("user")
        else:
            self.show_error("Error", f"User with Login ID '{user_login_id}' not found.")
            self.load_users_data()

    def _toggle_selected_user_active_status(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a user.")
            return

        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )

        user_obj = self.user_controller.get_user_by_login_id(user_login_id)

        if not user_obj:
            self.show_error("Error", f"User {user_login_id} not found.")
            return

        action = "deactivate" if user_obj.is_active else "activate"
        name_display = user_obj.user_name or user_obj.user_id

        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} user '{name_display}'?",
        ):
            success, message = self.user_controller.toggle_user_active_status(
                user_login_id,
                self.current_user_id,
            )
            if success:
                self.show_info("Success", message)
                self.load_users_data()
                self.entity_updated.emit("user")
            else:
                self.show_error("Error", message)

    def _delete_selected_user(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Delete User", "Please select a user to delete.")
            return

        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )
        user_name_item = self.users_table.item(selected_row, 1)
        display_name = user_name_item.text() if user_name_item else user_login_id

        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete user '{display_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.user_controller.delete_user_permanently(
                user_login_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_users_data()
                self.entity_updated.emit("user_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_user_action_buttons_state(self):
        has_selection = (
            self.users_table is not None and self.users_table.currentItem() is not None
        )
        if self.edit_user_btn:
            self.edit_user_btn.setEnabled(has_selection)
        if self.toggle_user_active_btn:
            self.toggle_user_active_btn.setEnabled(has_selection)
        if self.delete_user_btn:
            self.delete_user_btn.setEnabled(has_selection)

        if has_selection and self.toggle_user_active_btn and self.users_table:
            selected_row = self.users_table.currentRow()
            user_id_item = self.users_table.item(selected_row, 0)
            if not user_id_item:
                return

            user_login_id = (
                user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
            )
            user_obj = self.user_controller.get_user_by_login_id(user_login_id)
            if user_obj:
                action_text = "Deactivate" if user_obj.is_active else "Activate"
                self.toggle_user_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_user_active_btn,
                    "toggle_inactive" if user_obj.is_active else "standard",
                )

    # --- Locations Tab Methods ---
    def _create_locations_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()

        self.add_location_btn = QPushButton("➕ Add New Location")
        self._apply_standard_button_style(self.add_location_btn, "add")
        self.edit_location_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_location_btn, "edit")
        self.toggle_location_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_location_active_btn)
        self.delete_location_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_location_btn, "delete")

        button_layout.addWidget(self.add_location_btn)
        button_layout.addWidget(self.edit_location_btn)
        button_layout.addWidget(self.toggle_location_active_btn)
        button_layout.addWidget(self.delete_location_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)

        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.location_status_filter_combo = QComboBox()
        self.location_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.location_status_filter_combo.setCurrentText(
            self._active_filters.get(self.LOCATION_TAB_INDEX, "active")
        )
        self.location_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.location_status_filter_combo)

        layout.addLayout(top_bar_layout)

        self.locations_table = self._create_table_widget(
            ["Name", "Address", "City", "State", "Zip", "Contact", "Active"]
        )
        layout.addWidget(self.locations_table)
        self._update_location_action_buttons_state()
        return tab

    def load_locations_data(self):
        self.logger.info("Loading locations data for tab...")
        if not self.locations_table or not self.location_status_filter_combo:
            self.logger.error("Locations table or filter combo not initialized.")
            return
        try:
            status_filter = self.location_status_filter_combo.currentText().lower()
            self._active_filters[self.LOCATION_TAB_INDEX] = status_filter

            locations = self.location_controller.get_all_locations(
                status_filter=status_filter
            )
            self.locations_table.setRowCount(0)
            for loc_obj in locations:
                row_position = self.locations_table.rowCount()
                self.locations_table.insertRow(row_position)
                self.locations_table.setItem(
                    row_position, 0, QTableWidgetItem(loc_obj.location_name)
                )
                address_parts = [loc_obj.address_line1, loc_obj.address_line2]
                self.locations_table.setItem(
                    row_position,
                    1,
                    QTableWidgetItem(" ".join(filter(None, address_parts))),
                )
                self.locations_table.setItem(
                    row_position, 2, QTableWidgetItem(loc_obj.city or "")
                )
                state_display = loc_obj.state_code or ""
                if (
                    hasattr(loc_obj, "state")
                    and loc_obj.state
                    and hasattr(loc_obj.state, "state_code")
                ):
                    state_display = loc_obj.state.state_code
                self.locations_table.setItem(
                    row_position, 3, QTableWidgetItem(state_display)
                )
                self.locations_table.setItem(
                    row_position, 4, QTableWidgetItem(loc_obj.zip_code or "")
                )
                self.locations_table.setItem(
                    row_position, 5, QTableWidgetItem(loc_obj.contact_person or "")
                )
                self.locations_table.setItem(
                    row_position,
                    6,
                    QTableWidgetItem("Yes" if loc_obj.is_active else "No"),
                )
                self.locations_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, loc_obj.location_id
                )
            self.logger.info(f"Loaded {len(locations)} locations.")
        except Exception as e:
            self.logger.error(f"Error loading locations: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load locations: {e}")
        self._update_location_action_buttons_state()

    def _on_location_filter_changed(self, index: int):
        self.load_locations_data()

    def _add_location(self):
        dialog = AddEditLocationDialog(
            self,
            controller=self.location_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_locations_data()
            self.entity_updated.emit("location")

    def _edit_selected_location(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Edit Location", "Please select a location to edit.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        location_to_edit = self.location_controller.get_location_by_id(location_id)

        if location_to_edit:
            dialog = AddEditLocationDialog(
                self,
                controller=self.location_controller,
                location=location_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_locations_data()
                self.entity_updated.emit("location")
        else:
            self.show_error("Error", f"Location with ID '{location_id}' not found.")
            self.load_locations_data()

    def _toggle_selected_location_active_status(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a location.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        loc_obj = self.location_controller.get_location_by_id(location_id)

        if not loc_obj:
            self.show_error("Error", f"Location {location_id} not found.")
            return

        action = "deactivate" if loc_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} location '{loc_obj.location_name}'?",
        ):
            success, message = self.location_controller.toggle_location_active_status(
                location_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_locations_data()
                self.entity_updated.emit("location")
            else:
                self.show_error("Error", message)

    def _delete_selected_location(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Delete Location", "Please select a location to delete.")
            return

        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        location_name = location_id_item.text()

        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete location '{location_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.location_controller.delete_location(
                location_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_locations_data()
                self.entity_updated.emit("location_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_location_action_buttons_state(self):
        has_selection = (
            self.locations_table is not None
            and self.locations_table.currentItem() is not None
        )
        if self.edit_location_btn:
            self.edit_location_btn.setEnabled(has_selection)
        if self.toggle_location_active_btn:
            self.toggle_location_active_btn.setEnabled(has_selection)
        if self.delete_location_btn:
            self.delete_location_btn.setEnabled(has_selection)

        if has_selection and self.toggle_location_active_btn and self.locations_table:
            selected_row = self.locations_table.currentRow()
            location_id_item = self.locations_table.item(selected_row, 0)
            if not location_id_item:
                return

            loc_id = (
                location_id_item.data(Qt.ItemDataRole.UserRole)
                or location_id_item.text()
            )
            loc_obj = self.location_controller.get_location_by_id(loc_id)
            if loc_obj:
                action_text = "Deactivate" if loc_obj.is_active else "Activate"
                self.toggle_location_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_location_active_btn,
                    "toggle_inactive" if loc_obj.is_active else "standard",
                )

    # --- Categories/Processes Tab Methods ---
    def _create_categories_processes_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        top_bar_layout = QHBoxLayout()
        self.add_category_btn = QPushButton("➕ Add Category (L1)")
        self._apply_standard_button_style(self.add_category_btn, "add")
        self.add_process_btn = QPushButton("➕ Add Process (L2)")
        self._apply_standard_button_style(self.add_process_btn, "add")
        self.edit_category_process_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_category_process_btn, "edit")
        self.toggle_category_process_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_category_process_active_btn)
        self.delete_category_process_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_category_process_btn, "delete")

        top_bar_layout.addWidget(self.add_category_btn)
        top_bar_layout.addWidget(self.add_process_btn)
        top_bar_layout.addWidget(self.edit_category_process_btn)
        top_bar_layout.addWidget(self.toggle_category_process_active_btn)
        top_bar_layout.addWidget(self.delete_category_process_btn)
        top_bar_layout.addStretch(1)

        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.category_filter_combo = QComboBox()
        self.category_filter_combo.addItems(["Active", "Inactive", "All"])
        self.category_filter_combo.setCurrentText(
            self._active_filters.get(self.CATEGORY_PROCESS_TAB_INDEX, "active")
        )
        self.category_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.category_filter_combo)
        layout.addLayout(top_bar_layout)

        self.categories_tree = QTreeWidget()
        self.categories_tree.setHeaderLabels(
            ["Category/Process Name", "Level", "Status", "ID"]
        )
        self.categories_tree.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.categories_tree.setStyleSheet(
            f"""
            QTreeWidget {{ background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_BORDER}; border-radius: 4px; }}
            QHeaderView::section {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; color: {AppConfig.DARK_TEXT_SECONDARY}; padding: 5px; border: none; border-bottom: 1px solid {AppConfig.DARK_BORDER}; font-weight: 500; }}
            QTreeWidget::item:selected {{ background-color: {AppConfig.DARK_HIGHLIGHT_BG}; color: {AppConfig.DARK_HIGHLIGHT_TEXT}; }}
            QTreeWidget::item {{ padding: 3px; }}
        """
        )
        header = self.categories_tree.header()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        for i in range(1, 4):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)

        layout.addWidget(self.categories_tree)
        self._update_category_action_buttons_state()
        return tab

    def load_categories_processes_data(self):
        self.logger.info("Loading charge code categories/processes data...")
        if not self.categories_tree or not self.category_filter_combo:
            self.logger.error("Categories tree or filter combo not initialized.")
            return

        self.categories_tree.clear()

        try:
            level1_categories = self.charge_code_controller.get_charge_code_categories(
                level=1
            )

            ui_status_filter = self.category_filter_combo.currentText().lower()
            self._active_filters[self.CATEGORY_PROCESS_TAB_INDEX] = ui_status_filter

            for cat_l1 in level1_categories:
                if ui_status_filter != "all":
                    if (ui_status_filter == "active" and not cat_l1.is_active) or (
                        ui_status_filter == "inactive" and cat_l1.is_active
                    ):
                        continue

                l1_item = QTreeWidgetItem(self.categories_tree)
                l1_item.setText(0, cat_l1.name)
                l1_item.setText(1, str(cat_l1.level))
                l1_item.setText(2, "Active" if cat_l1.is_active else "Inactive")
                l1_item.setText(3, str(cat_l1.category_id))
                l1_item.setData(
                    0,
                    Qt.ItemDataRole.UserRole,
                    {"id": cat_l1.category_id, "level": 1, "obj": cat_l1},
                )

                level2_processes = (
                    self.charge_code_controller.get_charge_code_categories(
                        parent_id=cat_l1.category_id, level=2
                    )
                )

                has_visible_children = False
                for cat_l2 in level2_processes:
                    if ui_status_filter != "all":
                        if (ui_status_filter == "active" and not cat_l2.is_active) or (
                            ui_status_filter == "inactive" and cat_l2.is_active
                        ):
                            continue

                    l2_item = QTreeWidgetItem(l1_item)
                    l2_item.setText(0, cat_l2.name)
                    l2_item.setText(1, str(cat_l2.level))
                    l2_item.setText(2, "Active" if cat_l2.is_active else "Inactive")
                    l2_item.setText(3, str(cat_l2.category_id))
                    l2_item.setData(
                        0,
                        Qt.ItemDataRole.UserRole,
                        {"id": cat_l2.category_id, "level": 2, "obj": cat_l2},
                    )
                    has_visible_children = True

                if (
                    ui_status_filter != "all"
                    and not cat_l1.is_active
                    and not has_visible_children
                ):
                    if ui_status_filter == "active":
                        self.categories_tree.takeTopLevelItem(
                            self.categories_tree.indexOfTopLevelItem(l1_item)
                        )

            self.categories_tree.expandAll()
            self.logger.info(
                f"Displayed categories in tree (UI filter: '{ui_status_filter}')."
            )

        except Exception as e:
            self.logger.error(f"Error loading categories/processes: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load categories: {e}")
        self._update_category_action_buttons_state()

    def _on_category_filter_changed(self, index: int):
        self.load_categories_processes_data()

    def _add_category_or_process(self, is_process: bool = False):
        parent_category_id: Optional[int] = None
        parent_category_name: Optional[str] = None
        selected_item = (
            self.categories_tree.currentItem() if self.categories_tree else None
        )

        if is_process:
            if not selected_item:
                self.show_warning(
                    "Add Process",
                    "Please select a Level 1 Category to add a Process under.",
                )
                return
            item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
            if item_data.get("level") != 1:
                self.show_warning(
                    "Add Process",
                    "Processes (Level 2) can only be added under a Level 1 Category.",
                )
                return
            parent_category_id = item_data.get("id")
            parent_category_name = selected_item.text(0)

        dialog_title = "Add New Process" if is_process else "Add New Category"
        level_to_add = 2 if is_process else 1

        dialog = AddEditChargeCodeCategoryDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
            level=level_to_add,
            parent_id=parent_category_id,
            parent_name=parent_category_name,
            category_to_edit=None,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_categories_processes_data()
            self.entity_updated.emit("charge_code_category")

    def _edit_selected_category_process(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Edit Item", "Please select a category or process to edit.")
            return

        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        category_id = item_data.get("id")
        category_to_edit = self.charge_code_controller.get_category_by_id(category_id)

        if not category_to_edit:
            self.show_error(
                "Error",
                f"Could not find category/process with ID {category_id} to edit.",
            )
            self.load_categories_processes_data()
            return

        parent_name_for_dialog: Optional[str] = None
        if category_to_edit.parent:
            parent_name_for_dialog = category_to_edit.parent.name

        dialog = AddEditChargeCodeCategoryDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
            level=category_to_edit.level,
            parent_id=category_to_edit.parent_id,
            parent_name=parent_name_for_dialog,
            category_to_edit=category_to_edit,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_categories_processes_data()
            self.entity_updated.emit("charge_code_category")

    def _toggle_selected_category_process_active_status(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Toggle Status", "Please select an item.")
            return

        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        item_id = item_data.get("id")
        item_obj: Optional[ChargeCodeCategory] = item_data.get("obj")

        if not item_obj:
            item_obj = self.charge_code_controller.get_category_by_id(item_id)

        if not item_obj:
            self.show_error("Error", f"Item with ID {item_id} not found.")
            return

        action = "deactivate" if item_obj.is_active else "activate"
        item_name_display = item_obj.name

        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} '{item_name_display}'?",
        ):
            success, message = (
                self.charge_code_controller.toggle_category_active_status(
                    item_id, self.current_user_id
                )
            )
            if success:
                self.show_info("Success", message)
                self.load_categories_processes_data()
                self.entity_updated.emit("charge_code_category")
            else:
                self.show_error("Error", message)

    def _delete_selected_category_process(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Delete Item", "Please select an item to delete.")
            return

        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        item_id = item_data.get("id")
        item_name = selected_item.text(0)

        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete '{item_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.charge_code_controller.delete_category_or_process(
                item_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_categories_processes_data()
                self.entity_updated.emit("charge_code_category_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_category_action_buttons_state(self):
        if not self.categories_tree:
            return

        has_selection = self.categories_tree.currentItem() is not None
        is_l1_selected = False
        item_obj: Optional[ChargeCodeCategory] = None

        if has_selection:
            item_data = self.categories_tree.currentItem().data(
                0, Qt.ItemDataRole.UserRole
            )
            if item_data:
                if item_data.get("level") == 1:
                    is_l1_selected = True
                item_obj = item_data.get("obj")

        if self.add_category_btn:
            self.add_category_btn.setEnabled(True)
        if self.add_process_btn:
            self.add_process_btn.setEnabled(is_l1_selected)
        if self.edit_category_process_btn:
            self.edit_category_process_btn.setEnabled(has_selection)
        if self.toggle_category_process_active_btn:
            self.toggle_category_process_active_btn.setEnabled(has_selection)
        if self.delete_category_process_btn:
            self.delete_category_process_btn.setEnabled(has_selection)

        if has_selection and self.toggle_category_process_active_btn and item_obj:
            action_text = "Deactivate" if item_obj.is_active else "Activate"
            self.toggle_category_process_active_btn.setText(
                f"🔄 {action_text} Selected"
            )
            self._apply_standard_button_style(
                self.toggle_category_process_active_btn,
                "toggle_inactive" if item_obj.is_active else "standard",
            )

    # --- Charge Codes Tab Methods ---
    def _create_charge_codes_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()

        self.add_charge_code_btn = QPushButton("➕ Add New Charge Code")
        self._apply_standard_button_style(self.add_charge_code_btn, "add")
        self.edit_charge_code_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_charge_code_btn, "edit")
        self.toggle_charge_code_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_charge_code_active_btn)
        self.delete_charge_code_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_charge_code_btn, "delete")

        button_layout.addWidget(self.add_charge_code_btn)
        button_layout.addWidget(self.edit_charge_code_btn)
        button_layout.addWidget(self.toggle_charge_code_active_btn)
        button_layout.addWidget(self.delete_charge_code_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)

        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.charge_code_status_filter_combo = QComboBox()
        self.charge_code_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.charge_code_status_filter_combo.setCurrentText(
            self._active_filters.get(self.CHARGE_CODE_TAB_INDEX, "active")
        )
        self.charge_code_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.charge_code_status_filter_combo)
        layout.addLayout(top_bar_layout)

        self.charge_codes_table = self._create_table_widget(
            [
                "Code",
                "Alternate Code",
                "Category",
                "Description",
                "Std. Price",
                "Active",
            ]
        )
        if self.charge_codes_table:
            self.charge_codes_table.horizontalHeader().setSectionResizeMode(
                3, QHeaderView.ResizeMode.Stretch
            )
            for i in [0, 1, 2, 4, 5]:
                self.charge_codes_table.horizontalHeader().setSectionResizeMode(
                    i, QHeaderView.ResizeMode.ResizeToContents
                )

        layout.addWidget(self.charge_codes_table)
        self._update_charge_code_action_buttons_state()
        return tab

    def load_charge_codes_data(self):
        self.logger.info("Loading charge codes data for tab...")
        if not self.charge_codes_table or not self.charge_code_status_filter_combo:
            self.logger.error("Charge codes table or filter combo not initialized.")
            return
        try:
            status_filter = self.charge_code_status_filter_combo.currentText().lower()
            self.logger.info(f"Charge code status filter: {status_filter}")
            self._active_filters[self.CHARGE_CODE_TAB_INDEX] = status_filter

            charge_codes = self.charge_code_controller.get_all_charge_codes(
                status_filter=status_filter
            )
            self.charge_codes_table.setRowCount(0)
            for c_obj in charge_codes:
                row_position = self.charge_codes_table.rowCount()
                self.charge_codes_table.insertRow(row_position)
                self.charge_codes_table.setItem(
                    row_position, 0, QTableWidgetItem(c_obj.code)
                )
                self.charge_codes_table.setItem(
                    row_position, 1, QTableWidgetItem(c_obj.alternate_code or "")
                )

                category_path_str = "N/A"
                if c_obj.category_id:
                    path_objects = self.charge_code_controller.get_category_path(
                        c_obj.category_id
                    )
                    if path_objects:
                        category_path_str = " > ".join(
                            [p["name"] for p in path_objects]
                        )

                self.charge_codes_table.setItem(
                    row_position, 2, QTableWidgetItem(category_path_str)
                )
                self.charge_codes_table.setItem(
                    row_position, 3, QTableWidgetItem(c_obj.description)
                )
                price_str = (
                    f"${c_obj.standard_charge:.2f}"
                    if c_obj.standard_charge is not None
                    else "$0.00"
                )
                price_item = QTableWidgetItem(price_str)
                price_item.setTextAlignment(
                    Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
                )
                self.charge_codes_table.setItem(row_position, 4, price_item)

                self.charge_codes_table.setItem(
                    row_position,
                    5,
                    QTableWidgetItem("Yes" if c_obj.is_active else "No"),
                )
                self.charge_codes_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, c_obj.id
                )
            self.logger.info(
                f"Loaded {len(charge_codes)} charge codes based on filter '{status_filter}'."
            )
        except AttributeError as ae:
            self.logger.error(f"Error loading charge codes: {ae}", exc_info=True)
            self.show_error("Load Error", f"Could not load charge codes: {ae}")

        except Exception as e:
            self.logger.error(f"General error loading charge codes: {e}", exc_info=True)
            self.show_error("Load Error", f"An unexpected error occurred: {e}")
        self._update_charge_code_action_buttons_state()

    def _on_charge_code_filter_changed(self, index: int):
        self.load_charge_codes_data()

    def _add_charge_code(self):
        dialog = AddEditChargeCodeDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_charge_codes_data()
            self.entity_updated.emit("charge_code")

    def _edit_selected_charge_code(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info("Edit Charge Code", "Please select a charge code to edit.")
            return

        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        charge_code_to_edit = self.charge_code_controller.get_charge_code_by_id(
            charge_code_id
        )

        if charge_code_to_edit:
            dialog = AddEditChargeCodeDialog(
                self,
                controller=self.charge_code_controller,
                charge_code=charge_code_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code")
        else:
            self.show_error(
                "Error", f"Charge code with ID '{charge_code_id}' not found."
            )
            self.load_charge_codes_data()

    def _toggle_selected_charge_code_active_status(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a charge code.")
            return

        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        cc_obj = self.charge_code_controller.get_charge_code_by_id(charge_code_id)

        if not cc_obj:
            self.show_error("Error", f"Charge code {charge_code_id} not found.")
            return

        action = "deactivate" if cc_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} charge code '{cc_obj.code} - {cc_obj.description}'?",
        ):
            success, message = self.charge_code_controller.toggle_charge_code_status(
                charge_code_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code")
            else:
                self.show_error("Error", message)

    def _delete_selected_charge_code(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info(
                "Delete Charge Code", "Please select a charge code to delete."
            )
            return

        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        charge_code_name = self.charge_codes_table.item(selected_row, 0).text()

        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete charge code '{charge_code_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.charge_code_controller.delete_charge_code(
                charge_code_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_charge_code_action_buttons_state(self):
        has_selection = (
            self.charge_codes_table is not None
            and self.charge_codes_table.currentItem() is not None
        )
        if self.edit_charge_code_btn:
            self.edit_charge_code_btn.setEnabled(has_selection)
        if self.toggle_charge_code_active_btn:
            self.toggle_charge_code_active_btn.setEnabled(has_selection)
        if self.delete_charge_code_btn:
            self.delete_charge_code_btn.setEnabled(has_selection)

        if (
            has_selection
            and self.toggle_charge_code_active_btn
            and self.charge_codes_table
        ):
            selected_row = self.charge_codes_table.currentRow()
            charge_code_id_item = self.charge_codes_table.item(selected_row, 0)
            if not charge_code_id_item:
                return

            charge_code_id = charge_code_id_item.data(Qt.ItemDataRole.UserRole)
            cc_obj = self.charge_code_controller.get_charge_code_by_id(charge_code_id)
            if cc_obj:
                action_text = "Deactivate" if cc_obj.is_active else "Activate"
                self.toggle_charge_code_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_charge_code_active_btn,
                    "toggle_inactive" if cc_obj.is_active else "standard",
                )

    # --- Owners Tab Methods ---
    def _create_owners_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()

        self.add_owner_btn = QPushButton("➕ Add New Owner")
        self._apply_standard_button_style(self.add_owner_btn, "add")
        self.edit_owner_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_owner_btn, "edit")
        self.toggle_owner_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_owner_active_btn)
        self.delete_owner_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_owner_btn, "delete")

        button_layout.addWidget(self.add_owner_btn)
        button_layout.addWidget(self.edit_owner_btn)
        button_layout.addWidget(self.toggle_owner_active_btn)
        button_layout.addWidget(self.delete_owner_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)

        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.owner_status_filter_combo = QComboBox()
        self.owner_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.owner_status_filter_combo.setCurrentText(
            self._active_filters.get(self.OWNER_TAB_INDEX, "active")
        )
        self.owner_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.owner_status_filter_combo)

        layout.addLayout(top_bar_layout)

        self.owners_table = self._create_table_widget(
            [
                "Account #",
                "Farm Name",
                "Last Name",
                "First Name",
                "City",
                "State",
                "Phone",
                "Active",
            ]
        )
        if self.owners_table:
            self.owners_table.horizontalHeader().setSectionResizeMode(
                1, QHeaderView.ResizeMode.Stretch
            )
            self.owners_table.horizontalHeader().setSectionResizeMode(
                2, QHeaderView.ResizeMode.Stretch
            )
        layout.addWidget(self.owners_table)
        self._update_owner_action_buttons_state()
        return tab

    def load_owners_data(self):
        self.logger.info("Loading owners data for tab...")
        if not self.owners_table or not self.owner_status_filter_combo:
            self.logger.error("Owners table or filter combo not initialized.")
            return
        try:
            status_filter = self.owner_status_filter_combo.currentText().lower()
            self._active_filters[self.OWNER_TAB_INDEX] = status_filter

            owners = self.owner_controller.get_all_master_owners(
                status_filter=status_filter
            )
            self.owners_table.setRowCount(0)
            for owner_obj in owners:
                row_pos = self.owners_table.rowCount()
                self.owners_table.insertRow(row_pos)
                self.owners_table.setItem(
                    row_pos, 0, QTableWidgetItem(owner_obj.account_number or "")
                )
                self.owners_table.setItem(
                    row_pos, 1, QTableWidgetItem(owner_obj.farm_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 2, QTableWidgetItem(owner_obj.last_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 3, QTableWidgetItem(owner_obj.first_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 4, QTableWidgetItem(owner_obj.city or "")
                )
                state_display = owner_obj.state_code or ""
                if (
                    hasattr(owner_obj, "state")
                    and owner_obj.state
                    and hasattr(owner_obj.state, "state_code")
                ):
                    state_display = owner_obj.state.state_code
                self.owners_table.setItem(row_pos, 5, QTableWidgetItem(state_display))
                self.owners_table.setItem(
                    row_pos, 6, QTableWidgetItem(owner_obj.phone or "")
                )
                self.owners_table.setItem(
                    row_pos, 7, QTableWidgetItem("Yes" if owner_obj.is_active else "No")
                )
                self.owners_table.item(row_pos, 0).setData(
                    Qt.ItemDataRole.UserRole, owner_obj.owner_id
                )
            self.logger.info(f"Loaded {len(owners)} owners.")
        except Exception as e:
            self.logger.error(f"Error loading owners: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load owners: {e}")
        self._update_owner_action_buttons_state()

    def _on_owner_filter_changed(self, index: int):
        self.load_owners_data()

    def _add_owner(self):
        dialog = AddEditOwnerDialog(
            self,
            owner_controller=self.owner_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_owners_data()
            self.entity_updated.emit("owner")

    def _edit_selected_owner(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Edit Owner", "Please select an owner.")
            return

        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()

        owner_to_edit = self.owner_controller.get_owner_by_id(owner_id)

        if owner_to_edit:
            dialog = AddEditOwnerDialog(
                self,
                owner_controller=self.owner_controller,
                owner_object=owner_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_owners_data()
                self.entity_updated.emit("owner")
        else:
            self.show_error("Error", f"Owner ID '{owner_id}' not found.")
            self.load_owners_data()

    def _toggle_selected_owner_active_status(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Toggle Status", "Please select an owner.")
            return
        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
        owner_obj = self.owner_controller.get_owner_by_id(owner_id)

        if not owner_obj:
            self.show_error("Error", f"Owner ID {owner_id} not found.")
            return

        action = "deactivate" if owner_obj.is_active else "activate"
        name_display = (
            owner_obj.farm_name
            or f"{owner_obj.first_name or ''} {owner_obj.last_name or ''}".strip()
            or f"ID: {owner_obj.owner_id}"
        )
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} owner '{name_display}'?",
        ):
            success, message = self.owner_controller.toggle_owner_active_status(
                owner_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_owners_data()
                self.entity_updated.emit("owner")
            else:
                self.show_error("Error", message)

    def _delete_selected_owner(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Delete Owner", "Please select an owner to delete.")
            return

        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole)
        display_name = (
            self.owners_table.item(selected_row, 1).text()
            or self.owners_table.item(selected_row, 2).text()
        )

        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete owner '{display_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.owner_controller.delete_master_owner(
                owner_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_owners_data()
                self.entity_updated.emit("owner_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_owner_action_buttons_state(self):
        has_selection = (
            self.owners_table is not None
            and self.owners_table.currentItem() is not None
        )
        if self.edit_owner_btn:
            self.edit_owner_btn.setEnabled(has_selection)
        if self.toggle_owner_active_btn:
            self.toggle_owner_active_btn.setEnabled(has_selection)
        if self.delete_owner_btn:
            self.delete_owner_btn.setEnabled(has_selection)

        if has_selection and self.toggle_owner_active_btn and self.owners_table:
            selected_row = self.owners_table.currentRow()
            owner_id_item = self.owners_table.item(selected_row, 0)
            if not owner_id_item:
                return

            owner_id = (
                owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
            )
            owner_obj = self.owner_controller.get_owner_by_id(owner_id)
            if owner_obj:
                action_text = "Deactivate" if owner_obj.is_active else "Activate"
                self.toggle_owner_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_owner_active_btn,
                    "toggle_inactive" if owner_obj.is_active else "standard",
                )

    def show_info(self, title: str, message: str):
        QMessageBox.information(self, title, message)

    def show_warning(self, title: str, message: str):
        QMessageBox.warning(self, title, message)

    def show_error(self, title: str, message: str):
        QMessageBox.critical(self, title, message)

    def show_question(self, title: str, message: str) -> bool:
        reply = QMessageBox.question(
            self,
            title,
            message,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )
        return reply == QMessageBox.StandardButton.Yes


=============== FILE: views\admin\dialogs\__init__.py ===============

# views/admin/dialogs/__init__.py
"""
EDSI Veterinary Management System - Admin Dialogs Package
Version: 1.0.1 (Example Version)
Purpose: Makes admin dialog classes easily importable.
Last Updated: June 4, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-06-04):
    - Added AddEditOwnerDialog to exports.
    - Ensured other existing dialogs are exported.
"""

from .add_edit_user_dialog import AddEditUserDialog
from .add_edit_location_dialog import AddEditLocationDialog
from .add_edit_charge_code_dialog import AddEditChargeCodeDialog
from .add_edit_charge_code_category_dialog import AddEditChargeCodeCategoryDialog

# MODIFIED: Changed from AddEditMasterOwnerDialog to AddEditOwnerDialog
from .add_edit_owner_dialog import AddEditOwnerDialog


__all__ = [
    "AddEditUserDialog",
    "AddEditLocationDialog",
    "AddEditChargeCodeDialog",
    "AddEditChargeCodeCategoryDialog",
    "AddEditOwnerDialog",  # Ensure this matches the class name in the file
]


=============== FILE: views\admin\dialogs\add_edit_charge_code_category_dialog.py ===============

# views/admin/dialogs/add_edit_charge_code_category_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Category/Process Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing charge code categories (Level 1)
         and processes (Level 2).
Last Updated: June 3, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCodeCategory

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeCategoryDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        category_to_edit: Optional[ChargeCodeCategory] = None,
        parent_category: Optional[
            ChargeCodeCategory
        ] = None,  # For adding a new Level 2 Process
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.category_to_edit = category_to_edit
        self.parent_category = (
            parent_category  # Will be None if adding/editing a Level 1 Category
        )

        self.is_edit_mode = self.category_to_edit is not None

        # Determine level
        if self.is_edit_mode:
            self.current_level = self.category_to_edit.level
            self.current_parent_id = self.category_to_edit.parent_id
            if (
                self.current_parent_id and not self.parent_category
            ):  # Fetch parent if editing L2 and not passed
                self.parent_category = self.controller.get_category_by_id_internal(
                    self.current_parent_id
                )

        elif self.parent_category:  # Adding a new Level 2 Process
            self.current_level = 2
            self.current_parent_id = self.parent_category.category_id
        else:  # Adding a new Level 1 Category
            self.current_level = 1
            self.current_parent_id = None

        self.item_type_name = "Process" if self.current_level == 2 else "Category"

        self.setWindowTitle(
            f"{'Edit' if self.is_edit_mode else 'Add New'} {self.item_type_name}"
        )
        self.setMinimumWidth(450)

        # Input Fields
        self.name_input: Optional[QLineEdit] = None
        self.parent_name_label: Optional[QLabel] = None  # To display parent name
        self.level_label: Optional[QLabel] = None  # To display level
        self.is_active_checkbox: Optional[QCheckBox] = None

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.category_to_edit:
            self._populate_fields()
        else:  # New item
            self.is_active_checkbox.setChecked(True)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {base_bg};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px;
                padding: 6px 10px; font-size: 13px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled {{ 
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QCheckBox::indicator {{ width: 13px; height: 13px; }}
            QCheckBox {{ color: {DARK_TEXT_PRIMARY}; background-color: transparent; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        # ... (rest of palette setup - can be copied from another dialog) ...
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str, is_field_value: bool = False) -> QLabel:
        label = QLabel(text)
        style = f"color: {DARK_TEXT_PRIMARY if is_field_value else DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        if is_field_value:
            style += f" padding-left: 5px; border: 1px solid {DARK_BORDER}; border-radius: 4px; background-color: {DARK_HEADER_FOOTER}; min-height: 20px;"

        label.setStyleSheet(style)
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText(f"Enter {self.item_type_name} Name")

        # Display Parent Category Name (if applicable)
        parent_display_name = (
            self.parent_category.name if self.parent_category else "N/A (Top Level)"
        )
        self.parent_name_label = self._create_label(
            parent_display_name, is_field_value=True
        )

        # Display Level
        self.level_label = self._create_label(
            str(self.current_level), is_field_value=True
        )

        self.is_active_checkbox = QCheckBox("Is Active")

        form_layout.addRow(
            self._create_label(f"{self.item_type_name} Name*:"), self.name_input
        )
        if self.current_level == 2:  # Only show parent for Processes (Level 2)
            form_layout.addRow(
                self._create_label("Parent Category:"), self.parent_name_label
            )
        form_layout.addRow(self._create_label("Level:"), self.level_label)
        form_layout.addRow(self._create_label("Status:"), self.is_active_checkbox)

        input_style = self._get_form_input_style()
        self.name_input.setStyleSheet(input_style)
        self.is_active_checkbox.setStyleSheet(input_style)  # For QCheckBox part

        layout.addLayout(form_layout)
        layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        if self.category_to_edit:
            self.name_input.setText(self.category_to_edit.name)
            self.is_active_checkbox.setChecked(self.category_to_edit.is_active)
            # Parent and Level are already set in __init__ and displayed by labels

    def get_data(self) -> Optional[Dict[str, Any]]:
        name = self.name_input.text().strip()
        if not name:
            QMessageBox.warning(
                self, "Input Error", f"{self.item_type_name} Name is required."
            )
            return None

        return {
            "name": name,
            "is_active": self.is_active_checkbox.isChecked(),
            "level": self.current_level,
            "parent_id": self.current_parent_id,
        }

    def validate_and_accept(self):
        data = self.get_data()
        if data is None:
            return

        # Use the controller's validation method
        is_valid, errors = self.controller.validate_charge_code_category_data(
            data,
            is_new=(not self.is_edit_mode),
            category_id=(
                self.category_to_edit.category_id if self.is_edit_mode else None
            ),
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Validation Error",
                "Please correct errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.category_to_edit:
                success, message = self.controller.update_charge_code_category(
                    self.category_to_edit.category_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code_category(
                    data, self.current_user_id
                )

            if success:
                if hasattr(
                    self.parent_view, "show_info"
                ):  # Check if parent_view has show_info
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error saving category/process: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {str(e)}"
            )


=============== FILE: views\admin\dialogs\add_edit_charge_code_dialog.py ===============

# views/admin/dialogs/add_edit_charge_code_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Dialog
Version: 1.1.11
Purpose: Dialog for creating and editing charge codes.
         - Fixed dictionary key access for category path population.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.1.11 (2025-06-05):
    - Bug Fix: In `_populate_fields`, corrected the category path access from
      attribute-style (`path[0].category_id`) to dictionary key-style (`path[0]['id']`).
      This resolves the `AttributeError` when opening the dialog in edit mode.
- v1.1.10 (2025-06-03):
    - Added a slot `_on_alt_code_text_edited` connected to the `textEdited`
      signal of `alt_code_input` to automatically convert input to uppercase
      as the user types.
- v1.1.9 (2025-06-03):
    - Added `QHBoxLayout` to imports from `PySide6.QtWidgets` to resolve
      a NameError in `_setup_ui` when creating `status_layout`.
- v1.1.8 (2025-06-03):
    - Made 'is_active_checkbox' and 'taxable_checkbox' disabled (read-only).
- v1.1.7 (2025-06-03):
    - Removed 'detail_category_combo' for a 2-level hierarchy.
- v1.1.6 (2025-06-02):
    - Added `QTimer` import.
# ... (previous changelog entries)
"""

import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QTextEdit,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QHBoxLayout,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer, Slot

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCode as ChargeCodeModel
from models import ChargeCodeCategory

from config.app_config import AppConfig
import os

try:
    current_script_path_for_assets = os.path.dirname(os.path.abspath(__file__))
    project_root_for_assets = os.path.abspath(
        os.path.join(current_script_path_for_assets, "..", "..", "..")
    )
    assets_path = os.path.join(project_root_for_assets, "assets", "icons")
    if not os.path.exists(
        os.path.join(assets_path, "checkmark_light.svg")
    ):  # Basic check
        assets_path = "assets/icons"
except Exception:
    assets_path = "assets/icons"


from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        charge_code: Optional[ChargeCodeModel] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.charge_code = charge_code
        self.is_edit_mode = charge_code is not None

        self.code_input: Optional[QLineEdit] = None
        self.alt_code_input: Optional[QLineEdit] = None
        self.description_input: Optional[QTextEdit] = None
        self.main_category_combo: Optional[QComboBox] = None
        self.sub_category_combo: Optional[QComboBox] = None
        self.standard_charge_input: Optional[QDoubleSpinBox] = None
        self.taxable_checkbox: Optional[QCheckBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Charge Code")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_main_categories()

        if self.is_edit_mode and self.charge_code:
            self._populate_fields()
        else:
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(True)
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(False)
            if self.sub_category_combo:
                self.sub_category_combo.setEnabled(False)

        if self.is_active_checkbox:
            self.is_active_checkbox.setEnabled(False)
        if self.taxable_checkbox:
            self.taxable_checkbox.setEnabled(False)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        checkmark_path = os.path.join(assets_path, "checkmark_light.svg").replace(
            os.sep, "/"
        )
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; min-height: 20px; }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QLineEdit:disabled, QComboBox:disabled, QTextEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER}; }}
            QLineEdit[readOnly="true"] {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
            QCheckBox::indicator:disabled {{ background-color: {DARK_INPUT_FIELD_BACKGROUND}; border: 1px solid {DARK_TEXT_TERTIARY}; }}
            QCheckBox::indicator:checked:disabled {{ background-color: {DARK_PRIMARY_ACTION}; border: 1px solid {DARK_PRIMARY_ACTION}; image: url({checkmark_path}); }}
            QCheckBox:disabled {{ color: {DARK_TEXT_SECONDARY}; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;}} QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)
        self.code_input = QLineEdit()
        self.code_input.setPlaceholderText("Unique code (e.g., EXAM01)")
        self.alt_code_input = QLineEdit()
        self.alt_code_input.setPlaceholderText("Alternative code (optional)")
        if self.alt_code_input:
            self.alt_code_input.textEdited.connect(self._on_alt_code_text_edited)

        self.main_category_combo = QComboBox()
        self.main_category_combo.setPlaceholderText("Select Main Category")
        self.sub_category_combo = QComboBox()
        self.sub_category_combo.setPlaceholderText("Select Sub-Category")
        self.description_input = QTextEdit()
        self.description_input.setPlaceholderText("Detailed description")
        self.description_input.setFixedHeight(70)
        self.standard_charge_input = QDoubleSpinBox()
        self.standard_charge_input.setDecimals(2)
        self.standard_charge_input.setRange(0.00, 99999.99)
        self.standard_charge_input.setPrefix("$ ")
        self.standard_charge_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.taxable_checkbox = QCheckBox("Taxable")
        self.taxable_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )
        self.is_active_checkbox = QCheckBox("Active")
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Alt. Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.alt_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Main Category*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.main_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Sub-Category:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.sub_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Standard Charge*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.standard_charge_input, row, 1)
        status_layout = QHBoxLayout()
        status_layout.addWidget(self.taxable_checkbox)
        status_layout.addSpacing(20)
        status_layout.addWidget(self.is_active_checkbox)
        status_layout.addStretch()
        grid_layout.addLayout(
            status_layout,
            row,
            2,
            1,
            2,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )
        row += 1
        grid_layout.addWidget(
            self._create_label("Description*:"),
            row,
            0,
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight,
        )
        grid_layout.addWidget(self.description_input, row, 1, 1, 3)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        fields_to_style = [
            self.code_input,
            self.alt_code_input,
            self.description_input,
            self.main_category_combo,
            self.sub_category_combo,
            self.standard_charge_input,
        ]
        for field in fields_to_style:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_style = (
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
                button.setStyleSheet(ok_style)
        overall_layout.addWidget(self.button_box)
        if self.main_category_combo:
            self.main_category_combo.currentIndexChanged.connect(
                self._on_main_category_changed
            )

    @Slot(str)
    def _on_alt_code_text_edited(self, text: str):
        """Automatically converts the alt_code_input text to uppercase."""
        if self.alt_code_input:
            current_text = text
            uppercase_text = current_text.upper()
            if current_text != uppercase_text:
                self.alt_code_input.blockSignals(True)
                cursor_pos = self.alt_code_input.cursorPosition()
                self.alt_code_input.setText(uppercase_text)
                self.alt_code_input.setCursorPosition(cursor_pos)
                self.alt_code_input.blockSignals(False)

    def _load_main_categories(self):
        if not self.main_category_combo:
            return
        self.main_category_combo.clear()
        self.main_category_combo.addItem("Select Main Category...", None)
        try:
            categories = self.controller.get_charge_code_categories(level=1)
            for cat in categories:
                self.main_category_combo.addItem(cat.name, cat.category_id)
        except Exception as e:
            self.logger.error(f"Error loading main categories: {e}", exc_info=True)

    def _on_main_category_changed(self, index: int):
        if not self.main_category_combo or not self.sub_category_combo:
            return
        self.sub_category_combo.clear()
        self.sub_category_combo.addItem("Select Sub-Category...", None)
        parent_id = self.main_category_combo.itemData(index)
        if parent_id is not None:
            try:
                sub_categories = self.controller.get_charge_code_categories(
                    parent_id=parent_id, level=2
                )
                if sub_categories:
                    for cat in sub_categories:
                        self.sub_category_combo.addItem(cat.name, cat.category_id)
                    self.sub_category_combo.setEnabled(True)
                else:
                    self.sub_category_combo.setEnabled(False)
            except Exception as e:
                self.logger.error(
                    f"Error loading sub-categories for parent_id {parent_id}: {e}",
                    exc_info=True,
                )
                self.sub_category_combo.setEnabled(False)
        else:
            self.sub_category_combo.setEnabled(False)

    def _populate_fields(self):
        if self.is_edit_mode and self.charge_code:
            self.code_input.setText(self.charge_code.code)
            self.code_input.setReadOnly(True)
            self.code_input.setStyleSheet(
                self._get_form_input_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
            )
            self.alt_code_input.setText(self.charge_code.alternate_code or "")
            self.description_input.setPlainText(self.charge_code.description)
            self.standard_charge_input.setValue(
                float(self.charge_code.standard_charge)
                if self.charge_code.standard_charge is not None
                else 0.0
            )
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(self.charge_code.taxable or False)
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(self.charge_code.is_active)
            if self.charge_code.category_id is not None:
                path = self.controller.get_category_path(self.charge_code.category_id)
                if path:
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(True)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(True)
                    if len(path) > 0 and self.main_category_combo:
                        main_cat_id = path[0]["id"]  # FIXED
                        index = self.main_category_combo.findData(main_cat_id)
                        if index >= 0:
                            self.main_category_combo.setCurrentIndex(index)
                        self._on_main_category_changed(
                            self.main_category_combo.currentIndex()
                        )
                    if len(path) > 1 and self.sub_category_combo:
                        sub_cat_id = path[1]["id"]  # FIXED
                        QTimer.singleShot(
                            0,
                            lambda: self._select_combo_item(
                                self.sub_category_combo, sub_cat_id, False
                            ),
                        )
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(False)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(False)
            else:
                if self.sub_category_combo:
                    self.sub_category_combo.setEnabled(False)

    def _select_combo_item(
        self, combo: QComboBox, item_id_to_select: int, trigger_next_load: bool
    ):
        if not combo:
            return
        index = combo.findData(item_id_to_select)
        if index >= 0:
            combo.setCurrentIndex(index)

    def get_data(self) -> Optional[Dict[str, Any]]:
        code = self.code_input.text().strip().upper()
        description = self.description_input.toPlainText().strip()
        standard_charge_value = self.standard_charge_input.value()
        errors = []
        if not code:
            errors.append("Code is required.")
        if not description:
            errors.append("Description is required.")
        charge_decimal: Optional[Decimal] = None
        try:
            charge_decimal = Decimal(str(standard_charge_value))
            if charge_decimal < Decimal("0.00"):
                errors.append("Standard Charge cannot be negative.")
        except InvalidOperation:
            errors.append("Standard Charge must be a valid number (e.g., 25.00).")
        selected_category_id: Optional[int] = None
        if (
            self.sub_category_combo
            and self.sub_category_combo.currentIndex() > 0
            and self.sub_category_combo.isEnabled()
        ):
            selected_category_id = self.sub_category_combo.currentData()
        elif self.main_category_combo and self.main_category_combo.currentIndex() > 0:
            selected_category_id = self.main_category_combo.currentData()
        if selected_category_id is None:
            errors.append(
                "A category selection (Main Category, or Sub-Category if applicable) is required."
            )
        if errors:
            QMessageBox.warning(self, "Input Error", "\n".join(errors))
            return None
        return {
            "code": code,
            "alternate_code": self.alt_code_input.text().strip().upper() or None,
            "description": description,
            "category_id": selected_category_id,
            "standard_charge": charge_decimal,
        }

    def validate_and_accept(self):
        data = self.get_data()
        if data is None:
            return
        validation_data_for_controller = data.copy()
        if self.is_edit_mode and self.charge_code:
            if self.is_active_checkbox:
                validation_data_for_controller["is_active"] = (
                    self.is_active_checkbox.isChecked()
                )
            if self.taxable_checkbox:
                validation_data_for_controller["taxable"] = (
                    self.taxable_checkbox.isChecked()
                )
        is_valid, errors = self.controller.validate_charge_code_data(
            validation_data_for_controller, is_new=(not self.is_edit_mode)
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return
        try:
            if self.is_edit_mode and self.charge_code:
                success, message = self.controller.update_charge_code(
                    self.charge_code.id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code(
                    data, self.current_user_id
                )
            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(
                f"Error during charge code save/update: {e}", exc_info=True
            )
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views\admin\dialogs\add_edit_location_dialog.py ===============

# views/admin/dialogs/add_edit_location_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Location Dialog
Version: 1.1.6
Purpose: Dialog for creating and editing practice locations with detailed address fields,
         phone, email, contact person, and auto-populating country code.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.1.6 (2025-06-05):
    - In `validate_and_accept`, corrected the tuple unpacking for the `update_location`
      call to expect two return values (success, message) instead of three,
      resolving a ValueError.
- v1.1.5 (2025-06-02):
    - Added QLineEdit fields for Phone, Email, and Contact Person.
    - Updated QGridLayout in _setup_ui to include new fields.
    - Updated _populate_fields to load data for new fields.
    - Updated get_data to collect data from new fields.
    - Implemented _on_state_changed slot to auto-populate Country Code.
    - Modified _load_states_into_combobox to store country_code with state_code.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.location_controller import LocationController
from models import Location as LocationModel
from models import StateProvince as StateProvinceModel

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditLocationDialog(QDialog):
    def __init__(
        self,
        parent_view,
        controller: LocationController,
        current_user_id: str,
        location: Optional[LocationModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.controller = controller
        self.current_user_id = current_user_id
        self.location = location
        self.is_edit_mode = location is not None

        self.location_name_input: Optional[QLineEdit] = None
        self.contact_person_input: Optional[QLineEdit] = None
        self.address_line1_input: Optional[QLineEdit] = None
        self.address_line2_input: Optional[QLineEdit] = None
        self.city_input: Optional[QLineEdit] = None
        self.state_combo: Optional[QComboBox] = None
        self.zip_code_input: Optional[QLineEdit] = None
        self.country_code_input: Optional[QLineEdit] = None
        self.phone_input: Optional[QLineEdit] = None
        self.email_input: Optional[QLineEdit] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Location")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_states_into_combobox()
        if self.is_edit_mode and self.location:
            self._populate_fields()

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {base_bg};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; 
                border-radius: 4px;
                padding: 6px 10px; 
                font-size: 13px; 
                min-height: 20px; 
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled {{ 
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QComboBox::drop-down {{ 
                border: none;
                background-color: transparent;
            }}
            QComboBox::down-arrow {{ 
                color: {DARK_TEXT_SECONDARY}; 
            }}
            QComboBox QAbstractItemView {{ 
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)

        self.location_name_input = QLineEdit()
        self.location_name_input.setPlaceholderText("e.g., Main Barn, Paddock A")

        self.contact_person_input = QLineEdit()
        self.contact_person_input.setPlaceholderText("Name of contact person")

        self.address_line1_input = QLineEdit()
        self.address_line1_input.setPlaceholderText("Street Address")

        self.address_line2_input = QLineEdit()
        self.address_line2_input.setPlaceholderText("Apartment, Suite, etc. (Optional)")

        self.city_input = QLineEdit()
        self.city_input.setPlaceholderText("City/Town")

        self.state_combo = QComboBox()
        self.state_combo.setPlaceholderText("Select State/Province")
        self.state_combo.currentIndexChanged.connect(self._on_state_changed)

        self.zip_code_input = QLineEdit()
        self.zip_code_input.setPlaceholderText("Zip/Postal Code")

        self.country_code_input = QLineEdit()
        self.country_code_input.setPlaceholderText("e.g., USA, CAN")
        self.country_code_input.setMaxLength(10)

        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText("Primary phone number")

        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Contact email address")

        self.is_active_checkbox = QCheckBox("Location is Active")
        self.is_active_checkbox.setChecked(True)
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        grid_layout.addWidget(
            self._create_label("Location Name*:"), 0, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.location_name_input, 0, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Contact Person:"), 1, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.contact_person_input, 1, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Address Line 1:"), 2, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line1_input, 2, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Address Line 2:"), 3, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line2_input, 3, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("City:"), 4, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.city_input, 4, 1)
        grid_layout.addWidget(
            self._create_label("State/Province:"), 4, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.state_combo, 4, 3)
        grid_layout.addWidget(
            self._create_label("Zip/Postal Code:"), 5, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.zip_code_input, 5, 1)
        grid_layout.addWidget(
            self._create_label("Country Code:"), 5, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.country_code_input, 5, 3)
        grid_layout.addWidget(
            self._create_label("Phone:"), 6, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.phone_input, 6, 1)
        grid_layout.addWidget(
            self._create_label("Email:"), 6, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.email_input, 6, 3)
        grid_layout.addWidget(
            self.is_active_checkbox, 7, 1, 1, 1, Qt.AlignmentFlag.AlignLeft
        )

        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        for field in [
            self.location_name_input,
            self.contact_person_input,
            self.address_line1_input,
            self.address_line2_input,
            self.city_input,
            self.state_combo,
            self.zip_code_input,
            self.country_code_input,
            self.phone_input,
            self.email_input,
        ]:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_button_specific_style = (
                    f"background-color: {DARK_SUCCESS_ACTION}; color: white;"
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ {ok_button_specific_style} }}"
                )

        overall_layout.addWidget(self.button_box)

    def _load_states_into_combobox(self):
        if not self.state_combo:
            return
        self.state_combo.addItem("", None)
        session = None
        try:
            from config.database_config import db_manager

            session = db_manager.get_session()
            states: List[StateProvinceModel] = (
                session.query(StateProvinceModel)
                .filter(StateProvinceModel.is_active == True)
                .order_by(
                    StateProvinceModel.country_code, StateProvinceModel.state_name
                )
                .all()
            )
            for state in states:
                display_name = f"{state.state_name} ({state.state_code})"
                self.state_combo.addItem(
                    display_name,
                    {
                        "state_code": state.state_code,
                        "country_code": state.country_code,
                    },
                )
            self.logger.info(f"Loaded {len(states)} states into combobox.")
        except Exception as e:
            self.logger.error(f"Error loading states into combobox: {e}", exc_info=True)
            QMessageBox.warning(
                self, "Data Load Error", "Could not load states for selection."
            )
        finally:
            if session:
                session.close()

    def _on_state_changed(self, index: int):
        if not self.state_combo or not self.country_code_input:
            return
        selected_data = self.state_combo.itemData(index)
        if selected_data and isinstance(selected_data, dict):
            country_code = selected_data.get("country_code", "")
            self.country_code_input.setText(country_code)
        else:
            self.country_code_input.clear()

    def _populate_fields(self):
        if self.location:
            self.location_name_input.setText(self.location.location_name or "")
            self.contact_person_input.setText(self.location.contact_person or "")
            self.address_line1_input.setText(self.location.address_line1 or "")
            self.address_line2_input.setText(self.location.address_line2 or "")
            self.city_input.setText(self.location.city or "")
            if self.location.state_code:
                for i in range(self.state_combo.count()):
                    item_data = self.state_combo.itemData(i)
                    if (
                        item_data
                        and isinstance(item_data, dict)
                        and item_data.get("state_code") == self.location.state_code
                    ):
                        self.state_combo.setCurrentIndex(i)
                        break
                else:
                    self.logger.warning(
                        f"State code '{self.location.state_code}' not found in combobox. Location: {self.location.location_name}"
                    )
            else:
                self.state_combo.setCurrentIndex(0)
            self.zip_code_input.setText(self.location.zip_code or "")
            self.country_code_input.setText(self.location.country_code or "")
            self.phone_input.setText(self.location.phone or "")
            self.email_input.setText(self.location.email or "")
            self.is_active_checkbox.setChecked(self.location.is_active)

    def get_data(self) -> Dict[str, Any]:
        selected_state_code = None
        if self.state_combo.currentIndex() > 0:
            item_data = self.state_combo.currentData()
            if item_data and isinstance(item_data, dict):
                selected_state_code = item_data.get("state_code")

        return {
            "location_name": self.location_name_input.text(),
            "contact_person": self.contact_person_input.text(),
            "address_line1": self.address_line1_input.text(),
            "address_line2": self.address_line2_input.text(),
            "city": self.city_input.text(),
            "state_code": selected_state_code,
            "zip_code": self.zip_code_input.text(),
            "country_code": self.country_code_input.text(),
            "phone": self.phone_input.text(),
            "email": self.email_input.text(),
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        data = self.get_data()
        is_valid, errors = self.controller.validate_location_data(
            data,
            is_new=(not self.is_edit_mode),
            location_id_to_check_for_unique=(
                self.location.location_id
                if self.is_edit_mode and self.location
                else None
            ),
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.location:
                # MODIFIED: Correctly unpack the two return values from update_location
                success, message = self.controller.update_location(
                    self.location.location_id, data, self.current_user_id
                )
            else:
                # create_location returns three values
                success, message, _ = self.controller.create_location(
                    data, self.current_user_id
                )

            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    self.logger.warning(
                        "parent_view does not have show_info method. Using local QMessageBox."
                    )
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during location save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views\admin\dialogs\add_edit_owner_dialog.py ===============

# views/admin/dialogs/add_edit_owner_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Owner Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing Owner master file records,
         including contact, address, and financial information.
         Styled to match HorseUnifiedManagement forms, using QGridLayout.
Last Updated: June 2, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-06-02):
    - Initial implementation.
    - Includes fields for account info, name, address (with state dropdown
      and auto-populated, read-only country), contact details, and financial info
      (Balance (display-only), Credit Limit, Billing Terms dropdown).
    - Uses QGridLayout for layout.
    - Styled using _get_form_input_style (adapted from HorseUnifiedManagement)
      and _create_label helper.
    - Populates states from OwnerController and billing terms from a predefined list.
    - Implements _on_state_changed to auto-populate country code.
    - Implements _populate_fields, get_data, and validate_and_accept methods.
"""

import logging
from typing import Optional, Dict, Any, List
from decimal import Decimal, InvalidOperation

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QDoubleSpinBox,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController
from models import Owner as OwnerModel

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)

PREDEFINED_BILLING_TERMS = [
    "Net 30 Days",
    "Net 60 Days",
    "Net 90 Days",
    "Due on Receipt",
    "COD",
    "Prepay",
    "Monthly Statement",
]


class AddEditOwnerDialog(QDialog):
    def __init__(
        self,
        parent_view,
        owner_controller: OwnerController,
        current_user_id: str,
        owner_object: Optional[OwnerModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.owner_controller = owner_controller
        self.current_user_id = current_user_id
        self.owner = owner_object
        self.is_edit_mode = owner_object is not None

        self.account_number_input: Optional[QLineEdit] = None
        self.farm_name_input: Optional[QLineEdit] = None
        self.first_name_input: Optional[QLineEdit] = None
        self.last_name_input: Optional[QLineEdit] = None
        self.address_line1_input: Optional[QLineEdit] = None
        self.address_line2_input: Optional[QLineEdit] = None
        self.city_input: Optional[QLineEdit] = None
        self.state_combo: Optional[QComboBox] = None
        self.zip_code_input: Optional[QLineEdit] = None
        self.country_code_input: Optional[QLineEdit] = None
        self.phone_input: Optional[QLineEdit] = None
        self.mobile_phone_input: Optional[QLineEdit] = None
        self.email_input: Optional[QLineEdit] = None
        self.balance_display_input: Optional[QLineEdit] = None
        self.credit_limit_input: Optional[QDoubleSpinBox] = None
        self.billing_terms_combo: Optional[QComboBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Owner")
        self.setMinimumWidth(700)

        self._setup_palette()
        self._setup_ui()
        self._load_reference_data_into_combos()
        if self.is_edit_mode and self.owner:
            self._populate_fields()

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox, QDoubleSpinBox {{
                background-color: {base_bg}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px;
                padding: 6px 10px; font-size: 13px; min-height: 20px; 
            }}
            QLineEdit:focus, QComboBox:focus, QDoubleSpinBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled, QDoubleSpinBox:disabled {{ 
                background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
            }}
            QComboBox::drop-down {{ border: none; background-color: transparent; }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QComboBox QAbstractItemView {{ 
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)

        self.account_number_input = QLineEdit()
        self.account_number_input.setPlaceholderText("e.g., SMIJ01")
        self.farm_name_input = QLineEdit()
        self.farm_name_input.setPlaceholderText("Optional")
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Contact's First Name")
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Contact's Last Name")
        self.address_line1_input = QLineEdit()
        self.address_line1_input.setPlaceholderText("Street address, P.O. box")
        self.address_line2_input = QLineEdit()
        self.address_line2_input.setPlaceholderText("Apt, suite, etc. (Optional)")
        self.city_input = QLineEdit()
        self.city_input.setPlaceholderText("City/Town")
        self.state_combo = QComboBox()
        self.state_combo.setPlaceholderText("Select State/Province")
        self.zip_code_input = QLineEdit()
        self.zip_code_input.setPlaceholderText("Zip/Postal Code")
        self.country_code_input = QLineEdit()
        self.country_code_input.setPlaceholderText("Auto (e.g. USA, CAN)")
        self.country_code_input.setReadOnly(True)
        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText("(xxx) xxx-xxxx")
        self.mobile_phone_input = QLineEdit()
        self.mobile_phone_input.setPlaceholderText("Optional")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("example@domain.com")
        self.balance_display_input = QLineEdit("0.00")
        self.balance_display_input.setReadOnly(True)
        self.balance_display_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.credit_limit_input = QDoubleSpinBox()
        self.credit_limit_input.setDecimals(2)
        self.credit_limit_input.setRange(0.00, 9999999.99)
        self.credit_limit_input.setPrefix("$ ")
        self.credit_limit_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.credit_limit_input.setValue(0.00)
        self.billing_terms_combo = QComboBox()
        self.is_active_checkbox = QCheckBox("Owner is Active")
        self.is_active_checkbox.setChecked(True)
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Account #:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.account_number_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Farm Name:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.farm_name_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("First Name:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.first_name_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Last Name:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.last_name_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Address Line 1*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line1_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Address Line 2:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line2_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("City*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.city_input, row, 1)
        grid_layout.addWidget(
            self._create_label("State/Province*:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.state_combo, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Zip/Postal Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.zip_code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Country Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.country_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Phone:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.phone_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Mobile Phone:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.mobile_phone_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Email:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.email_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Balance:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.balance_display_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Credit Limit:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.credit_limit_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Billing Terms:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.billing_terms_combo, row, 1)
        grid_layout.addWidget(
            self.is_active_checkbox, row, 3, Qt.AlignmentFlag.AlignLeft
        )

        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 120)
        grid_layout.setColumnMinimumWidth(2, 120)

        form_style = self._get_form_input_style()
        all_fields = [
            self.account_number_input,
            self.farm_name_input,
            self.first_name_input,
            self.last_name_input,
            self.address_line1_input,
            self.address_line2_input,
            self.city_input,
            self.state_combo,
            self.zip_code_input,
            self.country_code_input,
            self.phone_input,
            self.mobile_phone_input,
            self.email_input,
            self.balance_display_input,
            self.credit_limit_input,
            self.billing_terms_combo,
        ]
        for field in all_fields:
            if field:
                field.setStyleSheet(form_style)

        # Special read-only style for balance and country code (as it's auto-populated)
        read_only_style_addon = f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        if self.balance_display_input:
            self.balance_display_input.setStyleSheet(form_style + read_only_style_addon)
        if self.country_code_input:
            self.country_code_input.setStyleSheet(form_style + read_only_style_addon)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_button_specific_style = (
                    f"background-color: {DARK_SUCCESS_ACTION}; color: white;"
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ {ok_button_specific_style} }}"
                )
        overall_layout.addWidget(self.button_box)

        self.state_combo.currentIndexChanged.connect(self._on_state_changed)

    def _load_reference_data_into_combos(self):
        # Load States
        if not self.state_combo:
            self.logger.error("State combo not initialized.")
            return
        self.state_combo.addItem("", None)
        try:
            ref_data = self.owner_controller.get_owner_form_reference_data()
            states = ref_data.get("states", [])
            for state_data in states:
                display_name = f"{state_data['name']} ({state_data['id']})"
                country_code = state_data.get(
                    "country_code", "USA"
                )  # Default to USA if not present
                if country_code.upper() != "USA":
                    display_name += f" - {country_code}"
                self.state_combo.addItem(
                    display_name,
                    {"state_code": state_data["id"], "country_code": country_code},
                )
            self.logger.info(f"Loaded {len(states)} states into combobox.")
        except Exception as e:
            self.logger.error(
                f"Error loading states from controller: {e}", exc_info=True
            )
            QMessageBox.warning(
                self, "Data Load Error", "Could not load states for selection."
            )

        # Load Billing Terms
        if not self.billing_terms_combo:
            self.logger.error("Billing terms combo not initialized.")
            return
        self.billing_terms_combo.addItem("", "")
        self.billing_terms_combo.addItems(PREDEFINED_BILLING_TERMS)
        self.billing_terms_combo.setCurrentIndex(0)
        self.logger.info(f"Loaded {len(PREDEFINED_BILLING_TERMS)} billing terms.")

    def _on_state_changed(self, index: int):
        if not self.state_combo or not self.country_code_input:
            return
        selected_data = self.state_combo.itemData(index)
        if selected_data and isinstance(selected_data, dict):
            country_code = selected_data.get("country_code", "")
            self.country_code_input.setText(country_code)
        else:
            self.country_code_input.clear()

    def _populate_fields(self):
        if self.owner:
            self.account_number_input.setText(self.owner.account_number or "")
            if self.is_edit_mode:
                self.account_number_input.setReadOnly(True)
                self.account_number_input.setStyleSheet(
                    self._get_form_input_style()
                    + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
                )

            self.farm_name_input.setText(self.owner.farm_name or "")
            self.first_name_input.setText(self.owner.first_name or "")
            self.last_name_input.setText(self.owner.last_name or "")
            self.address_line1_input.setText(self.owner.address_line1 or "")
            self.address_line2_input.setText(self.owner.address_line2 or "")
            self.city_input.setText(self.owner.city or "")

            current_state_code = self.owner.state_code
            if current_state_code:
                for i in range(self.state_combo.count()):
                    item_data = self.state_combo.itemData(i)
                    if (
                        item_data
                        and isinstance(item_data, dict)
                        and item_data.get("state_code") == current_state_code
                    ):
                        self.state_combo.setCurrentIndex(i)
                        # _on_state_changed will be triggered, setting country_code_input
                        break
            else:
                self.state_combo.setCurrentIndex(0)
                self.country_code_input.clear()  # Clear country if no state

            self.zip_code_input.setText(self.owner.zip_code or "")
            # self.country_code_input will be set by _on_state_changed or if state_code is initially None

            self.phone_input.setText(self.owner.phone or "")
            self.mobile_phone_input.setText(self.owner.mobile_phone or "")
            self.email_input.setText(self.owner.email or "")

            self.balance_display_input.setText(
                f"{self.owner.balance:.2f}"
                if self.owner.balance is not None
                else "0.00"
            )
            self.credit_limit_input.setValue(
                float(self.owner.credit_limit)
                if self.owner.credit_limit is not None
                else 0.00
            )

            if self.owner.billing_terms:
                index = self.billing_terms_combo.findText(
                    self.owner.billing_terms, Qt.MatchFlag.MatchExactly
                )
                if index >= 0:
                    self.billing_terms_combo.setCurrentIndex(index)
                else:
                    self.billing_terms_combo.addItem(self.owner.billing_terms)
                    self.billing_terms_combo.setCurrentText(self.owner.billing_terms)
            else:
                if self.billing_terms_combo.count() > 0:
                    self.billing_terms_combo.setCurrentIndex(0)

            self.is_active_checkbox.setChecked(self.owner.is_active)

    def get_data(self) -> Optional[Dict[str, Any]]:
        selected_state_item_data = self.state_combo.currentData()
        selected_state_code = None
        if selected_state_item_data and isinstance(selected_state_item_data, dict):
            selected_state_code = selected_state_item_data.get("state_code")

        credit_limit_val = self.credit_limit_input.value()
        credit_limit_decimal: Optional[Decimal] = None
        try:
            credit_limit_decimal = Decimal(str(credit_limit_val))
        except InvalidOperation:
            self.logger.warning(
                f"Invalid decimal value for credit limit: {credit_limit_val}, treating as None."
            )

        data = {
            "account_number": self.account_number_input.text().strip() or None,
            "farm_name": self.farm_name_input.text().strip() or None,
            "first_name": self.first_name_input.text().strip() or None,
            "last_name": self.last_name_input.text().strip() or None,
            "address_line1": self.address_line1_input.text().strip() or None,
            "address_line2": self.address_line2_input.text().strip() or None,
            "city": self.city_input.text().strip() or None,
            "state_code": selected_state_code,
            "zip_code": self.zip_code_input.text().strip() or None,
            "phone": self.phone_input.text().strip() or None,
            "mobile_phone": self.mobile_phone_input.text().strip() or None,
            "email": self.email_input.text().strip() or None,
            "credit_limit": credit_limit_decimal,
            "billing_terms": (
                self.billing_terms_combo.currentText()
                if self.billing_terms_combo.currentIndex() > 0
                else None
            ),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        return data

    def validate_and_accept(self):
        owner_data = self.get_data()
        if owner_data is None:
            return

        is_valid, errors = self.owner_controller.validate_owner_data(
            owner_data, is_new=(not self.is_edit_mode)
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.owner:
                success, message = self.owner_controller.update_master_owner(
                    self.owner.owner_id, owner_data, self.current_user_id
                )
            else:
                success, message, _ = self.owner_controller.create_master_owner(  # type: ignore
                    owner_data, self.current_user_id
                )
            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during owner save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views\admin\dialogs\add_edit_user_dialog.py ===============

# views/admin/dialogs/add_edit_user_dialog.py
"""
EDSI Veterinary Management System - Add/Edit User Dialog
Version: 1.0.5
Purpose: Dialog for creating new users and editing existing user details.
         - Added current_user_id parameter to __init__ for auditing.
Last Updated: June 3, 2025
Author: Gemini (Modified by User's AI Assistant)

Changelog:
- v1.0.5 (2025-06-03):
    - Added `current_user_id: Optional[str] = None` to the `__init__`
      method signature to correctly accept the auditing user ID passed
      from UserManagementScreen. Stored as `self.audit_user_id`.
- v1.0.4 (2025-05-29):
    - Corrected attribute access in _populate_fields method:
        - Changed self.current_user_object.username to self.current_user_object.user_id.
        - Changed self.current_user_object.full_name to self.current_user_object.user_name.
- v1.0.3 (2025-05-29):
    - Modified USER_ROLES list to ["ADMIN", "VETERINARIAN"].
- v1.0.2 (2025-05-29):
    - Refactored _get_dialog_button_style() to use a triple-quoted f-string.
- v1.0.1 (2025-05-27):
    - Modified get_user_data() to return 'user_id' and 'user_name'.
    - Changed 'vet' to 'VETERINARIAN' in USER_ROLES.
- v1.0.0 (2025-05-20):
    - Initial implementation.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QComboBox,
    QCheckBox,
    QDialogButtonBox,
    QLabel,
    QMessageBox,
)
from PySide6.QtGui import QPalette, QColor, QFont  # Added QFont
from PySide6.QtCore import Qt

from controllers.user_controller import UserController
from models.user_models import User
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_BORDER,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_SUCCESS_ACTION,
    DARK_HEADER_FOOTER,
    DEFAULT_FONT_FAMILY,  # Added
)


class AddEditUserDialog(QDialog):
    """Dialog for adding or editing user information."""

    USER_ROLES = [
        "ADMIN",
        "VETERINARIAN",
        "MANAGER",
        "TECHNICIAN",
        "RECEPTIONIST",
    ]  # Restored full list for now

    def __init__(
        self,
        parent_view,
        user_controller: UserController,
        current_user_object: Optional[User] = None,
        current_user_id: Optional[
            str
        ] = None,  # MODIFIED: Added current_user_id for auditing
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.user_controller = user_controller
        self.current_user_object = current_user_object
        self.audit_user_id = current_user_id  # MODIFIED: Store the audit user ID

        self.is_edit_mode = self.current_user_object is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} User")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.current_user_object:
            self._populate_fields()

        self.logger.info(
            f"AddEditUserDialog initialized. Edit mode: {self.is_edit_mode}, Audit User: {self.audit_user_id}"
        )

    def _setup_palette(self):
        # ... (method remains unchanged from v1.0.4) ...
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(
            QPalette.ColorRole.AlternateBase, QColor(DARK_WIDGET_BACKGROUND)
        )  # Was DARK_ITEM_HOVER, check consistency
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(
            QPalette.ColorRole.Highlight, QColor(DARK_PRIMARY_ACTION)
        )  # Or DARK_HIGHLIGHT_BG
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_TEXT_PRIMARY)
        )  # Or DARK_HIGHLIGHT_TEXT
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _get_input_field_style(self) -> str:
        # ... (method remains unchanged from v1.0.4) ...
        return f"""
            QLineEdit, QComboBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {QColor(DARK_PRIMARY_ACTION).darker(130).name()}; /* Adjusted for better visibility */
            }}
            QCheckBox {{
                color: {DARK_TEXT_PRIMARY};
                background-color: transparent;
            }}
            QCheckBox::indicator {{
                width: 13px;
                height: 13px;
            }}
        """

    def _get_dialog_button_style(self) -> str:
        # ... (method remains unchanged from v1.0.4) ...
        return f"""
            QPushButton {{
                background-color: {DARK_BUTTON_BG};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px;
                font-size: 12px; font-weight: 500; min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: {DARK_BUTTON_HOVER};
            }}
            QPushButton:disabled {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
            }}
        """

    def _setup_ui(self):
        # ... (method remains unchanged from v1.0.4) ...
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        form_layout = QFormLayout()
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setFieldGrowthPolicy(
            QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow
        )

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter unique username (Login ID)")
        self.full_name_input = QLineEdit()
        self.full_name_input.setPlaceholderText("Enter user's full name (Display Name)")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Enter user's email address")
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText(
            "Enter password (leave blank to keep current)"
        )
        self.confirm_password_input = QLineEdit()
        self.confirm_password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.confirm_password_input.setPlaceholderText("Confirm new password")
        self.role_combo = QComboBox()
        self.role_combo.addItems(self.USER_ROLES)
        self.is_active_checkbox = QCheckBox("User is Active")
        self.is_active_checkbox.setChecked(True)

        input_style = self._get_input_field_style()
        for field in [
            self.username_input,
            self.full_name_input,
            self.email_input,
            self.password_input,
            self.confirm_password_input,
            self.role_combo,
            self.is_active_checkbox,
        ]:
            if field:
                field.setStyleSheet(input_style)

        form_layout.addRow(QLabel("Login ID*:"), self.username_input)
        form_layout.addRow(QLabel("Full Name*:"), self.full_name_input)
        form_layout.addRow(QLabel("Email:"), self.email_input)
        form_layout.addRow(
            QLabel("Password:" if self.is_edit_mode else "Password*:"),
            self.password_input,
        )
        form_layout.addRow(QLabel("Confirm Password:"), self.confirm_password_input)
        form_layout.addRow(QLabel("Role*:"), self.role_combo)
        form_layout.addRow(QLabel("Status:"), self.is_active_checkbox)

        for i in range(form_layout.rowCount()):
            label_widget = form_layout.labelForField(
                form_layout.itemAt(i, QFormLayout.ItemRole.FieldRole).widget()
            )
            if label_widget:
                label_widget.setStyleSheet(
                    f"color: {DARK_TEXT_SECONDARY}; background: transparent; padding-top: 3px; font-family: {DEFAULT_FONT_FAMILY};"
                )
                # label_widget.setFont(QFont(DEFAULT_FONT_FAMILY)) # Ensure font consistency

        layout.addLayout(form_layout)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Save User" if self.is_edit_mode else "Add User")
        dialog_button_style = self._get_dialog_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(dialog_button_style)
        ok_button.setStyleSheet(
            dialog_button_style
            + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
        )
        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        # ... (method remains unchanged from v1.0.4) ...
        if self.current_user_object:
            self.username_input.setText(self.current_user_object.user_id)
            self.username_input.setReadOnly(True)
            self.username_input.setStyleSheet(
                self._get_input_field_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; }}"
            )
            self.full_name_input.setText(self.current_user_object.user_name or "")
            self.email_input.setText(self.current_user_object.email or "")
            user_role_name_to_select = ""
            if self.current_user_object.roles:
                for role_obj in self.current_user_object.roles:
                    if role_obj.name in self.USER_ROLES:
                        user_role_name_to_select = role_obj.name
                        break
                if not user_role_name_to_select:
                    self.logger.warning(
                        f"User {self.current_user_object.user_id} has roles, but none match current dialog options: {[r.name for r in self.current_user_object.roles]}. Defaulting selection."
                    )
            role_index = -1
            if user_role_name_to_select:
                role_index = self.role_combo.findText(
                    user_role_name_to_select, Qt.MatchFlag.MatchExactly
                )
            if role_index >= 0:
                self.role_combo.setCurrentIndex(role_index)
            else:
                self.logger.warning(
                    f"Role '{user_role_name_to_select}' for user '{self.current_user_object.user_id}' not found in USER_ROLES dropdown. Defaulting."
                )
                if self.role_combo.count() > 0:
                    self.role_combo.setCurrentIndex(0)
                else:
                    self.logger.error(
                        "USER_ROLES is empty, cannot set default role index."
                    )
            self.is_active_checkbox.setChecked(self.current_user_object.is_active)

    def _validate_input(self) -> bool:
        # ... (method remains unchanged from v1.0.4) ...
        login_id = self.username_input.text().strip()
        user_name_val = self.full_name_input.text().strip()
        password = self.password_input.text()
        confirm_password = self.confirm_password_input.text()
        if not login_id:
            QMessageBox.warning(self, "Validation Error", "Login ID cannot be empty.")
            self.username_input.setFocus()
            return False
        if not user_name_val:
            QMessageBox.warning(self, "Validation Error", "Full Name cannot be empty.")
            self.full_name_input.setFocus()
            return False
        if not self.is_edit_mode and not password:
            QMessageBox.warning(
                self, "Validation Error", "Password cannot be empty for new users."
            )
            self.password_input.setFocus()
            return False
        if password and password != confirm_password:
            QMessageBox.warning(self, "Validation Error", "Passwords do not match.")
            self.confirm_password_input.setFocus()
            return False
        email = self.email_input.text().strip()
        if email and ("@" not in email or "." not in email.split("@")[-1]):
            QMessageBox.warning(
                self, "Validation Error", "Please enter a valid email address."
            )
            self.email_input.setFocus()
            return False
        if self.role_combo.currentIndex() == -1 and self.USER_ROLES:
            QMessageBox.warning(self, "Validation Error", "A role must be selected.")
            self.role_combo.setFocus()
            return False
        return True

    def get_user_data(self) -> Optional[Dict]:
        # ... (method remains unchanged from v1.0.4) ...
        if not self._validate_input():
            return None
        data = {
            "user_id": self.username_input.text().strip(),
            "user_name": self.full_name_input.text().strip(),
            "email": self.email_input.text().strip() or None,
            "role": self.role_combo.currentText(),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        password = self.password_input.text()
        if password:
            data["password"] = password
        return data

    def _on_accept(self):
        user_data = self.get_user_data()
        if user_data is None:
            return

        try:
            # Use self.audit_user_id for who is performing the action
            performing_user_id = self.audit_user_id

            if self.is_edit_mode and self.current_user_object:
                self.logger.info(
                    f"Attempting to update user ID: {self.current_user_object.user_id} by {performing_user_id}"
                )
                success, message = self.user_controller.update_user(
                    self.current_user_object.user_id, user_data, performing_user_id
                )
            else:
                self.logger.info(
                    f"Attempting to create new user: {user_data['user_id']} by {performing_user_id}"
                )
                success, message, _ = self.user_controller.create_user(
                    user_data, performing_user_id
                )

            if success:
                self.logger.info(f"User operation successful: {message}")
                self.accept()
            else:
                self.logger.warning(f"User operation failed: {message}")
                QMessageBox.critical(self, "Operation Failed", message)
        except Exception as e:
            self.logger.error(f"Error during user save/update: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")


=============== FILE: views\auth\login_screen.py ===============

# views/auth/login_screen.py

"""
EDSI Veterinary Management System - Login Screen
Version: 1.1.2
Purpose: Handles user authentication (username and password).
Last Updated: May 12, 2025
Author: Claude Assistant

Changelog:
- v1.1.2 (2025-05-12): Debug password validation and fix styling.
  - Added detailed logging in `validate_credentials` to compare input hash vs stored hash.
  - Removed unsupported 'box-shadow' property from input field focus style.
- v1.1.1 (2025-05-12): Fixed TypeError on layout initialization.
  - Changed layout creation in setup_ui from `QVBoxLayout(parent)`
    to `QVBoxLayout()` followed by `parent.setLayout()`.
- v1.1.0 (2025-05-12): Refactored for Username/Password and PySide6
- v1.0.0 (2025-05-12): Initial implementation (PyQt6, User ID only)
"""

import logging
import hashlib
from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QFrame,
    QSpacerItem,
    QSizePolicy,
    QWidget,
    QMessageBox,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import (
    QFont,
    QPalette,
    QColor,
    QScreen,
)  # Added imports for styling if needed

from views.base_view import BaseView
from config.app_config import AppConfig
from config.database_config import db_manager
from models import User


class LoginScreen(BaseView):
    """User login screen for authentication with username and password."""

    login_successful = Signal(str)
    exit_requested = Signal()

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(self.__class__.__name__)
        # Apply specific palette/styling for this screen if needed,
        # otherwise it inherits from BaseView
        self.apply_login_screen_styling()

    def apply_login_screen_styling(self):
        """Apply styles specific to the Login Screen, potentially overriding BaseView."""
        # Example: Set a specific background if different from BaseView
        # palette = self.palette()
        # palette.setColor(QPalette.ColorRole.Window, QColor("#e9ecef")) # Light grey example
        # self.setPalette(palette)
        # self.setAutoFillBackground(True)
        pass  # No specific overrides for now, using BaseView style

    def setup_ui(self):
        """Setup the login screen UI elements."""
        self.set_title("Login")
        self.setMinimumSize(450, 400)
        self.center_on_screen()

        # Main login layout for the central widget
        login_layout = QVBoxLayout()
        self.central_widget.setLayout(login_layout)  # Correct way to set layout

        login_layout.setContentsMargins(30, 30, 30, 30)
        login_layout.setSpacing(20)
        login_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Login form frame
        form_frame = QFrame()
        form_frame.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        # Use object name for more specific styling if needed later
        form_frame.setObjectName("LoginFormFrame")
        form_frame.setStyleSheet(
            f"""
            #LoginFormFrame {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                border: 1px solid #dee2e6;
                border-radius: 8px;
                padding: 30px;
                max-width: 400px;
            }}
            """
        )

        form_layout = QVBoxLayout(form_frame)  # Layout for the frame's content
        form_layout.setSpacing(15)
        form_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Title
        title_label = QLabel(AppConfig.APP_NAME)
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 20, QFont.Weight.Bold)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            f"color: {AppConfig.PRIMARY_COLOR}; margin-bottom: 5px; background: transparent;"
        )
        form_layout.addWidget(title_label)

        # Version Label
        version_label = QLabel(f"Version {AppConfig.APP_VERSION}")
        version_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 10)
        version_label.setFont(version_font)
        version_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        version_label.setStyleSheet(
            f"color: {AppConfig.TEXT_SECONDARY}; margin-bottom: 20px; background: transparent;"
        )
        form_layout.addWidget(version_label)

        # Username label and input
        username_label = QLabel("Username:")
        username_label.setStyleSheet(self.get_label_style())
        form_layout.addWidget(username_label)

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter your username")
        self.username_input.setFixedHeight(40)
        self.username_input.setStyleSheet(self.get_input_style())  # Apply input style
        self.username_input.returnPressed.connect(self.handle_login)
        form_layout.addWidget(self.username_input)

        # Password label and input
        password_label = QLabel("Password:")
        password_label.setStyleSheet(self.get_label_style())
        form_layout.addWidget(password_label)

        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText("Enter your password")
        self.password_input.setFixedHeight(40)
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setStyleSheet(self.get_input_style())  # Apply input style
        self.password_input.returnPressed.connect(self.handle_login)
        form_layout.addWidget(self.password_input)

        # Spacer
        spacer = QSpacerItem(
            20, 20, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )
        form_layout.addItem(spacer)

        # Button layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)

        self.login_button = QPushButton("Login")
        self.login_button.clicked.connect(self.handle_login)
        self.login_button.setMinimumHeight(40)
        self.login_button.setStyleSheet(self.get_button_style(AppConfig.PRIMARY_COLOR))

        self.exit_button = QPushButton("Exit")
        self.exit_button.clicked.connect(self.handle_exit)
        self.exit_button.setMinimumHeight(40)
        self.exit_button.setStyleSheet(self.get_button_style(AppConfig.SECONDARY_COLOR))

        button_layout.addWidget(self.login_button)
        button_layout.addWidget(self.exit_button)
        form_layout.addLayout(button_layout)

        # Add the form frame to the main layout
        login_layout.addWidget(form_frame)

        # Set focus
        self.username_input.setFocus()

        # Set modality
        self.setWindowModality(Qt.WindowModality.ApplicationModal)

    def get_label_style(self):
        """Returns the standard style for labels."""
        # Ensure background is transparent to inherit window background
        return f"""
            QLabel {{
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                font-weight: bold;
                color: {AppConfig.TEXT_COLOR};
                margin-bottom: 2px;
                background-color: transparent;
            }}
        """

    def get_input_style(self):
        """Returns the standard style for input fields, removing box-shadow."""
        # Inherits from BaseView stylesheet, but we define focus explicitly here
        # to ensure box-shadow is removed from this specific context too.
        return f"""
            QLineEdit {{
                border: 1px solid #ced4da;
                border-radius: 4px;
                padding: 8px 12px;
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                background-color: white;
                color: {AppConfig.TEXT_COLOR}; /* Ensure text color is set */
            }}
            QLineEdit:focus {{
                border-color: {AppConfig.PRIMARY_COLOR};
                /* Removed unsupported box-shadow */
            }}
        """

    def get_button_style(self, background_color, hover_color=None):
        """Returns the standard style for buttons."""
        # Calculate hover color if not provided
        if hover_color is None:
            try:
                r = int(background_color[1:3], 16)
                g = int(background_color[3:5], 16)
                b = int(background_color[5:7], 16)
                hover_color = f"#{max(0, r-20):02x}{max(0, g-20):02x}{max(0, b-20):02x}"
            except:
                hover_color = background_color

        return f"""
            QPushButton {{
                background-color: {background_color};
                color: white;
                border: none;
                padding: 10px 16px;
                border-radius: 4px;
                font-family: "{AppConfig.DEFAULT_FONT_FAMILY}";
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: {hover_color};
            }}
            QPushButton:pressed {{
                background-color: {background_color};
            }}
            QPushButton:disabled {{
                background-color: #adb5bd;
                color: #f8f9fa;
            }}
        """

    def handle_login(self):
        """Handle login attempt using username and password."""
        username = self.username_input.text().strip()
        password = self.password_input.text()

        if not username:
            self.show_warning("Login Failed", "Please enter a username.")
            self.username_input.setFocus()
            return
        if not password:
            self.show_warning("Login Failed", "Please enter a password.")
            self.password_input.setFocus()
            return

        is_valid, user_id = self.validate_credentials(username, password)

        if is_valid:
            self.logger.info(f"User '{user_id}' logged in successfully")
            self.login_successful.emit(user_id)
            self.close()
        else:
            self.show_error("Login Failed", "Invalid username or password.")
            self.password_input.clear()
            self.username_input.setFocus()
            self.username_input.selectAll()

    def validate_credentials(self, username, password):
        """Validate username and password against the database."""
        session = None
        target_user_id = username.upper()  # Standardize username for query
        self.logger.debug(f"Attempting validation for user: {target_user_id}")
        try:
            session = db_manager.get_session()
            user = session.query(User).filter(User.user_id == target_user_id).first()

            if user:
                self.logger.debug(
                    f"User found in DB: ID={user.user_id}, Active={user.is_active}"
                )
                if user.is_active:
                    # Hash the entered password using SHA-256
                    entered_password_hash = hashlib.sha256(
                        password.encode("utf-8")
                    ).hexdigest()

                    # --- DEBUG LOGGING START ---
                    self.logger.debug(f"Comparing Hashes for user '{user.user_id}':")
                    self.logger.debug(f"  Entered Hash: {entered_password_hash}")
                    self.logger.debug(f"  Stored Hash : {user.password_hash}")
                    # --- DEBUG LOGGING END ---

                    # Compare the hash with the stored hash
                    if entered_password_hash == user.password_hash:
                        self.logger.info(
                            f"Password validation successful for user '{user.user_id}'."
                        )
                        return True, user.user_id
                    else:
                        self.logger.warning(
                            f"Password hash mismatch for user '{user.user_id}'."
                        )
                        return False, None
                else:
                    self.logger.warning(f"User '{user.user_id}' is inactive.")
                    return False, None
            else:
                self.logger.warning(f"User '{target_user_id}' not found in database.")
                return False, None

        except Exception as e:
            self.logger.error(
                f"Error during credential validation for '{target_user_id}': {e}",
                exc_info=True,
            )
            self.show_error(
                "Login Error", "An error occurred during login. Please check logs."
            )
            return False, None
        finally:
            if session:
                db_manager.close_session()

    def handle_exit(self):
        """Handle exit button click."""
        self.logger.info("Exit requested from login screen.")
        self.exit_requested.emit()
        self.close()

    def keyPressEvent(self, event):
        """Handle key press events (e.g., ESC to exit)."""
        if event.key() == Qt.Key.Key_Escape:
            self.handle_exit()
        else:
            super().keyPressEvent(event)

    # --- Message Box Helpers (Inherited from BaseView) ---
    # No need to override if BaseView uses PySide6 QMessageBox correctly.
    # def show_error(self, title, message): ...
    # def show_warning(self, title, message): ...
    # def show_info(self, title, message): ...


=============== FILE: views\auth\small_login_dialog.py ===============

# views/auth/small_login_dialog.py

"""
EDSI Veterinary Management System - Simplified Login Dialog
Version: 2.0.4
Purpose: Clean, simple login dialog using UserController for authentication.
         Ensures consistent authentication mechanism (bcrypt) across the application.
Last Updated: May 29, 2025
Author: Claude Assistant (Refactored by Gemini)

Changelog:
- v2.0.4 (2025-05-29):
    - Refactored to use UserController.authenticate_user() for login attempts.
    - Removed internal _authenticate_user and _verify_password methods.
    - Removed hashlib import and direct database session usage for authentication.
    - Login ID is now passed to UserController without uppercasing;
      controller handles case-insensitive lookup.
    - User feedback messages now sourced from UserController.
- v2.0.3 (2025-05-24):
    - Fixed RuntimeError: Internal C++ object already deleted
    - Added early return on successful login to prevent widget access after dialog closure
    - Added proper error handling for widget cleanup
- v2.0.2 (2025-05-24):
    - Updated database session handling for login attempts
    - Added last login timestamp update on successful authentication
- v2.0.1 (2025-05-24):
    - Fixed authentication to work with simplified database structure
    - Improved error handling and user feedback
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Removed UserController dependency and complex validation
    - Simplified to direct database authentication
    - Clean signal handling without over-engineering
    - Proper error handling and user feedback
    - Consistent dark theme styling
    - Focused on working login flow
    - Removed circular import issues
    - Clear separation of concerns
"""

import logging

# REMOVED: import hashlib - No longer used
from typing import Optional

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QMessageBox,
    QDialogButtonBox,
    QHBoxLayout,  # Retained, though not explicitly used in this version's example layout
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QPalette, QColor

from config.app_config import AppConfig

# REMOVED: from config.database_config import get_db_session - Controller handles session
# REMOVED: from models.user_models import User - Controller returns user info
from controllers.user_controller import UserController  # ADDED


class SmallLoginDialog(QDialog):
    """
    Simple login dialog for user authentication.
    Displays over the splash screen and handles user login.
    """

    # Signals
    login_successful = Signal(str)  # Emits user_id on successful login
    dialog_closed = Signal()  # Emits when dialog is closed

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.user_controller = UserController()  # ADDED UserController instance

        self.setWindowTitle("EDSI Login")
        self.setModal(True)
        self.setFixedSize(380, 250)

        self._setup_ui()
        self._apply_theme()

    def _setup_ui(self):
        """Setup the login dialog UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        title_label = QLabel("User Login")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            """
            QLabel {
                font-size: 16px;
                font-weight: bold;
                padding: 10px;
            }
        """
        )
        layout.addWidget(title_label)

        self.user_id_input = QLineEdit()
        self.user_id_input.setPlaceholderText("Login ID")
        self.user_id_input.setMaxLength(20)
        layout.addWidget(self.user_id_input)

        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText("Password")
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setMaxLength(255)  # Max length for input field
        layout.addWidget(self.password_input)

        self.password_input.returnPressed.connect(self._attempt_login)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )

        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Login")

        self.button_box.accepted.connect(self._attempt_login)
        self.button_box.rejected.connect(self.reject)

        layout.addWidget(self.button_box)
        self.user_id_input.setFocus()

    def _apply_theme(self):
        """Apply dark theme to the dialog"""
        palette = QPalette()
        palette.setColor(
            QPalette.ColorRole.Window, QColor(AppConfig.DARK_WIDGET_BACKGROUND)
        )
        palette.setColor(
            QPalette.ColorRole.WindowText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        palette.setColor(
            QPalette.ColorRole.Base, QColor(AppConfig.DARK_INPUT_FIELD_BACKGROUND)
        )
        palette.setColor(QPalette.ColorRole.Text, QColor(AppConfig.DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(AppConfig.DARK_BUTTON_BG))
        palette.setColor(
            QPalette.ColorRole.ButtonText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        palette.setColor(
            QPalette.ColorRole.PlaceholderText, QColor(AppConfig.DARK_TEXT_TERTIARY)
        )
        self.setPalette(palette)

        self.setStyleSheet(
            f"""
            QDialog {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QLineEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px;
                font-size: 14px;
            }}
            QLineEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 15px;
                font-size: 13px;
                min-width: 80px;
            }}
            QPushButton:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
            }}
            QPushButton:pressed {{
                background-color: {AppConfig.DARK_ITEM_HOVER};
            }}
            QPushButton[text="Login"] {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
            QPushButton[text="Login"]:hover {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION}dd; /* Assuming alpha modification if supported */
            }}
        """
        )

    def _attempt_login(self):
        """Attempt to authenticate the user using UserController"""
        login_id = self.user_id_input.text().strip()  # REMOVED .upper()
        password = self.password_input.text()

        if not login_id:
            self._show_error("Login ID is required.")
            self.user_id_input.setFocus()
            return

        if not password:
            self._show_error("Password is required.")
            self.password_input.setFocus()
            return

        # Authenticate user via UserController
        try:
            # UserController.authenticate_user returns -> Tuple[bool, str, Optional[Dict[str, Any]]]
            success, message, user_info = self.user_controller.authenticate_user(
                login_id, password
            )

            if success and user_info:
                actual_user_id = user_info.get(
                    "user_id", login_id
                )  # Use actual user_id from DB
                self.logger.info(f"User '{actual_user_id}' logged in successfully")
                # UserController's authenticate_user now handles updating last_login and committing
                self.login_successful.emit(actual_user_id)
                # self.accept() # No need to call accept() here, login_successful signal triggers closure in main.py
                return  # Exit immediately on success

            else:
                # Display the message from UserController (e.g., "Invalid login ID or password", "User inactive")
                self._show_error(
                    message or "Login failed. Please check your credentials."
                )
                self.logger.warning(
                    f"Failed login attempt for user input: {login_id}. Reason: {message}"
                )

        except Exception as e:  # Catch any unexpected errors from controller call
            self.logger.error(
                f"Login error during controller interaction: {e}", exc_info=True
            )
            self._show_error(
                "An unexpected error occurred during login. Please try again."
            )

        # Only clear password on failed login (we return early on success)
        try:
            self.password_input.clear()
            self.password_input.setFocus()
        except RuntimeError:
            self.logger.debug(
                "Password input widget might be deleted, skipping clear/focus."
            )

    # REMOVED: _authenticate_user(self, login_id: str, password: str) -> Optional[User]:
    # REMOVED: _verify_password(self, plain_password: str, password_hash: str) -> bool:

    def _show_error(self, message: str):
        """Show error message to user"""
        # Ensure widget exists before showing message box, in case dialog is closing.
        if self.isVisible():
            QMessageBox.critical(self, "Login Failed", message)
        else:
            self.logger.warning(
                f"Login dialog not visible, error not shown to user: {message}"
            )

    def reject(self):
        """Handle dialog rejection (Cancel button or Esc key)"""
        self.logger.debug("Login dialog cancelled by user")
        self.dialog_closed.emit()
        super().reject()

    # accept() is implicitly handled by login_successful signal flow in main.py;
    # direct call to self.accept() after emitting login_successful is removed
    # to let main.py manage the dialog closure after successful signal processing.
    # If accept() is needed for other QDialogButtonBox scenarios, it could be:
    # def accept(self):
    #     # This might be called if _attempt_login directly calls self.accept()
    #     # For now, _attempt_login calls return on success.
    #     self.logger.debug("Login dialog accepted (e.g. if OK directly called accept)")
    #     super().accept()

    def closeEvent(self, event):
        """Handle dialog close event (e.g., window 'X' button)"""
        # Check if login was successful; if so, accept() might have already been called
        # or login_successful emitted. If not, it's like a reject.
        self.logger.debug("Login dialog closed via closeEvent (e.g., X button)")
        self.dialog_closed.emit()  # Ensure dialog_closed is emitted
        super().closeEvent(event)


=============== FILE: views\auth\splash_screen.py ===============

# views/auth/splash_screen.py

"""
EDSI Veterinary Management System - Image-Based Splash Screen with Interactive Areas
Version: 1.3.2
Purpose: Displays an image-based splash screen with clickable login/exit areas.
         Corrected signal names to match usage in main.py.
         Updated AppConfig usage for asset path.
Last Updated: May 24, 2025
Author: Claude Assistant (Correcting user's v1.3.0, further modified by Gemini)

Changelog:
- v1.3.2 (2025-05-24):
    - Changed image_path construction in setup_splash_ui to use AppConfig.ASSETS_DIR
      resolving AttributeError for AppConfig.get_app_dir().
- v1.3.1 (2025-05-18):
    - Renamed signal `login_area_clicked` to `login_requested`.
    - Renamed signal `exit_area_clicked` to `exit_requested`.
- v1.3.0 (2025-05-16): (User's Base Version)
    - Implemented interactive image splash screen.
    - Loads splash_screen.jpg from assets.
    - Overlays transparent QPushButtons for "Login" and "Exit" areas based on coordinates.
    - Emits `login_area_clicked` or `exit_area_clicked` signals.
    - Removed old timer and generic key/mouse press handlers.
- v1.2.0 (2025-05-15): Attempted image display (placeholder).
- v1.1.0 (2025-05-12): Original text-based splash screen.
"""

import os
import logging
from typing import Optional

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton, QApplication
from PySide6.QtCore import (
    Qt,
    Signal,
    QSize,
    QRect,
    QTimer,
)
from PySide6.QtGui import QPixmap, QPalette, QColor

from config.app_config import AppConfig


class SplashScreen(QWidget):
    """EDSI splash screen that appears on startup, image-based with interactive areas."""

    login_requested = Signal()
    exit_requested = Signal()

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setWindowFlags(
            Qt.WindowType.SplashScreen
            | Qt.WindowType.FramelessWindowHint
            | Qt.WindowType.WindowStaysOnTopHint
        )

        self.pixmap: Optional[QPixmap] = None
        self.image_label: Optional[QLabel] = None
        self.login_button_overlay: Optional[QPushButton] = None
        self.exit_button_overlay: Optional[QPushButton] = None

        self.setup_splash_ui()

    def setup_splash_ui(self):
        try:
            # MODIFIED: Use AppConfig.ASSETS_DIR directly
            image_path = os.path.join(AppConfig.ASSETS_DIR, "splash_screen.jpg")
            self.logger.info(f"Attempting to load splash image from: {image_path}")

            if not os.path.exists(image_path):
                self.logger.error(
                    f"Splash screen image not found at {image_path}. Using fallback."
                )
                self._setup_fallback_ui()
                return

            self.pixmap = QPixmap(image_path)

            if self.pixmap.isNull():
                self.logger.error(
                    f"CRITICAL: Could not load splash image from {image_path}. Using fallback."
                )
                self._setup_fallback_ui()
                return

            self.setFixedSize(self.pixmap.size())
            self.center_on_screen()

            self.image_label = QLabel(self)
            self.image_label.setPixmap(self.pixmap)
            self.image_label.setGeometry(
                0, 0, self.pixmap.width(), self.pixmap.height()
            )
            self.image_label.setScaledContents(True)

            login_coords = QRect(280, 340, 95, 35)
            exit_coords = QRect(380, 340, 95, 35)

            self.login_button_overlay = QPushButton(self.image_label)
            self.login_button_overlay.setGeometry(login_coords)
            self.login_button_overlay.setFlat(True)
            self.login_button_overlay.setStyleSheet(
                "QPushButton { background-color: transparent; border: none; }"
            )
            self.login_button_overlay.setCursor(Qt.CursorShape.PointingHandCursor)
            self.login_button_overlay.clicked.connect(self.login_requested.emit)
            self.login_button_overlay.setToolTip("Login to EDSI System")

            self.exit_button_overlay = QPushButton(self.image_label)
            self.exit_button_overlay.setGeometry(exit_coords)
            self.exit_button_overlay.setFlat(True)
            self.exit_button_overlay.setStyleSheet(
                "QPushButton { background-color: transparent; border: none; }"
            )
            self.exit_button_overlay.setCursor(Qt.CursorShape.PointingHandCursor)
            self.exit_button_overlay.clicked.connect(self.exit_requested.emit)
            self.exit_button_overlay.setToolTip("Exit Application")

            v_layout = QVBoxLayout(self)
            v_layout.addWidget(self.image_label)
            v_layout.setContentsMargins(0, 0, 0, 0)
            self.setLayout(v_layout)

            self.logger.info("Splash screen UI setup complete.")

        except Exception as e:
            self.logger.error(f"Error setting up splash screen UI: {e}", exc_info=True)
            self._setup_fallback_ui()
            QTimer.singleShot(0, self.show)

    def _setup_fallback_ui(self):
        self.logger.info("Setting up fallback UI for splash screen.")
        if self.image_label:
            self.image_label.deleteLater()
            self.image_label = None
        if self.login_button_overlay:
            self.login_button_overlay.deleteLater()
            self.login_button_overlay = None
        if self.exit_button_overlay:
            self.exit_button_overlay.deleteLater()
            self.exit_button_overlay = None

        current_layout = self.layout()
        if current_layout is not None:
            while current_layout.count():
                child = current_layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()

        self.setFixedSize(350, 150)
        fallback_label = QLabel("EDSI Loading...", self)
        fallback_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        fallback_label.setStyleSheet(
            "background-color: #2D3748; color: white; font-size: 18px; padding: 20px; border-radius: 5px;"
        )
        main_layout = QVBoxLayout(self)
        main_layout.addWidget(fallback_label)
        self.setLayout(main_layout)
        self.center_on_screen()

    def center_on_screen(self):
        primary_screen = QApplication.primaryScreen()
        if primary_screen:
            screen_geometry = primary_screen.availableGeometry()
            self.move(screen_geometry.center() - self.rect().center())
        else:
            self.logger.warning(
                "Primary screen not available for centering splash, using default position."
            )
            self.move(100, 100)

    def showEvent(self, event):
        self.logger.debug("Splash screen shown.")
        super().showEvent(event)

    def closeEvent(self, event):
        self.logger.debug("Splash screen closed.")
        super().closeEvent(event)


=============== FILE: views\horse\__init__.py ===============

# views/horse/__init__.py

"""Horse views package"""


=============== FILE: views\horse\horse_unified_management.py ===============

# views/horse/horse_unified_management.py
"""
EDSI Veterinary Management System - Unified Horse Management Screen (Dark Theme)
Version: 1.7.39
Purpose: Unified interface for horse management.
         - Corrected BillingTab instantiation argument.
Last Updated: June 5, 2025
Author: Gemini (Further modified by Coding partner)

Changelog:
- v1.7.39 (2025-06-05):
    - Bug Fix: Corrected the keyword argument from `parent_view` to `parent`
      during the instantiation of `BillingTab` in the `setup_horse_tabs`
      method. This resolves the `TypeError` and allows the Billing tab to load.
- v1.7.38 (2025-06-04):
    - Full rewrite to integrate BillingTab.
    - Added instantiation of FinancialController.
    - BillingTab added to the main QTabWidget.
    - Updated load_horse_details and display_empty_state to call billing_tab.set_current_horse().
"""

import logging
from datetime import (
    datetime,
    date,
)
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QFrame,
    QListWidgetItem,
    QTabWidget,
    QWidget,
    QSplitter,
    QRadioButton,
    QButtonGroup,
    QApplication,
    QMenu,
    QDialog,
    QMessageBox,
    QStatusBar,
)
from PySide6.QtCore import Qt, Signal, QTimer, QDate
from PySide6.QtGui import (
    QFont,
    QPalette,
    QColor,
    QAction,
    QKeyEvent,
    QShowEvent,
    QCloseEvent,
)
from sqlalchemy.orm.exc import DetachedInstanceError

from views.base_view import BaseView
from config.app_config import (
    AppConfig,
    DARK_BACKGROUND,
    DARK_WIDGET_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_BORDER,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_ITEM_HOVER,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_INPUT_FIELD_BACKGROUND,
    DEFAULT_FONT_FAMILY,
    DARK_SUCCESS_ACTION,
    DARK_DANGER_ACTION,
)
from controllers.horse_controller import HorseController
from controllers.owner_controller import OwnerController
from controllers.location_controller import LocationController
from models import (
    Horse,
    Location as LocationModel,
    Owner as OwnerModel,
)

from .tabs.basic_info_tab import BasicInfoTab
from .tabs.owners_tab import OwnersTab
from .tabs.location_tab import LocationTab
from .tabs.billing_tab import BillingTab
from controllers.financial_controller import FinancialController


class HorseUnifiedManagement(BaseView):
    horse_selection_changed = Signal(int)
    exit_requested = Signal()
    setup_requested = Signal()
    closing = Signal()

    def __init__(self, current_user=None):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(
            f"HorseUnifiedManagement __init__ started for user: {current_user}"
        )
        self.current_user = current_user or "ADMIN"
        self.horse_controller = HorseController()
        self.owner_controller = OwnerController()
        self.location_controller = LocationController()
        self.financial_controller = FinancialController()

        self.tab_widget: Optional[QTabWidget] = None
        self.basic_info_tab: Optional[BasicInfoTab] = None
        self.owners_tab: Optional[OwnersTab] = None
        self.location_tab: Optional[LocationTab] = None
        self.billing_tab: Optional[BillingTab] = None

        self.horse_list: Optional[QWidget] = None
        self.empty_frame: Optional[QFrame] = None
        self.horse_details_content_widget: Optional[QWidget] = None
        self.horse_title: Optional[QLabel] = None
        self.horse_info_line: Optional[QLabel] = None
        self.add_horse_btn: Optional[QPushButton] = None
        self.edit_horse_btn: Optional[QPushButton] = None
        self.refresh_btn: Optional[QPushButton] = None
        self.help_btn: Optional[QPushButton] = None
        self.print_btn: Optional[QPushButton] = None
        self.setup_icon_btn: Optional[QPushButton] = None
        self.user_menu_button: Optional[QPushButton] = None
        self.user_menu: Optional[QMenu] = None
        self.active_only_radio: Optional[QRadioButton] = None
        self.all_horses_radio: Optional[QRadioButton] = None
        self.deactivated_radio: Optional[QRadioButton] = None
        self.filter_group: Optional[QButtonGroup] = None
        self.search_input: Optional[QLineEdit] = None
        self.splitter: Optional[QSplitter] = None
        self.list_widget_container: Optional[QWidget] = None
        self.details_widget: Optional[QWidget] = None
        self.details_layout: Optional[QVBoxLayout] = None
        self.status_bar: Optional[QStatusBar] = None
        self.status_label: Optional[QLabel] = None
        self.footer_horse_count_label: Optional[QLabel] = None
        self.shortcut_label: Optional[QLabel] = None

        super().__init__()

        self.horses_list_data: List[Horse] = []
        self.current_horse: Optional[Horse] = None
        self._has_changes_in_active_tab: bool = False
        self._is_new_mode: bool = False

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self.perform_search)

        self.logger.debug("Scheduling load_initial_data with QTimer.singleShot(0).")
        QTimer.singleShot(0, self.load_initial_data)
        self.logger.info(
            "HorseUnifiedManagement screen __init__ finished (initial data load deferred)."
        )

    def setup_ui(self):
        self.logger.info("HorseUnifiedManagement.setup_ui: EXECUTION CONFIRMED.")

        self.set_title("Horse Management")
        self.resize(1200, 800)

        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.setup_header(main_layout)
        self.setup_action_bar(main_layout)
        self.setup_main_content(main_layout)
        self.setup_footer(main_layout)
        self.setup_connections()

        self.logger.info("HorseUnifiedManagement.setup_ui: All components initialized.")

    def showEvent(self, event: QShowEvent):
        self.logger.info("HorseUnifiedManagement showEvent: START")
        super().showEvent(event)

        self.logger.debug(
            "showEvent: Checking core UI elements (empty_frame, horse_details_content_widget)..."
        )
        if (
            not hasattr(self, "empty_frame")
            or not self.empty_frame
            or not hasattr(self, "horse_details_content_widget")
            or not self.horse_details_content_widget
        ):
            self.logger.error(
                "showEvent: Core UI elements for displaying state are NOT ready. UI setup might be incomplete. Aborting showEvent further processing."
            )
            return
        self.logger.debug("showEvent: Core UI elements check PASSED.")

        if self.current_horse:
            self.logger.debug(
                "showEvent: current_horse exists. Calling display_details_state."
            )
            self.display_details_state()
            self.logger.debug("showEvent: display_details_state call completed.")
            if (
                self.basic_info_tab
                and not self._is_new_mode
                and hasattr(self.basic_info_tab, "_is_editing")
                and not self.basic_info_tab._is_editing
            ):
                self.logger.debug("showEvent: Setting basic_info_tab to read-only.")
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.basic_info_tab.set_form_read_only(True)
                self.logger.debug("showEvent: basic_info_tab set to read-only.")
        else:
            self.logger.debug(
                "showEvent: No current_horse. Calling display_empty_state."
            )
            self.display_empty_state()
            self.logger.debug("showEvent: display_empty_state call completed.")

        self.logger.debug("showEvent: Calling update_main_action_buttons_state.")
        self.update_main_action_buttons_state()
        self.logger.debug("showEvent: update_main_action_buttons_state call completed.")

        self.logger.info(
            "HorseUnifiedManagement showEvent: FINISHED - screen should be visible."
        )

    def display_empty_state(self):
        self.logger.debug("display_empty_state: START")

        if hasattr(self, "empty_frame") and self.empty_frame:
            self.logger.debug("display_empty_state: Showing empty_frame.")
            self.empty_frame.show()
        else:
            self.logger.warning(
                "display_empty_state: empty_frame not available or not valid."
            )

        if (
            hasattr(self, "horse_details_content_widget")
            and self.horse_details_content_widget
        ):
            self.logger.debug(
                "display_empty_state: Hiding horse_details_content_widget."
            )
            self.horse_details_content_widget.hide()
        else:
            self.logger.warning(
                "display_empty_state: horse_details_content_widget not available."
            )

        self.current_horse = None
        self._is_new_mode = False
        self._has_changes_in_active_tab = False
        self.logger.debug("display_empty_state: Basic state flags reset.")

        if self.basic_info_tab:
            self.logger.debug(
                "display_empty_state: Calling basic_info_tab.clear_fields()."
            )
            try:
                self.basic_info_tab.clear_fields()
                self.logger.debug(
                    "display_empty_state: basic_info_tab.clear_fields() successful."
                )
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.logger.debug(
                        "display_empty_state: Attempting basic_info_tab.set_form_read_only(True)."
                    )
                    self.basic_info_tab.set_form_read_only(True)
                    self.logger.debug(
                        "display_empty_state: basic_info_tab.set_form_read_only(True) done."
                    )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in basic_info_tab.clear_fields or set_form_read_only: {e}",
                    exc_info=True,
                )

            if hasattr(self.basic_info_tab, "update_buttons_state"):
                self.logger.debug(
                    "display_empty_state: Calling basic_info_tab.update_buttons_state(...)."
                )
                try:
                    self.basic_info_tab.update_buttons_state(
                        is_editing_or_new=False, has_selection=False, has_changes=False
                    )
                    self.logger.debug(
                        "display_empty_state: basic_info_tab.update_buttons_state() successful."
                    )
                except Exception as e:
                    self.logger.error(
                        f"display_empty_state: Error in basic_info_tab.update_buttons_state: {e}",
                        exc_info=True,
                    )
        else:
            self.logger.error("display_empty_state: BasicInfoTab is None.")

        if self.owners_tab and hasattr(self.owners_tab, "load_owners_for_horse"):
            self.logger.debug(
                "display_empty_state: Calling owners_tab.load_owners_for_horse(None)."
            )
            try:
                self.owners_tab.load_owners_for_horse(None)
                self.logger.debug(
                    "display_empty_state: owners_tab.load_owners_for_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in owners_tab.load_owners_for_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: OwnersTab is None or missing method."
            )

        if self.location_tab and hasattr(self.location_tab, "load_location_for_horse"):
            self.logger.debug(
                "display_empty_state: Calling location_tab.load_location_for_horse(None)."
            )
            try:
                self.location_tab.load_location_for_horse(None)
                self.logger.debug(
                    "display_empty_state: location_tab.load_location_for_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in location_tab.load_location_for_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: LocationTab is None or missing method."
            )

        if self.billing_tab and hasattr(self.billing_tab, "set_current_horse"):
            self.logger.debug(
                "display_empty_state: Calling billing_tab.set_current_horse(None)."
            )
            try:
                self.billing_tab.set_current_horse(None)
                self.logger.debug(
                    "display_empty_state: billing_tab.set_current_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in billing_tab.set_current_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: BillingTab is None or missing set_current_horse method."
            )

        if hasattr(self, "horse_title") and self.horse_title:
            self.logger.debug("display_empty_state: Setting horse_title text.")
            self.horse_title.setText("No Horse Selected")
        else:
            self.logger.warning(
                "display_empty_state: horse_title QLabel not available."
            )

        self.logger.debug("display_empty_state: Calling _update_horse_info_line(None).")
        self._update_horse_info_line(None)
        self.logger.debug(
            "display_empty_state: _update_horse_info_line(None) call completed."
        )

        self.logger.debug("display_empty_state: Calling update_status.")
        self.update_status("No horse selected. Add a new horse or select from list.")
        self.logger.info("display_empty_state: FINISHED")

    def update_main_action_buttons_state(self):
        self.logger.debug("update_main_action_buttons_state: START")
        can_add_new = not self._is_new_mode and not self._has_changes_in_active_tab
        if hasattr(self, "add_horse_btn") and self.add_horse_btn:
            self.add_horse_btn.setEnabled(can_add_new)
            self.logger.debug(
                f"update_main_action_buttons_state: add_horse_btn enabled: {can_add_new}"
            )
        else:
            self.logger.warning(
                "add_horse_btn not initialized in update_main_action_buttons_state"
            )

        form_is_editable_by_tab = False
        if self.basic_info_tab and hasattr(self.basic_info_tab, "_is_editing"):
            form_is_editable_by_tab = self.basic_info_tab._is_editing

        can_edit_selected = (
            self.current_horse is not None
            and not self._is_new_mode
            and not self._has_changes_in_active_tab
            and not form_is_editable_by_tab
        )

        if hasattr(self, "edit_horse_btn") and self.edit_horse_btn:
            self.edit_horse_btn.setEnabled(can_edit_selected)
            self.logger.debug(
                f"update_main_action_buttons_state: edit_horse_btn enabled: {can_edit_selected}"
            )
        else:
            self.logger.warning(
                "edit_horse_btn not initialized in update_main_action_buttons_state"
            )

        if self.basic_info_tab and hasattr(self.basic_info_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating basic_info_tab buttons."
            )
            try:
                is_editing_or_new_val = self._is_new_mode or form_is_editable_by_tab
                has_selection_val = self.current_horse is not None
                has_changes_val = self._has_changes_in_active_tab
                self.basic_info_tab.update_buttons_state(
                    is_editing_or_new_val, has_selection_val, has_changes_val
                )
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling basic_info_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.owners_tab and hasattr(self.owners_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating owners_tab buttons."
            )
            try:
                self.owners_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling owners_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.location_tab and hasattr(self.location_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating location_tab buttons."
            )
            try:
                self.location_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling location_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.billing_tab and hasattr(self.billing_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating billing_tab buttons."
            )
            try:
                self.billing_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling billing_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        self.logger.debug("update_main_action_buttons_state: FINISHED")

    def discard_changes(self):
        self.logger.debug("discard_changes: START")
        if not self._is_new_mode and not self._has_changes_in_active_tab:
            if (
                self.current_horse
                and self.basic_info_tab
                and hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing
            ):
                self.logger.info(
                    "discard_changes: Form in edit mode, no data changes. Reverting to read-only."
                )
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.basic_info_tab.set_form_read_only(True)
                self.update_main_action_buttons_state()
                self.update_status(
                    f"Viewing: {self.current_horse.horse_name or 'horse'}"
                )
                self.logger.debug("discard_changes: FINISHED (no actual changes)")
                return
            self.update_status("No changes to discard.")
            self.logger.debug("discard_changes: FINISHED (no changes to discard)")
            return

        if self.show_question("Confirm Discard", "Discard unsaved changes?"):
            self.logger.info("discard_changes: User confirmed discard.")
            was_in_new_mode = self._is_new_mode
            self._is_new_mode = False
            self._has_changes_in_active_tab = False
            if self.basic_info_tab:
                self.logger.debug("discard_changes: Clearing BasicInfoTab.")
                try:
                    self.basic_info_tab.clear_fields()
                    if hasattr(self.basic_info_tab, "set_form_read_only"):
                        self.basic_info_tab.set_form_read_only(True)
                except Exception as e:
                    self.logger.error(
                        f"discard_changes: Error in basic_info_tab.clear_fields/set_form_read_only: {e}",
                        exc_info=True,
                    )

            if self.current_horse and not was_in_new_mode:
                self.logger.debug(
                    f"discard_changes: Reloading horse ID {self.current_horse.horse_id}."
                )
                self.load_horse_details(self.current_horse.horse_id)
            else:
                self.logger.debug(
                    "discard_changes: Was new or no current horse. Selecting first in list or empty state."
                )
                if self.horse_list and self.horse_list.count() > 0:
                    self.horse_list.setCurrentRow(0)
                else:
                    self.display_empty_state()
            self.update_main_action_buttons_state()
            self.update_status("Changes discarded.")
        else:
            self.logger.info("discard_changes: User cancelled discard.")
        self.logger.debug("discard_changes: FINISHED")

    def load_initial_data(self):
        self.logger.info("load_initial_data: START - Attempting to load horses.")
        try:
            self.load_horses()
            self.logger.info(
                "load_initial_data: FINISHED - load_horses call completed."
            )
        except Exception as e:
            self.logger.error(
                f"load_initial_data: CRITICAL ERROR during load_horses: {e}",
                exc_info=True,
            )
            self.show_error(
                "Initial Data Load Failed", f"Could not load initial horse data: {e}"
            )

    def closeEvent(self, event: QCloseEvent):
        self.logger.warning(f"HorseUnifiedManagement closeEvent. Type: {event.type()}")
        self.closing.emit()
        super().closeEvent(event)
        self.logger.warning("HorseUnifiedManagement finished processing closeEvent.")

    def get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND):
        return f"""
            QLineEdit, QComboBox, QDateEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; }}
            QLineEdit:focus, QComboBox:focus, QDateEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QLineEdit:disabled, QComboBox:disabled, QDateEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; width: 15px; }} QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QDateEdit::up-button, QDateEdit::down-button {{ width: 18px; }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
        """

    def get_generic_button_style(self):
        return f"""
            QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px; }} 
            QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} 
            QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}
        """

    def get_toolbar_button_style(self, bg_color_hex, text_color_hex="#ffffff"):
        if len(bg_color_hex) == 4 and bg_color_hex.startswith("#"):
            bg_color_hex = f"#{bg_color_hex[1]*2}{bg_color_hex[2]*2}{bg_color_hex[3]*2}"
        try:
            base_qcolor = QColor(bg_color_hex)
            hover_bg = base_qcolor.lighter(115).name()
            pressed_bg = base_qcolor.darker(110).name()
        except ValueError:
            hover_bg, pressed_bg = DARK_BUTTON_HOVER, DARK_BUTTON_BG
            self.logger.warning(
                f"Could not parse color: {bg_color_hex} for button style."
            )
        return f"""
            QPushButton {{ background-color: {bg_color_hex}; color: {text_color_hex}; border: none; border-radius: 4px; padding: 8px 16px; font-size: 13px; font-weight: 500; }} 
            QPushButton:hover {{ background-color: {hover_bg}; }} QPushButton:pressed {{ background-color: {pressed_bg}; }} 
            QPushButton:disabled {{ background-color: #adb5bd; color: #f8f9fa; }}
        """

    def setup_header(self, parent_layout):
        self.logger.debug("setup_header: START")
        header_frame = QFrame()
        header_frame.setObjectName("HeaderFrame")
        header_frame.setFixedHeight(55)
        header_frame.setStyleSheet(
            f"""#HeaderFrame{{background-color:{DARK_HEADER_FOOTER};border:none;padding:0 20px;}} QLabel{{color:{DARK_TEXT_PRIMARY};background-color:transparent;}} QPushButton#UserMenuButton{{color:{DARK_TEXT_SECONDARY};font-size:12px;background-color:transparent;border:none;padding:5px;text-align:right;}} QPushButton#UserMenuButton::menu-indicator{{image:none;}} QPushButton#UserMenuButton:hover{{color:{DARK_TEXT_PRIMARY};background-color:{QColor(DARK_ITEM_HOVER).lighter(110).name(QColor.NameFormat.HexRgb)}33;}}"""
        )
        header_layout = QHBoxLayout(header_frame)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(15)
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setSpacing(2)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addStretch()
        title_label = QLabel("EDSI - Horse Management")
        title_label.setFont(QFont(DEFAULT_FONT_FAMILY, 15, QFont.Weight.Bold))
        left_layout.addWidget(title_label)
        breadcrumb_label = QLabel("🏠 Horse Management")
        breadcrumb_label.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:11px;background:transparent;"
        )
        left_layout.addWidget(breadcrumb_label)
        left_layout.addStretch()
        right_widget = QWidget()
        right_layout = QHBoxLayout(right_widget)
        right_layout.setSpacing(10)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.refresh_btn = QPushButton("🔄")
        self.refresh_btn.setToolTip("Refresh Data (F5)")
        self.help_btn = QPushButton("❓")
        self.help_btn.setToolTip("Help (F1)")
        self.print_btn = QPushButton("🖨️")
        self.print_btn.setToolTip("Print Options")
        self.setup_icon_btn = QPushButton("⚙️")
        self.setup_icon_btn.setToolTip("System Setup")
        header_button_style = f"""QPushButton{{background-color:{DARK_BUTTON_BG};color:{DARK_TEXT_PRIMARY};border:1px solid {DARK_BORDER};border-radius:4px;padding:5px;font-size:14px;min-width:28px;max-width:28px;min-height:28px;max-height:28px;}} QPushButton:hover{{background-color:{DARK_BUTTON_HOVER};}} QPushButton:pressed{{background-color:{DARK_BUTTON_BG};}}"""
        for btn in [
            self.refresh_btn,
            self.help_btn,
            self.print_btn,
            self.setup_icon_btn,
        ]:
            if btn:
                btn.setStyleSheet(header_button_style)
        self.user_menu_button = QPushButton(f"👤 User: {self.current_user}")
        self.user_menu_button.setObjectName("UserMenuButton")
        self.user_menu_button.setToolTip("User options")
        self.user_menu_button.setFlat(True)
        self.user_menu = QMenu(self)
        self.user_menu.setStyleSheet(
            f"""QMenu{{background-color:{DARK_WIDGET_BACKGROUND};color:{DARK_TEXT_PRIMARY};border:1px solid {DARK_BORDER};padding:5px;}} QMenu::item{{padding:5px 20px 5px 20px;min-width:100px;}} QMenu::item:selected{{background-color:{DARK_HIGHLIGHT_BG}70;color:{DARK_HIGHLIGHT_TEXT};}} QMenu::separator{{height:1px;background:{DARK_BORDER};margin-left:5px;margin-right:5px;}}"""
        )
        logout_action = QAction("Log Out", self)
        logout_action.triggered.connect(self.handle_logout_request_from_menu)
        self.user_menu.addAction(logout_action)
        if self.user_menu_button:
            self.user_menu_button.setMenu(self.user_menu)
        for btn in [
            self.refresh_btn,
            self.help_btn,
            self.print_btn,
            self.setup_icon_btn,
            self.user_menu_button,
        ]:
            if btn:
                right_layout.addWidget(btn)
        header_layout.addWidget(left_widget)
        header_layout.addStretch()
        header_layout.addWidget(right_widget)
        parent_layout.addWidget(header_frame)
        self.logger.debug("setup_header: END")

    def setup_action_bar(self, parent_layout):
        self.logger.debug("setup_action_bar: START")
        action_bar_frame = QFrame()
        action_bar_frame.setObjectName("ActionBarFrame")
        action_bar_frame.setFixedHeight(50)
        action_bar_frame.setStyleSheet(
            f"""#ActionBarFrame{{background-color:{DARK_BACKGROUND};border:none;border-bottom:1px solid {DARK_BORDER};padding:0 20px;}} QPushButton{{min-height:30px;}} QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;}} QRadioButton::indicator{{width:13px;height:13px;}} QRadioButton{{color:{DARK_TEXT_SECONDARY};background:transparent;padding:5px;}}"""
        )
        action_bar_layout = QHBoxLayout(action_bar_frame)
        action_bar_layout.setContentsMargins(0, 0, 0, 0)
        action_bar_layout.setSpacing(12)
        action_bar_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.add_horse_btn = QPushButton("➕ Add Horse")
        self.edit_horse_btn = QPushButton("✓ Edit Selected")
        action_button_style_str = self.get_generic_button_style()
        add_btn_bg_color = DARK_PRIMARY_ACTION
        if len(add_btn_bg_color) == 4:
            add_btn_bg_color = f"#{add_btn_bg_color[1]*2}{add_btn_bg_color[2]*2}{add_btn_bg_color[3]*2}"
        if self.add_horse_btn:
            self.add_horse_btn.setStyleSheet(
                action_button_style_str.replace(
                    DARK_BUTTON_BG, add_btn_bg_color + "B3"
                ).replace(f"color:{DARK_TEXT_PRIMARY}", "color:white;")
            )
        if self.edit_horse_btn:
            self.edit_horse_btn.setStyleSheet(action_button_style_str)
        action_bar_layout.addWidget(self.add_horse_btn)
        action_bar_layout.addWidget(self.edit_horse_btn)
        self.filter_group = QButtonGroup(self)
        self.active_only_radio = QRadioButton("Active Only")
        self.all_horses_radio = QRadioButton("All Horses")
        self.deactivated_radio = QRadioButton("Deactivated")
        for btn in [
            self.active_only_radio,
            self.all_horses_radio,
            self.deactivated_radio,
        ]:
            if btn:
                self.filter_group.addButton(btn)
                action_bar_layout.addWidget(btn)
        if self.active_only_radio:
            self.active_only_radio.setChecked(True)
        action_bar_layout.addStretch()
        self.search_input = QLineEdit()
        if self.search_input:
            self.search_input.setPlaceholderText("🔍 Search...")
            self.search_input.setFixedHeight(30)
            self.search_input.setFixedWidth(220)
            self.search_input.setStyleSheet(
                self.get_form_input_style(base_bg=DARK_HEADER_FOOTER)
            )
        action_bar_layout.addWidget(self.search_input)
        if self.edit_horse_btn:
            self.edit_horse_btn.setEnabled(False)
        parent_layout.addWidget(action_bar_frame)
        self.logger.debug("setup_action_bar: END")

    def setup_main_content(self, parent_layout):
        self.logger.debug("setup_main_content: START")
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        self.splitter.setHandleWidth(1)
        self.splitter.setStyleSheet(
            f"""QSplitter{{background-color:{DARK_BACKGROUND};border:none;}} QSplitter::handle{{background-color:{DARK_BORDER};}} QSplitter::handle:horizontal{{width:1px;}} QSplitter::handle:pressed{{background-color:{DARK_TEXT_SECONDARY};}}"""
        )
        self.setup_horse_list_panel()
        self.setup_horse_details_panel()
        self.splitter.setSizes([300, 850])
        self.splitter.setStretchFactor(0, 0)
        self.splitter.setStretchFactor(1, 1)
        self.splitter.setCollapsible(0, False)
        self.splitter.setCollapsible(1, False)
        parent_layout.addWidget(self.splitter, 1)
        self.logger.debug("setup_main_content: END")

    def setup_horse_list_panel(self):
        from .widgets.horse_list_widget import (
            HorseListWidget,
        )

        self.list_widget_container = QWidget()
        self.list_widget_container.setStyleSheet(
            f"background-color:{DARK_BACKGROUND};border:none;border-right:1px solid {DARK_BORDER};"
        )
        list_layout = QVBoxLayout(self.list_widget_container)
        list_layout.setContentsMargins(0, 0, 0, 0)
        list_layout.setSpacing(0)
        self.horse_list = HorseListWidget()
        if self.horse_list:
            self.horse_list.setMinimumWidth(250)
        list_layout.addWidget(self.horse_list, 1)
        if self.splitter:
            self.splitter.addWidget(self.list_widget_container)

    def setup_horse_details_panel(self):
        self.logger.debug("setup_horse_details_panel: START")
        self.details_widget = QWidget()
        self.details_widget.setStyleSheet(
            f"background-color:{DARK_BACKGROUND};border:none;"
        )
        self.details_layout = QVBoxLayout(self.details_widget)
        self.details_layout.setContentsMargins(15, 10, 15, 10)
        self.details_layout.setSpacing(15)
        self.horse_details_content_widget = QWidget()
        details_content_layout = QVBoxLayout(self.horse_details_content_widget)
        details_content_layout.setContentsMargins(0, 0, 0, 0)
        details_content_layout.setSpacing(15)
        self.setup_horse_header_details(details_content_layout)
        self.setup_horse_tabs(details_content_layout)
        self.setup_empty_state()
        if self.details_layout and self.empty_frame:
            self.details_layout.addWidget(self.empty_frame)
        if self.details_layout and self.horse_details_content_widget:
            self.details_layout.addWidget(self.horse_details_content_widget)
        if self.horse_details_content_widget:
            self.horse_details_content_widget.hide()
        if self.splitter:
            self.splitter.addWidget(self.details_widget)
        self.logger.debug("setup_horse_details_panel: END")

    def setup_empty_state(self):
        self.logger.debug("setup_empty_state (frame creation): START")
        self.empty_frame = QFrame()
        self.empty_frame.setObjectName("EmptyFrame")
        self.empty_frame.setStyleSheet(
            "#EmptyFrame{background-color:transparent;border:none;}"
        )
        empty_layout = QVBoxLayout(self.empty_frame)
        empty_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        empty_layout.setSpacing(15)
        empty_label = QLabel("Select a horse from the list, or click 'Add Horse'.")
        empty_label.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:16px;background:transparent;"
        )
        empty_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        empty_layout.addWidget(empty_label)
        self.logger.debug("setup_empty_state (frame creation): FINISHED")

    def setup_horse_header_details(self, parent_layout):
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(5)
        self.horse_title = QLabel("Horse Name")
        self.horse_title.setFont(QFont(DEFAULT_FONT_FAMILY, 18, QFont.Weight.Bold))
        self.horse_title.setStyleSheet(
            f"color:{DARK_TEXT_PRIMARY};background:transparent;"
        )
        self.horse_info_line = QLabel(
            "Acct: N/A | 👥 No Owner | Breed: N/A | Color: N/A | Sex: N/A | Age: N/A | 📍 N/A"
        )
        self.horse_info_line.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:12px;background:transparent;"
        )
        self.horse_info_line.setWordWrap(True)
        header_layout.addWidget(self.horse_title)
        header_layout.addWidget(self.horse_info_line)
        parent_layout.addWidget(header_widget)

    def setup_horse_tabs(self, parent_layout_for_tabs):
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_HORSE_TABS START ---")
        try:
            self.tab_widget = QTabWidget()
            self.tab_widget.setObjectName("DetailsTabWidget")
            self.tab_widget.setStyleSheet(
                f"""QTabWidget#DetailsTabWidget::pane{{border:1px solid {AppConfig.DARK_BORDER};background-color:{AppConfig.DARK_WIDGET_BACKGROUND};border-radius:6px;margin-top:-1px;}} QTabBar::tab{{padding:8px 15px;margin-right:2px;background-color:{AppConfig.DARK_BUTTON_BG};color:{AppConfig.DARK_TEXT_SECONDARY};border:1px solid {AppConfig.DARK_BORDER};border-bottom:none;border-top-left-radius:5px;border-top-right-radius:5px;min-width:90px;font-size:13px;font-weight:500;}} QTabBar::tab:selected{{background-color:{AppConfig.DARK_WIDGET_BACKGROUND};color:{AppConfig.DARK_TEXT_PRIMARY};border-color:{AppConfig.DARK_BORDER};border-bottom-color:{AppConfig.DARK_WIDGET_BACKGROUND};}} QTabBar::tab:!selected:hover{{background-color:{AppConfig.DARK_BUTTON_HOVER};color:{AppConfig.DARK_TEXT_PRIMARY};}} QTabBar{{border:none;background-color:transparent;margin-bottom:0px;}}"""
            )

            try:
                self.basic_info_tab = BasicInfoTab(
                    horse_controller=self.horse_controller, parent=self
                )
                self.tab_widget.addTab(self.basic_info_tab, "📋 Basic Info")
                self.logger.info("BasicInfoTab created.")
            except Exception as e_basic:
                self.logger.error(f"ERROR BasicInfoTab: {e_basic}", exc_info=True)
                self.basic_info_tab = None

            try:
                self.owners_tab = OwnersTab(
                    parent_view=self,
                    horse_controller=self.horse_controller,
                    owner_controller=self.owner_controller,
                )
                self.tab_widget.addTab(self.owners_tab, "👥 Owners")
                self.logger.info("OwnersTab created.")
            except Exception as e_owners:
                self.logger.error(f"ERROR OwnersTab: {e_owners}", exc_info=True)
                self.owners_tab = None

            try:
                self.location_tab = LocationTab(
                    parent_view=self,
                    horse_controller=self.horse_controller,
                    location_controller=self.location_controller,
                )
                self.tab_widget.addTab(self.location_tab, "📍 Location")
                self.logger.info("LocationTab created.")
            except Exception as e_location:
                self.logger.error(f"ERROR LocationTab: {e_location}", exc_info=True)
                self.location_tab = None

            try:
                self.billing_tab = BillingTab(
                    financial_controller=self.financial_controller, parent=self
                )
                self.tab_widget.addTab(self.billing_tab, "💰 Billing")
                self.logger.info("BillingTab created.")
            except Exception as e_billing:
                self.logger.error(f"ERROR BillingTab: {e_billing}", exc_info=True)
                self.billing_tab = None

            placeholder_tabs = ["📊 History"]
            for name in placeholder_tabs:
                placeholder_widget = QWidget(
                    objectName=f"Placeholder_{name.replace(' ','')}Tab"
                )
                layout = QVBoxLayout(placeholder_widget)
                label = QLabel(f"{name} - Coming Soon")
                label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                layout.addWidget(label)
                self.tab_widget.addTab(placeholder_widget, name)

            parent_layout_for_tabs.addWidget(self.tab_widget, 1)
            self.logger.info("Tabs added.")
        except Exception as e:
            self.logger.error(f"ERROR setup_horse_tabs: {e}", exc_info=True)
            if hasattr(self, "tab_widget") and self.tab_widget:
                self.tab_widget.deleteLater()
            self.tab_widget = None
            self.basic_info_tab = None
            self.owners_tab = None
            self.location_tab = None
            self.billing_tab = None

    def _handle_location_assignment_change(self, location_data: Dict):
        self.logger.info(f"Received location_assignment_changed: {location_data}")
        if self.current_horse and self.current_horse.horse_id is not None:
            horse_id_that_changed = self.current_horse.horse_id
            self.logger.info(
                f"Location changed for horse ID {horse_id_that_changed}. Reloading details."
            )
            self.load_horse_details(horse_id_that_changed)
            if self.current_horse:
                current_loc_name = "[N/A - Error]"
                try:
                    current_loc_name = (
                        self.current_horse.location.location_name
                        if self.current_horse.location
                        and hasattr(self.current_horse.location, "location_name")
                        else "N/A"
                    )
                except DetachedInstanceError:
                    current_loc_name = "[Location N/A - Session Issue]"
                self.update_status(
                    f"Location updated to '{current_loc_name}' for {self.current_horse.horse_name or 'horse'}."
                )
        else:
            self.logger.warning(
                "Location assignment changed, but no current_horse or valid horse_id to refresh."
            )

    def _get_display_owner_name(self, horse: Optional[Horse]) -> str:
        if not horse:
            return "No Owner"
        owner_name_display = "No Owner"
        try:
            if horse.owners and len(horse.owners) > 0:
                actual_owner = horse.owners[0]
                if actual_owner:
                    name_parts: List[str] = []
                    if (
                        hasattr(actual_owner, "farm_name")
                        and actual_owner.farm_name
                        and actual_owner.farm_name.strip()
                    ):
                        name_parts.append(actual_owner.farm_name.strip())
                    person_name_parts: List[str] = []
                    if (
                        hasattr(actual_owner, "first_name")
                        and actual_owner.first_name
                        and actual_owner.first_name.strip()
                    ):
                        person_name_parts.append(actual_owner.first_name.strip())
                    if (
                        hasattr(actual_owner, "last_name")
                        and actual_owner.last_name
                        and actual_owner.last_name.strip()
                    ):
                        person_name_parts.append(actual_owner.last_name.strip())
                    person_name_str = " ".join(person_name_parts).strip()
                    if person_name_str:
                        if name_parts:
                            name_parts.append(f"({person_name_str})")
                        else:
                            name_parts.append(person_name_str)
                    if name_parts:
                        owner_name_display = " ".join(name_parts)
                    elif hasattr(actual_owner, "owner_id"):
                        owner_name_display = f"Owner ID: {actual_owner.owner_id}"
                    else:
                        owner_name_display = "Owner Data Incomplete"
                else:
                    owner_name_display = "Owner Data Missing"
        except DetachedInstanceError:
            logger_obj = getattr(self, "logger", logging.getLogger(__name__))
            logger_obj.warning(
                f"Detached: horse.owners, Horse ID {horse.horse_id if horse else 'N/A'}."
            )
            owner_name_display = "[Own N/A - Detached]"
        except Exception as e:
            self.logger.error(
                f"Error constructing owner display name: {e}", exc_info=True
            )
            owner_name_display = "[Owner Display Error]"
        return owner_name_display

    def _get_display_location_name(self, horse: Optional[Horse]) -> str:
        if not horse:
            return "N/A"
        location_name_str = "N/A"
        try:
            if horse.location and hasattr(horse.location, "location_name"):
                location_name_str = horse.location.location_name or "N/A"
        except DetachedInstanceError:
            logger_obj = getattr(self, "logger", logging.getLogger(__name__))
            logger_obj.warning(
                f"Detached: horse.location, ID {horse.horse_id if horse else 'N/A'}."
            )
            location_name_str = "[Loc N/A - Detached]"
        except Exception as e:
            self.logger.error(f"Error getting location name: {e}", exc_info=True)
            location_name_str = "[Location Error]"
        return location_name_str

    def _update_horse_info_line(self, horse: Optional[Horse]):
        if not hasattr(self, "horse_info_line") or self.horse_info_line is None:
            self.logger.error(
                "_update_horse_info_line: horse_info_line QLabel is None."
            )
            return
        if not horse:
            self.horse_info_line.setText(
                "Acct: N/A | 👥 No Owner | Breed: N/A | Color: N/A | Sex: N/A | Age: N/A | 📍 N/A"
            )
            return
        age_str = "Age N/A"
        if self.horse_list and hasattr(self.horse_list, "_calculate_age"):
            age_str = self.horse_list._calculate_age(horse.date_of_birth)
        owner_name = self._get_display_owner_name(horse)
        location_name_val = self._get_display_location_name(horse)
        self.horse_info_line.setText(
            f"Acct: {horse.account_number or 'N/A'} | 👥 {owner_name} | Breed: {horse.breed or 'N/A'} | Color: {horse.color or 'N/A'} | Sex: {horse.sex or 'N/A'} | Age: {age_str} | 📍 {location_name_val}"
        )

    def load_horse_details(self, horse_id: int):
        self.logger.info(f"load_horse_details: START for horse ID: {horse_id}")
        horse = self.horse_controller.get_horse_by_id(horse_id)
        if not horse:
            self.show_error("Error", f"Could not load horse ID {horse_id}.")
            self.display_empty_state()
            self.logger.info("load_horse_details: FINISHED (horse not found)")
            return
        self.current_horse = horse
        self._is_new_mode = False
        self._has_changes_in_active_tab = False
        if hasattr(self, "horse_title") and self.horse_title:
            self.horse_title.setText(horse.horse_name or "Unnamed Horse")
        self._update_horse_info_line(horse)
        if self.basic_info_tab:
            self.basic_info_tab.populate_form_data(horse)
        if self.owners_tab:
            self.owners_tab.load_owners_for_horse(horse)
        if self.location_tab:
            self.location_tab.load_location_for_horse(horse)
        if self.billing_tab:
            self.logger.debug("load_horse_details: Loading BillingTab data")
            self.billing_tab.set_current_horse(horse)
        self.display_details_state()
        self.update_main_action_buttons_state()
        self.update_status(f"Viewing: {horse.horse_name or 'Unnamed Horse'}")
        self.logger.info(f"load_horse_details: FINISHED for horse ID: {horse_id}")

    def add_new_horse(self):
        self.logger.info("add_new_horse: START")
        if self._has_changes_in_active_tab and not self.show_question(
            "Unsaved Changes", "Discard current changes and start new horse record?"
        ):
            self.logger.info("add_new_horse: Aborted due to unsaved changes.")
            return
        self._is_new_mode = True
        self._has_changes_in_active_tab = False
        self.current_horse = None
        if self.horse_list and self.horse_list.selectionModel():
            self.logger.debug("add_new_horse: Clearing horse list selection.")
            self.horse_list.blockSignals(True)
            self.horse_list.selectionModel().clear()
            self.horse_list.blockSignals(False)
        if self.basic_info_tab and hasattr(self.basic_info_tab, "set_new_mode"):
            self.logger.debug("add_new_horse: Setting BasicInfoTab to new mode.")
            self.basic_info_tab.set_new_mode(is_new=True)
        else:
            self.logger.error("add_new_horse: BasicInfoTab missing or no set_new_mode.")
            self.show_error("UI Error", "Details form unavailable.")
            self._is_new_mode = False
            return
        if self.owners_tab:
            self.owners_tab.load_owners_for_horse(None)
        if self.location_tab:
            self.location_tab.load_location_for_horse(None)
        if self.billing_tab:
            self.billing_tab.set_current_horse(None)
        if hasattr(self, "horse_title") and self.horse_title:
            self.horse_title.setText("New Horse Record")
        self._update_horse_info_line(None)
        self.display_details_state()
        if self.tab_widget and self.basic_info_tab:
            self.logger.debug("add_new_horse: Setting current tab to BasicInfoTab.")
            self.tab_widget.setCurrentWidget(self.basic_info_tab)
        self.update_main_action_buttons_state()
        self.update_status("Enter details for new horse.")
        self.logger.info("add_new_horse: FINISHED")

    def _on_tab_data_modified(self):
        if (
            self.basic_info_tab
            and hasattr(self.basic_info_tab, "horse_name_input")
            and self.basic_info_tab.horse_name_input
            and not self.basic_info_tab.horse_name_input.isReadOnly()
        ):
            if not self._has_changes_in_active_tab:
                self._has_changes_in_active_tab = True
                self.logger.debug("_on_tab_data_modified: Change detected. Flag set.")
            self.update_main_action_buttons_state()
        else:
            self.logger.debug(
                "_on_tab_data_modified: Signal received, but form read-only or input missing."
            )

    def _on_owner_association_changed(self, message: str):
        self.logger.info(f"_on_owner_association_changed: {message}")
        self.update_status(message)
        if self.current_horse and self.current_horse.horse_id is not None:
            self.load_horse_details(self.current_horse.horse_id)
        self.update_main_action_buttons_state()

    def handle_toggle_active_status_from_tab(self, new_active_status_requested: bool):
        self.logger.info(
            f"handle_toggle_active_status_from_tab: Requested: {new_active_status_requested}"
        )
        if self.current_horse:
            self.handle_toggle_active_status()
        else:
            self.logger.warning(
                "handle_toggle_active_status_from_tab: No current horse."
            )

    def setup_footer(self, parent_layout):
        self.logger.debug("setup_footer: START")
        self.status_bar = QStatusBar()
        self.status_bar.setFixedHeight(28)
        self.status_bar.setStyleSheet(
            f"""QStatusBar{{background-color:{DARK_HEADER_FOOTER};color:{DARK_TEXT_SECONDARY};border:none;border-top:1px solid {DARK_BORDER};padding:0 15px;font-size:11px;}}QStatusBar::item{{border:none;}}QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;font-size:11px;}}"""
        )
        parent_layout.addWidget(self.status_bar)
        self.status_label = QLabel("Ready")
        self.footer_horse_count_label = QLabel("Showing 0 of 0 horses")
        self.shortcut_label = QLabel("F5=Refresh | Ctrl+N=New | Ctrl+S=Save")
        self.status_bar.addWidget(self.status_label, 1)
        self.status_bar.addPermanentWidget(self.footer_horse_count_label)
        separator_label = QLabel(" | ")
        separator_label.setStyleSheet(
            f"color:{DARK_BORDER};background:transparent;margin:0 5px;"
        )
        self.status_bar.addPermanentWidget(separator_label)
        self.status_bar.addPermanentWidget(self.shortcut_label)
        self.logger.debug("setup_footer: FINISHED")

    def save_changes(self):
        self.logger.info("save_changes: START")
        if not self.basic_info_tab:
            self.logger.error("save_changes: BasicInfoTab missing.")
            self.show_error("Save Error", "UI component missing.")
            return
        if not self._has_changes_in_active_tab and not self._is_new_mode:
            self.update_status("No changes to save.")
            if (
                hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing
                and hasattr(self.basic_info_tab, "set_form_read_only")
            ):
                self.basic_info_tab.set_form_read_only(True)
                self.update_main_action_buttons_state()
            return
        horse_data = self.basic_info_tab.get_data_from_form()
        if (
            self.current_horse
            and self.current_horse.current_location_id is not None
            and not self._is_new_mode
        ):
            horse_data["current_location_id"] = self.current_horse.current_location_id
        elif "current_location_id" not in horse_data:
            horse_data["current_location_id"] = None
        self.logger.debug(
            f"save_changes: Validating data. New: {self._is_new_mode}. Data: {horse_data}"
        )
        is_valid, errors = self.horse_controller.validate_horse_data(
            horse_data,
            is_new=self._is_new_mode,
            horse_id_to_check_for_unique=(
                self.current_horse.horse_id
                if not self._is_new_mode and self.current_horse
                else None
            ),
        )
        if not is_valid:
            self.show_warning(
                "Validation Error", "Correct errors:\n\n- " + "\n- ".join(errors)
            )
            self.logger.info("save_changes: Validation failed.")
            return
        try:
            saved_id: Optional[int] = None
            success: bool = False
            msg: str = ""
            if not self._is_new_mode and self.current_horse:
                self.logger.debug(
                    f"save_changes: Updating horse ID {self.current_horse.horse_id}"
                )
                success, msg = self.horse_controller.update_horse(
                    self.current_horse.horse_id, horse_data, self.current_user
                )
                if success:
                    saved_id = self.current_horse.horse_id
            else:
                self.logger.debug("save_changes: Creating new horse")
                success, msg, new_horse_obj = self.horse_controller.create_horse(
                    horse_data, self.current_user
                )
                if success and new_horse_obj:
                    saved_id = new_horse_obj.horse_id
                elif success and not new_horse_obj:
                    self.logger.error(
                        f"save_changes: Horse creation success={success}, but new_horse_obj is None. Msg: {msg}"
                    )
            if success:
                self.logger.info(f"save_changes: Save successful. Message: {msg}")
                self.show_info("Success", msg)
                self._has_changes_in_active_tab = False
                if self.basic_info_tab and hasattr(
                    self.basic_info_tab, "mark_as_saved"
                ):
                    self.basic_info_tab.mark_as_saved()
                if self._is_new_mode and saved_id is not None:
                    newly_saved_horse = self.horse_controller.get_horse_by_id(saved_id)
                    if newly_saved_horse:
                        self.current_horse = newly_saved_horse
                        self._is_new_mode = False
                        self.logger.debug(
                            f"save_changes: New horse {saved_id} set as current."
                        )
                    else:
                        self.logger.error(
                            f"save_changes: Failed to re-fetch new horse {saved_id}."
                        )
                        self.display_empty_state()
                        self.load_horses()
                        return
                self.load_horses()
                if saved_id is not None and self.horse_list:
                    self.logger.debug(
                        f"save_changes: Verifying selection for horse ID {saved_id} in list after load_horses."
                    )
                    found_and_selected = False
                    for i in range(self.horse_list.count()):
                        item = self.horse_list.item(i)
                        if item and item.data(Qt.ItemDataRole.UserRole) == saved_id:
                            if self.horse_list.currentRow() != i:
                                self.horse_list.setCurrentRow(i)
                            else:
                                self.load_horse_details(saved_id)
                            found_and_selected = True
                            self.logger.debug(
                                f"save_changes: Verified/reselected row {i} for ID {saved_id}."
                            )
                            break
                    if not found_and_selected:
                        self.logger.debug(
                            f"save_changes: Horse ID {saved_id} not found in list after save/refresh for final reselection attempt."
                        )
                        if self.horse_list.count() > 0:
                            self.horse_list.setCurrentRow(0)
                        else:
                            self.display_empty_state()
                elif self.horse_list and self.horse_list.count() > 0:
                    self.horse_list.setCurrentRow(0)
                elif not self.horse_list or self.horse_list.count() == 0:
                    self.display_empty_state()
            else:
                self.logger.error(f"save_changes: Save failed. Message: {msg}")
                self.show_error("Save Failed", msg or "Unknown error.")
        except Exception as e:
            self.logger.error(f"save_changes: Exception: {e}", exc_info=True)
            self.show_error("Save Error", f"Unexpected error: {e}")
        self.logger.info("save_changes: FINISHED")

    def populate_horse_list(self):
        self.logger.debug("populate_horse_list: START")
        if not hasattr(self, "horse_list") or not self.horse_list:
            self.logger.error("populate_horse_list: horse_list widget not ready.")
            return
        current_selected_id = None
        if self.horse_list.currentItem():
            current_selected_id = self.horse_list.currentItem().data(
                Qt.ItemDataRole.UserRole
            )
        self.logger.debug(
            f"populate_horse_list: Clearing list. Previously selected ID: {current_selected_id}"
        )
        self.horse_list.clear()
        for horse_obj in self.horses_list_data:
            item = QListWidgetItem()
            item_widget = self.horse_list.create_horse_list_item_widget(horse_obj)
            item.setSizeHint(item_widget.sizeHint())
            item.setData(Qt.ItemDataRole.UserRole, horse_obj.horse_id)
            self.horse_list.addItem(item)
            self.horse_list.setItemWidget(item, item_widget)
        self.logger.debug(
            f"populate_horse_list: List populated with {len(self.horses_list_data)} items."
        )
        if hasattr(self, "footer_horse_count_label") and self.footer_horse_count_label:
            total_horses_in_db = len(
                self.horse_controller.search_horses(status="all", search_term="")
            )
            self.footer_horse_count_label.setText(
                f"Showing {self.horse_list.count()} of {total_horses_in_db} total horses"
            )
        if current_selected_id is not None:
            for i in range(self.horse_list.count()):
                if (
                    self.horse_list.item(i).data(Qt.ItemDataRole.UserRole)
                    == current_selected_id
                ):
                    self.horse_list.setCurrentRow(i)
                    self.logger.debug(
                        f"populate_horse_list: Reselected row {i} for ID {current_selected_id}"
                    )
                    break
        self.logger.debug("populate_horse_list: FINISHED")

    def load_horses(self):
        self.logger.debug("load_horses: START")
        try:
            if (
                not hasattr(self, "search_input")
                or self.search_input is None
                or not hasattr(self, "active_only_radio")
                or self.active_only_radio is None
                or not hasattr(self, "all_horses_radio")
                or self.all_horses_radio is None
                or not hasattr(self, "deactivated_radio")
                or self.deactivated_radio is None
            ):
                self.logger.error("load_horses: Search/filter UI elements not ready.")
                return
            search_term = self.search_input.text()
            status_filter = "active"
            if self.all_horses_radio.isChecked():
                status_filter = "all"
            elif self.deactivated_radio.isChecked():
                status_filter = "inactive"
            self.logger.info(
                f"load_horses: Filter status: '{status_filter}', Search: '{search_term}'"
            )
            previously_selected_id = None
            if self.current_horse and not self._is_new_mode:
                previously_selected_id = self.current_horse.horse_id
            elif self.horse_list and self.horse_list.currentItem():
                current_item_data = self.horse_list.currentItem().data(
                    Qt.ItemDataRole.UserRole
                )
                if isinstance(current_item_data, int):
                    previously_selected_id = current_item_data
            self.logger.debug(
                f"load_horses: Previously selected ID to try and reselect: {previously_selected_id}"
            )
            self.horses_list_data = self.horse_controller.search_horses(
                search_term=search_term, status=status_filter
            )
            self.logger.debug(
                f"load_horses: {len(self.horses_list_data)} horses found by controller."
            )
            self.populate_horse_list()
            if not self.horses_list_data:
                self.logger.debug(
                    "load_horses: No horses found, displaying empty state."
                )
                self.display_empty_state()
                self.logger.debug("load_horses: FINISHED (no horses)")
                return
            reselected_successfully = False
            if previously_selected_id is not None and self.horse_list:
                for i in range(self.horse_list.count()):
                    item = self.horse_list.item(i)
                    if (
                        item
                        and item.data(Qt.ItemDataRole.UserRole)
                        == previously_selected_id
                    ):
                        self.logger.debug(
                            f"load_horses: Attempting to reselect ID {previously_selected_id} at row {i}."
                        )
                        self.horse_list.setCurrentRow(i)
                        reselected_successfully = True
                        self.logger.debug(
                            "load_horses: Reselected row. on_selection_changed will handle details load."
                        )
                        break
            if (
                not reselected_successfully
                and self.horse_list
                and self.horse_list.count() > 0
            ):
                self.logger.debug(
                    "load_horses: No reselection or previous ID not found, selecting row 0."
                )
                self.horse_list.setCurrentRow(0)
            elif not self.horse_list or self.horse_list.count() == 0:
                self.logger.debug(
                    "load_horses: List is empty after populate, displaying empty state."
                )
                self.display_empty_state()
            if not (self.horse_list and self.horse_list.currentItem()):
                self.update_main_action_buttons_state()
        except Exception as e:
            self.logger.error(f"load_horses: ERROR: {e}", exc_info=True)
            self.show_error("Load Horses Error", f"{e}")
            self.horses_list_data = []
            if hasattr(self, "horse_list") and self.horse_list:
                self.populate_horse_list()
            self.display_empty_state()
        self.logger.debug("load_horses: FINISHED")

    def on_search_text_changed(self):
        if hasattr(self.search_timer, "isActive") and self.search_timer.isActive():
            self.search_timer.stop()
        self.search_timer.start(350)

    def perform_search(self):
        self.logger.debug(
            f"perform_search: Term: '{self.search_input.text() if self.search_input else ''}'"
        )
        self.load_horses()

    def on_filter_changed(self):
        sender_widget = self.sender()
        if isinstance(sender_widget, QRadioButton) and sender_widget.isChecked():
            self.logger.info(f"on_filter_changed: To {sender_widget.text()}")
            self.load_horses()

    def on_selection_changed(self):
        self.logger.debug("on_selection_changed: START")
        if not self.horse_list:
            self.logger.warning("on_selection_changed: horse_list is None.")
            return
        selected_items = self.horse_list.selectedItems()
        if not selected_items:
            self.logger.debug("on_selection_changed: No items selected.")
            if not self._is_new_mode and not self._has_changes_in_active_tab:
                self.display_empty_state()
            return
        selected_item = selected_items[0]
        newly_selected_horse_id = selected_item.data(Qt.ItemDataRole.UserRole)
        self.logger.debug(
            f"on_selection_changed: Newly selected ID: {newly_selected_horse_id}"
        )
        current_horse_id = self.current_horse.horse_id if self.current_horse else None
        self.logger.debug(
            f"on_selection_changed: Current horse ID: {current_horse_id}, New mode: {self._is_new_mode}, Has changes: {self._has_changes_in_active_tab}"
        )
        if (self._has_changes_in_active_tab or self._is_new_mode) and (
            newly_selected_horse_id != current_horse_id
            or (self._is_new_mode and newly_selected_horse_id is not None)
        ):
            self.logger.debug(
                "on_selection_changed: Unsaved changes detected. Prompting user."
            )
            if not self.show_question(
                "Unsaved Changes",
                f"Discard unsaved {'new horse record' if self._is_new_mode else 'changes to current horse'}?",
            ):
                self.logger.debug(
                    "on_selection_changed: User chose NOT to discard. Reverting selection."
                )
                self.horse_list.blockSignals(True)
                if current_horse_id is not None and not self._is_new_mode:
                    for i in range(self.horse_list.count()):
                        if (
                            self.horse_list.item(i).data(Qt.ItemDataRole.UserRole)
                            == current_horse_id
                        ):
                            self.horse_list.setCurrentRow(i)
                            break
                else:
                    self.horse_list.clearSelection()
                self.horse_list.blockSignals(False)
                self.logger.debug("on_selection_changed: FINISHED (reverted selection)")
                return
            self.logger.debug("on_selection_changed: User chose to discard changes.")
            self._has_changes_in_active_tab = False
            self._is_new_mode = False
            self.logger.debug(
                "on_selection_changed: Flags reset (_has_changes_in_active_tab, _is_new_mode)."
            )
        if newly_selected_horse_id is not None:
            if newly_selected_horse_id == current_horse_id and not self._is_new_mode:
                self.logger.debug(
                    f"on_selection_changed: Same horse ID ({current_horse_id}) re-selected. Ensuring read-only state."
                )
                if (
                    self.basic_info_tab
                    and hasattr(self.basic_info_tab, "_is_editing")
                    and self.basic_info_tab._is_editing
                    and not self._has_changes_in_active_tab
                    and hasattr(self.basic_info_tab, "set_form_read_only")
                ):
                    self.basic_info_tab.set_form_read_only(True)
                self.update_main_action_buttons_state()
                self.logger.debug(
                    "on_selection_changed: FINISHED (same horse, no load unless it was new mode that got discarded)"
                )
                return
            self.load_horse_details(newly_selected_horse_id)
        else:
            self.logger.debug(
                "on_selection_changed: newly_selected_horse_id is None, displaying empty state."
            )
            self.display_empty_state()
        self.logger.debug("on_selection_changed: FINISHED")

    def edit_selected_horse(self):
        self.logger.debug("edit_selected_horse: START")
        if self.current_horse and not self._is_new_mode:
            if not self.tab_widget:
                self.logger.error("edit_selected_horse: Tab widget missing.")
                self.show_error("UI Error", "Tabs unavailable.")
                return
            current_tab_widget = self.tab_widget.currentWidget()
            self.logger.debug(
                f"edit_selected_horse: Current tab: {current_tab_widget.objectName() if current_tab_widget else 'None'}"
            )
            if (
                current_tab_widget == self.basic_info_tab
                and self.basic_info_tab
                and hasattr(self.basic_info_tab, "set_edit_mode")
            ):
                self.logger.debug(
                    "edit_selected_horse: Setting BasicInfoTab to edit mode."
                )
                self.basic_info_tab.set_edit_mode(True)
                self._has_changes_in_active_tab = False
            elif hasattr(current_tab_widget, "set_edit_mode"):
                self.logger.debug(
                    f"edit_selected_horse: Setting current tab {current_tab_widget.objectName()} to edit mode."
                )
                current_tab_widget.set_edit_mode(True)
                self._has_changes_in_active_tab = False
            else:
                self.logger.info(
                    f"edit_selected_horse: Current tab does not support direct edit. Defaulting to BasicInfoTab edit mode."
                )
                if self.basic_info_tab and hasattr(
                    self.basic_info_tab, "set_edit_mode"
                ):
                    self.basic_info_tab.set_edit_mode(True)
                    self._has_changes_in_active_tab = False
            self.update_main_action_buttons_state()
            self.update_status(
                f"Editing details for: {self.current_horse.horse_name or 'Unnamed Horse'}"
            )
        elif self._is_new_mode:
            self.show_info(
                "Information", "Currently adding new. Save or discard first."
            )
        else:
            self.show_info("Edit Horse", "Select a horse to edit.")
        self.logger.debug("edit_selected_horse: FINISHED")

    def refresh_data(self):
        self.logger.debug("refresh_data: START")
        if (
            self._has_changes_in_active_tab or self._is_new_mode
        ) and not self.show_question("Unsaved Changes", "Discard and refresh?"):
            self.logger.debug("refresh_data: Aborted due to unsaved changes.")
            return
        self.logger.info("refresh_data: Proceeding with refresh.")
        self._has_changes_in_active_tab = False
        self._is_new_mode = False
        self.load_horses()
        self.update_status("Data refreshed.")
        self.logger.debug("refresh_data: FINISHED")

    def show_help(self):
        self.logger.debug("show_help: Displaying help message.")
        QMessageBox.information(
            self,
            "EDSI Help",
            "Horse Management Screen:\n\n- Use the list on the left to select a horse.\n- Click 'Add Horse' or Ctrl+N to create a new record.\n- Click 'Edit Selected' to modify the current horse's basic info.\n- Tabs on the right show different aspects of the horse's data.\n- Use radio buttons to filter the list by status.\n- Search box filters by name, account, chip, etc.\n- F5 to refresh. Ctrl+S to save (when editing). Esc to discard (when editing).",
        )

    def display_details_state(self):
        self.logger.debug("display_details_state: START")
        if hasattr(self, "empty_frame") and self.empty_frame:
            self.empty_frame.hide()
        if (
            hasattr(self, "horse_details_content_widget")
            and self.horse_details_content_widget
        ):
            self.horse_details_content_widget.show()
        self.logger.debug("display_details_state: FINISHED")

    def update_status(self, message, timeout=4000):
        if hasattr(self, "status_label") and self.status_label:
            self.status_label.setText(message)
            if timeout > 0:
                QTimer.singleShot(
                    timeout, lambda: self.clear_status_if_matches(message)
                )

    def clear_status_if_matches(self, original_message):
        if (
            hasattr(self, "status_label")
            and self.status_label
            and self.status_label.text() == original_message
        ):
            self.status_label.setText("Ready")

    def handle_toggle_active_status(self):
        self.logger.debug("handle_toggle_active_status: START")
        if not self.current_horse:
            self.logger.warning("handle_toggle_active_status: No current horse.")
            return
        action_verb = "activate" if not self.current_horse.is_active else "deactivate"
        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        self.logger.debug(
            f"handle_toggle_active_status: Prompting to {action_verb} '{horse_name_display}'."
        )
        if self.show_question(
            f"Confirm {action_verb.capitalize()}",
            f"Are you sure you want to {action_verb} horse '{horse_name_display}'?",
        ):
            self.logger.info(
                f"handle_toggle_active_status: User confirmed. Calling controller to {action_verb}."
            )
            controller_method = (
                self.horse_controller.activate_horse
                if not self.current_horse.is_active
                else self.horse_controller.deactivate_horse
            )
            success, message = controller_method(
                self.current_horse.horse_id, self.current_user
            )
            if success:
                self.logger.info(
                    f"handle_toggle_active_status: {action_verb.capitalize()} successful. {message}"
                )
                self.show_info("Status Changed", message)
                self.load_horse_details(self.current_horse.horse_id)
                self.load_horses()
                if self.basic_info_tab and hasattr(
                    self.basic_info_tab, "populate_form_data"
                ):
                    self.basic_info_tab.populate_form_data(self.current_horse)
            else:
                self.logger.error(
                    f"handle_toggle_active_status: {action_verb.capitalize()} failed. {message}"
                )
                self.show_error(f"{action_verb.capitalize()} Failed", message)
        else:
            self.logger.info("handle_toggle_active_status: User cancelled.")
        self.logger.debug("handle_toggle_active_status: FINISHED")

    def handle_logout_request_from_menu(self):
        self.logger.info(
            f"handle_logout_request_from_menu: User '{self.current_user}' logout."
        )
        self.exit_requested.emit()

    def keyPressEvent(self, event: QKeyEvent):
        key = event.key()
        modifiers = QApplication.keyboardModifiers()
        self.logger.debug(f"keyPressEvent: Key {key}, Modifiers {modifiers}")
        if key == Qt.Key.Key_F5:
            self.refresh_data()
        elif modifiers == Qt.KeyboardModifier.ControlModifier and key == Qt.Key.Key_N:
            if (
                hasattr(self, "add_horse_btn")
                and self.add_horse_btn
                and self.add_horse_btn.isEnabled()
            ):
                self.add_new_horse()
        elif modifiers == Qt.KeyboardModifier.ControlModifier and key == Qt.Key.Key_S:
            if (
                self.tab_widget
                and self.basic_info_tab
                and self.tab_widget.currentWidget() == self.basic_info_tab
                and hasattr(self.basic_info_tab, "save_btn")
                and self.basic_info_tab.save_btn.isEnabled()
            ):
                self.logger.info("keyPressEvent: Ctrl+S triggering BasicInfoTab save.")
                self.basic_info_tab.save_requested.emit()
            else:
                self.logger.info(
                    "keyPressEvent: Ctrl+S conditions not met for BasicInfoTab save."
                )
        elif key == Qt.Key.Key_F1:
            self.show_help()
        elif key == Qt.Key.Key_Escape:
            active_modal_widget = QApplication.activeModalWidget()
            if active_modal_widget and isinstance(active_modal_widget, QDialog):
                self.logger.debug(
                    "keyPressEvent: Escape rejecting active modal dialog."
                )
                active_modal_widget.reject()
            elif self._has_changes_in_active_tab or self._is_new_mode:
                self.logger.debug("keyPressEvent: Escape triggering discard_changes.")
                self.discard_changes()
            elif (
                self.basic_info_tab
                and hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing
            ):
                self.logger.debug(
                    "keyPressEvent: Escape reverting BasicInfoTab to read-only."
                )
                self.discard_changes()
            else:
                super().keyPressEvent(event)
        else:
            super().keyPressEvent(event)

    def setup_connections(self):
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_CONNECTIONS START ---")
        if hasattr(self, "add_horse_btn") and self.add_horse_btn:
            self.add_horse_btn.clicked.connect(self.add_new_horse)
        if hasattr(self, "edit_horse_btn") and self.edit_horse_btn:
            self.edit_horse_btn.clicked.connect(self.edit_selected_horse)
        if hasattr(self, "refresh_btn") and self.refresh_btn:
            self.refresh_btn.clicked.connect(self.refresh_data)
        if hasattr(self, "help_btn") and self.help_btn:
            self.help_btn.clicked.connect(self.show_help)
        if hasattr(self, "setup_icon_btn") and self.setup_icon_btn:
            self.setup_icon_btn.clicked.connect(self.setup_requested.emit)
        if hasattr(self, "active_only_radio") and self.active_only_radio:
            self.active_only_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "all_horses_radio") and self.all_horses_radio:
            self.all_horses_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "deactivated_radio") and self.deactivated_radio:
            self.deactivated_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "search_input") and self.search_input:
            self.search_input.textChanged.connect(self.on_search_text_changed)
        if hasattr(self, "horse_list") and self.horse_list:
            self.horse_list.itemSelectionChanged.connect(self.on_selection_changed)
        if self.basic_info_tab:
            self.logger.info("Connecting BasicInfoTab signals.")
            if hasattr(self.basic_info_tab, "data_modified"):
                self.basic_info_tab.data_modified.connect(self._on_tab_data_modified)
            if hasattr(self.basic_info_tab, "save_requested"):
                self.basic_info_tab.save_requested.connect(self.save_changes)
            if hasattr(self.basic_info_tab, "discard_requested"):
                self.basic_info_tab.discard_requested.connect(self.discard_changes)
            if hasattr(self.basic_info_tab, "toggle_active_requested"):
                self.basic_info_tab.toggle_active_requested.connect(
                    self.handle_toggle_active_status_from_tab
                )
        else:
            self.logger.warning(
                "BasicInfoTab is None, its signals cannot be connected."
            )
        if self.owners_tab:
            self.logger.info("Connecting OwnersTab signals.")
            if hasattr(self.owners_tab, "owner_association_changed"):
                self.owners_tab.owner_association_changed.connect(
                    self._on_owner_association_changed
                )
        else:
            self.logger.warning("OwnersTab is None, its signals cannot be connected.")
        if self.location_tab:
            self.logger.info("Connecting LocationTab signals.")
            if hasattr(self.location_tab, "location_assignment_changed"):
                self.location_tab.location_assignment_changed.connect(
                    self._handle_location_assignment_change
                )
        else:
            self.logger.warning("LocationTab is None, its signals cannot be connected.")
        if self.billing_tab:
            self.logger.info("Connecting BillingTab signals (if any needed by parent).")
            # Example: if BillingTab emits a signal that HorseUnifiedManagement needs to react to
            # self.billing_tab.charges_updated.connect(self.handle_billing_charges_updated) # Placeholder
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_CONNECTIONS END ---")


=============== FILE: views\horse\dialogs\__init__.py ===============



=============== FILE: views\horse\dialogs\add_charge_dialog.py ===============

# views/horse/dialogs/add_charge_dialog.py
"""
EDSI Veterinary Management System - Add Charge Dialog
Version: 2.3.7
Purpose: Dialog for entering multiple charge transactions for a horse.
         - Added missing QAbstractSpinBox import.
Last Updated: June 6, 2025
Author: Gemini
"""

import logging
from decimal import Decimal, InvalidOperation
from datetime import date
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QPushButton,
    QLabel,
    QDialogButtonBox,
    QMessageBox,
    QWidget,
    QHBoxLayout,
    QSpacerItem,
    QSizePolicy,
    QToolButton,
    QScrollArea,
    QFormLayout,
    QDoubleSpinBox,
    QTextEdit,
    QAbstractSpinBox,
    QHeaderView,
    QStyledItemDelegate,
    QLineEdit,
    QCompleter,
    QCheckBox,
)
from PySide6.QtCore import Qt, Signal, QTimer, QEvent, QSize, Slot
from PySide6.QtGui import QFont, QIcon, QColor

from models import Horse, Transaction, ChargeCode
from controllers import FinancialController, ChargeCodeController
from config.app_config import AppConfig
from ..widgets.charge_line_item_widget import ChargeLineItemWidget


class AddChargeDialog(QDialog):
    """A dialog for adding multiple charge items for a horse."""

    charges_saved = Signal(list)

    def __init__(
        self,
        horse: Horse,
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse = horse
        self.financial_controller = financial_controller
        self.charge_code_controller = ChargeCodeController()

        self.setWindowTitle(f"Add Charges for: {self.horse.horse_name}")
        self.setMinimumSize(1200, 750)

        self._charge_codes_list: List[ChargeCode] = []
        self._charge_widgets: List[ChargeLineItemWidget] = []

        self._setup_ui_elements()
        self._setup_layout()
        self._apply_styles()
        self._setup_connections()

        self._populate_header()
        QTimer.singleShot(0, self._load_initial_data)

    def _setup_ui_elements(self):
        self.horse_title_label = QLabel()
        self.horse_info_line_label = QLabel()

        self.scroll_area = QScrollArea()
        self.scroll_content_widget = QWidget()
        self.charges_layout = QVBoxLayout(self.scroll_content_widget)

        self.add_row_btn = QPushButton("➕ Add")
        self.remove_row_btn = QPushButton("➖ Remove")

        self.subtotal_label = QLabel("$0.00")
        self.taxable_subtotal_label = QLabel("$0.00")
        self.tax_amount_input = QDoubleSpinBox()
        self.grand_total_label = QLabel("$0.00")

        self.button_box = QDialogButtonBox()
        self.save_button = self.button_box.addButton(
            "Save Charges", QDialogButtonBox.ButtonRole.AcceptRole
        )
        self.cancel_button = self.button_box.addButton(
            "Cancel", QDialogButtonBox.ButtonRole.RejectRole
        )

    def _setup_layout(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)

        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 5)
        header_layout.setSpacing(5)
        header_layout.addWidget(self.horse_title_label)
        header_layout.addWidget(self.horse_info_line_label)
        main_layout.addWidget(header_widget)

        top_action_layout = QHBoxLayout()
        title_label = QLabel("Enter Charges")
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        title_label.setFont(title_font)
        title_label.setStyleSheet(f"color: {AppConfig.DARK_TEXT_SECONDARY};")
        top_action_layout.addWidget(title_label)
        top_action_layout.addStretch()
        top_action_layout.addWidget(self.add_row_btn)
        top_action_layout.addWidget(self.remove_row_btn)
        main_layout.addLayout(top_action_layout)

        self.charges_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.scroll_area.setWidget(self.scroll_content_widget)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setObjectName("ChargeScrollArea")
        main_layout.addWidget(self.scroll_area, 1)

        footer_layout = QHBoxLayout()
        footer_layout.setContentsMargins(0, 10, 0, 0)
        footer_layout.addWidget(self.button_box)
        footer_layout.addStretch()
        totals_form_layout = self._create_totals_layout()
        footer_layout.addLayout(totals_form_layout)
        main_layout.addLayout(footer_layout)

    def _create_totals_layout(self) -> QFormLayout:
        totals_layout = QFormLayout()
        totals_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        totals_layout.addRow("Subtotal:", self.subtotal_label)
        totals_layout.addRow("Taxable Subtotal:", self.taxable_subtotal_label)
        totals_layout.addRow("Tax Amount:", self.tax_amount_input)
        totals_layout.addRow("<b>Grand Total:</b>", self.grand_total_label)
        return totals_layout

    def _populate_header(self):
        self.horse_title_label.setText(self.horse.horse_name)
        owner = self.horse.owners[0] if self.horse.owners else None
        owner_name = "No Owner"
        acct_num = "N/A"
        if owner:
            owner_name_parts = [
                name for name in [owner.first_name, owner.last_name] if name
            ]
            owner_name = " ".join(owner_name_parts)
            if owner.farm_name:
                owner_name = f"{owner_name} ({owner.farm_name})"
            acct_num = owner.account_number or "N/A"

        age_str = "N/A"
        if self.horse.date_of_birth:
            today = date.today()
            age = (
                today.year
                - self.horse.date_of_birth.year
                - (
                    (today.month, today.day)
                    < (self.horse.date_of_birth.month, self.horse.date_of_birth.day)
                )
            )
            age_str = f"{age} yrs"

        location = self.horse.location
        location_name = location.location_name if location else "N/A"

        info_parts = [
            f"Acct: {acct_num}",
            f"👥 {owner_name}",
            f"Breed: {self.horse.breed or 'N/A'}",
            f"Color: {self.horse.color or 'N/A'}",
            f"Sex: {self.horse.sex or 'N/A'}",
            f"Age: {age_str}",
            f"📍 {location_name}",
        ]
        self.horse_info_line_label.setText(" | ".join(info_parts))

    def _apply_styles(self):
        self.horse_title_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 18, QFont.Weight.Bold)
        )
        self.horse_title_label.setStyleSheet(f"color:{AppConfig.DARK_TEXT_PRIMARY};")
        self.horse_info_line_label.setStyleSheet(
            f"color:{AppConfig.DARK_TEXT_SECONDARY}; font-size: 11px;"
        )

        self.tax_amount_input.setDecimals(2)
        self.tax_amount_input.setRange(0.00, 99999.99)
        self.tax_amount_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)

        totals_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 11)
        totals_font.setBold(True)
        self.grand_total_label.setFont(totals_font)
        self.grand_total_label.setStyleSheet(
            f"color: white; font-size: 14px; font-weight: bold;"
        )

        button_style = f"""
            QPushButton {{
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px; padding: 5px 10px;
                font-size: 12px; font-weight: 500;
                min-height: 28px;
            }}
            QPushButton:hover {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
        """
        self.add_row_btn.setStyleSheet(
            button_style + f"background-color: {AppConfig.DARK_BUTTON_BG};"
        )
        self.remove_row_btn.setStyleSheet(
            button_style + f"background-color: {AppConfig.DARK_BUTTON_BG};"
        )

        self.save_button.setMinimumSize(120, 40)
        self.cancel_button.setMinimumSize(120, 40)

        save_style = (
            button_style
            + f"background-color: {AppConfig.DARK_SUCCESS_ACTION}; color: white;"
        )
        cancel_style = button_style.replace(
            AppConfig.DARK_DANGER_ACTION, AppConfig.DARK_BUTTON_BG
        )

        self.save_button.setStyleSheet(save_style)
        self.cancel_button.setStyleSheet(cancel_style)

    def _setup_connections(self):
        self.add_row_btn.clicked.connect(self._add_charge_widget)
        self.remove_row_btn.clicked.connect(self._remove_last_charge_widget)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.tax_amount_input.valueChanged.connect(self._update_totals)

    def _load_initial_data(self):
        self._charge_codes_list = (
            self.financial_controller.get_charge_codes_for_lookup()
        )
        if not self._charge_codes_list:
            self._charge_codes_list = []
        self.logger.debug(f"Loaded {len(self._charge_codes_list)} charge codes.")
        self._add_charge_widget()

    def _add_charge_widget(self):
        charge_widget = ChargeLineItemWidget(self._charge_codes_list, self)
        charge_widget.remove_requested.connect(self._remove_charge_widget)
        charge_widget.amount_changed.connect(self._update_totals)

        self.charges_layout.addWidget(charge_widget)
        self._charge_widgets.append(charge_widget)
        self._update_totals()
        charge_widget.charge_code_input.setFocus()

    @Slot(QWidget)
    def _remove_charge_widget(self, widget: QWidget):
        if widget in self._charge_widgets:
            self._charge_widgets.remove(widget)
            widget.deleteLater()
            self._update_totals()

    def _remove_last_charge_widget(self):
        if self._charge_widgets:
            widget_to_remove = self._charge_widgets[-1]
            self._remove_charge_widget(widget_to_remove)

    def _update_totals(self):
        subtotal = Decimal(0)
        taxable_subtotal = Decimal(0)

        for widget in self._charge_widgets:
            data = widget.get_data()
            if data and data.get("total_price") is not None:
                line_total = data.get("total_price", Decimal(0))
                subtotal += line_total
                if data.get("taxable", False):
                    taxable_subtotal += line_total

        manual_tax = Decimal(self.tax_amount_input.value())
        grand_total = subtotal + manual_tax

        self.subtotal_label.setText(f"${subtotal:.2f}")
        self.taxable_subtotal_label.setText(f"${taxable_subtotal:.2f}")
        self.grand_total_label.setText(f"${grand_total:.2f}")

    def accept(self):
        charges_to_save = []
        for widget in self._charge_widgets:
            data = widget.get_data()
            if data:
                charges_to_save.append(data)

        if not charges_to_save:
            QMessageBox.warning(
                self, "No Charges", "Please add at least one valid charge item."
            )
            return

        success, message, new_transactions = (
            self.financial_controller.add_charge_batch_to_horse(
                horse_id=self.horse.horse_id,
                owner_id=self.horse.owners[0].owner_id,
                charge_items=charges_to_save,
                batch_transaction_date=date.today(),
                administered_by_user_id=QApplication.instance().current_user_id,
            )
        )

        if success:
            self.charges_saved.emit(new_transactions)
            super().accept()
        else:
            QMessageBox.critical(self, "Error Saving Charges", message)


=============== FILE: views\horse\dialogs\add_edit_location_dialog.py ===============

# views/admin/dialogs/add_edit_location_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Location Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing practice locations.
Last Updated: May 19, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-05-19):
    - Initial implementation for adding and editing locations.
    - Fields: Location Name, Description, Is Active.
    - Uses LocationController for backend operations.
    - Styled for dark theme using imported constants.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QTextEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.location_controller import LocationController
from models import Location as LocationModel

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class AddEditLocationDialog(QDialog):
    def __init__(
        self,
        parent_view,
        controller: LocationController,
        current_user_id: str,
        location: Optional[LocationModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.controller = controller
        self.current_user_id = current_user_id
        self.location = location
        self.is_edit_mode = location is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Location")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()
        if self.is_edit_mode and self.location:
            self._populate_fields()

    def _get_dialog_specific_input_field_style(self) -> str:
        """Generates style string for input fields within this dialog."""
        return f"""
            QLineEdit, QTextEdit {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QTextEdit:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        """Generates generic button style string for this dialog."""
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.WrapAllRows)
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)

        input_style = self._get_dialog_specific_input_field_style()
        dialog_styles = (
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top:3px; }}"
            + f"QCheckBox::indicator {{ width: 13px; height: 13px; }}"
        )
        self.setStyleSheet(dialog_styles)

        self.location_name_input = QLineEdit()
        self.location_name_input.setStyleSheet(input_style)
        self.location_name_input.setPlaceholderText("e.g., Main Barn, Paddock A")
        form_layout.addRow("Location Name*:", self.location_name_input)

        self.description_input = QTextEdit()
        self.description_input.setStyleSheet(input_style)
        self.description_input.setPlaceholderText(
            "Optional description or details about the location"
        )
        self.description_input.setFixedHeight(80)
        form_layout.addRow("Description:", self.description_input)

        self.is_active_checkbox = QCheckBox("Location is Active")
        self.is_active_checkbox.setChecked(True)  # Default to active for new locations
        form_layout.addRow("", self.is_active_checkbox)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith("#"):
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        """Populates fields if in edit mode."""
        if self.location:  # Should always be true if self.is_edit_mode is true
            self.location_name_input.setText(self.location.location_name)
            self.description_input.setPlainText(self.location.description or "")
            self.is_active_checkbox.setChecked(self.location.is_active)

    def get_data(self) -> Dict[str, Any]:
        """Collects data from the form fields."""
        return {
            "location_name": self.location_name_input.text().strip(),
            "description": self.description_input.toPlainText().strip(),
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        """Validates form data and accepts dialog if valid."""
        data = self.get_data()

        # Use controller's validation method
        is_valid, errors = self.controller.validate_location_data(
            data,
            is_new=(not self.is_edit_mode),
            location_id_to_check_for_unique=(
                self.location.location_id
                if self.is_edit_mode and self.location
                else None
            ),
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return  # Keep dialog open

        try:
            if self.is_edit_mode and self.location:
                success, message = self.controller.update_location(
                    self.location.location_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_location(
                    data, self.current_user_id
                )

            if success:
                # Show info message from the parent view for consistency if possible
                if hasattr(self.parent(), "show_info"):
                    self.parent().show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()  # Close dialog with Accepted state
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
                # Keep dialog open if controller indicates failure that might be correctable
        except Exception as e:
            self.logger.error(f"Error during location save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )
            # Keep dialog open


=============== FILE: views\horse\dialogs\create_link_owner_dialog.py ===============

# views/horse/dialogs/create_link_owner_dialog.py
"""
EDSI Veterinary Management System - Create New Owner and Link Dialog
Version: 1.0.8
Purpose: Dialog for creating a new owner and linking them to a horse with a percentage.
         - Corrected tuple unpacking error in _setup_ui by ensuring all field
           definitions in `fields_setup` list have a consistent number of elements.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.0.8 (2025-05-26):
    - In `_setup_ui`, standardized the tuples in the `fields_setup` list to consistently
      provide 8 elements (label, name, layout coordinates, widget_type_str, placeholder).
    - Updated the for-loop unpacking these tuples to match the 8 elements,
      resolving the "ValueError: not enough values to unpack".
- v1.0.7 (2025-05-26):
    - Modified `__init__` to accept an optional `total_ownership_validator` callback.
    - Updated `validate_and_accept` to call this external validator.
- v1.0.6 (2025-05-26):
    - Redesigned UI to use a two-column QGridLayout for owner detail fields.
# ... (rest of previous changelog entries assumed present)
"""

import logging
from typing import Optional, Dict, List, Callable

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QComboBox,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QWidget,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class CreateAndLinkOwnerDialog(QDialog):
    def __init__(
        self,
        parent_view,
        horse_name: str,
        current_user_login: str,
        total_ownership_validator: Optional[
            Callable[[Optional[int], float], bool]
        ] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_name = horse_name
        self.current_user_login = current_user_login
        self.owner_controller = OwnerController()
        self.total_ownership_validator = total_ownership_validator

        self.setWindowTitle(f"Create & Link New Owner to {self.horse_name}")
        self.setMinimumWidth(750)

        self._setup_palette()
        self._setup_ui()

        if "state_code" in self.form_fields and isinstance(
            self.form_fields["state_code"], QComboBox
        ):
            self._populate_states_combo(self.form_fields["state_code"])

    def _get_dialog_specific_input_field_style(self):
        # (Same as v1.0.7)
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; subcontrol-position: right center; width: 15px; }}
            QComboBox::down-arrow {{ image: url(none); }} /* Consider a Qt built-in or SVG icon for better dark theme compatibility */
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }} """

    def _get_dialog_generic_button_style(self):
        # (Same as v1.0.7)
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        # (Same as v1.0.7)
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        main_dialog_layout = QVBoxLayout(self)
        main_dialog_layout.setSpacing(15)
        main_dialog_layout.setContentsMargins(15, 15, 15, 15)

        instruction_label = QLabel(
            f"Enter details for the new owner to be linked to <b>{self.horse_name}</b>."
        )
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 5px; background-color: transparent;"
        )
        instruction_label.setWordWrap(True)
        main_dialog_layout.addWidget(instruction_label)

        grid_layout = QGridLayout()
        grid_layout.setHorizontalSpacing(20)
        grid_layout.setVerticalSpacing(10)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)

        self.form_fields = {}
        specific_input_style = self._get_dialog_specific_input_field_style()

        # Each tuple: (Label, field_name, r_lbl, c_lbl, r_fld, c_fld, widget_type_str, placeholder_or_None)
        fields_setup = [
            ("Farm Name:", "farm_name", 0, 0, 0, 1, "QLineEdit", None),
            ("Account #:", "account_number", 0, 2, 0, 3, "QLineEdit", None),
            ("First Name:", "first_name", 1, 0, 1, 1, "QLineEdit", None),
            ("Last Name*:", "last_name", 1, 2, 1, 3, "QLineEdit", None),
            ("Address 1*:", "address_line1", 2, 0, 2, 1, "QLineEdit", None),
            ("Address 2:", "address_line2", 2, 2, 2, 3, "QLineEdit", None),
            ("City*:", "city", 3, 0, 3, 1, "QLineEdit", None),
            ("State*:", "state_code", 3, 2, 3, 3, "QComboBox", None),
            ("Zip/Postal*:", "zip_code", 4, 0, 4, 1, "QLineEdit", None),
            ("Country:", "country_name", 4, 2, 4, 3, "QLineEdit", "e.g. USA"),
            ("Phone:", "phone", 5, 0, 5, 1, "QLineEdit", None),
            ("Email:", "email", 5, 2, 5, 3, "QLineEdit", None),
        ]

        for (
            label_text,
            field_name,
            r_lbl,
            c_lbl,
            r_fld,
            c_fld,
            widget_type_str,
            placeholder_text,
        ) in fields_setup:
            lbl = QLabel(label_text)
            grid_layout.addWidget(lbl, r_lbl, c_lbl, Qt.AlignmentFlag.AlignRight)

            widget: QWidget  # Type hint for clarity
            if widget_type_str == "QComboBox":
                widget = QComboBox()
            else:  # Default to QLineEdit
                widget = QLineEdit()
                if placeholder_text:  # Check if placeholder_text is not None
                    widget.setPlaceholderText(placeholder_text)

            widget.setStyleSheet(specific_input_style)
            self.form_fields[field_name] = widget
            grid_layout.addWidget(widget, r_fld, c_fld)

        # Row 6: Ownership Percentage and Active Checkbox
        self.percentage_input = QDoubleSpinBox()
        self.percentage_input.setRange(0.00, 100.00)
        self.percentage_input.setDecimals(2)
        self.percentage_input.setSuffix(" %")
        self.percentage_input.setValue(100.00)
        self.percentage_input.setStyleSheet(specific_input_style)
        grid_layout.addWidget(
            QLabel("Ownership %*:"), 6, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.percentage_input, 6, 1)

        self.form_fields["is_active"] = QCheckBox("Owner is Active")
        self.form_fields["is_active"].setChecked(True)
        self.form_fields["is_active"].setStyleSheet(
            f"QCheckBox{{color:{DARK_TEXT_SECONDARY};background:transparent;padding-top:3px;}}QCheckBox::indicator{{width:13px;height:13px;}}"
        )
        grid_layout.addWidget(
            self.form_fields["is_active"],
            6,
            3,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )  # Align left in its cell

        main_dialog_layout.addLayout(grid_layout)
        main_dialog_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(
            "Create & Link Owner"
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg = DARK_SUCCESS_ACTION
                ok_bg = (
                    f"#{ok_bg[1]*2}{ok_bg[2]*2}{ok_bg[3]*2}"
                    if len(ok_bg) == 4
                    else ok_bg
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton{{background-color:{ok_bg};color:white;}}"
                )
        main_dialog_layout.addWidget(self.button_box)
        self.setStyleSheet(
            f"QDialog{{background-color:{DARK_WIDGET_BACKGROUND};}} QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;padding-top:3px;}} QCheckBox::indicator{{width:13px;height:13px;}} QCheckBox{{color:{DARK_TEXT_SECONDARY};}}"
        )

    def _populate_states_combo(self, combo_box: QComboBox):
        # (Same as v1.0.7)
        try:
            ref_data = self.owner_controller.get_owner_form_reference_data()
            states: List[Dict[str, str]] = ref_data.get("states", [])
            combo_box.blockSignals(True)
            combo_box.clear()
            combo_box.addItem("", None)
            for state_data in states:
                combo_box.addItem(state_data["name"], state_data["id"])
            combo_box.blockSignals(False)
            self.logger.debug(f"Populated states: {len(states)}")
        except Exception as e:
            self.logger.error(f"Error populating states: {e}", exc_info=True)
            QMessageBox.warning(self, "Error", "Could not load states.")

    def validate_and_accept(self):
        # (Same as v1.0.7 - calls self.total_ownership_validator)
        owner_data = {}
        for field_name, widget in self.form_fields.items():
            if isinstance(widget, QLineEdit):
                owner_data[field_name] = widget.text().strip()
            elif isinstance(widget, QComboBox):
                owner_data[field_name] = widget.currentData()
            elif isinstance(widget, QCheckBox):
                owner_data[field_name] = widget.isChecked()
        percentage = self.percentage_input.value()

        is_valid, errors = self.owner_controller.validate_owner_data(
            owner_data, is_new=True
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct owner details:\n- " + "\n- ".join(errors),
            )
            return
        if not (0.00 <= percentage <= 100.00):
            QMessageBox.warning(
                self,
                "Input Error",
                "Ownership percentage must be between 0.00 and 100.00.",
            )
            return
        if self.total_ownership_validator:
            if not self.total_ownership_validator(
                None, percentage
            ):  # Pass None for owner_id_being_changed (new owner)
                self.logger.debug(
                    "External total ownership validation failed for new owner link."
                )
                return
        self.logger.debug("CreateAndLinkOwnerDialog validation successful, accepting.")
        super().accept()

    def get_data(self) -> Optional[Dict]:
        # (Same as v1.0.7)
        owner_details = {}
        for field_name, widget in self.form_fields.items():
            if isinstance(widget, QLineEdit):
                owner_details[field_name] = widget.text().strip()
            elif isinstance(widget, QComboBox):
                owner_details[field_name] = widget.currentData()
            elif isinstance(widget, QCheckBox):
                owner_details[field_name] = widget.isChecked()
        return {
            "owner_details": owner_details,
            "percentage": self.percentage_input.value(),
        }


=============== FILE: views\horse\dialogs\edit_charge_dialog.py ===============

# views/horse/dialogs/edit_charge_dialog.py
"""
EDSI Veterinary Management System - Edit Charge Dialog
Version: 1.0.1
Purpose: Dialog for editing the details of a single charge transaction.
         - Corrected primary key attribute name for Transaction model.
Last Updated: June 6, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-06-06):
    - Bug Fix: Corrected `self.transaction.id` to `self.transaction.transaction_id`
      in the `save_changes` method to match the model.
- v1.0.0 (2025-06-06):
    - Initial implementation of the dialog to edit a single charge transaction.
"""

import logging
from decimal import Decimal, InvalidOperation
from datetime import date
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QDialogButtonBox,
    QMessageBox,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QCheckBox,
    QTextEdit,
    QLabel,
)
from PySide6.QtCore import Qt, QDate

from models import Transaction
from controllers import FinancialController
from config.app_config import AppConfig


class EditChargeDialog(QDialog):
    """A dialog for editing a single charge item."""

    def __init__(
        self,
        transaction: Transaction,
        financial_controller: FinancialController,
        current_user_id: str,
        parent=None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.transaction = transaction
        self.financial_controller = financial_controller
        self.current_user_id = current_user_id

        self.setWindowTitle(f"Edit Charge: {self.transaction.description[:30]}...")
        self.setMinimumWidth(500)

        self._setup_ui()
        self._apply_styles()
        self._populate_form()

        self.button_box.accepted.connect(self.save_changes)
        self.button_box.rejected.connect(self.reject)

    def _setup_ui(self):
        """Initializes and lays out the UI widgets."""
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.service_date_edit = QDateEdit()
        self.service_date_edit.setCalendarPopup(True)
        self.service_date_edit.setDisplayFormat("yyyy-MM-dd")

        self.description_edit = QLineEdit()
        self.qty_spinbox = QDoubleSpinBox()
        self.price_spinbox = QDoubleSpinBox()
        self.taxable_checkbox = QCheckBox("This item is taxable")
        self.notes_edit = QTextEdit()

        form_layout.addRow("Service Date:", self.service_date_edit)
        form_layout.addRow("Description:", self.description_edit)
        form_layout.addRow("Quantity:", self.qty_spinbox)
        form_layout.addRow("Unit Price:", self.price_spinbox)
        form_layout.addRow("", self.taxable_checkbox)
        form_layout.addRow("Item Notes:", self.notes_edit)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Save
            | QDialogButtonBox.StandardButton.Cancel
        )

        layout.addLayout(form_layout)
        layout.addWidget(self.button_box)

    def _apply_styles(self):
        """Applies consistent styling to the dialog's widgets."""
        self.qty_spinbox.setDecimals(3)
        self.qty_spinbox.setRange(0.001, 9999.999)
        self.price_spinbox.setDecimals(2)
        self.price_spinbox.setRange(0.00, 99999.99)
        self.price_spinbox.setPrefix("$ ")
        self.notes_edit.setMinimumHeight(80)

    def _populate_form(self):
        """Fills the form widgets with data from the transaction object."""
        self.service_date_edit.setDate(QDate(self.transaction.transaction_date))
        self.description_edit.setText(self.transaction.description)
        self.qty_spinbox.setValue(float(self.transaction.quantity))
        self.price_spinbox.setValue(float(self.transaction.unit_price))
        self.taxable_checkbox.setChecked(self.transaction.taxable)
        self.notes_edit.setPlainText(self.transaction.notes or "")

    def get_data_from_form(self) -> Dict[str, Any]:
        """Collects and returns the current data from the form widgets."""
        return {
            "transaction_date": self.service_date_edit.date().toPython(),
            "description": self.description_edit.text().strip(),
            "quantity": Decimal(str(self.qty_spinbox.value())),
            "unit_price": Decimal(str(self.price_spinbox.value())),
            "taxable": self.taxable_checkbox.isChecked(),
            "notes": self.notes_edit.toPlainText().strip() or None,
        }

    def save_changes(self):
        """Validates and saves the changes via the financial controller."""
        updated_data = self.get_data_from_form()

        if not updated_data["description"]:
            QMessageBox.warning(
                self, "Validation Error", "Description cannot be empty."
            )
            return

        success, message = self.financial_controller.update_charge_transaction(
            transaction_id=self.transaction.transaction_id,  # FIXED
            data=updated_data,
            current_user_id=self.current_user_id,
        )

        if success:
            QMessageBox.information(self, "Success", message)
            self.accept()
        else:
            QMessageBox.critical(self, "Error", message)


=============== FILE: views\horse\dialogs\link_existing_owner_dialog.py ===============

# views/horse/dialogs/link_existing_owner_dialog.py
"""
EDSI Veterinary Management System - Link Existing Owner Dialog
Version: 1.0.4
Purpose: Dialog for selecting an existing owner and linking them to a horse.
         Allows 0% ownership and ensures dialog stays open on validation error.
Last Updated: May 19, 2025
Author: Claude Assistant

Changelog:
- v1.0.4 (2025-05-19):
    - Changed percentage_input range and validation to allow 0.00%.
    - Ensured dialog validation logic explicitly keeps dialog open on error.
- v1.0.3 (2025-05-19):
    - Resolved AppConfig constant AttributeError by importing constants directly.
    - Removed import of UserManagementScreen and localized style helper methods.
    - Added missing `from typing import Optional, Dict, List`.
    - Improved UI consistency, label alignment, and QComboBox population logic.
    - Ensured setAutoFillBackground(True) is called after setPalette.
    - Set a base stylesheet for the dialog to ensure `QLabel` color is consistent.
- v1.0.2 (User's May 17th version):
    - Changed percentage_spinbox minimum to 0.00 to allow 0% ownership.
    - Updated percentage validation in `get_data` to allow 0%.
"""
import logging
from typing import Optional, Dict, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QComboBox,
    QDoubleSpinBox,
    QDialogButtonBox,
    QMessageBox,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController
from models import Owner as OwnerModel

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class LinkExistingOwnerDialog(QDialog):
    def __init__(self, parent_view_or_dialog, horse_name: str):
        super().__init__(parent_view_or_dialog)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_name = horse_name
        self.owner_controller = OwnerController()
        self.owners_list: List[OwnerModel] = []
        self.selected_owner_id: Optional[int] = None

        self.setWindowTitle(f"Link Existing Owner to {self.horse_name}")
        self.setMinimumWidth(500)

        self._setup_palette()
        self._setup_ui()
        self._load_owners_and_search()

    def _get_dialog_specific_input_field_style(self) -> str:
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; subcontrol-position: right center; width: 15px; }}
            QComboBox::down-arrow {{ image: url(none); }}
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }} """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _get_dialog_list_widget_style(self) -> str:
        return f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none; border-radius: 4px;
            }}
            QListWidget::item {{ padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND}; }}
            QListWidget::item:selected {{ background-color: {DARK_PRIMARY_ACTION}4D; color: #ffffff; border-left: 3px solid {DARK_PRIMARY_ACTION}; }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }} """

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(12)
        layout.setContentsMargins(15, 15, 15, 15)
        self.setStyleSheet(
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; }}"
        )
        instruction_label = QLabel(
            f"Search for an existing owner to link to <b>{self.horse_name}</b>, select them from the list, then specify their ownership percentage."
        )
        instruction_label.setWordWrap(True)
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 8px; background-color: transparent;"
        )
        layout.addWidget(instruction_label)
        input_style = self._get_dialog_specific_input_field_style()
        list_widget_style = self._get_dialog_list_widget_style()
        search_layout = QHBoxLayout()
        search_label = QLabel("Search Owner:")
        self.owner_search_input = QLineEdit()
        self.owner_search_input.setPlaceholderText("Name or Account #")
        self.owner_search_input.setStyleSheet(input_style)
        self.owner_search_input.textChanged.connect(self._load_owners_and_search)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.owner_search_input, 1)
        layout.addLayout(search_layout)
        self.owner_results_list = QListWidget()
        self.owner_results_list.setStyleSheet(list_widget_style)
        self.owner_results_list.setFixedHeight(150)
        self.owner_results_list.itemClicked.connect(self._on_owner_selected_from_search)
        layout.addWidget(self.owner_results_list)
        self.selected_owner_label = QLabel("Selected Owner:")
        self.selected_owner_display_text = QLabel("<i>No owner selected</i>")
        self.selected_owner_display_text.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-style: italic; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
        )
        self.selected_owner_display_text.setMinimumHeight(20 + 12)
        layout.addWidget(self.selected_owner_label)
        layout.addWidget(self.selected_owner_display_text)
        percentage_layout = QHBoxLayout()
        percentage_label = QLabel("Ownership %:*")
        percentage_label.setAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        self.percentage_spinbox = QDoubleSpinBox()
        self.percentage_spinbox.setStyleSheet(input_style)
        self.percentage_spinbox.setRange(0.00, 100.00)  # MODIFIED: Allow 0.00
        self.percentage_spinbox.setDecimals(2)
        self.percentage_spinbox.setSuffix(" %")
        self.percentage_spinbox.setValue(100.00)
        percentage_layout.addWidget(percentage_label)
        percentage_layout.addWidget(self.percentage_spinbox)
        percentage_layout.addStretch()
        layout.addLayout(percentage_layout)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText("Link Owner")
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)
        self.button_box.accepted.connect(self._validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith("#"):
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _load_owners_and_search(self):
        search_term = (
            self.owner_search_input.text()
            if hasattr(self, "owner_search_input")
            else ""
        )
        try:
            self.owners_list = self.owner_controller.get_all_owners_for_lookup(
                search_term
            )
            self.owner_results_list.blockSignals(True)
            self.owner_results_list.clear()
            if self.owners_list:
                for o_data in self.owners_list:
                    item = QListWidgetItem(o_data["name_account"])
                    item.setData(Qt.ItemDataRole.UserRole, o_data["id"])
                    self.owner_results_list.addItem(item)
            else:
                self.owner_results_list.addItem(
                    "No owners found matching search."
                    if search_term
                    else "No active owners available."
                )
            self.owner_results_list.blockSignals(False)
        except Exception as e:
            self.logger.error(f"Error loading/searching owners: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Load Error", "Could not load existing owners for search."
            )
            self.owner_results_list.blockSignals(True)
            self.owner_results_list.clear()
            self.owner_results_list.addItem("Error loading owners")
            self.owner_results_list.blockSignals(False)
        self._clear_selection_state()

    def _on_owner_selected_from_search(self, item: QListWidgetItem):
        owner_id = item.data(Qt.ItemDataRole.UserRole)
        if owner_id is not None:
            self.selected_owner_id = owner_id
            self.selected_owner_display_text.setText(item.text())
            self.selected_owner_display_text.setStyleSheet(
                f"color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
            )
            self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(True)
            self.logger.info(
                f"Owner selected from search: ID {self.selected_owner_id}, Display: {item.text()}"
            )
        else:
            self._clear_selection_state()

    def _clear_selection_state(self):
        self.selected_owner_id = None
        self.selected_owner_display_text.setText("<i>No owner selected</i>")
        self.selected_owner_display_text.setStyleSheet(
            f"color: {DARK_TEXT_TERTIARY}; font-style: italic; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)

    def _validate_and_accept(self):
        if self.selected_owner_id is None:
            QMessageBox.warning(
                self,
                "Selection Error",
                "Please search for and select an owner from the list.",
            )
            return  # Keep dialog open
        percentage = self.percentage_spinbox.value()
        if not (0.00 <= percentage <= 100.00):  # MODIFIED: Allow 0.00
            QMessageBox.warning(
                self,
                "Input Error",
                "Ownership percentage must be between 0.00 and 100.00.",
            )
            return  # Keep dialog open
        self.logger.debug("LinkExistingOwnerDialog validation successful, accepting.")
        super().accept()  # Close dialog with Accepted result

    def get_data(self) -> Optional[Dict]:
        if self.selected_owner_id is None:
            return None
        return {
            "owner_id": self.selected_owner_id,
            "percentage": self.percentage_spinbox.value(),
        }


=============== FILE: views\horse\dialogs\select_existing_location_dialog.py ===============

# views/horse/dialogs/select_existing_location_dialog.py
"""
EDSI Veterinary Management System - Select Existing Location Dialog
Version: 1.0.0
Purpose: Dialog for searching and selecting an existing active location.
Last Updated: May 20, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-05-20):
    - Initial implementation.
    - UI with search input (QLineEdit) and results list (QListWidget).
    - Fetches active locations using LocationController.
    - Search functionality filters locations by name (case-insensitive).
    - "Select Location" (OK) button enabled only when a location is selected.
    - Provides get_selected_location_id() method.
    - Styled for dark theme.
"""

import logging
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QDialogButtonBox,
    QApplication,  # For clipboard
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt, QTimer

from controllers.location_controller import LocationController
from models import Location as LocationModel  # Import the model

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class SelectExistingLocationDialog(QDialog):
    """Dialog to search and select an existing active location."""

    def __init__(self, parent_view, horse_name: str):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_name = horse_name
        self.location_controller = LocationController()
        self.all_active_locations: List[LocationModel] = []
        self.selected_location_id: Optional[int] = None

        self.setWindowTitle(f"Select Location for {self.horse_name}")
        self.setMinimumWidth(450)
        self.setMinimumHeight(350)

        self._setup_palette()
        self._setup_ui()
        self._load_initial_locations()

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self._filter_locations_list)

    def _get_dialog_specific_input_field_style(self) -> str:
        return f"""
            QLineEdit {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _get_dialog_list_widget_style(self) -> str:
        return f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none; border-radius: 4px;
            }}
            QListWidget::item {{ padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND}; }}
            QListWidget::item:selected {{ background-color: {DARK_PRIMARY_ACTION}4D; color: #ffffff; border-left: 3px solid {DARK_PRIMARY_ACTION}; }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }}
        """

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)
        self.setStyleSheet(
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; }}"
        )

        instruction_label = QLabel(
            f"Search for and select a location to assign to <b>{self.horse_name}</b>."
        )
        instruction_label.setWordWrap(True)
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 5px; background-color: transparent;"
        )
        layout.addWidget(instruction_label)

        input_style = self._get_dialog_specific_input_field_style()
        list_widget_style = self._get_dialog_list_widget_style()

        search_layout = QHBoxLayout()
        search_label = QLabel("Search Location:")
        self.location_search_input = QLineEdit()
        self.location_search_input.setPlaceholderText(
            "Enter location name to search..."
        )
        self.location_search_input.setStyleSheet(input_style)
        self.location_search_input.textChanged.connect(self._on_search_text_changed)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.location_search_input, 1)
        layout.addLayout(search_layout)

        self.locations_results_list = QListWidget()
        self.locations_results_list.setStyleSheet(list_widget_style)
        self.locations_results_list.itemClicked.connect(self._on_location_selected)
        layout.addWidget(self.locations_results_list, 1)  # Give stretch factor

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        self.ok_button.setText("Select Location")
        self.ok_button.setEnabled(False)  # Disabled until a location is selected

        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if button == self.ok_button:
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith(
                    "#"
                ):  # Expand 3-digit hex
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _load_initial_locations(self):
        try:
            self.all_active_locations = self.location_controller.get_all_locations(
                status_filter="active"
            )
            self._filter_locations_list()  # Populate initially with all active
            self.logger.info(
                f"Loaded {len(self.all_active_locations)} active locations initially."
            )
        except Exception as e:
            self.logger.error(
                f"Error loading initial active locations: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Load Error", "Could not load active locations.")
            self.locations_results_list.addItem("Error loading locations.")

    def _on_search_text_changed(self):
        self.search_timer.start(300)  # Debounce search

    def _filter_locations_list(self):
        search_term = self.location_search_input.text().strip().lower()
        self.locations_results_list.clear()
        self.selected_location_id = None  # Clear selection on new search
        self.ok_button.setEnabled(False)

        found_any = False
        for loc in self.all_active_locations:
            if search_term in loc.location_name.lower():
                item_text = f"{loc.location_name}"
                if loc.city and loc.state_code:
                    item_text += f" ({loc.city}, {loc.state_code})"
                elif loc.city:
                    item_text += f" ({loc.city})"

                list_item = QListWidgetItem(item_text)
                list_item.setData(Qt.ItemDataRole.UserRole, loc.location_id)
                self.locations_results_list.addItem(list_item)
                found_any = True

        if not found_any:
            self.locations_results_list.addItem(
                "No locations match your search."
                if search_term
                else "No active locations found."
            )

    def _on_location_selected(self, item: QListWidgetItem):
        location_id = item.data(Qt.ItemDataRole.UserRole)
        if location_id is not None:
            self.selected_location_id = location_id
            self.ok_button.setEnabled(True)
            self.logger.info(
                f"Location selected: ID {self.selected_location_id}, Display: {item.text()}"
            )
        else:
            self.selected_location_id = None
            self.ok_button.setEnabled(False)
            self.logger.info("Location selection cleared or invalid item clicked.")

    def get_selected_location_id(self) -> Optional[int]:
        """Returns the ID of the selected location if the dialog was accepted."""
        if self.result() == QDialog.DialogCode.Accepted:
            return self.selected_location_id
        return None


=============== FILE: views\horse\tabs\__init__.py ===============



=============== FILE: views\horse\tabs\basic_info_tab.py ===============

# views/horse/tabs/basic_info_tab.py
"""
EDSI Veterinary Management System - Horse Basic Info Tab
Version: 1.2.20
Purpose: UI for displaying and editing basic information of a horse.
         - Implemented robust owner name display logic in populate_form_data
           for the owner_display_label.
Last Updated: May 26, 2025
Author: Gemini

Changelog:
- v1.2.20 (2025-05-26):
    - Updated `populate_form_data` to use more robust logic for displaying the
      primary owner's name in `owner_display_label`. It now constructs the
      name from farm_name, first_name, and last_name attributes of the
      Owner model, similar to the logic in HorseUnifiedManagement's header.
- v1.2.19 (2025-05-26):
    - Added `owner_display_label` (QLabel) to show the primary owner's name.
    - Positioned "Owner" field in the grid layout below "Location".
    - Updated `populate_form_data` and `clear_fields`.
- v1.2.18 (2025-05-25):
    - Modified `get_data_from_form` to return Python `datetime.date` objects.
# ... (rest of previous changelog entries assumed present)
"""
import logging
from typing import Optional, Dict, Any, TYPE_CHECKING
from datetime import date

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QDateEdit,
    QLabel,
    QComboBox,
    QFrame,
    QScrollArea,
    QHBoxLayout,
    QPushButton,
    QTextEdit,
    QFormLayout,
)
from PySide6.QtCore import Qt, Signal, QDate, QSize  # QSize for icon placeholder
from PySide6.QtGui import QDoubleValidator, QIcon  # QIcon for icon placeholder

from controllers.horse_controller import HorseController

# No direct import of OwnerModel here, assuming Horse object has it via relationship

if TYPE_CHECKING:
    from models import Horse, Owner as OwnerModel  # For type hinting horse_data.owners


class BasicInfoTab(QWidget):
    data_modified = Signal()
    save_requested = Signal()
    discard_requested = Signal()
    toggle_active_requested = Signal(bool)
    edit_mode_toggled = Signal(bool)

    SEX_OPTIONS = ["Unknown", "Stallion", "Mare", "Gelding", "Colt", "Filly"]

    INPUT_FIELD_STYLE = (
        "background-color: #3E3E3E; "
        "color: white; "
        "border: 1px solid #B0B0B0; "
        "border-radius: 3px; "
        "padding: 5px;"
    )
    TEXT_AREA_STYLE = INPUT_FIELD_STYLE
    COMBO_DATE_STYLE = INPUT_FIELD_STYLE
    DEACTIVATE_BUTTON_STYLE = (
        "QPushButton {"
        "background-color: #FFC107; color: black; border: 1px solid #707070; "
        "border-radius: 3px; padding: 6px 12px; }"
        "QPushButton:hover { background-color: #FFD54F; }"
        "QPushButton:pressed { background-color: #FFA000; }"
    )
    DISCARD_BUTTON_STYLE = (
        "QPushButton {"
        "background-color: #212121; color: white; border: 1px solid #707070; "
        "border-radius: 3px; padding: 6px 12px; }"
        "QPushButton:hover { background-color: #424242; }"
        "QPushButton:pressed { background-color: #000000; }"
    )
    SAVE_BUTTON_STYLE = (
        "QPushButton {"
        "background-color: #607D8B; color: white; border: 1px solid #707070; "
        "border-radius: 3px; padding: 6px 12px; }"
        "QPushButton:hover { background-color: #78909C; }"
        "QPushButton:pressed { background-color: #546E7A; }"
    )

    def __init__(
        self,
        horse_controller: Optional[HorseController] = None,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_controller = (
            horse_controller if horse_controller else HorseController()
        )
        self.parent_view: Optional[QWidget] = parent

        self.current_horse_id: Optional[int] = None
        self._is_new_mode: bool = False
        self._is_editing: bool = False
        self._has_unsaved_changes: bool = False
        self._current_horse_is_active: bool = True

        # UI Elements
        self.horse_name_input: QLineEdit
        self.breed_input: QLineEdit
        self.sex_combo: QComboBox
        self.reg_number_input: QLineEdit
        self.tattoo_number_input: QLineEdit
        self.location_display_label: QLabel
        self.owner_display_label: QLabel  # Added in v1.2.19

        self.account_number_input: QLineEdit
        self.color_input: QLineEdit
        self.dob_input: QDateEdit
        self.microchip_id_input: QLineEdit
        self.brand_input: QLineEdit
        self.band_tag_input: QLineEdit

        self.coggins_date_input: QDateEdit
        self.height_input: QLineEdit
        self.description_input: QTextEdit

        self.save_btn: QPushButton
        self.discard_btn: QPushButton
        self.toggle_active_btn: QPushButton

        self._suppress_data_changed_signal = False
        self._setup_ui()
        self.set_form_read_only(True)
        self.update_buttons_state(
            is_editing_or_new=False, has_selection=False, has_changes=False
        )

    def _setup_ui(self):
        # (Setup for layout, scroll_area, content_widget, top_grid_layout same as v1.2.19)
        # (Rows 0-5 for Name to Band/Tag same as v1.2.19)
        # (NEW Row 6: Owner is already in v1.2.19 _setup_ui as per my last response)
        # (Coggins/Height layout, Description layout, Buttons layout same as v1.2.19)
        # For brevity, re-confirming the structure is as per previous response that added owner_display_label.
        # The only change is ensuring populate_form_data correctly fills owner_display_label.
        # All other UI setup code from v1.2.19 (which included adding the owner_display_label to the grid) remains.

        # --- Full _setup_ui from v1.2.19 (which included owner_display_label) ---
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        scroll_area = QScrollArea(self)
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        content_widget = QWidget()
        outer_layout = QVBoxLayout(content_widget)
        outer_layout.setContentsMargins(15, 15, 15, 15)
        outer_layout.setSpacing(15)
        top_grid_layout = QGridLayout()
        top_grid_layout.setSpacing(10)
        top_grid_layout.setHorizontalSpacing(20)
        top_grid_layout.setColumnStretch(1, 1)
        top_grid_layout.setColumnStretch(3, 1)

        # Row 0
        top_grid_layout.addWidget(QLabel("Name*:"), 0, 0, Qt.AlignmentFlag.AlignRight)
        self.horse_name_input = QLineEdit()
        self.horse_name_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.horse_name_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.horse_name_input, 0, 1)
        top_grid_layout.addWidget(
            QLabel("Account Number:"), 0, 2, Qt.AlignmentFlag.AlignRight
        )
        self.account_number_input = QLineEdit()
        self.account_number_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.account_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.account_number_input, 0, 3)
        # Row 1
        top_grid_layout.addWidget(QLabel("Breed:"), 1, 0, Qt.AlignmentFlag.AlignRight)
        self.breed_input = QLineEdit()
        self.breed_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.breed_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.breed_input, 1, 1)
        top_grid_layout.addWidget(QLabel("Color:"), 1, 2, Qt.AlignmentFlag.AlignRight)
        self.color_input = QLineEdit()
        self.color_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.color_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.color_input, 1, 3)
        # Row 2
        top_grid_layout.addWidget(QLabel("Sex:"), 2, 0, Qt.AlignmentFlag.AlignRight)
        self.sex_combo = QComboBox()
        self.sex_combo.addItems(self.SEX_OPTIONS)
        self.sex_combo.setStyleSheet(self.COMBO_DATE_STYLE)
        self.sex_combo.currentIndexChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.sex_combo, 2, 1)
        top_grid_layout.addWidget(
            QLabel("Date of Birth:"), 2, 2, Qt.AlignmentFlag.AlignRight
        )
        self.dob_input = QDateEdit()
        self.dob_input.setCalendarPopup(True)
        self.dob_input.setDisplayFormat("yyyy-MM-dd")
        self.dob_input.setDate(QDate(2000, 1, 1))
        self.dob_input.setMaximumDate(QDate.currentDate())
        self.dob_input.setSpecialValueText(" ")
        self.dob_input.setStyleSheet(self.COMBO_DATE_STYLE)
        self.dob_input.dateChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.dob_input, 2, 3)
        # Row 3
        top_grid_layout.addWidget(
            QLabel("Reg. Number:"), 3, 0, Qt.AlignmentFlag.AlignRight
        )
        self.reg_number_input = QLineEdit()
        self.reg_number_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.reg_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.reg_number_input, 3, 1)
        top_grid_layout.addWidget(
            QLabel("Microchip ID:"), 3, 2, Qt.AlignmentFlag.AlignRight
        )
        self.microchip_id_input = QLineEdit()
        self.microchip_id_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.microchip_id_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.microchip_id_input, 3, 3)
        # Row 4
        top_grid_layout.addWidget(QLabel("Tattoo:"), 4, 0, Qt.AlignmentFlag.AlignRight)
        self.tattoo_number_input = QLineEdit()
        self.tattoo_number_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.tattoo_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.tattoo_number_input, 4, 1)
        top_grid_layout.addWidget(QLabel("Brand:"), 4, 2, Qt.AlignmentFlag.AlignRight)
        self.brand_input = QLineEdit()
        self.brand_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.brand_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.brand_input, 4, 3)
        # Row 5
        top_grid_layout.addWidget(
            QLabel("Location:"), 5, 0, Qt.AlignmentFlag.AlignRight
        )
        self.location_display_label = QLabel("N/A")
        self.location_display_label.setStyleSheet(self.INPUT_FIELD_STYLE)
        if self.horse_name_input.sizeHint().isValid():
            self.location_display_label.setMinimumHeight(
                self.horse_name_input.sizeHint().height()
            )
        else:
            font_metrics = self.location_display_label.fontMetrics()
            padding = 5
            self.location_display_label.setMinimumHeight(
                font_metrics.height() + 2 * padding + 2
            )
        top_grid_layout.addWidget(self.location_display_label, 5, 1)
        top_grid_layout.addWidget(
            QLabel("Band/Tag:"), 5, 2, Qt.AlignmentFlag.AlignRight
        )
        self.band_tag_input = QLineEdit()
        self.band_tag_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.band_tag_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(self.band_tag_input, 5, 3)
        # Row 6 (Owner Display)
        top_grid_layout.addWidget(QLabel("Owner:"), 6, 0, Qt.AlignmentFlag.AlignRight)
        self.owner_display_label = QLabel("N/A")
        self.owner_display_label.setStyleSheet(self.INPUT_FIELD_STYLE)
        if self.horse_name_input.sizeHint().isValid():
            self.owner_display_label.setMinimumHeight(
                self.horse_name_input.sizeHint().height()
            )
        else:
            font_metrics = self.owner_display_label.fontMetrics()
            padding = 5
            self.owner_display_label.setMinimumHeight(
                font_metrics.height() + 2 * padding + 2
            )
        top_grid_layout.addWidget(
            self.owner_display_label, 6, 1
        )  # Spans one column for now

        outer_layout.addLayout(top_grid_layout)

        coggins_height_layout = QGridLayout()
        coggins_height_layout.setSpacing(10)
        coggins_height_layout.setHorizontalSpacing(20)
        coggins_height_layout.setColumnStretch(1, 1)
        coggins_height_layout.setColumnStretch(3, 1)
        coggins_height_layout.addWidget(
            QLabel("Coggins Date:"), 0, 0, Qt.AlignmentFlag.AlignRight
        )
        self.coggins_date_input = QDateEdit()
        self.coggins_date_input.setCalendarPopup(True)
        self.coggins_date_input.setDisplayFormat("yyyy-MM-dd")
        self.coggins_date_input.setDate(QDate(2000, 1, 1))
        self.coggins_date_input.setSpecialValueText(" ")
        self.coggins_date_input.setStyleSheet(self.COMBO_DATE_STYLE)
        self.coggins_date_input.dateChanged.connect(self._on_data_modified)
        coggins_height_layout.addWidget(self.coggins_date_input, 0, 1)
        coggins_height_layout.addWidget(
            QLabel("Height (Hands):"), 0, 2, Qt.AlignmentFlag.AlignRight
        )
        self.height_input = QLineEdit()
        double_validator = QDoubleValidator(0.00, 99.99, 2)
        double_validator.setNotation(QDoubleValidator.Notation.StandardNotation)
        self.height_input.setValidator(double_validator)
        self.height_input.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.height_input.textChanged.connect(self._on_data_modified)
        coggins_height_layout.addWidget(self.height_input, 0, 3)
        outer_layout.addLayout(coggins_height_layout)

        description_form_layout = QFormLayout()
        description_form_layout.setContentsMargins(0, 0, 0, 0)
        description_form_layout.setSpacing(10)
        description_form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        self.description_input = QTextEdit()
        self.description_input.setFixedHeight(80)
        self.description_input.setStyleSheet(self.TEXT_AREA_STYLE)
        self.description_input.textChanged.connect(self._on_data_modified)
        description_form_layout.addRow(
            QLabel("Description/Markings:"), self.description_input
        )
        outer_layout.addLayout(description_form_layout)

        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setSpacing(10)
        self.toggle_active_btn = QPushButton("Deactivate Horse")
        self.toggle_active_btn.setStyleSheet(self.DEACTIVATE_BUTTON_STYLE)
        self.toggle_active_btn.clicked.connect(self._request_toggle_active)
        self.toggle_active_btn.setObjectName("ToggleActiveButton")
        self.discard_btn = QPushButton("Discard Changes")
        self.discard_btn.setStyleSheet(self.DISCARD_BUTTON_STYLE)
        self.discard_btn.clicked.connect(self.discard_requested.emit)
        self.discard_btn.setObjectName("DiscardButton")
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.setStyleSheet(self.SAVE_BUTTON_STYLE)
        self.save_btn.clicked.connect(self.save_requested.emit)
        self.save_btn.setObjectName("SaveButton")
        button_layout.addWidget(self.toggle_active_btn)
        button_layout.addStretch()
        button_layout.addWidget(self.discard_btn)
        button_layout.addWidget(self.save_btn)
        outer_layout.addWidget(button_frame)
        outer_layout.addStretch(1)
        scroll_area.setWidget(content_widget)
        self.main_layout.addWidget(scroll_area)

    def _request_toggle_active(self):
        # (Same as v1.2.19)
        if self._current_horse_is_active:
            self.toggle_active_requested.emit(False)
        else:
            self.toggle_active_requested.emit(True)

    def update_toggle_active_button_text(self, is_active: bool):
        # (Same as v1.2.19)
        self.toggle_active_btn.setText(
            "Deactivate Horse" if is_active else "Activate Horse"
        )
        self._current_horse_is_active = is_active

    def populate_form_data(self, horse_data: Optional["Horse"]):
        self.logger.debug(
            f"Populating BasicInfoTab with horse_data: {horse_data.horse_name if horse_data else 'None'}"
        )
        self._suppress_data_changed_signal = True
        if horse_data:
            self.current_horse_id = horse_data.horse_id
            self.horse_name_input.setText(horse_data.horse_name or "")
            self.account_number_input.setText(horse_data.account_number or "")
            self.breed_input.setText(horse_data.breed or "")
            self.color_input.setText(horse_data.color or "")
            sex_idx = self.sex_combo.findText(
                horse_data.sex or "Unknown", Qt.MatchFlag.MatchFixedString
            )
            self.sex_combo.setCurrentIndex(sex_idx if sex_idx >= 0 else 0)
            if horse_data.date_of_birth:
                self.dob_input.setDate(
                    QDate.fromString(str(horse_data.date_of_birth), "yyyy-MM-dd")
                )
            else:
                self.dob_input.setDate(self.dob_input.minimumDate().addDays(-1))
                self.dob_input.setDate(QDate(2000, 1, 1))
            self.reg_number_input.setText(getattr(horse_data, "reg_number", "") or "")
            self.microchip_id_input.setText(horse_data.chip_number or "")
            self.tattoo_number_input.setText(horse_data.tattoo_number or "")
            self.brand_input.setText(getattr(horse_data, "brand", "") or "")
            self.band_tag_input.setText(getattr(horse_data, "band_tag", "") or "")
            self.location_display_label.setText(
                horse_data.location.location_name
                if horse_data.location and hasattr(horse_data.location, "location_name")
                else "N/A"
            )

            # Populate NEW owner field using robust name construction
            owner_name_display = "N/A"
            if (
                hasattr(horse_data, "owners")
                and horse_data.owners
                and len(horse_data.owners) > 0
            ):
                first_owner_model = horse_data.owners[
                    0
                ]  # This is an OwnerModel instance
                if first_owner_model:
                    name_parts = []
                    if (
                        hasattr(first_owner_model, "farm_name")
                        and first_owner_model.farm_name
                    ):
                        name_parts.append(first_owner_model.farm_name)

                    person_name_parts = []
                    if (
                        hasattr(first_owner_model, "first_name")
                        and first_owner_model.first_name
                    ):
                        person_name_parts.append(first_owner_model.first_name)
                    if (
                        hasattr(first_owner_model, "last_name")
                        and first_owner_model.last_name
                    ):
                        person_name_parts.append(first_owner_model.last_name)

                    person_name_str = " ".join(person_name_parts).strip()
                    if person_name_str:
                        if name_parts:
                            name_parts.append(f"({person_name_str})")
                        else:
                            name_parts.append(person_name_str)

                    if name_parts:
                        owner_name_display = " ".join(name_parts)
                    elif hasattr(first_owner_model, "owner_id"):
                        owner_name_display = f"Owner ID: {first_owner_model.owner_id}"
                    else:
                        owner_name_display = "Owner Data Incomplete"
                else:
                    owner_name_display = "Owner Data Missing"
            else:  # No owners associated
                owner_name_display = "No Owner Associated"
            self.owner_display_label.setText(owner_name_display)

            if horse_data.coggins_date:
                self.coggins_date_input.setDate(
                    QDate.fromString(str(horse_data.coggins_date), "yyyy-MM-dd")
                )
            else:
                self.coggins_date_input.setDate(
                    self.coggins_date_input.minimumDate().addDays(-1)
                )
                self.coggins_date_input.setDate(QDate(2000, 1, 1))
            self.height_input.setText(
                f"{horse_data.height_hands:.2f}"
                if horse_data.height_hands is not None
                else ""
            )
            self.description_input.setPlainText(horse_data.description or "")
            self.update_toggle_active_button_text(horse_data.is_active)
            self.set_form_read_only(True)
            self._is_new_mode = False
            self._is_editing = False
            self.update_buttons_state(
                is_editing_or_new=False, has_selection=True, has_changes=False
            )
        else:
            self.clear_fields(suppress_signal=True)
            self.set_form_read_only(True)
            self._is_new_mode = False
            self._is_editing = False
            self.update_buttons_state(
                is_editing_or_new=False, has_selection=False, has_changes=False
            )
        self._has_unsaved_changes = False
        self._suppress_data_changed_signal = False

    def _on_data_modified(self, *args):
        # (Same as v1.2.19)
        if self._suppress_data_changed_signal:
            return
        if not self.horse_name_input.isReadOnly():
            if not self._has_unsaved_changes:
                self._has_unsaved_changes = True
                self.logger.debug("Data modified.")
                self.data_modified.emit()
            self.update_buttons_state(
                is_editing_or_new=(self._is_new_mode or self._is_editing),
                has_selection=(self.current_horse_id is not None),
                has_changes=True,
            )

    def get_data_from_form(self) -> Dict[str, Any]:
        # (Same as v1.2.19 - owner is display only, not collected here)
        def get_date_object(date_edit_widget: QDateEdit) -> Optional[date]:
            q_date = date_edit_widget.date()
            if (
                date_edit_widget.text().strip() == ""
                or (
                    q_date == QDate(2000, 1, 1)
                    and date_edit_widget.text() == date_edit_widget.specialValueText()
                )
                or q_date < date_edit_widget.minimumDate()
                or not q_date.isValid()
                or q_date == date_edit_widget.minimumDate().addDays(-1)
            ):
                return None
            return date(q_date.year(), q_date.month(), q_date.day())

        data = {
            "horse_name": self.horse_name_input.text().strip() or None,
            "account_number": self.account_number_input.text().strip() or None,
            "breed": self.breed_input.text().strip() or None,
            "color": self.color_input.text().strip() or None,
            "sex": (
                self.sex_combo.currentText()
                if self.sex_combo.currentText() != "Unknown"
                else None
            ),
            "date_of_birth": get_date_object(self.dob_input),
            "chip_number": self.microchip_id_input.text().strip() or None,
            "tattoo_number": self.tattoo_number_input.text().strip() or None,
            "is_active": self._current_horse_is_active,
            "reg_number": self.reg_number_input.text().strip() or None,
            "brand": self.brand_input.text().strip() or None,
            "band_tag": self.band_tag_input.text().strip() or None,
            "coggins_date": get_date_object(self.coggins_date_input),
            "height_hands": (
                float(self.height_input.text())
                if self.height_input.text().strip()
                else None
            ),
            "description": self.description_input.toPlainText().strip() or None,
            "date_deceased": None,
        }
        for key in [
            "account_number",
            "breed",
            "color",
            "chip_number",
            "tattoo_number",
            "reg_number",
            "brand",
            "band_tag",
            "description",
        ]:
            if data[key] == "":
                data[key] = None
        if data["sex"] == "Unknown":
            data["sex"] = None
        self.logger.debug(f"Data extracted: {data}")
        return data

    def set_form_read_only(self, read_only: bool):
        # (Same as v1.2.19)
        self.logger.debug(f"BasicInfoTab.set_form_read_only: {read_only}")
        self._suppress_data_changed_signal = True
        line_edit_fields = [
            self.horse_name_input,
            self.account_number_input,
            self.breed_input,
            self.color_input,
            self.reg_number_input,
            self.microchip_id_input,
            self.tattoo_number_input,
            self.brand_input,
            self.band_tag_input,
            self.height_input,
        ]
        for field in line_edit_fields:
            field.setReadOnly(read_only)
            style_suffix = "background-color: #2E2E2E;" if read_only else ""
            field.setStyleSheet(self.INPUT_FIELD_STYLE + style_suffix)
        interactive_widgets = [self.sex_combo, self.dob_input, self.coggins_date_input]
        for widget in interactive_widgets:
            widget.setEnabled(not read_only)
            style_suffix_interactive = (
                "background-color: #2E2E2E; color: #AAAAAA;" if read_only else ""
            )
            widget.setStyleSheet(self.COMBO_DATE_STYLE + style_suffix_interactive)
        self.description_input.setReadOnly(read_only)
        style_suffix_desc = "background-color: #2E2E2E;" if read_only else ""
        self.description_input.setStyleSheet(self.TEXT_AREA_STYLE + style_suffix_desc)
        self._is_editing = not read_only
        if read_only:
            self._has_unsaved_changes = False
        self._suppress_data_changed_signal = False

    def clear_fields(self, suppress_signal: bool = False):
        if suppress_signal:
            self._suppress_data_changed_signal = True
        self.current_horse_id = None
        self.horse_name_input.clear()
        self.account_number_input.clear()
        self.breed_input.clear()
        self.color_input.clear()
        self.sex_combo.setCurrentIndex(0)
        self.dob_input.setDate(self.dob_input.minimumDate().addDays(-1))
        self.dob_input.setDate(QDate(2000, 1, 1))
        self.reg_number_input.clear()
        self.microchip_id_input.clear()
        self.tattoo_number_input.clear()
        self.brand_input.clear()
        self.band_tag_input.clear()
        self.location_display_label.setText("N/A")
        self.owner_display_label.setText("N/A")  # Clear owner display
        self.coggins_date_input.setDate(
            self.coggins_date_input.minimumDate().addDays(-1)
        )
        self.coggins_date_input.setDate(QDate(2000, 1, 1))
        self.height_input.clear()
        self.description_input.clear()
        self.update_toggle_active_button_text(True)
        if suppress_signal:
            self._suppress_data_changed_signal = False
        self._has_unsaved_changes = False
        if not suppress_signal:
            self.data_modified.emit()

    # (set_new_mode, set_edit_mode, update_buttons_state, has_unsaved_changes,
    #  mark_as_saved, update_displayed_location methods remain the same as in v1.2.19)
    def set_new_mode(self, is_new: bool):
        self.logger.info(f"BasicInfoTab set_new_mode: {is_new}")
        self._is_new_mode = is_new
        self._is_editing = True
        self.current_horse_id = None
        self.clear_fields(suppress_signal=True)
        self.set_form_read_only(False)
        self._has_unsaved_changes = False
        self.update_buttons_state(
            is_editing_or_new=True, has_selection=False, has_changes=False
        )
        self.edit_mode_toggled.emit(True)
        self.horse_name_input.setFocus()

    def set_edit_mode(self, editable: bool):
        self.logger.info(f"BasicInfoTab set_edit_mode: {editable}")
        self._is_new_mode = False
        self._is_editing = editable
        self.set_form_read_only(not editable)
        if editable:
            self._has_unsaved_changes = False
            self.horse_name_input.setFocus()
        self.update_buttons_state(
            is_editing_or_new=editable,
            has_selection=(self.current_horse_id is not None),
            has_changes=self._has_unsaved_changes,
        )
        self.edit_mode_toggled.emit(editable)

    def update_buttons_state(
        self, is_editing_or_new: bool, has_selection: bool, has_changes: bool
    ):
        can_save_discard = (is_editing_or_new or self._is_editing) and has_changes
        self.save_btn.setEnabled(can_save_discard)
        self.discard_btn.setEnabled(can_save_discard)
        can_toggle_active = (
            has_selection
            and (is_editing_or_new or self._is_editing)
            and not self._is_new_mode
        )
        self.toggle_active_btn.setEnabled(can_toggle_active)
        if not has_selection and not self._is_new_mode:
            self.update_toggle_active_button_text(True)
            self.toggle_active_btn.setEnabled(False)
        elif self._is_new_mode:
            self.update_toggle_active_button_text(True)
            self.toggle_active_btn.setEnabled(False)

    def has_unsaved_changes(self) -> bool:
        return self._has_unsaved_changes

    def mark_as_saved(self):
        self.logger.debug("BasicInfoTab.mark_as_saved.")
        self._has_unsaved_changes = False
        self._is_editing = False
        self.set_form_read_only(True)
        self.update_buttons_state(False, (self.current_horse_id is not None), False)

    def update_displayed_location(
        self, location_id: Optional[int], location_name: Optional[str]
    ):
        if hasattr(self, "location_display_label"):
            self.location_display_label.setText(location_name or "N/A")


=============== FILE: views\horse\tabs\billing_tab.py ===============

# views/horse/tabs/billing_tab.py
"""
EDSI Veterinary Management System - Horse Billing Tab
Version: 1.1.5
Purpose: UI for displaying and managing billing charges for a specific horse.
         - Corrected transaction list initialization to prevent TypeError.
Last Updated: June 6, 2025
Author: Gemini

Changelog:
- v1.1.5 (2025-06-06):
    - Bug Fix: Ensured the `self.transactions` attribute is always initialized
      as a list in both `__init__` and `clear_display` to prevent a TypeError.
- v1.1.4 (2025-06-06):
    - Bug Fix: Corrected attribute access for horse location and birth date.
- v1.1.3 (2025-06-06):
    - Bug Fix: Added `QColor` to the `PySide6.QtGui` import list.
- v1.1.2 (2025-06-06):
    - Bug Fix: Corrected the column count and headers in the transactions table.
- v1.1.1 (2025-06-06):
    - Bug Fix: Corrected attribute access for administered_by user.
- v1.1.0 (2025-06-06):
    - Major UI Overhaul and implementation of edit/delete functionality.
"""

import logging
from typing import Optional, List
from decimal import Decimal, InvalidOperation

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QTableWidget,
    QPushButton,
    QHBoxLayout,
    QHeaderView,
    QAbstractItemView,
    QTableWidgetItem,
    QMessageBox,
    QDialog,
    QToolButton,
    QLabel,
    QSpacerItem,
    QSizePolicy,
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QFont, QIcon, QColor

from models import Horse, Transaction
from controllers import FinancialController
from views.horse.dialogs.add_charge_dialog import AddChargeDialog
from views.horse.dialogs.edit_charge_dialog import EditChargeDialog
from config.app_config import AppConfig


class BillingTab(QWidget):
    status_message = Signal(str)

    def __init__(
        self,
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.financial_controller = financial_controller
        self.current_horse: Optional[Horse] = None
        self.transactions: List[Transaction] = []

        self._setup_ui()
        self._setup_connections()
        self.clear_display()

    def _create_action_button(
        self, text: str, icon_char: str, color: str
    ) -> QToolButton:
        """Helper to create styled QToolButtons."""
        button = QToolButton()
        button.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        button.setText(f"  {text}")

        font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 10)
        font.setBold(True)
        button.setFont(font)

        button.setProperty("iconchar", icon_char)
        button.setIconSize(QSize(20, 20))
        button.setMinimumHeight(40)
        button.setStyleSheet(
            f"""
            QToolButton {{
                background-color: {color};
                color: white;
                border-radius: 5px;
                padding: 5px 15px 5px 10px;
                border: 1px solid {AppConfig.DARK_BORDER};
                text-align: left;
            }}
            QToolButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
                border: 1px solid {AppConfig.DARK_TEXT_TERTIARY};
            }}
            QToolButton:hover {{
                background-color: {QColor(color).lighter(115).name()};
            }}
        """
        )
        return button

    def _setup_ui(self):
        """Initialize the UI components of the tab."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        action_layout = QHBoxLayout()
        action_layout.setSpacing(15)
        self.add_charge_btn = self._create_action_button(
            "Add New Charges", "➕", AppConfig.DARK_SUCCESS_ACTION
        )
        self.edit_charge_btn = self._create_action_button(
            "Edit Selected Charge", "✏️", AppConfig.DARK_PRIMARY_ACTION
        )
        self.delete_charge_btn = self._create_action_button(
            "Delete Selected Charge", "🗑️", AppConfig.DARK_DANGER_ACTION
        )
        self.create_invoice_btn = self._create_action_button(
            "Create Invoice", "📄", AppConfig.DARK_BUTTON_BG
        )
        self.record_payment_btn = self._create_action_button(
            "Record Payment", "💰", AppConfig.DARK_BUTTON_BG
        )

        action_layout.addWidget(self.add_charge_btn)
        action_layout.addWidget(self.edit_charge_btn)
        action_layout.addWidget(self.delete_charge_btn)
        action_layout.addSpacerItem(
            QSpacerItem(
                40, 20, QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum
            )
        )
        action_layout.addWidget(self.create_invoice_btn)
        action_layout.addWidget(self.record_payment_btn)
        main_layout.addLayout(action_layout)

        self.title_label = QLabel("Un-invoiced Charges")
        font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 12)
        font.setBold(True)
        self.title_label.setFont(font)
        self.title_label.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-top: 10px;"
        )
        main_layout.addWidget(self.title_label)

        self.transactions_table = QTableWidget()
        self.transactions_table.setColumnCount(8)
        self.transactions_table.setHorizontalHeaderLabels(
            [
                "ID",
                "Service Date",
                "Description",
                "Qty",
                "Unit Price",
                "Total",
                "Notes",
                "Administered By",
            ]
        )
        self.transactions_table.setEditTriggers(
            QAbstractItemView.EditTrigger.NoEditTriggers
        )
        self.transactions_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )
        self.transactions_table.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.transactions_table.verticalHeader().setVisible(False)
        self.transactions_table.horizontalHeader().setStretchLastSection(True)
        self.transactions_table.horizontalHeader().setSectionResizeMode(
            2, QHeaderView.ResizeMode.Stretch
        )
        self.transactions_table.setColumnHidden(0, True)
        main_layout.addWidget(self.transactions_table)

        total_layout = QHBoxLayout()
        total_layout.addStretch()
        total_due_title_label = QLabel("Total Due:")
        font.setPointSize(14)
        total_due_title_label.setFont(font)
        self.total_due_label = QLabel("$0.00")
        self.total_due_label.setFont(font)
        self.total_due_label.setStyleSheet("color: white;")

        total_layout.addWidget(total_due_title_label)
        total_layout.addWidget(self.total_due_label)
        main_layout.addLayout(total_layout)

    def _setup_connections(self):
        """Set up signal-slot connections."""
        self.add_charge_btn.clicked.connect(self._launch_add_charge_dialog)
        self.edit_charge_btn.clicked.connect(self._edit_selected_charge)
        self.delete_charge_btn.clicked.connect(self._delete_selected_charge)
        self.transactions_table.itemSelectionChanged.connect(self.update_buttons_state)

    def set_current_horse(self, horse: Optional[Horse]):
        """Set the currently displayed horse and update the view."""
        self.current_horse = horse
        self.load_transactions()
        self.update_buttons_state()

    def load_transactions(self):
        """Load and display transactions for the current horse."""
        if not self.current_horse:
            self.clear_display()
            return

        self.transactions = self.financial_controller.get_transactions_for_horse(
            self.current_horse.horse_id, invoiced=False
        )
        self.populate_transactions_table()

    def populate_transactions_table(self):
        """Fills the transactions table with data."""
        self.transactions_table.setRowCount(0)

        if self.transactions:
            self.transactions_table.setRowCount(len(self.transactions))
            for row, trans in enumerate(self.transactions):
                id_item = QTableWidgetItem(str(trans.id))
                id_item.setData(Qt.ItemDataRole.UserRole, trans.id)
                self.transactions_table.setItem(row, 0, id_item)

                self.transactions_table.setItem(
                    row,
                    1,
                    QTableWidgetItem(trans.transaction_date.strftime("%Y-%m-%d")),
                )
                self.transactions_table.setItem(
                    row, 2, QTableWidgetItem(trans.description)
                )
                self.transactions_table.setItem(
                    row, 3, QTableWidgetItem(str(trans.quantity))
                )
                self.transactions_table.setItem(
                    row, 4, QTableWidgetItem(f"{trans.unit_price:.2f}")
                )
                self.transactions_table.setItem(
                    row, 5, QTableWidgetItem(f"{trans.total_amount:.2f}")
                )
                self.transactions_table.setItem(
                    row, 6, QTableWidgetItem(trans.item_notes or "")
                )

                admin_name = (
                    trans.administered_by.user_name if trans.administered_by else "N/A"
                )
                self.transactions_table.setItem(row, 7, QTableWidgetItem(admin_name))

        self._update_total_due_display()

    def clear_display(self):
        """Clears all displayed data from the tab."""
        self.transactions_table.setRowCount(0)
        self.transactions = []  # FIXED: Ensure this is always a list
        self.current_horse = None
        self.update_buttons_state()
        self._update_total_due_display()

    def update_buttons_state(self):
        """Enables or disables buttons based on current state."""
        has_horse = self.current_horse is not None
        has_selection = has_horse and len(self.transactions_table.selectedItems()) > 0

        # Ensure transactions is a list before checking its length
        has_items_to_invoice = has_horse and (
            self.transactions is not None and len(self.transactions) > 0
        )

        self.add_charge_btn.setEnabled(has_horse)
        self.edit_charge_btn.setEnabled(has_selection)
        self.delete_charge_btn.setEnabled(has_selection)
        self.create_invoice_btn.setEnabled(has_items_to_invoice)
        self.record_payment_btn.setEnabled(has_horse)

    def _update_total_due_display(self):
        """Calculates and updates the total due label."""
        total_due = Decimal(0)
        for row in range(self.transactions_table.rowCount()):
            try:
                total_item = self.transactions_table.item(row, 5)  # Total column
                total_due += Decimal(total_item.text())
            except (InvalidOperation, TypeError, AttributeError):
                continue

        self.total_due_label.setText(f"${total_due:.2f}")

    def _launch_add_charge_dialog(self):
        """Opens the dialog to add new charges."""
        if not self.current_horse:
            QMessageBox.warning(
                self,
                "No Horse Selected",
                "Please select a horse before adding charges.",
            )
            return

        self.logger.info(
            f"Launching AddChargeDialog for horse: {self.current_horse.horse_name}"
        )
        dialog = AddChargeDialog(
            horse=self.current_horse,
            financial_controller=self.financial_controller,
            parent=self,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit(
                f"New charges added for {self.current_horse.horse_name}."
            )
            self.load_transactions()

    def _edit_selected_charge(self):
        """Opens the EditChargeDialog for the selected transaction."""
        selected_items = self.transactions_table.selectedItems()
        if not selected_items:
            return

        row = selected_items[0].row()
        transaction_id = self.transactions_table.item(row, 0).data(
            Qt.ItemDataRole.UserRole
        )

        transaction_to_edit = self.financial_controller.get_transaction_by_id(
            transaction_id
        )
        if not transaction_to_edit:
            QMessageBox.critical(
                self, "Error", "Could not find the selected transaction to edit."
            )
            return

        dialog = EditChargeDialog(
            transaction=transaction_to_edit,
            financial_controller=self.financial_controller,
            current_user_id=QApplication.instance().current_user_id,
            parent=self,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit("Charge updated successfully.")
            self.load_transactions()

    def _delete_selected_charge(self):
        """Deletes the selected transaction after confirmation."""
        selected_items = self.transactions_table.selectedItems()
        if not selected_items:
            return

        row = selected_items[0].row()
        transaction_id = self.transactions_table.item(row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        description = self.transactions_table.item(row, 2).text()

        reply = QMessageBox.question(
            self,
            "Confirm Delete",
            f"Are you sure you want to delete this charge?\n\n- {description}",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            success, message = self.financial_controller.delete_charge_transaction(
                transaction_id
            )
            if success:
                self.status_message.emit(message)
                self.load_transactions()
            else:
                QMessageBox.critical(self, "Error", message)


=============== FILE: views\horse\tabs\location_tab.py ===============

# views/horse/tabs/location_tab.py
"""
EDSI Veterinary Management System - Horse Location Tab
Version: 1.0.1
Purpose: Manages the assignment of a single location to a horse.
         - Modified assign/remove location logic to call HorseController for
           database persistence BEFORE emitting location_assignment_changed signal,
           ensuring data integrity and proper UI updates in parent views.
Last Updated: May 25, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-05-25):
    - Refactored `_assign_location_to_horse`: Now calls
      `horse_controller.assign_horse_to_location` to save the assignment
      to the database. Emits `location_assignment_changed` only on successful save.
      Updates local UI based on controller success.
    - Refactored `_handle_remove_location_link`: Now calls
      `horse_controller.remove_horse_from_location` to update the database.
      Emits `location_assignment_changed` (with None for location) only on
      successful removal. Updates local UI based on controller success.
    - Ensured user feedback (info/error messages) is provided based on the
      outcome of controller operations.
- v1.0.0 (2025-05-20):
    - Initial implementation.
    - UI with current location display (QLabel).
    - Buttons: "Create New & Link Location", "Link Existing Location", "Remove Location Link".
    - Integrates AddEditLocationDialog and SelectExistingLocationDialog.
    - Emits location_assignment_changed(location_id: Optional[int], location_name: Optional[str]) signal.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFrame,
    QDialog,
    QMessageBox,  # Explicitly imported for clarity, though parent_view might handle
)
from PySide6.QtCore import Qt, Signal

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_SUCCESS_ACTION,
    DARK_PRIMARY_ACTION,
    DARK_DANGER_ACTION,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
)
from models import (
    Horse,
)  # LocationModel not directly used here, controller returns names/ids
from controllers.horse_controller import HorseController
from controllers.location_controller import LocationController
from views.admin.dialogs.add_edit_location_dialog import AddEditLocationDialog
from views.horse.dialogs.select_existing_location_dialog import (
    SelectExistingLocationDialog,
)


class LocationTab(QWidget):
    """Tab widget for managing a horse's single assigned location."""

    location_assignment_changed = Signal(
        object
    )  # Emits a dict: {'id': Optional[int], 'name': Optional[str]}

    def __init__(
        self,
        parent_view,
        horse_controller: HorseController,
        location_controller: LocationController,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_controller = horse_controller
        self.location_controller = location_controller

        self.current_horse: Optional[Horse] = None
        self._current_location_id: Optional[int] = None
        self._current_location_name: str = "N/A"

        self.current_user_login = "UnknownUser"
        if hasattr(self.parent_view, "current_user") and self.parent_view.current_user:
            self.current_user_login = self.parent_view.current_user
        else:
            self.logger.warning(
                "Could not determine current_user for LocationTab auditing."
            )

        self.setStyleSheet(f"background-color: {DARK_WIDGET_BACKGROUND};")
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(15)

        self._setup_ui(main_layout)
        self._setup_connections()
        self.update_buttons_state()

    def _get_generic_button_style(self) -> str:
        if hasattr(self.parent_view, "get_generic_button_style"):
            return self.parent_view.get_generic_button_style()
        return (
            f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_ui(self, main_layout: QVBoxLayout):
        location_display_frame = QFrame()
        location_display_frame.setStyleSheet("background-color: transparent;")
        location_display_layout = QHBoxLayout(location_display_frame)
        location_display_layout.setContentsMargins(0, 0, 0, 10)

        current_location_title_label = QLabel("Currently Assigned Location:")
        current_location_title_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-weight: bold; background: transparent;"
        )
        self.current_location_display_label = QLabel(self._current_location_name)
        self.current_location_display_label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 14px; background-color: {DARK_INPUT_FIELD_BACKGROUND}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; min-height: 22px;"
        )
        self.current_location_display_label.setWordWrap(True)

        location_display_layout.addWidget(current_location_title_label)
        location_display_layout.addWidget(self.current_location_display_label, 1)
        main_layout.addWidget(location_display_frame)

        action_buttons_layout = QHBoxLayout()
        self.create_link_location_btn = QPushButton("➕ Create New & Assign Location")
        self.link_existing_location_btn = QPushButton("🔗 Assign Existing Location")
        self.remove_location_link_btn = QPushButton("➖ Clear Assigned Location")

        button_style = self._get_generic_button_style()
        self.create_link_location_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_SUCCESS_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        self.link_existing_location_btn.setStyleSheet(
            button_style.replace(
                DARK_BUTTON_BG, DARK_PRIMARY_ACTION
            )  # Assuming default text color is fine
        )
        self.remove_location_link_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_DANGER_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )

        action_buttons_layout.addWidget(self.create_link_location_btn)
        action_buttons_layout.addWidget(self.link_existing_location_btn)
        action_buttons_layout.addWidget(self.remove_location_link_btn)
        action_buttons_layout.addStretch()
        main_layout.addLayout(action_buttons_layout)
        main_layout.addStretch(1)

    def _setup_connections(self):
        self.create_link_location_btn.clicked.connect(
            self._handle_create_and_link_location
        )
        self.link_existing_location_btn.clicked.connect(
            self._handle_link_existing_location
        )
        self.remove_location_link_btn.clicked.connect(self._handle_remove_location_link)

    def load_location_for_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.logger.debug(
            f"LocationTab: Loading location for horse: {horse.horse_name if horse else 'None'}"
        )
        if self.current_horse and self.current_horse.horse_id is not None:
            # The horse object passed might already be eager-loaded by HorseUnifiedManagement
            # If not, self.horse_controller.get_horse_by_id() would re-fetch.
            # For consistency, let's use the passed horse object directly if its location is loaded.
            # If horse.location is not loaded, then a fresh fetch might be needed,
            # but this should ideally be handled by the caller providing a fully loaded horse.

            # Let's assume the passed 'horse' object has its .location eager-loaded
            # by HorseUnifiedManagement calling HorseController.get_horse_by_id().
            self._current_location_id = self.current_horse.current_location_id
            if self.current_horse.location and hasattr(
                self.current_horse.location, "location_name"
            ):
                self._current_location_name = (
                    self.current_horse.location.location_name or "N/A"
                )
            else:
                self._current_location_name = (
                    "N/A"  # If location object is None or no name
                )

            self.logger.debug(
                f"LocationTab: Horse ID {self.current_horse.horse_id}, "
                f"current_location_id: {self._current_location_id}, "
                f"current_location_name: '{self._current_location_name}'"
            )
        else:
            self._current_location_id = None
            self._current_location_name = "N/A (No horse selected)"
            self.logger.debug("LocationTab: No current horse, location set to N/A.")

        self.current_location_display_label.setText(self._current_location_name)
        self.update_buttons_state()

    def _handle_create_and_link_location(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Assign Location", "Please select a horse first."
            )
            return
        self.logger.info(
            f"Initiating Create & Assign New Location for horse: {self.current_horse.horse_name}"
        )

        dialog = AddEditLocationDialog(
            self.parent_view,
            self.location_controller,
            self.current_user_login,
            location=None,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # IMPORTANT: AddEditLocationDialog must be modified to return the created location's ID and name
            # For example, by adding methods like dialog.get_created_location_id() and dialog.get_created_location_name()
            created_location_id = getattr(
                dialog, "created_location_id", None
            )  # Hypothetical
            created_location_name = getattr(
                dialog, "created_location_name", None
            )  # Hypothetical

            if created_location_id is not None and created_location_name is not None:
                self.logger.info(
                    f"New location created: ID {created_location_id}, Name '{created_location_name}'. Assigning to horse."
                )
                self._assign_location_to_horse(
                    created_location_id, created_location_name
                )
            else:
                self.logger.warning(
                    "AddEditLocationDialog did not return created location details. User may need to assign manually."
                )
                self.parent_view.show_info(
                    "Location Created",
                    "New location created. If not automatically assigned, please use 'Assign Existing Location' to link it.",
                )
        else:
            self.logger.info("Create & Assign New Location dialog cancelled.")

    def _handle_link_existing_location(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Assign Location", "Please select a horse first."
            )
            return
        self.logger.info(
            f"Initiating Assign Existing Location for horse: {self.current_horse.horse_name}"
        )

        dialog = SelectExistingLocationDialog(
            self.parent_view, self.current_horse.horse_name or "Selected Horse"
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_id = dialog.get_selected_location_id()
            if selected_id is not None:
                # Fetch location details to get the name for UI update and signal
                loc_obj = self.location_controller.get_location_by_id(selected_id)
                if loc_obj and hasattr(loc_obj, "location_name"):
                    self._assign_location_to_horse(
                        loc_obj.location_id, loc_obj.location_name
                    )
                else:
                    self.parent_view.show_error(
                        "Error",
                        f"Could not retrieve details for Location ID {selected_id}.",
                    )
            else:
                self.parent_view.show_warning(
                    "Assign Location", "No location was selected."
                )
        else:
            self.logger.info("Assign Existing Location dialog cancelled.")

    def _assign_location_to_horse(self, location_id: int, location_name: str):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.logger.error("No current horse to assign location to.")
            self.parent_view.show_error(
                "Error", "No horse selected to assign location."
            )
            return

        self.logger.info(
            f"Attempting to assign Location ID {location_id} ('{location_name}') to Horse ID {self.current_horse.horse_id}"
        )

        # Call controller to persist the change
        success, message = self.horse_controller.assign_horse_to_location(
            horse_id=self.current_horse.horse_id,
            location_id=location_id,
            notes=None,  # Or add a notes field to this tab/dialog if needed
            modified_by_user=self.current_user_login,
        )

        if success:
            self._current_location_id = location_id
            self._current_location_name = location_name
            self.current_location_display_label.setText(self._current_location_name)

            self.logger.info(
                f"Successfully assigned Location ID {location_id} to Horse ID {self.current_horse.horse_id}. Emitting signal."
            )
            self.location_assignment_changed.emit(
                {"id": location_id, "name": location_name}
            )
            self.parent_view.show_info(
                "Location Assigned", message
            )  # Use message from controller
        else:
            self.logger.error(f"Failed to assign location: {message}")
            self.parent_view.show_error("Assignment Failed", message)

        self.update_buttons_state()

    def _handle_remove_location_link(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Clear Location", "Please select a horse first."
            )
            return
        if self._current_location_id is None:  # Check local state first
            self.parent_view.show_info(
                "Clear Location", "No location is currently assigned to this horse."
            )
            return

        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        if self.parent_view.show_question(
            "Confirm Clear Location",
            f"Are you sure you want to clear the location assignment for horse '{horse_name_display}'?",
        ):
            self.logger.info(
                f"Attempting to clear location for horse ID {self.current_horse.horse_id}, current loc ID: {self._current_location_id}"
            )

            success, message = self.horse_controller.remove_horse_from_location(
                horse_id=self.current_horse.horse_id,
                location_id=self._current_location_id,  # Pass current location ID to ensure correct history update
                modified_by_user=self.current_user_login,
            )

            if success:
                self._current_location_id = None
                self._current_location_name = "N/A"
                self.current_location_display_label.setText(self._current_location_name)

                self.logger.info(
                    f"Successfully cleared location for Horse ID {self.current_horse.horse_id}. Emitting signal."
                )
                self.location_assignment_changed.emit({"id": None, "name": "N/A"})
                self.parent_view.show_info(
                    "Location Cleared", message
                )  # Use message from controller
            else:
                self.logger.error(f"Failed to clear location: {message}")
                self.parent_view.show_error("Clear Location Failed", message)

            self.update_buttons_state()
        else:
            self.logger.info("Clear location assignment cancelled by user.")

    def update_buttons_state(self):
        is_horse_selected = (
            self.current_horse is not None and self.current_horse.horse_id is not None
        )
        is_location_assigned = self._current_location_id is not None

        self.create_link_location_btn.setEnabled(is_horse_selected)
        self.link_existing_location_btn.setEnabled(is_horse_selected)
        self.remove_location_link_btn.setEnabled(
            is_horse_selected and is_location_assigned
        )


=============== FILE: views\horse\tabs\owners_tab.py ===============

# views/horse/tabs/owners_tab.py
"""
EDSI Veterinary Management System - Horse Owners Tab
Version: 1.2.5
Purpose: Manages the association of owners with a specific horse.
         - Passes its own validation method to CreateAndLinkOwnerDialog and
           LinkExistingOwnerDialog to ensure total ownership validation occurs
           before the dialogs close.
Last Updated: May 26, 2025
Author: Claude Assistant (based on user's v1.2.0, modified by Gemini)

Changelog:
- v1.2.5 (2025-05-26):
    - Modified `_handle_create_and_link_owner` and `_handle_link_existing_owner`
      to pass a new method `_validate_total_ownership_for_dialog` as a callback
      to `CreateAndLinkOwnerDialog` and `LinkExistingOwnerDialog` respectively.
    - The dialogs will now call this callback to perform total ownership
      validation before closing. If validation fails, the dialog remains open.
    - Renamed internal `_validate_total_ownership` to
      `_validate_total_ownership_for_dialog` to reflect its use by dialogs.
- v1.2.4 (2025-05-26):
    - Added `_validate_total_ownership` helper method for client-side validation.
    - Integrated this validation into relevant handler methods.
# ... (rest of previous changelog entries)
"""

import logging
from typing import Optional, List, Dict
from decimal import Decimal

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFrame,
    QDoubleSpinBox,
    QMessageBox,
    QDialog,
    QListWidgetItem,
)
from PySide6.QtCore import Qt, Signal

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_BORDER,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_SUCCESS_ACTION,
    DARK_PRIMARY_ACTION,
    DARK_DANGER_ACTION,
    DARK_TEXT_SECONDARY,
    DARK_ITEM_HOVER,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
)
from models import Horse, Owner as OwnerModel
from controllers.horse_controller import HorseController
from controllers.owner_controller import OwnerController

from ..dialogs.create_link_owner_dialog import CreateAndLinkOwnerDialog
from ..dialogs.link_existing_owner_dialog import LinkExistingOwnerDialog
from ..widgets.horse_owner_list_widget import HorseOwnerListWidget


class OwnersTab(QWidget):
    owner_association_changed = Signal(str)

    def __init__(
        self,
        parent_view,
        horse_controller: HorseController,
        owner_controller: OwnerController,
    ):
        # (Same as v1.2.4)
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_controller = horse_controller
        self.owner_controller = owner_controller
        self.current_horse: Optional[Horse] = None
        self.current_horse_owners_assoc: List[Dict] = []
        self.selected_horse_owner_assoc_id: Optional[int] = None
        self.current_user_login = "UnknownUser"
        if hasattr(self.parent_view, "current_user") and self.parent_view.current_user:
            self.current_user_login = self.parent_view.current_user
        else:
            self.logger.warning(
                "Could not determine current_user for OwnersTab auditing."
            )
        self.setStyleSheet(f"background-color: {DARK_WIDGET_BACKGROUND};")
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)
        self._setup_ui(main_layout)
        self._setup_connections()
        self.update_buttons_state()

    # (_get_generic_button_style, _get_input_style, _setup_ui, _setup_connections,
    #  load_owners_for_horse, _on_horse_owner_selection_changed,
    #  _handle_remove_owner_from_horse, update_buttons_state remain IDENTICAL to v1.2.4)
    def _get_generic_button_style(self) -> str:
        if hasattr(self.parent_view, "get_generic_button_style"):
            return self.parent_view.get_generic_button_style()
        return f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;}} QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"

    def _get_input_style(self) -> str:
        return f"QDoubleSpinBox {{ background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; padding: 5px; border-radius: 4px; }}"

    def _setup_ui(self, main_layout: QVBoxLayout):
        owners_action_layout = QHBoxLayout()
        self.create_link_owner_btn = QPushButton("➕ Create New & Link Owner")
        self.link_existing_owner_btn = QPushButton("🔗 Link Existing Owner")
        self.remove_horse_owner_btn = QPushButton("➖ Remove Selected Owner Link")
        button_style = self._get_generic_button_style()
        self.create_link_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_SUCCESS_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        self.link_existing_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_PRIMARY_ACTION)
        )
        self.remove_horse_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_DANGER_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        owners_action_layout.addWidget(self.create_link_owner_btn)
        owners_action_layout.addWidget(self.link_existing_owner_btn)
        owners_action_layout.addWidget(self.remove_horse_owner_btn)
        owners_action_layout.addStretch()
        main_layout.addLayout(owners_action_layout)
        self.current_owners_list_widget = HorseOwnerListWidget()
        owners_list_label = QLabel("Current Owners & Percentages:")
        owners_list_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; background: transparent; margin-bottom: 5px; font-weight: bold;"
        )
        main_layout.addWidget(owners_list_label)
        main_layout.addWidget(self.current_owners_list_widget, 1)
        self.percentage_edit_frame = QFrame()
        self.percentage_edit_frame.setStyleSheet("background-color: transparent;")
        percentage_edit_layout = QHBoxLayout(self.percentage_edit_frame)
        percentage_edit_layout.setContentsMargins(0, 5, 0, 0)
        self.selected_owner_for_pct_label = QLabel("Edit % for:")
        self.selected_owner_for_pct_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-right: 5px;"
        )
        self.edit_owner_percentage_spinbox = QDoubleSpinBox()
        self.edit_owner_percentage_spinbox.setRange(0.00, 100.00)
        self.edit_owner_percentage_spinbox.setDecimals(2)
        self.edit_owner_percentage_spinbox.setSuffix(" %")
        self.edit_owner_percentage_spinbox.setStyleSheet(self._get_input_style())
        self.edit_owner_percentage_spinbox.setFixedWidth(100)
        self.save_owner_percentage_btn = QPushButton("💾 Save %")
        self.save_owner_percentage_btn.setStyleSheet(
            self._get_generic_button_style().replace(
                DARK_BUTTON_BG, DARK_SUCCESS_ACTION
            )
        )
        percentage_edit_layout.addWidget(self.selected_owner_for_pct_label)
        percentage_edit_layout.addWidget(self.edit_owner_percentage_spinbox)
        percentage_edit_layout.addWidget(self.save_owner_percentage_btn)
        percentage_edit_layout.addStretch()
        main_layout.addWidget(self.percentage_edit_frame)
        self.percentage_edit_frame.hide()

    def _setup_connections(self):
        self.current_owners_list_widget.itemSelectionChanged.connect(
            self._on_horse_owner_selection_changed
        )
        self.create_link_owner_btn.clicked.connect(self._handle_create_and_link_owner)
        self.link_existing_owner_btn.clicked.connect(self._handle_link_existing_owner)
        self.remove_horse_owner_btn.clicked.connect(
            self._handle_remove_owner_from_horse
        )
        self.save_owner_percentage_btn.clicked.connect(
            self._handle_save_owner_percentage
        )

    def load_owners_for_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.current_owners_list_widget.clear()
        self.selected_horse_owner_assoc_id = None
        self.current_horse_owners_assoc = []
        if self.current_horse and self.current_horse.horse_id is not None:
            self.logger.debug(
                f"Populating owners for horse ID {self.current_horse.horse_id}"
            )
            self.current_horse_owners_assoc = self.horse_controller.get_horse_owners(
                self.current_horse.horse_id
            )
            for owner_assoc_data in self.current_horse_owners_assoc:
                item_text = f"{owner_assoc_data.get('owner_name', 'N/A')} - {owner_assoc_data.get('percentage_ownership', 0.0):.2f}%"
                list_item = QListWidgetItem(item_text)
                list_item.setData(
                    Qt.ItemDataRole.UserRole, owner_assoc_data.get("owner_id")
                )
                self.current_owners_list_widget.addItem(list_item)
        else:
            self.logger.debug("No current horse or horse ID to load owners for.")
        self.percentage_edit_frame.hide()
        self.update_buttons_state()

    def _on_horse_owner_selection_changed(self):
        selected_items = self.current_owners_list_widget.selectedItems()
        if selected_items:
            list_item = selected_items[0]
            self.selected_horse_owner_assoc_id = list_item.data(
                Qt.ItemDataRole.UserRole
            )
            self.logger.info(f"Owner ID {self.selected_horse_owner_assoc_id} selected.")
            assoc_data = next(
                (
                    ho
                    for ho in self.current_horse_owners_assoc
                    if ho["owner_id"] == self.selected_horse_owner_assoc_id
                ),
                None,
            )
            if assoc_data:
                self.edit_owner_percentage_spinbox.setValue(
                    assoc_data.get("percentage_ownership", 0.0)
                )
                self.selected_owner_for_pct_label.setText(
                    f"Edit % for: {assoc_data.get('owner_name','N/A')}"
                )
                self.percentage_edit_frame.show()
            else:
                self.logger.warning(
                    f"No data for selected owner ID {self.selected_horse_owner_assoc_id}"
                )
                self.percentage_edit_frame.hide()
        else:
            self.selected_horse_owner_assoc_id = None
            self.percentage_edit_frame.hide()
            self.logger.info("Owner selection cleared.")
        self.update_buttons_state()

    def _validate_total_ownership_for_dialog(
        self,
        owner_id_being_changed: Optional[int],
        new_percentage_for_this_owner: float,
    ) -> bool:
        """Called by dialogs to validate total ownership before they accept."""
        if not self.current_horse:
            return False
        current_total_other_owners = Decimal("0.00")
        for assoc in self.current_horse_owners_assoc:
            if (
                owner_id_being_changed is not None
                and assoc.get("owner_id") == owner_id_being_changed
            ):
                continue
            current_total_other_owners += Decimal(
                str(assoc.get("percentage_ownership", 0.0))
            )

        prospective_total = current_total_other_owners + Decimal(
            str(new_percentage_for_this_owner)
        )
        self.logger.debug(
            f"Dialog validation: Others total={current_total_other_owners}, New%={new_percentage_for_this_owner}, Prospective={prospective_total}"
        )
        if prospective_total > Decimal("100.00"):
            msg = (
                f"Total ownership cannot exceed 100%.\n"
                f"Other owners: {current_total_other_owners:.2f}%\n"
                f"This owner: {new_percentage_for_this_owner:.2f}%\n"
                f"Resulting total: {prospective_total:.2f}%"
            )
            QMessageBox.warning(
                self.parent_view, "Ownership Error", msg
            )  # Show error via parent_view
            return False
        return True

    def _handle_create_and_link_owner(self):
        if not self.current_horse:
            self.parent_view.show_warning("Add Owner", "Select horse first.")
            return
        self.logger.info(
            f"Initiating Create & Link Owner for: {self.current_horse.horse_name}"
        )

        # Pass the validation method to the dialog
        dialog = CreateAndLinkOwnerDialog(
            self,
            self.current_horse.horse_name or "Selected Horse",
            self.current_user_login,
            total_ownership_validator=self._validate_total_ownership_for_dialog,  # Pass callback
        )
        if (
            dialog.exec() == QDialog.DialogCode.Accepted
        ):  # Dialog only accepts if ALL validation (incl. total %) passed
            data = dialog.get_data()
            if (
                data
                and data.get("owner_details")
                and data.get("percentage") is not None
            ):
                owner_details, percentage = data["owner_details"], data["percentage"]
                self.logger.info(
                    f"Dialog OK. Owner: {owner_details}, Percentage: {percentage}"
                )
                # Total ownership validation already done by the dialog via callback
                success_create, msg_create, new_owner_obj = (
                    self.owner_controller.create_master_owner(
                        owner_details, self.current_user_login
                    )
                )
                if (
                    success_create
                    and new_owner_obj
                    and self.current_horse
                    and self.current_horse.horse_id is not None
                ):
                    success_link, msg_link = self.horse_controller.add_owner_to_horse(
                        self.current_horse.horse_id,
                        new_owner_obj.owner_id,
                        percentage,
                        self.current_user_login,
                    )
                    if success_link:
                        self.parent_view.show_info("Owner Linked", msg_link)
                        self.load_owners_for_horse(self.current_horse)
                        self.owner_association_changed.emit(msg_link)
                    else:
                        self.parent_view.show_error("Link Error", msg_link)
                else:
                    self.parent_view.show_error(
                        "Create Error", msg_create or "Could not create owner."
                    )
            else:
                self.logger.warning("Create dialog accepted, but no valid data.")
                self.parent_view.show_warning("Data Error", "No data from form.")
        else:
            self.logger.info("Create & link owner dialog cancelled.")

    def _handle_link_existing_owner(self):
        if not self.current_horse:
            self.parent_view.show_warning("Link Owner", "Select horse first.")
            return
        self.logger.info(
            f"Initiating Link Existing Owner for: {self.current_horse.horse_name}"
        )

        # LinkExistingOwnerDialog needs similar modification to accept validator
        # For now, we'll keep its internal validation and add OwnersTab validation after it closes.
        # This means if total % validation fails, user has to re-open LinkExistingOwnerDialog.
        # Ideal solution: Modify LinkExistingOwnerDialog to also take the callback.

        dialog = LinkExistingOwnerDialog(
            self, self.current_horse.horse_name or "Selected Horse"
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_data()
            if (
                data
                and data.get("owner_id") is not None
                and data.get("percentage") is not None
                and self.current_horse
                and self.current_horse.horse_id is not None
            ):
                owner_id, percentage = data["owner_id"], data["percentage"]
                self.logger.info(
                    f"Linking owner ID {owner_id} with {percentage}% to horse ID {self.current_horse.horse_id}"
                )

                # Perform total ownership validation AFTER dialog closes for this dialog type (can be improved)
                if not self._validate_total_ownership_for_dialog(None, percentage):
                    # User has to click "Link Existing Owner" again if this fails.
                    return

                success_link, msg_link = self.horse_controller.add_owner_to_horse(
                    self.current_horse.horse_id,
                    owner_id,
                    percentage,
                    self.current_user_login,
                )
                if success_link:
                    self.parent_view.show_info("Owner Linked", msg_link)
                    self.load_owners_for_horse(self.current_horse)
                    self.owner_association_changed.emit(msg_link)
                else:
                    self.parent_view.show_error("Link Error", msg_link)
            else:
                self.logger.warning("No data from link dialog.")
                self.parent_view.show_warning("Data Error", "No selection from form.")
        else:
            self.logger.info("Link existing owner dialog cancelled.")

    def _handle_save_owner_percentage(self):
        if (
            not self.current_horse
            or self.current_horse.horse_id is None
            or self.selected_horse_owner_assoc_id is None
        ):
            self.parent_view.show_warning(
                "Save %", "Select horse and owner to update %."
            )
            return
        new_percentage = self.edit_owner_percentage_spinbox.value()

        # VALIDATION using the dialog-focused validator
        if not self._validate_total_ownership_for_dialog(
            self.selected_horse_owner_assoc_id, new_percentage
        ):
            return  # Error message already shown by validator

        self.logger.info(
            f"Updating % for owner ID {self.selected_horse_owner_assoc_id} on horse ID {self.current_horse.horse_id} to {new_percentage}%"
        )
        success, message = self.horse_controller.update_horse_owner_percentage(
            self.current_horse.horse_id,
            self.selected_horse_owner_assoc_id,
            new_percentage,
            self.current_user_login,
        )
        if success:
            self.parent_view.show_info("Percentage Updated", message)
            self.load_owners_for_horse(self.current_horse)
            self.owner_association_changed.emit(message)
        else:
            self.parent_view.show_error("Update % Error", message)

    def _handle_remove_owner_from_horse(self):
        # (Same as v1.2.4 - no percentage validation needed for removal)
        if (
            not self.current_horse
            or self.current_horse.horse_id is None
            or self.selected_horse_owner_assoc_id is None
        ):
            warn_msg = "Select horse and owner from list."
            if hasattr(self.parent_view, "show_warning"):
                self.parent_view.show_warning("Remove Owner", warn_msg)
            else:
                QMessageBox.warning(self, "Remove Owner", warn_msg)
                return
        owner_id_to_remove = self.selected_horse_owner_assoc_id
        owner_display_name = f"Owner ID {owner_id_to_remove}"
        for oa in self.current_horse_owners_assoc:
            if oa.get("owner_id") == owner_id_to_remove:
                owner_display_name = oa.get("owner_name", owner_display_name)
                break
        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        confirm_msg = (
            f"Remove owner '{owner_display_name}' from horse '{horse_name_display}'?"
        )
        proceed = False
        if hasattr(self.parent_view, "show_question"):
            proceed = self.parent_view.show_question("Confirm Removal", confirm_msg)
        else:
            proceed = (
                QMessageBox.question(
                    self,
                    "Confirm Removal",
                    confirm_msg,
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No,
                )
                == QMessageBox.StandardButton.Yes
            )
        if proceed:
            self.logger.info(
                f"Confirmed removal of owner ID {owner_id_to_remove} from horse ID {self.current_horse.horse_id}"
            )
            success, message = self.horse_controller.remove_owner_from_horse(
                self.current_horse.horse_id, owner_id_to_remove, self.current_user_login
            )
            if success:
                if hasattr(self.parent_view, "show_info"):
                    self.parent_view.show_info("Owner Removed", message)
                else:
                    QMessageBox.information(self, "Owner Removed", message)
                self.load_owners_for_horse(self.current_horse)
                self.owner_association_changed.emit(message)
            else:
                if hasattr(self.parent_view, "show_error"):
                    self.parent_view.show_error("Remove Error", message)
                else:
                    QMessageBox.critical(self, "Remove Error", message)
        else:
            self.logger.info("Owner removal cancelled.")

    def update_buttons_state(self):
        # (Same as v1.2.4)
        is_horse_selected = (
            self.current_horse is not None and self.current_horse.horse_id is not None
        )
        is_owner_in_list_selected = self.selected_horse_owner_assoc_id is not None
        self.create_link_owner_btn.setEnabled(is_horse_selected)
        self.link_existing_owner_btn.setEnabled(is_horse_selected)
        self.remove_horse_owner_btn.setEnabled(
            is_horse_selected and is_owner_in_list_selected
        )
        self.save_owner_percentage_btn.setEnabled(
            is_horse_selected and is_owner_in_list_selected
        )
        self.percentage_edit_frame.setVisible(
            is_horse_selected and is_owner_in_list_selected
        )


=============== FILE: views\horse\widgets\__init__.py ===============



=============== FILE: views\horse\widgets\charge_line_item_widget.py ===============

# views/horse/widgets/charge_line_item_widget.py
"""
EDSI Veterinary Management System - Charge Line Item Widget
Version: 1.1.0
Purpose: A self-contained widget for a single charge line item, including notes.
         - Added styling for input fields.
Last Updated: June 6, 2025
Author: Gemini
"""
import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDoubleSpinBox,
    QCheckBox,
    QTextEdit,
    QCompleter,
    QToolButton,
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QFont, QIcon

from models import ChargeCode
from config.app_config import AppConfig


class ChargeLineItemWidget(QWidget):
    """A widget representing a single, editable charge line."""

    remove_requested = Signal(QWidget)
    amount_changed = Signal()

    def __init__(self, charge_codes: List[ChargeCode], parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self._charge_codes = charge_codes if charge_codes else []
        self._charge_code_lookup = {cc.code: cc for cc in self._charge_codes}
        self._alt_code_lookup = {
            cc.alternate_code: cc for cc in self._charge_codes if cc.alternate_code
        }

        self.charge_data: Optional[ChargeCode] = None

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 10)
        main_layout.setSpacing(5)
        self.setStyleSheet(
            f"background-color: {AppConfig.DARK_WIDGET_BACKGROUND}; border-radius: 5px; padding: 5px;"
        )

        top_layout = QHBoxLayout()
        top_layout.setSpacing(5)

        self.charge_code_input = QLineEdit()
        self.alt_code_input = QLineEdit()
        self.description_label = QLineEdit()
        self.qty_spinbox = QDoubleSpinBox()
        self.price_spinbox = QDoubleSpinBox()
        self.taxable_checkbox = QCheckBox()
        self.total_label = QLabel("$0.00")
        self.remove_button = QToolButton()

        top_layout.addWidget(self.charge_code_input, 2)
        top_layout.addWidget(self.alt_code_input, 2)
        top_layout.addWidget(self.description_label, 6)
        top_layout.addWidget(self.qty_spinbox, 1)
        top_layout.addWidget(self.price_spinbox, 2)
        top_layout.addWidget(self.taxable_checkbox)
        top_layout.addWidget(self.total_label, 2)
        top_layout.addWidget(self.remove_button)

        self.notes_edit = QTextEdit()

        main_layout.addLayout(top_layout)
        main_layout.addWidget(self.notes_edit)

    def _apply_styles(self):
        # Apply the "boxed" style to all input fields
        input_style = f"""
            QLineEdit, QDoubleSpinBox, QTextEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
            }}
        """
        self.setStyleSheet(self.styleSheet() + input_style)

        self.charge_code_input.setPlaceholderText("Code")
        self.alt_code_input.setPlaceholderText("Alt Code")
        self.description_label.setPlaceholderText("Description")
        self.description_label.setReadOnly(True)

        self.qty_spinbox.setRange(0.001, 9999.0)
        self.qty_spinbox.setDecimals(3)
        self.qty_spinbox.setValue(1.0)

        self.price_spinbox.setRange(0.00, 99999.99)
        self.price_spinbox.setDecimals(2)
        self.price_spinbox.setPrefix("$ ")

        self.total_label.setAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        self.total_label.setMinimumWidth(80)

        self.notes_edit.setPlaceholderText("Enter notes for this line item...")
        self.notes_edit.setFixedHeight(40)

        self.remove_button.setIcon(QIcon(":/icons/delete"))  # Placeholder
        self.remove_button.setToolTip("Remove this charge")

    def _setup_connections(self):
        self.charge_code_input.editingFinished.connect(self._on_code_entered)
        self.alt_code_input.editingFinished.connect(self._on_alt_code_entered)
        self.qty_spinbox.valueChanged.connect(self._update_total)
        self.price_spinbox.valueChanged.connect(self._update_total)
        self.taxable_checkbox.stateChanged.connect(self.amount_changed.emit)
        self.remove_button.clicked.connect(lambda: self.remove_requested.emit(self))

    @Slot()
    def _on_code_entered(self):
        code_text = self.charge_code_input.text().upper()
        self.charge_data = self._charge_code_lookup.get(code_text)
        self._populate_from_charge_code()

    @Slot()
    def _on_alt_code_entered(self):
        alt_code_text = self.alt_code_input.text().upper()
        self.charge_data = self._alt_code_lookup.get(alt_code_text)
        self._populate_from_charge_code()

    def _populate_from_charge_code(self):
        if self.charge_data:
            self.charge_code_input.setText(self.charge_data.code)
            self.alt_code_input.setText(self.charge_data.alternate_code or "")
            self.description_label.setText(self.charge_data.description)
            self.price_spinbox.setValue(float(self.charge_data.standard_charge))
            self.taxable_checkbox.setChecked(self.charge_data.taxable)
        self._update_total()

    @Slot()
    def _update_total(self):
        try:
            qty = Decimal(self.qty_spinbox.value())
            price = Decimal(self.price_spinbox.value())
            total = qty * price
            self.total_label.setText(f"${total:.2f}")
        except (InvalidOperation, TypeError):
            self.total_label.setText("$0.00")
        self.amount_changed.emit()

    def get_data(self) -> Optional[Dict[str, Any]]:
        if not self.charge_data:
            return None

        return {
            "charge_code_id": self.charge_data.id,
            "description": self.description_label.text(),
            "quantity": Decimal(str(self.qty_spinbox.value())),
            "unit_price": Decimal(str(self.price_spinbox.value())),
            "total_price": (
                Decimal(str(self.qty_spinbox.value()))
                * Decimal(str(self.price_spinbox.value()))
            ),
            "taxable": self.taxable_checkbox.isChecked(),
            "item_notes": self.notes_edit.toPlainText().strip() or None,
        }


=============== FILE: views\horse\widgets\horse_list_widget.py ===============

# views/horse/widgets/horse_list_widget.py

"""
EDSI Veterinary Management System - Horse List Widget
Version: 1.0.1
Purpose: Custom QListWidget for displaying a list of horses with specific styling
         and item representation. Corrected AppConfig constant usage.
Last Updated: May 18, 2025
Author: Claude Assistant

Changelog:
- v1.0.1 (2025-05-18):
    - Corrected AppConfig constant usage. Imported constants directly instead of
      accessing them via the AppConfig class.
- v1.0.0 (2025-05-17):
    - Initial extraction from horse_unified_management.py.
"""

import logging
from typing import Optional
from datetime import date

from PySide6.QtWidgets import QListWidget, QVBoxLayout, QLabel, QWidget
from PySide6.QtGui import QFont
from PySide6.QtCore import Qt

# Corrected import: Import constants directly
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_BORDER,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
    DEFAULT_FONT_FAMILY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
)


class HorseListWidget(QListWidget):
    """Custom list widget styled for the dark theme and responsible for horse item rendering."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setStyleSheet(
            f"""
            QListWidget {{
                border: none; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none;
            }}
            QListWidget::item {{
                padding: 10px 15px; border-bottom: 1px solid {DARK_BORDER};
                min-height: 55px; background-color: {DARK_WIDGET_BACKGROUND};
            }}
            QListWidget::item:selected {{
                background-color: {DARK_PRIMARY_ACTION}40; /* RGBA */
                border-left: 3px solid {DARK_PRIMARY_ACTION}; color: #ffffff;
            }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }}
            """
        )

    def create_horse_list_item_widget(self, horse) -> QWidget:
        """
        Creates a custom widget for displaying a single horse item in the list.
        Args:
            horse: The horse data object (expected to have attributes like
                   horse_name, account_number, breed, color, sex, date_of_birth, location).
        Returns:
            QWidget: The custom widget for the list item.
        """
        widget = QWidget()
        # Ensure the widget itself doesn't override the transparent background needed for items
        widget.setStyleSheet(
            f"background-color: transparent; border: none; color: {DARK_TEXT_PRIMARY};"
        )
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(0, 5, 0, 5)
        layout.setSpacing(2)

        name_label = QLabel(horse.horse_name or "Unnamed Horse")
        name_label.setFont(QFont(DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold))
        name_label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background: transparent;"
        )

        info_text = f"Acct: {horse.account_number or 'N/A'} | {horse.breed or 'N/A'}"
        info_label = QLabel(info_text)
        info_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-size: 10px; background: transparent;"
        )

        details_text = f"{horse.color or '?'} | {horse.sex or '?'} | {self._calculate_age(horse.date_of_birth)}"
        details_label = QLabel(details_text)
        details_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-size: 10px; background: transparent;"
        )

        location_text = horse.location.location_name if horse.location else "N/A"
        location_label = QLabel(f"📍 {location_text}")
        location_label.setStyleSheet(
            f"color: {DARK_TEXT_TERTIARY}; font-size: 10px; background: transparent;"
        )

        layout.addWidget(name_label)
        layout.addWidget(info_label)
        layout.addWidget(details_label)
        layout.addWidget(location_label)
        layout.addStretch()
        return widget

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        """
        Calculates the age of the horse based on the birth date.
        Args:
            birth_date_obj: The date of birth of the horse.
        Returns:
            str: A string representation of the horse's age.
        """
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            # self.logger.warning(f"Invalid birth_date_obj for age calculation: {birth_date_obj}")
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yr" if age_val == 1 else f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"


=============== FILE: views\horse\widgets\horse_owner_list_widget.py ===============

# views/horse/widgets/horse_owner_list_widget.py

"""
EDSI Veterinary Management System - Horse Owner List Widget
Version: 1.0.1
Purpose: Custom QListWidget for displaying horse-owner associations with specific styling.
         Corrected AppConfig constant usage.
Last Updated: May 18, 2025
Author: Claude Assistant

Changelog:
- v1.0.1 (2025-05-18):
    - Corrected AppConfig constant usage. Imported constants directly instead of
      accessing them via the AppConfig class.
- v1.0.0 (2025-05-17):
    - Initial extraction from horse_unified_management.py.
"""

import logging
from PySide6.QtWidgets import QListWidget

# QColor might not be directly used if config provides strings, but good to keep if needed by palette
from PySide6.QtGui import QColor

# Corrected import: Import constants directly
from config.app_config import (
    DARK_BORDER,
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
)


class HorseOwnerListWidget(QListWidget):
    """Custom list widget for displaying horse owners in the Owners tab."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setStyleSheet(
            f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER};
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                outline: none; border-radius: 4px;
            }}
            QListWidget::item {{
                padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER};
            }}
            QListWidget::item:selected {{
                background-color: {DARK_PRIMARY_ACTION}50; /* Using alpha for selection */
                color: #ffffff; /* Ensure text is readable on selection */
            }}
            QListWidget::item:hover:!selected {{
                background-color: {DARK_ITEM_HOVER};
            }}
            """
        )


