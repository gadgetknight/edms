=============== FILE: main.py ===============

# main.py

"""
EDSI Veterinary Management System - Main Application Entry Point
Version: 2.1.1
Purpose: Configured to use user-defined paths from AppConfig for logging and database.
         Now imports all top-level managers/controllers directly and passes them
         down using dependency injection to resolve persistent ModuleNotFoundError.
Last Updated: June 23, 2025
Author: Claude Assistant (Modified by Gemini, further modified by Coding partner)

Changelog:
- v2.1.1 (2025-06-23):
    - **CRITICAL BUG FIX (Final Attempt for ModuleNotFoundError):** Moved `sys.path`
      manipulation to the *absolute very top* of the file, before any other imports,
      to guarantee that the project root is added to Python's search path immediately.
      This ensures top-level packages like 'config' and 'services' are discoverable.
# ... (previous changelog entries)
"""

import sys
import os

# CRITICAL BUG FIX: Add project root to sys.path at the very beginning of the script.
# This ensures Python can find top-level packages like 'config' and 'services'.
# __file__ gives the path to this script. dirname(__file__) is its directory.
# os.pardir is '..'. So, join(dirname(__file__), os.pardir) goes up one level.
# abspath ensures it's a full path.
_PROJECT_ROOT_FOR_PATHING = os.path.abspath(
    os.path.join(os.path.dirname(__file__), os.pardir)
)

if _PROJECT_ROOT_FOR_PATHING not in sys.path:
    sys.path.insert(0, _PROJECT_ROOT_FOR_PATHING)


import logging
from logging.handlers import RotatingFileHandler
from typing import Optional
import traceback

from PySide6.QtWidgets import (
    QApplication,
    QMessageBox,
    QDialog,
)
from PySide6.QtCore import (
    Qt,
)
from sqlalchemy import text

# Now, with the sys.path fixed above, these imports should resolve correctly.
from config.config_manager import config_manager as _config_manager_instance
from services.backup_manager import backup_manager as _backup_manager_instance

# Import AppConfig (which now pulls paths from _config_manager_instance)
from config.database_config import db_manager
from config.app_config import AppConfig

# These imports are dependent on AppConfig's paths being set up correctly
# For instance, SplashScreen may try to load assets.
from views.auth.splash_screen import SplashScreen
from views.auth.small_login_dialog import SmallLoginDialog
from views.horse.horse_unified_management import HorseUnifiedManagement
from views.admin.user_management_screen import UserManagementScreen

# The global exception hook logger is defined here for early availability
exception_logger = logging.getLogger("GlobalExceptionHook")


def global_exception_hook(exctype, value, tb):
    """Handle uncaught exceptions globally and log them."""
    formatted_traceback = "".join(traceback.format_exception(exctype, value, tb))
    exception_logger.critical(
        f"Unhandled exception: {exctype.__name__}: {value}\n{formatted_traceback}",
        exc_info=(exctype, value, tb),
    )
    app_instance = QApplication.instance()
    if app_instance:
        # Show a critical error message box if the QApplication exists
        QMessageBox.critical(
            None,
            "Critical Application Error",
            f"A critical error occurred: {value}\n\nPlease check logs for details.",
        )


class EDSIApplication(QApplication):
    """
    Main application class for the EDSI Veterinary Management System.
    Handles application lifecycle, logging, database initialization, and screen flow.
    """

    def __init__(self, config_manager_instance, backup_manager_instance):
        super().__init__(sys.argv)
        # Set the global exception hook early
        sys.excepthook = global_exception_hook

        self._config_manager = config_manager_instance
        self._backup_manager = backup_manager_instance

        self.current_user_id: Optional[str] = None
        self.splash_screen: Optional[SplashScreen] = None
        self.login_dialog: Optional[SmallLoginDialog] = None
        self.horse_management_screen: Optional[HorseUnifiedManagement] = None
        self.user_management_screen: Optional[UserManagementScreen] = None
        self.active_screen_name: Optional[str] = None

        # Ensure core application directories exist (now uses AppConfig's resolved paths)
        AppConfig.ensure_directories()

        # Set basic application info
        self.setApplicationName(AppConfig.APP_NAME)
        self.setApplicationVersion(AppConfig.APP_VERSION)
        self.setOrganizationName("EDSI")

        # Initialize the logger for this instance *before* calling setup_logging
        self.logger = logging.getLogger(self.__class__.__name__)

        # Setup logging using the paths resolved by AppConfig
        self.setup_logging()

        self.logger.info(f"Starting {AppConfig.APP_NAME} v{AppConfig.APP_VERSION}")
        self.logger.info(f"Python version: {sys.version}")
        self.logger.info(f"PySide6 version: {self.applicationVersion()}")

        # Initialize the database using the URL from AppConfig
        self.initialize_database()

        # Start the application flow with the splash screen
        self.show_splash_screen()

    def setup_logging(self):
        """
        Configures application logging to both console and a rotating file.
        Uses log directory and file paths from AppConfig.
        """
        log_config = AppConfig.get_logging_config()

        # Ensure the log directory exists BEFORE setting up file handlers.
        # AppConfig.ensure_directories() should have already done this,
        # but a defensive check here doesn't hurt.
        if not os.path.exists(log_config["log_dir"]):
            try:
                os.makedirs(log_config["log_dir"])
            except OSError as e:
                # If log directory creation fails, fall back to console-only logging
                print(f"Error creating log directory: {e}", file=sys.stderr)
                logging.basicConfig(
                    level=log_config["level"],
                    format="%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s",
                    handlers=[logging.StreamHandler(sys.stdout)],
                )
                logging.warning(
                    "Log directory creation failed. Logging to console only."
                )
                return

        root_logger = logging.getLogger()
        root_logger.setLevel(log_config["level"])

        # Clear existing handlers to prevent duplicate logs if called multiple times
        if root_logger.hasHandlers():
            root_logger.handlers.clear()

        formatter = logging.Formatter(
            "%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s"
        )

        # Add console handler
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(formatter)
        root_logger.addHandler(console_handler)

        # Add file handler with rotation
        try:
            file_handler = RotatingFileHandler(
                log_config["app_log_file"],
                maxBytes=log_config["log_max_bytes"],
                backupCount=log_config["log_backup_count"],
                encoding="utf-8",
            )
            file_handler.setFormatter(formatter)
            root_logger.addHandler(file_handler)
            self.logger.info("Logging configured (Console and File)")
        except Exception as e:
            print(f"Error setting up file logger: {e}", file=sys.stderr)
            self.logger.info(
                "Logging configured (Console only due to file handler error)"
            )

    def initialize_database(self):
        """
        Initializes the database connection using the URL from AppConfig.
        Ensures the database is accessible before proceeding.
        """
        self.logger.info("Initializing database...")
        try:
            # db_manager is a function that returns the instance, so call it first
            db_manager().initialize_database()  # Corrected line
            # Perform a simple query to verify connection
            with db_manager().get_session() as session:  # Corrected line
                session.execute(text("SELECT 1"))
            self.logger.info("Database initialized successfully")
        except Exception as e:
            self.logger.critical(f"Database initialization failed: {e}", exc_info=True)
            QMessageBox.critical(
                None,
                "Database Error",
                f"Failed to initialize database: {e}\n\nThe application will exit.",
            )
            sys.exit(1)

    def show_splash_screen(self):
        """Displays the application splash screen."""
        self.logger.info("Showing splash screen")
        self._cleanup_screens(keep_main=False)
        self.splash_screen = SplashScreen()
        self.splash_screen.login_requested.connect(self.show_login_dialog)
        self.splash_screen.exit_requested.connect(self.quit_application)
        self.splash_screen.show()

    def show_login_dialog(self):
        """Displays the login dialog, potentially over the splash screen."""
        self.logger.info("Showing login dialog")
        if self.login_dialog and self.login_dialog.isVisible():
            self.login_dialog.raise_()
            self.login_dialog.activateWindow()
            return

        parent_widget = (
            self.splash_screen
            if self.splash_screen and self.splash_screen.isVisible()
            else None
        )
        self.login_dialog = SmallLoginDialog(parent=parent_widget)
        self.login_dialog.login_successful.connect(self.handle_login_success)
        self.login_dialog.dialog_closed.connect(self.handle_login_dialog_closed)
        self.login_dialog.setModal(True)
        self.login_dialog.show()

    def handle_login_success(self, user_id: str):
        """Handles a successful login event."""
        self.current_user_id = user_id
        self.logger.info(f"User '{user_id}' logged in successfully")

        if self.login_dialog:
            try:
                self.login_dialog.login_successful.disconnect(self.handle_login_success)
                self.login_dialog.dialog_closed.disconnect(
                    self.handle_login_dialog_closed
                )
            except RuntimeError:
                self.logger.debug("Slots already disconnected from login_dialog.")
            self.login_dialog.close()
            self.login_dialog.deleteLater()
            self.login_dialog = None

        if self.splash_screen:
            self.splash_screen.close()
            self.splash_screen.deleteLater()
            self.splash_screen = None

        self.show_horse_management_screen()

    def handle_login_dialog_closed(self):
        """Handles the event when the login dialog is closed without a successful login."""
        self.logger.debug("Login dialog closed signal received.")
        if not self.current_user_id:
            if self.login_dialog:
                self.login_dialog.deleteLater()
                self.login_dialog = None
            if not (self.splash_screen and self.splash_screen.isVisible()):
                self.logger.info("Login dialog closed, no splash. Returning to splash.")
                self.show_splash_screen()
            else:
                self.logger.info("Login dialog closed. Splash screen remains active.")

    def show_horse_management_screen(self):
        """Displays the main horse management screen."""
        if not self.current_user_id:
            self.logger.warning("Attempted to show Horse Management without login.")
            self.show_splash_screen()
            return

        self.logger.info(
            f"Showing Horse Management screen for user: {self.current_user_id}"
        )
        self._cleanup_screens(keep_main=False)
        self.horse_management_screen = HorseUnifiedManagement(
            current_user=self.current_user_id
        )
        self.active_screen_name = "Horse Management"

        self.horse_management_screen.exit_requested.connect(self.handle_logout)
        self.horse_management_screen.closing.connect(self.on_main_screen_closing)
        self.horse_management_screen.setup_requested.connect(
            self.show_user_management_screen
        )
        self.horse_management_screen.show()
        self.logger.info("Horse Management Screen shown.")

    def show_user_management_screen(self):
        """Displays the user and system management screen."""
        self.logger.info(
            "Setup icon clicked, attempting to show User Management Screen."
        )
        if not self.current_user_id:
            self.logger.error("Cannot show User Management Screen: No user logged in.")
            QMessageBox.warning(
                None,
                "Authentication Error",
                "No user is currently logged in. Please log in to access setup.",
            )
            return

        if self.user_management_screen and self.user_management_screen.isVisible():
            self.logger.info(
                "User Management Screen is already visible. Activating and raising."
            )
            self.user_management_screen.activateWindow()
            self.user_management_screen.raise_()
            return
        if self.user_management_screen:
            self.logger.info("Re-showing existing User Management Screen instance.")
            self.user_management_screen.show()
            self.user_management_screen.activateWindow()
            self.user_management_screen.raise_()
            return

        self.logger.info("Creating new User Management Screen instance.")
        self.user_management_screen = UserManagementScreen(
            current_user_id=self.current_user_id,
            config_manager_instance=self._config_manager,
            backup_manager_instance=self._backup_manager,
        )

        self.user_management_screen.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose)
        self.user_management_screen.destroyed.connect(
            self.handle_user_management_destroyed
        )

        self.user_management_screen.show()
        self.logger.info("User Management Screen shown.")

    def handle_user_management_destroyed(self):
        """Slot to reset reference when User Management Screen is destroyed."""
        self.logger.info(
            "User Management Screen was closed and its instance destroyed."
        )
        self.user_management_screen = None

    def handle_logout(self):
        """Handles user logout request."""
        active_user = self.current_user_id or "Unknown user"
        screen_name = self.active_screen_name or "current screen"
        self.logger.info(f"User '{active_user}' logging out from {screen_name}.")
        self.current_user_id = None
        self.active_screen_name = None
        self.logger.info("Logout requested. Application will now exit.")
        self.quit_application()

    def on_main_screen_closing(self):
        """Handles closure of the main application screen (Horse Management)."""
        self.logger.info("Main application screen (Horse Management) is closing.")
        if self.current_user_id:
            self.logger.info("Main screen closed by user; initiating application quit.")
            self.quit_application()

    def quit_application(self):
        """Initiates a clean shutdown of the entire application."""
        self.logger.info("Application quit requested.")
        self._cleanup_screens(keep_main=False)
        self.quit()

    def _cleanup_screens(self, keep_main: bool = False):
        """
        Closes and deletes existing screen instances.
        Args:
            keep_main (bool): If True, the HorseUnifiedManagement screen will not be closed.
        """
        self.logger.debug(f"Cleanup screens called. Keep main: {keep_main}")

        if self.user_management_screen:
            self.logger.debug("Cleaning up User Management Screen.")
            try:
                self.user_management_screen.destroyed.disconnect(
                    self.handle_user_management_destroyed
                )
            except RuntimeError:
                pass
            self.user_management_screen.close()
            self.user_management_screen = None

        if self.splash_screen:
            try:
                self.splash_screen.login_requested.disconnect(self.show_login_dialog)
                self.splash_screen.exit_requested.connect(self.quit_application)
            except RuntimeError:
                pass
            self.splash_screen.close()
            self.splash_screen.deleteLater()
            self.splash_screen = None
            self.logger.debug("Splash screen cleaned up.")

        if self.login_dialog:
            try:
                self.login_dialog.login_successful.disconnect(self.handle_login_success)
                self.login_dialog.dialog_closed.disconnect(
                    self.handle_login_dialog_closed
                )
            except RuntimeError:
                pass
            self.login_dialog.close()
            self.login_dialog.deleteLater()
            self.login_dialog = None
            self.logger.debug("Login dialog cleaned up.")

        if not keep_main and self.horse_management_screen:
            self.logger.debug("Cleaning up Horse Management Screen.")
            try:
                self.horse_management_screen.exit_requested.disconnect(
                    self.handle_logout
                )
                self.horse_management_screen.closing.disconnect(
                    self.on_main_screen_closing
                )
                self.horse_management_screen.setup_requested.disconnect(
                    self.show_user_management_screen
                )
            except RuntimeError:
                pass
            self.horse_management_screen.close()
            self.horse_management_screen.deleteLater()
            self.horse_management_screen = None
            self.logger.debug("Horse management screen cleaned up.")
        self.logger.debug("Screens cleanup finished.")

    def run(self):
        """Starts the QApplication event loop."""
        self.logger.info(f"Starting {AppConfig.APP_NAME} event loop")
        try:
            exit_code = self.exec()
            self.logger.info(f"Application finished with exit code: {exit_code}")
            return exit_code
        except Exception as e:
            self.logger.critical(f"Critical error in event loop: {e}", exc_info=True)
            QMessageBox.critical(
                None,
                "Fatal Error",
                f"A fatal error occurred in the application event loop: {e}\nPlease check logs.",
            )
            return 1


def main():
    """Main entry point function for the application."""
    # This block requires _config_manager_instance to be available.
    # AppConfig.LOG_DIR depends on _config_manager_instance.
    # To handle potential issues with _config_manager_instance not being fully
    # initialized (e.g., if it attempts to load config.ini which depends on AppConfig
    # in a circular way during global import), we must manage this carefully.

    # 1. Instantiate ConfigManager (which also handles its own file loading)
    # This needs to be done *before* AppConfig is initialized if AppConfig uses it immediately.
    # The global _config_manager_instance from config.config_manager is already instantiated.
    # So we just refer to it.
    _injected_config_manager = _config_manager_instance

    # 2. Inject ConfigManager into AppConfig
    # This must happen before AppConfig.ensure_directories() and AppConfig.get_logging_config()
    # AppConfig.set_config_manager_instance(_injected_config_manager) # Line was not present in 2.1.0 (from your dump)

    # Now that AppConfig is configured with _injected_config_manager, its paths are ready.
    # We can ensure the log directory exists and set up initial logging.
    if not os.path.exists(AppConfig.LOG_DIR):
        try:
            os.makedirs(AppConfig.LOG_DIR)
        except OSError as e:
            print(
                f"Could not create log directory: {AppConfig.LOG_DIR}. Error: {e}",
                file=sys.stderr,
            )

    logging.basicConfig(
        level=AppConfig.LOGGING_LEVEL,
        format="%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)],
    )
    main_logger = logging.getLogger(__name__)
    main_logger.info("Application main script started.")

    try:
        # 3. Instantiate DatabaseManager, injecting AppConfig and ConfigManager
        # DatabaseManager needs AppConfig for its DB_URL and ConfigManager for internal config queries.
        from config.database_config import set_db_manager_instance, DatabaseManager

        set_db_manager_instance(DatabaseManager(AppConfig, _injected_config_manager))

        # Pass the instantiated manager instances to the QApplication constructor
        app = EDSIApplication(
            config_manager_instance=_injected_config_manager,
            backup_manager_instance=_backup_manager_instance,  # This assumes _backup_manager_instance is globally available from a successful import
        )
        exit_code = app.run()
        main_logger.info(f"Application exiting with code {exit_code}")
        sys.exit(exit_code)
    except Exception as e:
        critical_logger = logging.getLogger("main_entry_point")
        critical_logger.critical(
            f"Fatal error starting or running application: {e}", exc_info=True
        )
        try:
            if not QApplication.instance():
                QApplication(sys.argv)
            QMessageBox.critical(
                None,
                "Fatal Application Error",
                f"A fatal error occurred: {e}\nApplication will exit. Check logs.",
            )
        except Exception as mb_error:
            print(
                f"Could not display fatal error message box: {mb_error}",
                file=sys.stderr,
            )
        sys.exit(1)


if __name__ == "__main__":
    # Ensure initial log directory for main's own logging is robust
    # This might be redundant after the main() function's AppConfig.LOG_DIR check,
    # but good for very early errors before main() takes over.
    _initial_log_dir_fallback = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "logs_temp"
    )
    if not os.path.exists(_initial_log_dir_fallback):
        os.makedirs(_initial_log_dir_fallback, exist_ok=True)

    # Configure basic logging for the `__main__` block.
    # This is a fallback/initial logging that will be reconfigured
    # more thoroughly by `EDSIApplication.setup_logging` once the app starts.
    logging.basicConfig(
        level=logging.INFO,  # Use INFO here as AppConfig is not yet fully linked
        format="%(asctime)s - %(levelname)s - %(name)s - %(module)s:%(lineno)d - %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)],
    )

    main_logger_for_init = logging.getLogger(__name__)
    main_logger_for_init.info("Application main script invoked from __main__ block.")

    # Call main function to start the application logic
    main()

    main_logger_for_init.info("Application main script finished execution.")


=============== FILE: config/__init__.py ===============

# config/__init__.py

"""Configuration package"""


=============== FILE: config/app_config.py ===============

# config/app_config.py

"""
EDSI Veterinary Management System - Application Configuration
Version: 2.1.0
Purpose: Centralized configuration for application settings, paths, and constants.
         Now integrates with ConfigManager for user-configurable data directories.
Last Updated: June 23, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.2.0 (2025-06-23):
    - Integrated `config_manager` to allow user-configurable paths for:
        - `DATABASE_URL`
        - `LOG_DIR`
        - `ASSETS_DIR` (using relative fallback)
        - `INVOICES_DIR`
        - `STATEMENTS_DIR` (newly added configurable path)
    - Modified path constants to check `config_manager` first, then fallback to project defaults.
    - Updated `ensure_directories()` to create all managed directories.
- v2.1.0 (2025-06-09):
    - Added INVOICES_DIR path constant for storing generated invoice PDFs.
    - Updated ensure_directories() to create the 'invoices' folder on startup.
- v2.0.1 (2025-05-26):
    - Added LOG_MAX_BYTES and LOG_BACKUP_COUNT constants for log file rotation.
    - Included log_max_bytes and log_backup_count in the get_logging_config() dictionary.
    - Updated module-level APP_VERSION constant to "2.0.3" to align with main application.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Consolidated all configuration into single AppConfig class
"""

import os
import logging
from typing import Dict, Any

# Import the new ConfigManager for user-configurable paths
from config.config_manager import config_manager, ConfigManager

# --- Core Project Path (always relative to app_config.py location) ---
# This remains the absolute base for default fallbacks
_BASE_PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

# --- Application Information ---
APP_NAME = "EDSI Veterinary Management System"
APP_VERSION = "2.0.3"
APP_AUTHOR = "EDSI"

# --- Database Configuration ---
# Prioritize user-defined DB path, fallback to project root default
_DEFAULT_DB_PATH = os.path.join(_BASE_PROJECT_ROOT, "edsi_database.db")
DATABASE_URL = f"sqlite:///{config_manager.get_path(ConfigManager.DB_PATH_KEY) or _DEFAULT_DB_PATH}"

# --- Paths (User-configurable with fallbacks) ---
# Prioritize user-defined paths, fallback to project root defaults
PROJECT_ROOT = _BASE_PROJECT_ROOT  # This refers to the application's installed root
LOG_DIR = config_manager.get_path(ConfigManager.LOG_DIR_KEY) or os.path.join(
    _BASE_PROJECT_ROOT, "logs"
)
ASSETS_DIR = config_manager.get_path(ConfigManager.ASSETS_DIR_KEY) or os.path.join(
    _BASE_PROJECT_ROOT, "assets"
)
INVOICES_DIR = config_manager.get_path(ConfigManager.INVOICES_DIR_KEY) or os.path.join(
    _BASE_PROJECT_ROOT, "invoices"
)
STATEMENTS_DIR = config_manager.get_path(
    ConfigManager.STATEMENTS_DIR_KEY
) or os.path.join(
    _BASE_PROJECT_ROOT, "statements"
)  # NEW

# --- Logging Configuration (uses LOG_DIR defined above) ---
APP_LOG_FILE = os.path.join(LOG_DIR, "edsi_app.log")
DB_LOG_FILE = os.path.join(LOG_DIR, "edsi_db.log")
LOGGING_LEVEL = logging.INFO
LOG_MAX_BYTES = 1024 * 1024 * 5
LOG_BACKUP_COUNT = 5

# --- UI Configuration ---
DEFAULT_FONT_FAMILY = "Inter"
DEFAULT_FONT_SIZE = 10
SMALL_FONT_SIZE = 9
MIN_WINDOW_WIDTH = 900
MIN_WINDOW_HEIGHT = 700

# --- Dark Theme Colors (Essential Only) ---
DARK_BACKGROUND = "#2D3748"
DARK_WIDGET_BACKGROUND = "#1A202C"
DARK_HEADER_FOOTER = "#222B38"
DARK_BORDER = "#4A5568"
DARK_TEXT_PRIMARY = "#E2E8F0"
DARK_TEXT_SECONDARY = "#A0AEC0"
DARK_TEXT_TERTIARY = "#718096"
DARK_PRIMARY_ACTION = "#3182CE"
DARK_SUCCESS_ACTION = "#38A169"
DARK_WARNING_ACTION = "#DD6B20"
DARK_DANGER_ACTION = "#E53E3E"
DARK_BUTTON_BG = "#4A5568"
DARK_BUTTON_HOVER = "#718096"
DARK_ITEM_HOVER = "#2C3543"
DARK_HIGHLIGHT_BG = "#3182CE"
DARK_HIGHLIGHT_TEXT = "#FFFFFF"
DARK_INPUT_FIELD_BACKGROUND = "#222B38"


class AppConfig:
    """
    Centralized application configuration class.
    Provides clean access to all application settings.
    """

    # Application Info
    APP_NAME = APP_NAME
    APP_VERSION = APP_VERSION
    APP_AUTHOR = APP_AUTHOR

    # Paths
    PROJECT_ROOT = PROJECT_ROOT
    LOG_DIR = LOG_DIR
    ASSETS_DIR = ASSETS_DIR
    INVOICES_DIR = INVOICES_DIR
    STATEMENTS_DIR = STATEMENTS_DIR  # NEW

    # Database
    DATABASE_URL = DATABASE_URL

    # Logging
    APP_LOG_FILE = APP_LOG_FILE
    DB_LOG_FILE = DB_LOG_FILE
    LOGGING_LEVEL = LOGGING_LEVEL
    LOG_MAX_BYTES = LOG_MAX_BYTES
    LOG_BACKUP_COUNT = LOG_BACKUP_COUNT

    # UI Settings
    DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY
    DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE
    SMALL_FONT_SIZE = SMALL_FONT_SIZE
    MIN_WINDOW_WIDTH = MIN_WINDOW_WIDTH
    MIN_WINDOW_HEIGHT = MIN_WINDOW_HEIGHT

    # Theme Colors
    DARK_BACKGROUND = DARK_BACKGROUND
    DARK_WIDGET_BACKGROUND = DARK_WIDGET_BACKGROUND
    DARK_HEADER_FOOTER = DARK_HEADER_FOOTER
    DARK_BORDER = DARK_BORDER
    DARK_TEXT_PRIMARY = DARK_TEXT_PRIMARY
    DARK_TEXT_SECONDARY = DARK_TEXT_SECONDARY
    DARK_TEXT_TERTIARY = DARK_TEXT_TERTIARY
    DARK_PRIMARY_ACTION = DARK_PRIMARY_ACTION
    DARK_SUCCESS_ACTION = DARK_SUCCESS_ACTION
    DARK_WARNING_ACTION = DARK_WARNING_ACTION
    DARK_DANGER_ACTION = DARK_DANGER_ACTION
    DARK_BUTTON_BG = DARK_BUTTON_BG
    DARK_BUTTON_HOVER = DARK_BUTTON_HOVER
    DARK_ITEM_HOVER = DARK_ITEM_HOVER
    DARK_HIGHLIGHT_BG = DARK_HIGHLIGHT_BG
    DARK_HIGHLIGHT_TEXT = DARK_HIGHLIGHT_TEXT
    DARK_INPUT_FIELD_BACKGROUND = DARK_INPUT_FIELD_BACKGROUND

    @classmethod
    def get_database_url(cls) -> str:
        return cls.DATABASE_URL

    @classmethod
    def get_app_dir(cls) -> str:
        # This will still return the original _BASE_PROJECT_ROOT for consistency
        # unless specific user override for app_dir is added to config_manager
        return cls.PROJECT_ROOT

    @classmethod
    def get_assets_dir(cls) -> str:
        return cls.ASSETS_DIR

    @classmethod
    def get_invoices_dir(cls) -> str:
        return cls.INVOICES_DIR

    @classmethod
    def get_statements_dir(cls) -> str:  # NEW
        return cls.STATEMENTS_DIR

    @classmethod
    def get_logging_config(cls) -> Dict[str, Any]:
        """Get logging configuration"""
        return {
            "level": cls.LOGGING_LEVEL,
            # Use dynamically configured paths for log files
            "app_log_file": os.path.join(cls.LOG_DIR, "edsi_app.log"),
            "db_log_file": os.path.join(cls.LOG_DIR, "edsi_db.log"),
            "log_dir": cls.LOG_DIR,
            "log_max_bytes": cls.LOG_MAX_BYTES,
            "log_backup_count": cls.LOG_BACKUP_COUNT,
        }

    @classmethod
    def get_ui_config(cls) -> Dict[str, Any]:
        return {
            "font_family": cls.DEFAULT_FONT_FAMILY,
            "font_size": cls.DEFAULT_FONT_SIZE,
            "small_font_size": cls.SMALL_FONT_SIZE,
            "min_window_width": cls.MIN_WINDOW_WIDTH,
            "min_window_height": cls.MIN_WINDOW_HEIGHT,
        }

    @classmethod
    def get_theme_colors(cls) -> Dict[str, str]:
        return {
            "background": cls.DARK_BACKGROUND,
            "widget_background": cls.DARK_WIDGET_BACKGROUND,
            "header_footer": cls.DARK_HEADER_FOOTER,
            "border": cls.DARK_BORDER,
            "text_primary": cls.DARK_TEXT_PRIMARY,
            "text_secondary": cls.DARK_TEXT_SECONDARY,
            "text_tertiary": cls.DARK_TEXT_TERTIARY,
            "primary_action": cls.DARK_PRIMARY_ACTION,
            "success_action": cls.DARK_SUCCESS_ACTION,
            "warning_action": cls.DARK_WARNING_ACTION,
            "danger_action": cls.DARK_DANGER_ACTION,
            "button_bg": cls.DARK_BUTTON_BG,
            "button_hover": DARK_BUTTON_HOVER,
            "item_hover": DARK_ITEM_HOVER,
            "highlight_bg": DARK_HIGHLIGHT_BG,
            "highlight_text": DARK_HIGHLIGHT_TEXT,
            "input_field_background": DARK_INPUT_FIELD_BACKGROUND,
        }

    @classmethod
    def ensure_directories(cls) -> None:
        """Ensure required directories exist, including user-configurable ones."""
        # Get current effective paths
        directories = [
            cls.LOG_DIR,
            cls.ASSETS_DIR,
            cls.INVOICES_DIR,
            cls.STATEMENTS_DIR,  # NEW
        ]

        for directory in directories:
            if not os.path.exists(directory):
                try:
                    os.makedirs(directory, exist_ok=True)
                    # Use standard logging now that it's set up in main.py
                    logging.info(f"Created directory: {directory}")
                except OSError as e:
                    logging.error(f"Failed to create directory {directory}: {e}")
                    # Continue attempting to create other directories


=============== FILE: config/config_manager.py ===============

# config/config_manager.py

"""
EDSI Veterinary Management System - Configuration Manager
Version: 1.0.2
Purpose: Manages user-configurable application paths for database, invoices, and statements.
         Uses a configuration file for persistent storage of these paths.
Last Updated: June 23, 2025
Author: Gemini

Changelog:
- v1.0.2 (2025-06-23):
    - **BUG FIX:** Added missing class attribute `ASSETS_DIR_KEY` to the `ConfigManager` class.
      Ensured all path keys (`DB_PATH_KEY`, `LOG_DIR_KEY`, `INVOICES_DIR_KEY`, `STATEMENTS_DIR_KEY`)
      are explicitly defined as class attributes. This resolves the `AttributeError` for `ASSETS_DIR_KEY`.
- v1.0.1 (2025-06-23):
    - **BUG FIX:** Added missing class attributes `DB_PATH_KEY`, `LOG_DIR_KEY`,
      `INVOICES_DIR_KEY`, and `STATEMENTS_DIR_KEY` to the `ConfigManager` class.
      This resolves the `AttributeError: type object 'ConfigManager' has no attribute 'LOG_DIR_KEY'`.
- v1.0.0 (2025-06-23):
    - Initial creation of the ConfigManager class.
    - Implemented methods to load, save, get, and set user-configurable paths.
    - Uses 'config.ini' file for persistence in the user's home directory.
"""

import os
import configparser
import logging
from typing import Optional


class ConfigManager:
    """
    Manages user-configurable application paths (database, invoices, statements).
    Loads configuration from and saves to a 'config.ini' file.
    """

    # Define configuration keys for paths (FIXED: All keys are now present)
    DB_PATH_KEY = "database_path"
    LOG_DIR_KEY = "logs_directory"
    ASSETS_DIR_KEY = "assets_directory"  # FIXED: Added this missing key
    INVOICES_DIR_KEY = "invoices_directory"
    STATEMENTS_DIR_KEY = "statements_directory"

    # Define the default configuration file name
    CONFIG_FILE_NAME = "edms_config.ini"

    def __init__(self):
        """
        Initializes the ConfigManager, setting up the logger and determining
        the path to the configuration file.
        """
        self.logger = logging.getLogger(self.__class__.__name__)
        # Store config file in a user-specific and OS-appropriate location
        self.config_file_path = self._get_config_file_path()
        self.config = configparser.ConfigParser()
        self._load_config()

    def _get_config_file_path(self) -> str:
        """
        Determines the appropriate path for the configuration file based on the OS.
        For Windows, it uses APPDATA; for Linux/macOS, it uses ~/.config or ~/.local/share.
        """
        if os.name == "nt":  # Windows
            app_config_dir = os.path.join(
                os.environ.get("APPDATA", os.path.expanduser("~")), "EDMS"
            )
        else:  # Linux, macOS, etc.
            app_config_dir = os.path.join(os.path.expanduser("~"), ".config", "EDMS")

        # Ensure the directory exists
        os.makedirs(app_config_dir, exist_ok=True)

        return os.path.join(app_config_dir, self.CONFIG_FILE_NAME)

    def _load_config(self):
        """
        Loads the configuration from the INI file. If the file or section
        does not exist, it initializes with default (empty) values.
        """
        try:
            self.config.read(self.config_file_path)
            if "Paths" not in self.config:
                self.config["Paths"] = {}
                self.logger.info(
                    f"Initialized 'Paths' section in {self.config_file_path}."
                )
            self.logger.info(f"Configuration loaded from {self.config_file_path}.")
        except Exception as e:
            self.logger.error(
                f"Error loading configuration from {self.config_file_path}: {e}",
                exc_info=True,
            )
            # Ensure 'Paths' section exists even if loading fails
            if "Paths" not in self.config:
                self.config["Paths"] = {}

    def _save_config(self):
        """
        Saves the current configuration to the INI file.
        """
        try:
            with open(self.config_file_path, "w", encoding="utf-8") as configfile:
                self.config.write(configfile)
            self.logger.info(f"Configuration saved to {self.config_file_path}.")
        except Exception as e:
            self.logger.error(
                f"Error saving configuration to {self.config_file_path}: {e}",
                exc_info=True,
            )

    def get_path(self, key: str) -> Optional[str]:
        """
        Retrieves a configured path.

        Args:
            key (str): The key corresponding to the path (e.g., DB_PATH_KEY).

        Returns:
            Optional[str]: The configured path, or None if not set.
        """
        return self.config.get("Paths", key, fallback=None)

    def set_path(self, key: str, path: str):
        """
        Sets a configurable path and saves the configuration.

        Args:
            key (str): The key corresponding to the path.
            path (str): The path to set.
        """
        self.config["Paths"][key] = path
        self._save_config()
        self.logger.info(f"Path '{key}' set to '{path}' and saved.")


# Instantiate the ConfigManager to be used globally
config_manager = ConfigManager()


=============== FILE: config/database_config.py ===============

# config/database_config.py

"""
EDSI Veterinary Management System - Database Configuration
Version: 2.0.4
Purpose: Simplified database connection and session management using SQLAlchemy.
         Now receives ConfigManager instance via dependency injection.
Last Updated: June 23, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.4 (2025-06-23):
    - **CRITICAL ARCHITECTURAL CHANGE & BUG FIX:** Removed direct import of `AppConfig`.
    - `DatabaseManager` now receives `AppConfig` and `ConfigManager` instances via dependency injection.
    - Modified `initialize_database` to accept and use the injected `AppConfig` instance.
    - Updated `get_session`, `create_tables`, `_ensure_default_admin_user` to rely on injected instances.
    - This ensures robust database initialization without `ModuleNotFoundError` during early startup.
- v2.0.3 (2025-06-04):
    - Added Transaction and Invoice from financial_models to _import_models method
      to ensure their tables are created by Base.metadata.create_all.
# ... (previous changelog entries)
"""

import logging
import os
from typing import Optional
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, scoped_session, Session as SQLAlchemySession
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.exc import SQLAlchemyError

# REMOVED: Direct import of AppConfig. It will be injected.
# from config.app_config import AppConfig

# Create Base for all models
Base = declarative_base()

# Setup logger
db_logger = logging.getLogger("database_operations")


class DatabaseManager:
    """
    Simplified database manager for EDSI application.
    Handles database initialization, session creation, and table management.
    """

    def __init__(
        self, app_config_instance, config_manager_instance
    ):  # NEW: Accept injected instances
        self.engine = None
        self.SessionLocal: Optional[scoped_session[SQLAlchemySession]] = None
        self.db_url: Optional[str] = None
        self.logger = logging.getLogger(self.__class__.__name__)

        self._app_config = app_config_instance  # Store injected AppConfig
        self._config_manager = config_manager_instance  # Store injected ConfigManager

    def initialize_database(
        self,
    ) -> None:  # Removed db_url argument, use injected AppConfig
        """
        Initialize database connection and create tables.
        Uses the DATABASE_URL provided by the injected AppConfig instance.
        """
        if self.engine:
            self.logger.info("Database already initialized")
            return

        # Use the DATABASE_URL from the injected AppConfig instance
        self.db_url = self._app_config.get_database_url()
        if not self.db_url:
            raise ValueError("DATABASE_URL is not configured in AppConfig.")

        self.logger.info(f"Initializing database: {self.db_url}")

        try:
            self.engine = create_engine(
                self.db_url,
                echo=False,  # Set to True for SQL logging, False for production
                pool_pre_ping=True,
            )

            self.SessionLocal = scoped_session(
                sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
            )

            self.logger.info("Database engine and session factory created")
            self.create_tables()
            self._test_connection()
            self._ensure_default_admin_user()
            self.logger.info("Database initialization completed successfully")

        except SQLAlchemyError as e:
            self.logger.error(f"SQLAlchemy error during database initialization: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error during database initialization: {e}")
            raise

    def get_session(self) -> SQLAlchemySession:
        """
        Get a database session.
        """
        if not self.SessionLocal:
            raise RuntimeError(
                "Database not initialized. Call initialize_database() first."
            )
        return self.SessionLocal()

    def create_tables(self) -> None:
        """
        Create all database tables.
        """
        if not self.engine:
            raise RuntimeError("Database engine not initialized")

        try:
            self.logger.info("Creating database tables...")
            self._import_models()  # This ensures all models are known to Base
            Base.metadata.create_all(bind=self.engine)
            table_names = list(Base.metadata.tables.keys())
            self.logger.info(f"Database tables created/verified: {table_names}")

        except Exception as e:
            self.logger.error(f"Error creating database tables: {e}")
            raise

    def _import_models(self) -> None:
        """
        Import all model classes to ensure they are registered with Base.
        This is crucial for Base.metadata.create_all() to work correctly.
        """
        try:
            from models.base_model import BaseModel  # Already imported by other models
            from models.user_models import User, Role, UserRole
            from models.horse_models import Horse, HorseOwner, HorseLocation
            from models.owner_models import Owner, OwnerBillingHistory, OwnerPayment

            # The placeholder Invoice from owner_models is implicitly imported if not removed from its __init__ or owner_models.py
            from models.reference_models import (
                StateProvince,
                ChargeCodeCategory,
                ChargeCode,
                Veterinarian,
                Location,
                Procedure,  # Placeholder
                Drug,  # Placeholder
                TreatmentLog,  # Placeholder
                CommunicationLog,  # Placeholder
                Document,  # Placeholder
                Reminder,  # Placeholder
                Appointment,  # Placeholder
                # The placeholder Transaction & TransactionDetail from reference_models might also be imported
                # if not removed from its __init__ or reference_models.py
            )

            # Import new financial models
            from models.financial_models import Transaction, Invoice
            from models.company_profile_model import (
                CompanyProfile,
            )  # Added explicitly for AppConfig to work.

            self.logger.debug(
                "Models imported for table creation, including new financial models."
            )
        except ImportError as e:
            self.logger.error(
                f"Critical error: Could not import core models for table creation: {e}",
                exc_info=True,
            )
            # Depending on severity, you might want to raise this error
            # raise ImportError(f"Failed to import essential models: {e}") from e
        except Exception as e:
            self.logger.error(
                f"Unexpected error during model imports for table creation: {e}",
                exc_info=True,
            )

    def _test_connection(self) -> None:
        """
        Test database connection.
        """
        try:
            with self.get_session() as session:
                session.execute(text("SELECT 1"))
            self.logger.info("Database connection test successful")
        except Exception as e:
            self.logger.error(f"Database connection test failed: {e}")
            raise

    def _ensure_default_admin_user(self) -> None:
        """
        Ensure default admin user always exists with correct credentials
        (password hashed using bcrypt via User.set_password).
        Handles pre-existing non-bcrypt hashes for ADMIN by resetting the password.
        """
        try:
            with self.get_session() as session:
                from models.user_models import (
                    User,
                    Role,
                )

                self.logger.info(
                    "Ensuring default ADMIN user exists with bcrypt password."
                )

                admin_role_name = "ADMIN"
                admin_role = (
                    session.query(Role).filter(Role.name == admin_role_name).first()
                )
                if not admin_role:
                    self.logger.warning(
                        f"Role '{admin_role_name}' not found. Creating it now. "
                        "It's recommended to run add_initial_data.py for full role setup."
                    )
                    admin_role = Role(
                        name=admin_role_name,
                        description="System Administrator (auto-created by db_config)",
                        created_by="SYSTEM_DB_CONFIG",
                        modified_by="SYSTEM_DB_CONFIG",
                    )
                    session.add(admin_role)
                    session.flush()
                    self.logger.info(f"Created '{admin_role_name}' role.")

                admin_user = session.query(User).filter(User.user_id == "ADMIN").first()
                default_password = "admin1234"
                admin_default_name = "System Administrator"
                admin_default_email = "admin@edsi.local"

                if admin_user:
                    password_reset_done = False
                    attributes_updated = False

                    try:
                        if not admin_user.check_password(default_password):
                            self.logger.info(
                                "ADMIN user password check failed. Resetting."
                            )
                            admin_user.set_password(default_password)
                            password_reset_done = True
                    except ValueError as e:
                        self.logger.warning(
                            f"ADMIN password hash not bcrypt/valid ({e}). Resetting password."
                        )
                        admin_user.set_password(default_password)
                        password_reset_done = True

                    if password_reset_done:
                        admin_user.modified_by = "SYSTEM_DB_CONFIG_PWD"
                        self.logger.info(
                            "ADMIN user password has been set/reset to a bcrypt hash."
                        )

                    if not admin_user.is_active:
                        admin_user.is_active = True
                        self.logger.info("Activated ADMIN user.")
                        attributes_updated = True

                    if admin_user.user_name != admin_default_name:
                        admin_user.user_name = admin_default_name
                        self.logger.info(
                            f"Set ADMIN user_name to '{admin_default_name}'."
                        )
                        attributes_updated = True

                    if admin_user.email != admin_default_email:
                        admin_user.email = admin_default_email
                        self.logger.info(f"Set ADMIN email to '{admin_default_email}'.")
                        attributes_updated = True

                    if attributes_updated and not password_reset_done:
                        admin_user.modified_by = "SYSTEM_DB_CONFIG_ATTR"

                    if password_reset_done or attributes_updated:
                        self.logger.info("ADMIN user record updated/verified.")
                    else:
                        self.logger.info(
                            "ADMIN user credentials, status, and name are correct."
                        )

                else:
                    self.logger.info("ADMIN user not found. Creating new ADMIN user...")
                    admin_user = User(
                        user_id="ADMIN",
                        user_name=admin_default_name,
                        email=admin_default_email,
                        is_active=True,
                        created_by="SYSTEM_DB_CONFIG",
                        modified_by="SYSTEM_DB_CONFIG",
                    )
                    admin_user.set_password(default_password)
                    session.add(admin_user)
                    session.flush()
                    self.logger.info("Created new ADMIN user with bcrypt password.")

                if admin_role and admin_role not in admin_user.roles:
                    admin_user.roles.append(admin_role)
                    self.logger.info("Linked ADMIN user to ADMIN role.")
                elif not admin_role:
                    self.logger.error(
                        f"Cannot link ADMIN user to '{admin_role_name}' role as role object is missing."
                    )

                session.commit()
                self.logger.info(
                    f"Default ADMIN user ready (Username: ADMIN, Password: {default_password})"
                )

        except Exception as e:
            self.logger.error(f"Error ensuring default admin user: {e}", exc_info=True)
            if "session" in locals() and session.is_active:
                session.rollback()

    def close(self) -> None:
        if self.SessionLocal:
            self.SessionLocal.remove()
            self.logger.info("Database sessions closed")
        if self.engine:
            self.engine.dispose()
            self.logger.info("Database engine disposed")

    def get_engine(self):
        return self.engine


# db_manager is now a function that requires AppConfig and ConfigManager instances
# It will be instantiated in main.py and passed down.
_db_manager_instance = None  # Placeholder for the singleton instance


def set_db_manager_instance(instance):
    """Allows main.py to inject the configured db_manager instance."""
    global _db_manager_instance
    _db_manager_instance = instance


def db_manager() -> DatabaseManager:
    """Provides access to the singleton DatabaseManager instance."""
    if _db_manager_instance is None:
        raise RuntimeError(
            "DatabaseManager instance not set. Call set_db_manager_instance() from main.py first."
        )
    return _db_manager_instance


# init_database is no longer needed as db_manager.initialize_database() is called directly
# from EDSIApplication.
# def init_database(db_url: Optional[str] = None) -> None:
#    db_manager.initialize_database(db_url)


=============== FILE: reports/__init__.py ===============

"""
Report generator classes.
"""

from .owner_statement_generator import OwnerStatementGenerator
from .ar_aging_generator import ARAgingGenerator
from .invoice_register_generator import InvoiceRegisterGenerator
from .payment_history_generator import PaymentHistoryGenerator
from .charge_code_usage_generator import ChargeCodeUsageGenerator
from .horse_transaction_history_generator import HorseTransactionHistoryGenerator
from .invoice_generator import InvoiceGenerator


__all__ = [
    "OwnerStatementGenerator",
    "ARAgingGenerator",
    "InvoiceRegisterGenerator",
    "PaymentHistoryGenerator",
    "ChargeCodeUsageGenerator",
    "HorseTransactionHistoryGenerator",
    "InvoiceGenerator",
]


=============== FILE: reports/ar_aging_generator.py ===============

# reports/ar_aging_generator.py
"""
EDSI Veterinary Management System - A/R Aging PDF Generator
Version: 1.1.0
Purpose: Creates a PDF A/R Aging report.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-12):
    - Final corrected version. Standalone class.
"""
import logging
from decimal import Decimal
from typing import Dict, Any, Tuple

from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER
from reportlab.lib.pagesizes import landscape, letter

from config.app_config import AppConfig


class ARAgingGenerator:
    """Generates an A/R Aging PDF."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.styles = getSampleStyleSheet()
        self._setup_styles()

    def _setup_styles(self):
        """Creates custom styles for the report."""
        self.styles.add(
            ParagraphStyle(
                name="Normal_Right", parent=self.styles["Normal"], alignment=TA_RIGHT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Left", parent=self.styles["Normal"], alignment=TA_LEFT
            )
        )
        self.styles["h1"].alignment = TA_LEFT
        self.styles["h2"].alignment = TA_LEFT

    def _add_page_numbers(self, canvas, doc):
        """Adds page numbers to each page of the PDF."""
        canvas.saveState()
        canvas.setFont("Helvetica", 9)
        page_number_text = f"Page {doc.page}"
        canvas.drawCentredString(
            doc.width / 2.0 + doc.leftMargin, 0.25 * inch, page_number_text
        )
        canvas.restoreState()

    def generate_pdf(
        self, report_data: Dict[str, Any], file_path: str
    ) -> Tuple[bool, str]:
        """Creates and saves the A/R Aging PDF."""
        try:
            doc = SimpleDocTemplate(
                file_path,
                pagesize=landscape(letter),
                leftMargin=0.5 * inch,
                rightMargin=0.5 * inch,
                topMargin=0.5 * inch,
                bottomMargin=0.5 * inch,
            )

            story = []

            story.append(
                Paragraph("Accounts Receivable Aging Report", self.styles["h1"])
            )
            as_of_date_str = report_data["as_of_date"].strftime("%B %d, %Y")
            story.append(Paragraph(f"Aged as of: {as_of_date_str}", self.styles["h2"]))
            story.append(Spacer(1, 0.25 * inch))

            self._add_aging_table(story, report_data["lines"], report_data["totals"])

            doc.build(
                story,
                onFirstPage=self._add_page_numbers,
                onLaterPages=self._add_page_numbers,
            )
            self.logger.info(f"Successfully generated A/R Aging report: {file_path}")
            return True, f"Successfully generated report to {file_path}"
        except Exception as e:
            self.logger.error(f"Failed to generate A/R Aging PDF: {e}", exc_info=True)
            return False, f"Failed to generate PDF: {e}"

    def _add_aging_table(self, story, lines, totals):
        table_data = [
            [
                "Owner",
                "Current",
                "31-60 Days",
                "61-90 Days",
                "Over 90 Days",
                "Total Balance",
            ]
        ]

        for line in lines:
            table_data.append(
                [
                    Paragraph(line["name"], self.styles["Normal_Left"]),
                    f"${line['buckets']['current']:,.2f}",
                    f"${line['buckets']['31-60']:,.2f}",
                    f"${line['buckets']['61-90']:,.2f}",
                    f"${line['buckets']['over_90']:,.2f}",
                    f"${line['total']:,.2f}",
                ]
            )

        table_data.append(
            [
                Paragraph("<b>TOTALS</b>", self.styles["Normal"]),
                Paragraph(
                    f"<b>${totals['current']:,.2f}</b>", self.styles["Normal_Right"]
                ),
                Paragraph(
                    f"<b>${totals['31-60']:,.2f}</b>", self.styles["Normal_Right"]
                ),
                Paragraph(
                    f"<b>${totals['61-90']:,.2f}</b>", self.styles["Normal_Right"]
                ),
                Paragraph(
                    f"<b>${totals['over_90']:,.2f}</b>", self.styles["Normal_Right"]
                ),
                Paragraph(
                    f"<b>${totals['total']:,.2f}</b>", self.styles["Normal_Right"]
                ),
            ]
        )

        style = TableStyle(
            [
                ("BACKGROUND", (0, 0), (-1, 0), colors.darkgrey),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                ("ALIGN", (0, 0), (-1, -1), "LEFT"),
                ("ALIGN", (1, 1), (-1, -1), "RIGHT"),
                ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                ("FONTNAME", (0, -1), (-1, -1), "Helvetica-Bold"),
                ("GRID", (0, 0), (-1, -1), 1, colors.black),
                ("LINEABOVE", (0, -1), (-1, -1), 2, colors.black),
            ]
        )
        tbl = Table(
            table_data,
            colWidths=[
                3 * inch,
                1.5 * inch,
                1.5 * inch,
                1.5 * inch,
                1.5 * inch,
                1.5 * inch,
            ],
            repeatRows=1,
        )
        tbl.setStyle(style)
        story.append(tbl)


=============== FILE: reports/charge_code_usage_generator.py ===============

"""
EDSI Veterinary Management System - Charge Code Usage PDF Generator
Version: 2.0.0
Purpose: Generates a PDF report for charge code usage statistics, including revenue and sorting.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v2.0.0 (2025-06-12):
    - Upgraded generator to handle a more complex data structure including summary
      data and revenue totals.
    - Added a summary box to the top of the report.
    - Added "Total Revenue" column to the details table.
    - Updated styling to use AppConfig colors for a professional look.
    - Added a more detailed page footer.
"""

import logging
from datetime import datetime
from typing import Dict, Any, List, Tuple

from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_RIGHT, TA_CENTER
from reportlab.lib import colors
from reportlab.lib.units import inch

from config.app_config import AppConfig


class ChargeCodeUsageGenerator:
    """Generates a PDF for the Charge Code Usage report."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.styles = getSampleStyleSheet()
        self.story = []

    def generate_pdf(
        self, report_data: Dict[str, Any], file_path: str
    ) -> Tuple[bool, str]:
        """
        Generates the full PDF report.

        Args:
            report_data: The data dictionary from ReportsController.
            file_path: The full path to save the PDF file.

        Returns:
            A tuple (success, message).
        """
        try:
            self.doc = SimpleDocTemplate(
                file_path,
                rightMargin=0.5 * inch,
                leftMargin=0.5 * inch,
                topMargin=0.5 * inch,
                bottomMargin=0.5 * inch,
            )

            self._add_header(report_data)
            self._add_summary(report_data["summary"])
            self._add_details_table(report_data["details"])

            self.doc.build(
                self.story,
                onFirstPage=self._add_page_footer,
                onLaterPages=self._add_page_footer,
            )
            self.logger.info(
                f"Successfully generated Charge Code Usage report at {file_path}"
            )
            return True, "Report generated successfully."
        except Exception as e:
            self.logger.error(f"Failed to generate PDF: {e}", exc_info=True)
            return False, f"An error occurred: {e}"

    def _add_header(self, report_data: Dict[str, Any]):
        """Adds the main header to the document."""
        options = report_data["options"]
        start_date_str = options["start_date"].strftime("%Y-%m-%d")
        end_date_str = options["end_date"].strftime("%Y-%m-%d")

        title_style = self.styles["h1"]
        title_style.alignment = TA_CENTER
        title_style.textColor = colors.HexColor("#2D3748")

        self.story.append(Paragraph("Charge Code Usage Report", title_style))
        self.story.append(Spacer(1, 0.1 * inch))

        subtitle_style = self.styles["h3"]
        subtitle_style.alignment = TA_CENTER
        self.story.append(
            Paragraph(f"For Period: {start_date_str} to {end_date_str}", subtitle_style)
        )
        self.story.append(Spacer(1, 0.25 * inch))

    def _add_summary(self, summary_data: Dict[str, Any]):
        """Adds a summary box with key metrics."""
        summary_style = ParagraphStyle(
            "Summary", parent=self.styles["Normal"], spaceAfter=10
        )

        summary_text = f"""
            <b>Total Unique Codes Used:</b> {summary_data['unique_codes_used']}<br/>
            <b>Total Usage Count:</b> {summary_data['total_usage_count']}<br/>
            <b>Total Revenue:</b> ${summary_data['total_revenue']:,.2f}
        """

        p = Paragraph(summary_text, summary_style)
        self.story.append(p)
        self.story.append(Spacer(1, 0.25 * inch))

    def _add_details_table(self, details: List[Dict]):
        """Creates and adds the main data table."""
        if not details:
            self.story.append(
                Paragraph(
                    "No usage data found for the selected criteria.",
                    self.styles["Normal"],
                )
            )
            return

        col_widths = [1.2 * inch, 2.8 * inch, 1.5 * inch, 1 * inch, 1 * inch]
        header = [
            Paragraph("<b>Code</b>", self.styles["Normal"]),
            Paragraph("<b>Description</b>", self.styles["Normal"]),
            Paragraph("<b>Category</b>", self.styles["Normal"]),
            Paragraph("<b>Usage Count</b>", self.styles["Normal"]),
            Paragraph("<b>Total Revenue</b>", self.styles["Normal"]),
        ]

        data = [header]

        num_style = ParagraphStyle(
            name="num_style", parent=self.styles["Normal"], alignment=TA_RIGHT
        )

        for item in details:
            row = [
                Paragraph(item["code"], self.styles["Normal"]),
                Paragraph(item["description"], self.styles["Normal"]),
                Paragraph(item["category_name"], self.styles["Normal"]),
                Paragraph(str(item["usage_count"]), num_style),
                Paragraph(f"${item['total_revenue']:,.2f}", num_style),
            ]
            data.append(row)

        table = Table(data, colWidths=col_widths)
        table.setStyle(
            TableStyle(
                [
                    (
                        "BACKGROUND",
                        (0, 0),
                        (-1, 0),
                        colors.HexColor(AppConfig.DARK_PRIMARY_ACTION),
                    ),
                    ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                    ("ALIGN", (0, 0), (-1, -1), "CENTER"),
                    ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                    ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                    ("BOTTOMPADDING", (0, 0), (-1, 0), 12),
                    ("BACKGROUND", (0, 1), (-1, -1), colors.HexColor("#EDF2F7")),
                    ("GRID", (0, 0), (-1, -1), 1, colors.black),
                ]
            )
        )

        self.story.append(table)

    def _add_page_footer(self, canvas, doc):
        """Adds a footer to each page."""
        canvas.saveState()
        canvas.setFont("Helvetica", 9)

        page_num_text = f"Page {doc.page}"
        canvas.drawRightString(doc.width + 0.5 * inch, 0.25 * inch, page_num_text)

        gen_date_text = f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        canvas.drawString(doc.leftMargin, 0.25 * inch, gen_date_text)

        canvas.restoreState()


=============== FILE: reports/horse_transaction_history_generator.py ===============

# reports/horse_transaction_history_generator.py
"""
EDSI Veterinary Management System - Horse Transaction History PDF Generator
Version: 1.1.0
Purpose: Generates a PDF report detailing all financial transactions for a horse.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-12):
    - Refactored to be a standalone class, removing the dependency on
      ReportGeneratorBase to fix import errors.
    - Added local _setup_styles and _add_page_numbers methods.
- v1.0.0 (2025-06-12):
    - Initial creation of the Horse Transaction History report generator.
"""

import logging
from typing import Dict, Any, Tuple
from decimal import Decimal

from reportlab.platypus import (
    SimpleDocTemplate,
    Table,
    TableStyle,
    Paragraph,
    Spacer,
    PageBreak,
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.pagesizes import letter, landscape
from reportlab.lib.enums import TA_RIGHT, TA_CENTER, TA_LEFT

from config.app_config import AppConfig


class HorseTransactionHistoryGenerator:
    """Generates a PDF for a single horse's transaction history."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.styles = getSampleStyleSheet()
        self._setup_styles()

    def _setup_styles(self):
        """Sets up custom paragraph styles."""
        self.styles.add(
            ParagraphStyle(
                name="Normal_Left", parent=self.styles["Normal"], alignment=TA_LEFT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Center", parent=self.styles["Normal"], alignment=TA_CENTER
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Right", parent=self.styles["Normal"], alignment=TA_RIGHT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="h1",
                parent=self.styles["h1"],
                fontName="Helvetica-Bold",
                fontSize=16,
                alignment=TA_CENTER,
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="h2",
                parent=self.styles["h2"],
                fontName="Helvetica-Bold",
                fontSize=12,
                alignment=TA_CENTER,
            )
        )

    def _add_page_numbers(self, canvas, doc):
        """Adds page numbers to each page of the PDF."""
        canvas.saveState()
        canvas.setFont("Helvetica", 9)
        page_number_text = f"Page {doc.page}"
        canvas.drawCentredString(
            doc.width / 2.0 + doc.leftMargin, 0.25 * inch, page_number_text
        )
        canvas.restoreState()

    def generate_pdf(
        self, report_data: Dict[str, Any], file_path: str
    ) -> Tuple[bool, str]:
        """
        Generates the PDF document.
        """
        try:
            horse = report_data.get("horse")
            transactions = report_data.get("transactions", [])
            start_date = report_data.get("start_date")
            end_date = report_data.get("end_date")

            if not horse:
                return False, "Horse data is missing from the report."

            doc = SimpleDocTemplate(
                file_path,
                pagesize=landscape(letter),
                leftMargin=0.5 * inch,
                rightMargin=0.5 * inch,
                topMargin=0.5 * inch,
                bottomMargin=0.5 * inch,
            )

            story = []
            self._add_header(story, horse, start_date, end_date)
            self._add_transaction_table(story, transactions)

            doc.build(
                story,
                onFirstPage=self._add_page_numbers,
                onLaterPages=self._add_page_numbers,
            )
            self.logger.info(f"Successfully generated PDF: {file_path}")
            return True, "PDF generated successfully."

        except Exception as e:
            self.logger.error(
                f"Error generating Horse Transaction History PDF: {e}", exc_info=True
            )
            return False, f"An unexpected error occurred: {e}"

    def _add_header(self, story: list, horse, start_date, end_date):
        """Adds the report header to the story."""
        styles = self.styles
        story.append(
            Paragraph(f"Transaction History for: {horse.horse_name}", styles["h1"])
        )
        story.append(Spacer(1, 0.1 * inch))
        story.append(
            Paragraph(
                f"Report Period: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}",
                styles["h2"],
            )
        )
        story.append(Spacer(1, 0.2 * inch))

        owner_names = ", ".join(
            [
                owner.farm_name or f"{owner.first_name} {owner.last_name}"
                for owner in horse.owners
            ]
        )
        horse_info = f"<b>Account:</b> {horse.account_number or 'N/A'} | <b>Owner(s):</b> {owner_names}"
        story.append(Paragraph(horse_info, styles["Normal"]))

        story.append(Spacer(1, 0.2 * inch))

    def _add_transaction_table(self, story: list, transactions: list):
        """Creates and styles the main data table."""
        if not transactions:
            story.append(
                Paragraph(
                    "No transactions found for this period.", self.styles["Normal"]
                )
            )
            return

        header = [
            "Date",
            "Code",
            "Description",
            "Qty",
            "Unit Price",
            "Total",
            "Billed?",
            "Admin by",
        ]

        data = [header]

        total_charges = Decimal("0.00")

        for trans in transactions:
            total_charges += trans.total_price
            row = [
                trans.transaction_date.strftime("%Y-%m-%d"),
                trans.charge_code.code if trans.charge_code else "N/A",
                Paragraph(trans.description, self.styles["Normal_Left"]),
                f"{trans.quantity:.2f}",
                f"${trans.unit_price:.2f}",
                f"${trans.total_price:.2f}",
                "Yes" if trans.invoice_id else "No",
                trans.administered_by.user_name if trans.administered_by else "N/A",
            ]
            data.append(row)

        # Add totals row
        data.append(
            [
                "",
                "",
                Paragraph("<b>TOTAL</b>", self.styles["Normal_Right"]),
                "",
                "",
                Paragraph(f"<b>${total_charges:.2f}</b>", self.styles["Normal_Right"]),
                "",
                "",
            ]
        )

        table = Table(
            data,
            colWidths=[
                0.8 * inch,
                0.7 * inch,
                3.5 * inch,
                0.6 * inch,
                0.8 * inch,
                0.8 * inch,
                0.6 * inch,
                1.0 * inch,
            ],
            repeatRows=1,
        )

        style = TableStyle(
            [
                (
                    "BACKGROUND",
                    (0, 0),
                    (-1, 0),
                    colors.HexColor(AppConfig.DARK_HEADER_FOOTER),
                ),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                ("ALIGN", (0, 0), (-1, 0), "CENTER"),
                ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                ("BOTTOMPADDING", (0, 0), (-1, 0), 12),
                ("BACKGROUND", (0, 1), (-1, -2), colors.HexColor("#e0e0e0")),
                ("GRID", (0, 0), (-1, -1), 1, colors.black),
                # Alignment for data rows
                ("ALIGN", (0, 1), (1, -1), "CENTER"),  # Date, Code
                ("ALIGN", (3, 1), (3, -1), "RIGHT"),  # Qty
                ("ALIGN", (4, 1), (6, -1), "RIGHT"),  # Prices, Total, Billed
                ("ALIGN", (7, 1), (7, -1), "LEFT"),  # Admin
                # Totals Row Style
                ("SPAN", (2, -1), (4, -1)),
                ("ALIGN", (2, -1), (2, -1), "RIGHT"),
                ("FONTNAME", (2, -1), (5, -1), "Helvetica-Bold"),
                ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
            ]
        )
        table.setStyle(style)
        story.append(table)


=============== FILE: reports/invoice_generator.py ===============

# reports/invoice_generator.py
"""
EDSI Veterinary Management System - Invoice PDF Generator
Version: 1.2.4
Purpose: Generates a professional, print-friendly PDF for a single invoice.
Last Updated: June 13, 2025
Author: Gemini

Changelog:
- v1.2.4 (2025-06-13):
    - Fixed KeyError by correcting style name from 'Center' to 'Normal_Center'
      in the footer creation.
- v1.2.3 (2025-06-13):
    - Fixed KeyError by correcting style name from 'Right' to 'Normal_Right' in
      the summary table creation.
- v1.2.2 (2025-06-13):
    - Fixed KeyError by correcting style name from 'Right' to 'Normal_Right' in
      the summary table creation.
- v1.2.1 (2025-06-13):
    - Fixed KeyError by modifying existing 'h1' and 'h2' styles instead of
      trying to add new ones with the same name.
- v1.2.0 (2025-06-12):
    - Refactored to be a standalone class, removing the dependency on
      ReportGeneratorBase to fix import errors.
    - Added local _setup_styles and _add_page_numbers methods.
- v1.1.0 (2025-06-12):
    - Refactored to inherit from ReportGeneratorBase.
- v1.0.1 (2025-06-09):
    - Bug Fix: Added `Tuple` to the import from the `typing` module.
- v1.0.0 (2025-06-09):
    - Initial creation of the invoice PDF generator.
"""
import logging
from typing import Dict, Any, Tuple
from decimal import Decimal

from reportlab.platypus import (
    SimpleDocTemplate,
    Table,
    TableStyle,
    Paragraph,
    Spacer,
    Image,
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.pagesizes import letter
from reportlab.lib.enums import TA_RIGHT, TA_LEFT, TA_CENTER

from config.app_config import AppConfig
from controllers import FinancialController, CompanyProfileController
from models import Invoice, Transaction


class InvoiceGenerator:
    """Generates a PDF for a single invoice."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.styles = getSampleStyleSheet()
        self.company_profile_controller = CompanyProfileController()
        self.financial_controller = FinancialController()
        self._setup_styles()

    def _setup_styles(self):
        """Sets up custom paragraph styles."""
        self.styles.add(
            ParagraphStyle(
                name="Normal_Left", parent=self.styles["Normal"], alignment=TA_LEFT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Center", parent=self.styles["Normal"], alignment=TA_CENTER
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Right", parent=self.styles["Normal"], alignment=TA_RIGHT
            )
        )

        self.styles["h1"].fontName = "Helvetica-Bold"
        self.styles["h1"].fontSize = 16
        self.styles["h1"].alignment = TA_CENTER

        self.styles["h2"].fontName = "Helvetica-Bold"
        self.styles["h2"].fontSize = 12
        self.styles["h2"].alignment = TA_CENTER

    def _add_page_numbers(self, canvas, doc):
        """Adds page numbers to each page of the PDF."""
        canvas.saveState()
        canvas.setFont("Helvetica", 9)
        page_number_text = f"Page {doc.page}"
        canvas.drawCentredString(
            doc.width / 2.0 + doc.leftMargin, 0.25 * inch, page_number_text
        )
        canvas.restoreState()

    def generate_invoice_pdf(self, invoice_id: int, file_path: str) -> Tuple[bool, str]:
        """
        Fetches all data for an invoice and generates a PDF at the specified path.
        """
        try:
            invoice = self.financial_controller.get_invoice_by_id(invoice_id)
            if not invoice:
                return False, f"Invoice ID {invoice_id} not found."

            company_profile = self.company_profile_controller.get_company_profile()
            if not company_profile:
                return False, "Company Profile is not set up."

            owner = invoice.owner
            if not owner:
                return False, f"Owner with ID {invoice.owner_id} not found."

            transactions = self.financial_controller.get_transactions_for_invoice(
                invoice_id
            )

            doc = SimpleDocTemplate(
                file_path,
                pagesize=letter,
                rightMargin=0.75 * inch,
                leftMargin=0.75 * inch,
                topMargin=0.75 * inch,
                bottomMargin=0.75 * inch,
            )
            story = []

            story.append(self._create_header(company_profile))
            story.append(Spacer(1, 0.25 * inch))
            story.append(self._create_info_tables(owner, invoice))
            story.append(Spacer(1, 0.25 * inch))
            story.append(self._create_transactions_table(transactions))
            story.append(Spacer(1, 0.2 * inch))
            story.append(self._create_summary_table(invoice))
            story.append(Spacer(1, 0.4 * inch))
            story.append(self._create_footer_notes())

            doc.build(
                story,
                onFirstPage=self._add_page_numbers,
                onLaterPages=self._add_page_numbers,
            )

            self.logger.info(
                f"Successfully generated PDF for Invoice #{invoice_id} at {file_path}"
            )
            return True, "PDF generated successfully."

        except Exception as e:
            self.logger.error(
                f"Failed to generate PDF for Invoice #{invoice_id}: {e}", exc_info=True
            )
            return False, f"An unexpected error occurred: {e}"

    def _create_header(self, profile) -> Table:
        header_text = f"""
            <font size=18>{profile.company_name or 'Your Company Name'}</font><br/>
            <font size=10>{profile.address_line1 or ''}<br/>
            {profile.address_line2 or ''}<br/>
            {profile.city or ''}, {profile.state or ''} {profile.zip_code or ''}<br/>
            Phone: {profile.phone or ''} | Email: {profile.email or ''}</font>
        """
        header_paragraph = Paragraph(header_text, self.styles["Normal"])
        header_table = Table([[header_paragraph]], colWidths=[6.5 * inch])
        header_table.setStyle(
            TableStyle(
                [("ALIGN", (0, 0), (0, 0), "LEFT"), ("VALIGN", (0, 0), (0, 0), "TOP")]
            )
        )
        return header_table

    def _create_info_tables(self, owner, invoice) -> Table:
        col_widths = [3 * inch, 0.5 * inch, 3 * inch]
        bill_to_text = f"""
            <b>BILL TO</b><br/>
            {owner.farm_name or f'{owner.first_name or ""} {owner.last_name or ""}'.strip()}<br/>
            {owner.address_line1 or ''}<br/>
            {owner.city or ''}, {owner.state_code or ''} {owner.zip_code or ''}
        """
        bill_to_p = Paragraph(bill_to_text, self.styles["Normal_Left"])

        invoice_info_text = f"""
            <b>STATEMENT #:</b> INV-{invoice.invoice_id}<br/>
            <b>DATE:</b> {invoice.invoice_date.strftime('%B %d, %Y')}<br/>
            <b>ACCOUNT #:</b> {owner.account_number or 'N/A'}<br/>
        """
        invoice_info_p = Paragraph(invoice_info_text, self.styles["Normal_Left"])

        info_table = Table([[bill_to_p, "", invoice_info_p]], colWidths=col_widths)
        info_table.setStyle(TableStyle([("VALIGN", (0, 0), (-1, -1), "TOP")]))
        return info_table

    def _create_transactions_table(self, transactions) -> Table:
        header = [
            Paragraph("<b>DATE</b>", self.styles["Normal"]),
            Paragraph("<b>DESCRIPTION</b>", self.styles["Normal"]),
            Paragraph("<b>QTY</b>", self.styles["Normal_Right"]),
            Paragraph("<b>PRICE</b>", self.styles["Normal_Right"]),
            Paragraph("<b>AMOUNT</b>", self.styles["Normal_Right"]),
        ]
        table_data = [header]

        for t in transactions:
            table_data.append(
                [
                    t.transaction_date.strftime("%m/%d/%Y"),
                    Paragraph(t.description, self.styles["Normal_Left"]),
                    f"{t.quantity:.2f}",
                    f"${t.unit_price:.2f}",
                    Paragraph(f"${t.total_price:.2f}", self.styles["Normal_Right"]),
                ]
            )

        trans_table = Table(
            table_data,
            colWidths=[0.75 * inch, 3.2 * inch, 0.6 * inch, 0.9 * inch, 1.0 * inch],
        )
        trans_table.setStyle(
            TableStyle(
                [
                    (
                        "BACKGROUND",
                        (0, 0),
                        (-1, 0),
                        colors.HexColor(AppConfig.DARK_HEADER_FOOTER),
                    ),
                    ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                    ("ALIGN", (0, 0), (-1, 0), "CENTER"),
                    ("ALIGN", (1, 1), (1, -1), "LEFT"),
                    ("ALIGN", (2, 1), (-1, -1), "RIGHT"),
                    ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                    ("BOTTOMPADDING", (0, 0), (-1, 0), 12),
                    ("BACKGROUND", (0, 1), (-1, -1), colors.HexColor("#f0f0f0")),
                    ("GRID", (0, 0), (-1, -1), 1, colors.grey),
                ]
            )
        )
        return trans_table

    def _create_summary_table(self, invoice) -> Table:
        container_col_widths = [4.5 * inch, 2.0 * inch]
        summary_data = [
            ["Subtotal:", f"${invoice.subtotal:.2f}"],
            ["Tax:", f"${invoice.tax_total or 0.00:.2f}"],
            ["Amount Paid:", f"(${invoice.amount_paid:.2f})"],
            ["", ""],
            [
                Paragraph("<b>BALANCE DUE:</b>", self.styles["Normal_Right"]),
                Paragraph(
                    f"<b>${invoice.balance_due:.2f}</b>", self.styles["Normal_Right"]
                ),
            ],
        ]
        summary_table = Table(summary_data, colWidths=[1.0 * inch, 1.0 * inch])
        summary_table.setStyle(
            TableStyle(
                [
                    ("ALIGN", (0, 0), (-1, -1), "RIGHT"),
                    ("LINEABOVE", (0, -1), (1, -1), 1, colors.black),
                    ("TOPPADDING", (0, -1), (1, -1), 5),
                ]
            )
        )
        container_table = Table([[None, summary_table]], colWidths=container_col_widths)
        container_table.setStyle(TableStyle([("VALIGN", (0, 0), (-1, -1), "TOP")]))
        return container_table

    def _create_footer_notes(self) -> Paragraph:
        text = """
            <font size=9><b>Terms:</b> Payment is due upon receipt. A service charge of 1.50% per month will be assessed on past due balances.</font>
        """
        return Paragraph(text, self.styles["Normal_Center"])


=============== FILE: reports/invoice_register_generator.py ===============

# reports/invoice_register_generator.py
"""
EDSI Veterinary Management System - Invoice Register PDF Generator
Version: 1.1.0
Purpose: Creates a PDF Invoice Register report.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-12):
    - Final corrected version. Standalone class.
"""
import logging
from decimal import Decimal
from typing import Dict, Any, Tuple

from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER
from reportlab.lib.pagesizes import landscape, letter

from config.app_config import AppConfig
from models import Invoice


class InvoiceRegisterGenerator:
    """Generates an Invoice Register PDF."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.styles = getSampleStyleSheet()
        self._setup_styles()

    def _setup_styles(self):
        """Creates custom styles for the report."""
        self.styles.add(
            ParagraphStyle(
                name="Normal_Right", parent=self.styles["Normal"], alignment=TA_RIGHT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Left", parent=self.styles["Normal"], alignment=TA_LEFT
            )
        )
        self.styles["h1"].alignment = TA_LEFT
        self.styles["h2"].alignment = TA_LEFT

    def _add_page_numbers(self, canvas, doc):
        """Adds page numbers to each page of the PDF."""
        canvas.saveState()
        canvas.setFont("Helvetica", 9)
        page_number_text = f"Page {doc.page}"
        canvas.drawCentredString(
            doc.width / 2.0 + doc.leftMargin, 0.25 * inch, page_number_text
        )
        canvas.restoreState()

    def generate_pdf(
        self, report_data: Dict[str, Any], file_path: str
    ) -> Tuple[bool, str]:
        """Creates and saves the Invoice Register PDF."""
        try:
            doc = SimpleDocTemplate(
                file_path,
                pagesize=landscape(letter),
                leftMargin=0.5 * inch,
                rightMargin=0.5 * inch,
                topMargin=0.5 * inch,
                bottomMargin=0.5 * inch,
            )

            story = []

            story.append(Paragraph("Invoice Register", self.styles["h1"]))
            start_date_str = report_data["start_date"].strftime("%Y-%m-%d")
            end_date_str = report_data["end_date"].strftime("%Y-%m-%d")
            story.append(
                Paragraph(
                    f"For Period: {start_date_str} to {end_date_str}", self.styles["h2"]
                )
            )
            story.append(Spacer(1, 0.25 * inch))

            self._add_register_table(story, report_data["invoices"])

            doc.build(
                story,
                onFirstPage=self._add_page_numbers,
                onLaterPages=self._add_page_numbers,
            )
            self.logger.info(
                f"Successfully generated Invoice Register report: {file_path}"
            )
            return True, f"Successfully generated report to {file_path}"
        except Exception as e:
            self.logger.error(
                f"Failed to generate Invoice Register PDF: {e}", exc_info=True
            )
            return False, f"Failed to generate PDF: {e}"

    def _add_register_table(self, story, invoices):
        table_data = [
            [
                "Inv #",
                "Date",
                "Billed To",
                "Total",
                "Amount Paid",
                "Balance Due",
                "Status",
            ]
        ]

        grand_total = Decimal("0.00")
        for inv in invoices:
            owner_name = (
                inv.owner.farm_name
                or f"{inv.owner.first_name or ''} {inv.owner.last_name or ''}".strip()
            )
            table_data.append(
                [
                    f"INV-{inv.invoice_id}",
                    inv.invoice_date.strftime("%Y-%m-%d"),
                    Paragraph(owner_name, self.styles["Normal_Left"]),
                    f"${inv.grand_total:,.2f}",
                    f"${inv.amount_paid:,.2f}",
                    f"${inv.balance_due:,.2f}",
                    inv.status,
                ]
            )
            grand_total += inv.grand_total

        table_data.append(
            [
                Paragraph(
                    f"<b>Total Invoices: {len(invoices)}</b>",
                    self.styles["Normal"],
                ),
                "",
                "",
                Paragraph(f"<b>${grand_total:,.2f}</b>", self.styles["Normal_Right"]),
                "",
                "",
                "",
            ]
        )

        style = TableStyle(
            [
                ("BACKGROUND", (0, 0), (-1, 0), colors.darkgrey),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                ("ALIGN", (0, 0), (-1, -1), "LEFT"),
                ("ALIGN", (3, 1), (-1, -1), "RIGHT"),
                ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                ("FONTNAME", (0, -1), (-1, -1), "Helvetica-Bold"),
                ("GRID", (0, 0), (-1, -1), 1, colors.black),
                ("LINEABOVE", (0, -1), (-1, -1), 2, colors.black),
                ("SPAN", (0, -1), (2, -1)),
                ("SPAN", (3, -1), (6, -1)),
                ("ALIGN", (3, -1), (3, -1), "RIGHT"),
            ]
        )
        tbl = Table(
            table_data,
            colWidths=[
                0.7 * inch,
                0.9 * inch,
                3.4 * inch,
                1.5 * inch,
                1.5 * inch,
                1.5 * inch,
                1.5 * inch,
            ],
            repeatRows=1,
        )
        tbl.setStyle(style)
        story.append(tbl)


=============== FILE: reports/owner_statement_generator.py ===============

# reports/owner_statement_generator.py
"""
EDSI Veterinary Management System - Owner Statement PDF Generator
Version: 1.2.2
Purpose: Creates a PDF statement for a given owner.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v1.2.2 (2025-06-12):
    - Final corrected version based on user-provided code.
    - Ensured all styled text is correctly wrapped in Paragraph objects.
    - Maintained professional layout and correct balance calculations.
- v1.2.1 (2025-06-11):
    - Redesigned the PDF layout for better readability and alignment.
- v1.2.0 (2025-06-11):
    - Redesigned PDF with a clean, high-contrast, black-on-white style.
"""
import logging
import os
from decimal import Decimal, InvalidOperation
from typing import Dict, Any, Tuple

from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
    Image,
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER

from models import Owner
from controllers import CompanyProfileController
from config.app_config import AppConfig


class OwnerStatementGenerator:
    """Generates a professionally styled Owner Statement PDF."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.styles = getSampleStyleSheet()
        self.company_profile = CompanyProfileController().get_company_profile()
        self._setup_styles()

    def _setup_styles(self):
        """Creates custom paragraph and table styles for a clean, readable report."""
        self.styles.add(
            ParagraphStyle(
                name="Normal_Right", parent=self.styles["Normal"], alignment=TA_RIGHT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Body_Left",
                parent=self.styles["BodyText"],
                alignment=TA_LEFT,
                leading=14,
            )
        )

        self.styles.add(
            ParagraphStyle(
                name="Company_Title",
                parent=self.styles["h1"],
                alignment=TA_LEFT,
                fontName="Helvetica-Bold",
                fontSize=14,
            )
        )

        self.styles.add(
            ParagraphStyle(
                name="Bold_Right",
                parent=self.styles["Normal"],
                alignment=TA_RIGHT,
                fontName="Helvetica-Bold",
            )
        )

        self.styles["h1"].alignment = TA_LEFT
        self.styles["h1"].fontName = "Helvetica-Bold"
        self.styles["h1"].fontSize = 16

        self.styles["h2"].alignment = TA_LEFT
        self.styles["h2"].fontName = "Helvetica-Bold"
        self.styles["h2"].fontSize = 12

    def generate_statement_pdf(
        self, statement_data: Dict[str, Any], file_path: str
    ) -> Tuple[bool, str]:
        """Creates and saves the owner statement PDF."""
        try:
            doc = SimpleDocTemplate(
                file_path,
                pagesize=(8.5 * inch, 11 * inch),
                leftMargin=0.75 * inch,
                rightMargin=0.75 * inch,
                topMargin=0.5 * inch,
                bottomMargin=0.5 * inch,
            )

            story = []

            self._add_header(story, statement_data)
            story.append(Spacer(1, 0.25 * inch))

            self._add_statement_table(story, statement_data)

            doc.build(story)
            self.logger.info(f"Successfully generated owner statement: {file_path}")
            return True, f"Successfully generated owner statement to {file_path}"
        except Exception as e:
            self.logger.error(
                f"Failed to generate owner statement PDF: {e}", exc_info=True
            )
            return False, f"Failed to generate PDF: {e}"

    def _add_header(self, story, data):
        """Adds the header section with company logo, address, and statement details."""
        owner: Owner = data["owner"]

        company_name = (
            self.company_profile.company_name
            if self.company_profile
            else "EDSI Veterinary Management"
        )
        company_details_parts = [
            self.company_profile.address_line1,
            self.company_profile.address_line2,
            f"{self.company_profile.city}, {self.company_profile.state} {self.company_profile.zip_code}",
            self.company_profile.phone,
            self.company_profile.email,
            self.company_profile.website,
        ]
        company_details = "<br/>".join(filter(None, company_details_parts))

        story.append(Paragraph(company_name, self.styles["Company_Title"]))
        story.append(Spacer(1, 2))
        story.append(Paragraph(company_details, self.styles["Body_Left"]))
        story.append(Spacer(1, 0.3 * inch))

        story.append(Paragraph("STATEMENT", self.styles["h1"]))
        story.append(Spacer(1, 0.2 * inch))

        contact_name = f"{owner.first_name or ''} {owner.last_name or ''}".strip()
        bill_to_parts = []
        if owner.farm_name:
            bill_to_parts.append(owner.farm_name)
        if contact_name:
            bill_to_parts.append(contact_name)
        bill_to_parts.extend(
            filter(
                None,
                [
                    owner.address_line1,
                    owner.address_line2,
                    f"{owner.city}, {owner.state_code} {owner.zip_code}",
                    owner.phone,
                    owner.email,
                ],
            )
        )

        bill_to_details = "<br/>".join(bill_to_parts)
        bill_to_para = Paragraph(
            f"<b>BILL TO:</b><br/>{bill_to_details}", self.styles["Body_Left"]
        )

        statement_info_data = [
            [
                Paragraph("<b>Statement Date:</b>", self.styles["Normal"]),
                Paragraph(data["end_date"].strftime("%Y-%m-%d"), self.styles["Normal"]),
            ],
            [
                Paragraph("<b>Account #:</b>", self.styles["Normal"]),
                Paragraph(owner.account_number or "N/A", self.styles["Normal"]),
            ],
            [
                Paragraph("<b>For Period:</b>", self.styles["Normal"]),
                Paragraph(
                    f"{data['start_date'].strftime('%Y-%m-%d')} to {data['end_date'].strftime('%Y-%m-%d')}",
                    self.styles["Normal"],
                ),
            ],
        ]
        statement_info_table = Table(
            statement_info_data, colWidths=[1.2 * inch, 2.3 * inch], hAlign="LEFT"
        )
        statement_info_table.setStyle(
            TableStyle(
                [
                    ("ALIGN", (0, 0), (-1, -1), "LEFT"),
                    ("VALIGN", (0, 0), (-1, -1), "TOP"),
                ]
            )
        )

        header_details_table = Table(
            [[bill_to_para, statement_info_table]], colWidths=[3.5 * inch, 3.5 * inch]
        )
        header_details_table.setStyle(TableStyle([("VALIGN", (0, 0), (-1, -1), "TOP")]))

        story.append(header_details_table)

    def _add_statement_table(self, story, data):
        table_data = [
            [
                Paragraph(f"<b>{cell}</b>", self.styles["Normal"])
                for cell in ["Date", "Description", "Charges", "Payments", "Balance"]
            ]
        ]

        balance = Decimal(data.get("starting_balance", "0.00"))

        table_data.append(
            [
                data["start_date"].strftime("%Y-%m-%d"),
                "Previous Balance",
                "",
                "",
                f"${balance:,.2f}",
            ]
        )

        for item in data["items"]:
            charge = Decimal(item.get("charge", "0.00"))
            payment = Decimal(item.get("payment", "0.00"))
            balance += charge - payment

            charge_str = f"${charge:,.2f}" if charge else ""
            payment_str = f"${payment:,.2f}" if payment else ""

            table_data.append(
                [
                    item["date"].strftime("%Y-%m-%d"),
                    item["description"],
                    charge_str,
                    payment_str,
                    f"${balance:,.2f}",
                ]
            )

        tbl = Table(
            table_data,
            colWidths=[0.8 * inch, 3.7 * inch, 1 * inch, 1 * inch, 1 * inch],
            repeatRows=1,
        )
        tbl.setStyle(
            TableStyle(
                [
                    ("BACKGROUND", (0, 0), (-1, 0), colors.darkgrey),
                    ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                    ("ALIGN", (0, 0), (-1, -1), "CENTER"),
                    ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                    ("ALIGN", (1, 1), (1, -1), "LEFT"),
                    ("ALIGN", (2, 1), (-1, -1), "RIGHT"),
                    ("BOTTOMPADDING", (0, 0), (-1, 0), 10),
                    ("TOPPADDING", (0, 0), (-1, 0), 10),
                    ("GRID", (0, 0), (-1, -1), 1, colors.black),
                ]
            )
        )

        for i in range(1, len(table_data)):
            bg_color = colors.whitesmoke if i % 2 == 0 else colors.white
            tbl.setStyle(TableStyle([("BACKGROUND", (0, i), (-1, i), bg_color)]))

        story.append(tbl)
        story.append(Spacer(1, 0.1 * inch))

        ending_balance_label = Paragraph(
            "<b>Ending Balance:</b>", self.styles["Normal_Right"]
        )
        ending_balance_value = Paragraph(
            f"<b>${balance:,.2f}</b>", self.styles["Normal_Right"]
        )
        summary_data = [["", ending_balance_label, ending_balance_value]]

        summary_table = Table(summary_data, colWidths=[5.5 * inch, 1 * inch, 1 * inch])
        summary_table.setStyle(
            TableStyle(
                [
                    ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                    ("LINEABOVE", (1, 0), (2, 0), 1, colors.black),
                    ("TOPPADDING", (0, 0), (-1, -1), 6),
                ]
            )
        )
        story.append(summary_table)


=============== FILE: reports/payment_history_generator.py ===============

# reports/payment_history_generator.py
"""
EDSI Veterinary Management System - Payment History PDF Generator
Version: 1.1.0
Purpose: Generates a PDF report listing all payments in a date range.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-12):
    - Refactored to be a standalone class, removing ReportGeneratorBase dependency.
    - Added local style and page number setup.
- v1.0.0 (2025-06-11):
    - Initial creation of the Payment History report generator.
"""
import logging
from typing import Dict, Any, Tuple
from decimal import Decimal

from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.lib.pagesizes import letter

from config.app_config import AppConfig


class PaymentHistoryGenerator:
    """Generates a PDF for the Payment History report."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.styles = getSampleStyleSheet()
        self._setup_styles()

    def _setup_styles(self):
        """Creates custom styles for the report."""
        self.styles.add(
            ParagraphStyle(
                name="Normal_Right", parent=self.styles["Normal"], alignment=TA_RIGHT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Left", parent=self.styles["Normal"], alignment=TA_LEFT
            )
        )
        self.styles["h1"].alignment = TA_LEFT
        self.styles["h2"].alignment = TA_LEFT

    def _add_page_numbers(self, canvas, doc):
        """Adds page numbers to each page of the PDF."""
        canvas.saveState()
        canvas.setFont("Helvetica", 9)
        page_number_text = f"Page {doc.page}"
        canvas.drawCentredString(
            doc.width / 2.0 + doc.leftMargin, 0.25 * inch, page_number_text
        )
        canvas.restoreState()

    def generate_pdf(
        self, report_data: Dict[str, Any], file_path: str
    ) -> Tuple[bool, str]:
        """
        Generates the Payment History PDF.
        """
        try:
            doc = SimpleDocTemplate(
                file_path,
                pagesize=letter,
                leftMargin=0.75 * inch,
                rightMargin=0.75 * inch,
                topMargin=0.75 * inch,
                bottomMargin=0.75 * inch,
            )
            story = []

            self._add_header(story, report_data["start_date"], report_data["end_date"])
            self._add_payments_table(story, report_data["payments"])

            doc.build(
                story,
                onFirstPage=self._add_page_numbers,
                onLaterPages=self._add_page_numbers,
            )
            return True, "Payment History report generated successfully."
        except Exception as e:
            self.logger.error(
                f"Failed to generate Payment History PDF: {e}", exc_info=True
            )
            return False, f"An unexpected error occurred: {e}"

    def _add_header(self, story, start_date, end_date):
        story.append(Paragraph("Payment History", self.styles["h1"]))
        story.append(Spacer(1, 0.2 * inch))
        story.append(
            Paragraph(
                f"For Period: {start_date.strftime('%B %d, %Y')} to {end_date.strftime('%B %d, %Y')}",
                self.styles["h2"],
            )
        )
        story.append(Spacer(1, 0.3 * inch))

    def _add_payments_table(self, story, payments):
        header = ["Date", "Paid By", "Amount", "Method", "Reference #"]

        data = [header]

        total_payments = Decimal("0.00")

        for pmt in payments:
            total_payments += pmt.amount
            owner_name = (
                pmt.owner.farm_name
                or f"{pmt.owner.first_name or ''} {pmt.owner.last_name or ''}".strip()
            )
            row = [
                pmt.payment_date.strftime("%Y-%m-%d"),
                Paragraph(owner_name, self.styles["Normal_Left"]),
                f"${pmt.amount:.2f}",
                pmt.payment_method,
                pmt.reference_number or "",
            ]
            data.append(row)

        # Add totals row
        data.append(
            ["", "<b>TOTAL PAYMENTS</b>", f"<b>${total_payments:.2f}</b>", "", ""]
        )

        payment_table = Table(
            data,
            colWidths=[1 * inch, 2.5 * inch, 1.2 * inch, 1.2 * inch, 1.5 * inch],
            repeatRows=1,
        )

        style = TableStyle(
            [
                ("BACKGROUND", (0, 0), (-1, 0), colors.darkgrey),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                ("ALIGN", (0, 0), (-1, 0), "CENTER"),
                ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                ("BOTTOMPADDING", (0, 0), (-1, 0), 12),
                ("BACKGROUND", (0, 1), (-1, -2), colors.HexColor("#f0f0f0")),
                ("GRID", (0, 0), (-1, -1), 1, colors.grey),
                ("ALIGN", (2, 1), (2, -1), "RIGHT"),  # Amount
                ("ALIGN", (0, 1), (1, -1), "LEFT"),  # Date, Paid By
                ("ALIGN", (3, 1), (4, -1), "CENTER"),  # Method, Ref
                # Style for the totals row
                ("BACKGROUND", (0, -1), (-1, -1), colors.lightgrey),
                ("FONTNAME", (0, -1), (-1, -1), "Helvetica-Bold"),
                ("ALIGN", (1, -1), (1, -1), "RIGHT"),
                ("SPAN", (0, -1), (1, -1)),  # Span the total label
                ("ALIGN", (2, -1), (2, -1), "RIGHT"),
            ]
        )
        payment_table.setStyle(style)

        story.append(payment_table)


=============== FILE: reports/report_generator_base.py ===============

# reports/report_generator_base.py
"""
EDSI Veterinary Management System - Report Generator Base Class
Version: 1.0.0
Purpose: Provides a base class for all PDF report generators, handling
         common elements like page numbering and standard styles.
Last Updated: June 12, 2025
Author: Gemini
"""

import logging
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from reportlab.lib.colors import black
from config.app_config import AppConfig


class ReportGeneratorBase:
    """Base class for PDF report generators."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.styles = getSampleStyleSheet()
        self._setup_styles()

    def _setup_styles(self):
        """Sets up custom paragraph styles."""
        self.styles.add(
            ParagraphStyle(
                name="Normal_Left", parent=self.styles["Normal"], alignment=TA_LEFT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Center", parent=self.styles["Normal"], alignment=TA_CENTER
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="Normal_Right", parent=self.styles["Normal"], alignment=TA_RIGHT
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="h1",
                parent=self.styles["h1"],
                fontName="Helvetica-Bold",
                fontSize=16,
                alignment=TA_CENTER,
            )
        )
        self.styles.add(
            ParagraphStyle(
                name="h2",
                parent=self.styles["h2"],
                fontName="Helvetica-Bold",
                fontSize=12,
                alignment=TA_CENTER,
            )
        )

    def _add_page_numbers(self, canvas, doc):
        """Adds page numbers to each page of the PDF."""
        canvas.saveState()
        canvas.setFont("Helvetica", 9)
        page_number_text = f"Page {doc.page}"
        canvas.drawCentredString(
            doc.width / 2.0 + doc.leftMargin, 0.25 * AppConfig.inch, page_number_text
        )
        canvas.restoreState()


=============== FILE: controllers/__init__.py ===============

# controllers/__init__.py
"""
EDSI Veterinary Management System - Controllers Package
"""
from .user_controller import UserController
from .location_controller import LocationController
from .charge_code_controller import ChargeCodeController
from .owner_controller import OwnerController
from .financial_controller import FinancialController
from .horse_controller import HorseController
from .company_profile_controller import CompanyProfileController
from .veterinarian_controller import VeterinarianController
from .reports_controller import ReportsController

__all__ = [
    "UserController",
    "LocationController",
    "ChargeCodeController",
    "OwnerController",
    "FinancialController",
    "HorseController",
    "CompanyProfileController",
    "VeterinarianController",
    "ReportsController",
]


=============== FILE: controllers/charge_code_controller.py ===============

# controllers/charge_code_controller.py
"""
EDSI Veterinary Management System - Charge Code Controller
Version: 1.2.1
Purpose: Business logic for charge code and charge code category operations.
         - Added delete_charge_code method.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v1.2.1 (2025-06-10):
    - Modified `get_all_charge_code_categories_hierarchical` query to explicitly
      `joinedload` the `parent` of each child category. This prevents a
      `DetachedInstanceError` in the UI when editing a child category.
- v1.2.0 (2025-06-05):
    - Added `delete_charge_code` method to permanently delete a charge code.
    - The method checks for linked records in the `Transaction` model to prevent deletion if the charge code is in use.
    - Added `Transaction` to the model imports.
- v1.1.3 (2025-06-04):
    - Added `get_category_by_id` method to fetch a single category by its ID,
      as required by UserManagementScreen.
    - Modified `get_charge_code_by_id` to filter by `ChargeCode.id` (assuming 'id'
      is the current primary key attribute on the ChargeCode model) instead of
      `ChargeCode.charge_code_id` to resolve an AttributeError.
- v1.1.2 (2025-06-03):
    - Modified `get_all_charge_code_categories_hierarchical` to remove the
      `active_filter` parameter. It now always fetches all Level 1 categories
      (active and inactive) and their children. Filtering logic is handled by the view.
- v1.1.1 (2025-06-03):
    - Added `toggle_charge_code_category_status` method to specifically handle
      activating/deactivating ChargeCodeCategory items.
- v1.1.0 (2025-06-03):
    - Added full CRUD operations and validation for ChargeCodeCategory.
# ... (previous changelog entries)
"""

import logging
import re
from datetime import datetime
from typing import List, Optional, Tuple, Dict, Any
from decimal import Decimal, InvalidOperation

from sqlalchemy.orm import Session, joinedload, aliased, selectinload
from sqlalchemy import or_, func, exc as sqlalchemy_exc, and_

from config.database_config import db_manager
from models import ChargeCode, ChargeCodeCategory, Transaction


class ChargeCodeController:
    """Controller for charge code and charge code category operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    # --- ChargeCode Methods ---
    def validate_charge_code_data(
        self,
        charge_data: dict,
        is_new: bool = True,
        charge_code_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        code = charge_data.get("code", "").strip()
        description = charge_data.get("description", "").strip()
        standard_charge_str = str(charge_data.get("standard_charge", "")).strip()

        if not code:
            errors.append("Charge Code (Code) is required.")
        elif len(code) > 20:
            errors.append("Charge Code (Code) cannot exceed 20 characters.")

        # Validate code uniqueness
        if code:  # Only check if code is provided
            session = db_manager().get_session()  # Corrected line
            try:
                query = session.query(ChargeCode).filter(
                    ChargeCode.code.collate("NOCASE") == code.upper()
                )
                if not is_new and charge_code_id_to_ignore is not None:
                    query = query.filter(ChargeCode.id != charge_code_id_to_ignore)
                if query.first():
                    errors.append(f"Charge Code '{code.upper()}' already exists.")
            finally:
                db_manager().close()  # Corrected line

        if not description:
            errors.append("Description is required.")
        elif len(description) > 255:
            errors.append("Description cannot exceed 255 characters.")

        if not standard_charge_str:
            errors.append("Standard Charge is required.")
        else:
            try:
                charge_value = Decimal(standard_charge_str)
                if charge_value < Decimal("0.00"):
                    errors.append("Standard Charge cannot be negative.")
            except InvalidOperation:
                errors.append("Standard Charge must be a valid number (e.g., 25.00).")

        alternate_code = charge_data.get("alternate_code")
        if alternate_code is not None and len(str(alternate_code).strip()) > 50:
            errors.append("Alternate Code cannot exceed 50 characters.")

        if "taxable" in charge_data and not isinstance(
            charge_data.get("taxable"), bool
        ):
            errors.append("Taxable field must be a true/false value.")

        category_id = charge_data.get("category_id")
        if category_id is not None:
            session = db_manager().get_session()  # Corrected line
            try:
                category_exists = (
                    session.query(ChargeCodeCategory)
                    .filter(ChargeCodeCategory.category_id == category_id)
                    .first()
                )
                if not category_exists:
                    errors.append(
                        f"Selected category ID '{category_id}' does not exist."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"Error validating category_id '{category_id}': {e}", exc_info=True
                )
                errors.append("Database error validating category.")
            finally:
                db_manager().close()  # Corrected line
        elif "category_id" not in charge_data:
            errors.append("Category selection is required.")

        return not errors, errors

    def create_charge_code(
        self, charge_data: dict, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[ChargeCode]]:
        is_valid, errors = self.validate_charge_code_data(
            charge_data, is_new=True, charge_code_id_to_ignore=None
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager().get_session()  # Corrected line
        try:
            new_charge_code = ChargeCode(
                code=charge_data["code"].strip().upper(),
                alternate_code=(
                    (charge_data.get("alternate_code", "").strip().upper() or None)
                    if charge_data.get("alternate_code") is not None
                    else None
                ),
                description=charge_data["description"].strip(),
                category_id=charge_data.get("category_id"),
                standard_charge=Decimal(str(charge_data["standard_charge"]).strip()),
                is_active=charge_data.get("is_active", True),
                taxable=charge_data.get("taxable", False),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_charge_code)
            session.commit()
            session.refresh(new_charge_code)
            self.logger.info(
                f"Charge Code '{new_charge_code.code}' created (ID: {new_charge_code.id}) by {current_user_id}."
            )
            return True, "Charge code created successfully.", new_charge_code
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating charge code: {str(ie.orig)}", exc_info=True
            )
            if "UNIQUE constraint failed: charge_codes.code" in str(ie.orig).lower():
                return (
                    False,
                    f"Charge Code '{charge_data['code'].strip().upper()}' already exists.",
                    None,
                )
            return False, f"Database integrity error: {str(ie.orig)}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating charge code: {e}", exc_info=True)
            return False, f"Failed to create charge code: {str(e)}", None
        finally:
            db_manager().close()  # Corrected line

    def get_charge_code_by_id(self, charge_code_pk_value: int) -> Optional[ChargeCode]:
        session = db_manager().get_session()  # Corrected line
        try:
            return (
                session.query(ChargeCode)
                .options(joinedload(ChargeCode.category))
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code by ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def get_charge_code_by_code(self, code: str) -> Optional[ChargeCode]:
        session = db_manager().get_session()  # Corrected line
        try:
            return (
                session.query(ChargeCode)
                .options(joinedload(ChargeCode.category))
                .filter(ChargeCode.code.collate("NOCASE") == code.upper())
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code by code '{code}': {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def get_all_charge_codes(
        self, search_term: str = "", status_filter: str = "all"
    ) -> List[ChargeCode]:
        session = db_manager().get_session()  # Corrected line
        try:
            category_alias = aliased(ChargeCodeCategory)
            query = session.query(ChargeCode).options(joinedload(ChargeCode.category))

            if status_filter == "active":
                query = query.filter(ChargeCode.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(ChargeCode.is_active == False)

            query = query.outerjoin(category_alias, ChargeCode.category)

            if search_term:
                like_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        ChargeCode.code.ilike(like_pattern),
                        ChargeCode.alternate_code.ilike(like_pattern),
                        ChargeCode.description.ilike(like_pattern),
                        category_alias.name.ilike(like_pattern),
                    )
                )
            query = query.order_by(
                category_alias.name.asc().nullsfirst(), ChargeCode.code.asc()
            )
            return query.all()
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all charge codes: {e}", exc_info=True)
            return []
        finally:
            db_manager().close()  # Corrected line

    def update_charge_code(
        self,
        charge_code_pk_value: int,
        charge_data: dict,
        current_user_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            charge_code_to_update = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
            if not charge_code_to_update:
                return False, "Charge code not found."

            validation_data = charge_data.copy()
            if "code" not in validation_data:
                validation_data["code"] = charge_code_to_update.code

            is_valid, errors = self.validate_charge_code_data(
                validation_data,
                is_new=False,
                charge_code_id_to_ignore=charge_code_pk_value,
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            if "code" in charge_data:
                charge_code_to_update.code = charge_data["code"].strip().upper()
            if "description" in charge_data:
                charge_code_to_update.description = charge_data["description"].strip()
            if (
                "standard_charge" in charge_data
                and charge_data["standard_charge"] is not None
            ):
                try:
                    charge_code_to_update.standard_charge = Decimal(
                        str(charge_data["standard_charge"])
                    )
                except InvalidOperation:
                    return False, "Invalid Standard Charge value provided for update."
            if "alternate_code" in charge_data:
                alt_code = charge_data.get("alternate_code")
                charge_code_to_update.alternate_code = (
                    (alt_code.strip().upper() or None)
                    if isinstance(alt_code, str)
                    else None
                )

            if "category_id" in charge_data:
                charge_code_to_update.category_id = charge_data.get("category_id")

            if "is_active" in charge_data:
                charge_code_to_update.is_active = charge_data["is_active"]
            if "taxable" in charge_data:
                charge_code_to_update.taxable = charge_data["taxable"]

            charge_code_to_update.modified_by = current_user_id

            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code_to_update.code}' (ID: {charge_code_pk_value}) updated by {current_user_id}."
            )
            return True, "Charge code updated successfully."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            if "UNIQUE constraint failed: charge_codes.code" in str(ie.orig).lower():
                return (
                    False,
                    f"Charge Code '{charge_data.get('code', '').strip().upper()}' already exists.",
                )
            return False, f"Database integrity error: {str(ie.orig)}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating charge code ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return False, f"Failed to update charge code: {str(e)}"
        finally:
            db_manager().close()  # Corrected line

    def toggle_charge_code_status(
        self,
        charge_code_pk_value: int,
        current_user_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            charge_code = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
            if not charge_code:
                return False, "Charge code not found."

            charge_code.is_active = not charge_code.is_active
            charge_code.modified_by = current_user_id
            new_status = "active" if charge_code.is_active else "inactive"
            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code.code}' (ID: {charge_code_pk_value}) status changed to {new_status} by {current_user_id}."
            )
            return True, f"Charge code '{charge_code.code}' status set to {new_status}."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error toggling status for charge code ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle charge code status: {str(e)}"
        finally:
            db_manager().close()  # Corrected line

    def delete_charge_code(
        self, charge_code_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        """Permanently deletes a charge code after checking for dependencies."""
        session = db_manager().get_session()  # Corrected line
        try:
            # Check for linked transactions before deleting
            linked_transactions_count = (
                session.query(Transaction)
                .filter(Transaction.charge_code_id == charge_code_id)
                .count()
            )

            if linked_transactions_count > 0:
                message = f"Cannot delete charge code. It is used in {linked_transactions_count} financial transaction(s)."
                self.logger.warning(
                    f"Attempt to delete charge code ID {charge_code_id} failed: {message}"
                )
                return False, message

            # Proceed with deletion if no links are found
            charge_code_to_delete = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_id)
                .first()
            )

            if not charge_code_to_delete:
                return False, "Charge code not found."

            code = charge_code_to_delete.code
            session.delete(charge_code_to_delete)
            session.commit()
            self.logger.info(
                f"Charge Code '{code}' (ID: {charge_code_id}) deleted by {current_user_id}."
            )
            return True, f"Charge Code '{code}' was successfully deleted."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting charge code ID {charge_code_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred: {e}"
        finally:
            db_manager().close()  # Corrected line

    # --- ChargeCodeCategory Management Methods ---

    def get_category_by_id(self, category_id: int) -> Optional[ChargeCodeCategory]:
        session = db_manager().get_session()  # Corrected line
        try:
            category = (
                session.query(ChargeCodeCategory)
                .options(joinedload(ChargeCodeCategory.parent))
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            return category
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching category by ID {category_id}: {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def validate_charge_code_category_data(
        self,
        category_data: dict,
        is_new: bool = True,
        category_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        name = category_data.get("name", "").strip()
        level = category_data.get("level")
        parent_id = category_data.get("parent_id")

        if not name:
            errors.append("Category/Process name is required.")
        elif len(name) > 100:
            errors.append("Category/Process name cannot exceed 100 characters.")

        if level not in [1, 2]:
            errors.append("Level must be 1 (for Category) or 2 (for Process).")

        if level == 1 and parent_id is not None:
            errors.append("A Level 1 Category cannot have a parent.")
        if level == 2 and parent_id is None:
            errors.append("A Level 2 Process must have a parent Category.")

        if name and level is not None:
            session = db_manager().get_session()  # Corrected line
            try:
                query = session.query(ChargeCodeCategory.category_id).filter(
                    ChargeCodeCategory.name.collate("NOCASE") == name,
                    ChargeCodeCategory.level == level,
                )
                if parent_id:
                    query = query.filter(ChargeCodeCategory.parent_id == parent_id)
                else:
                    query = query.filter(ChargeCodeCategory.parent_id.is_(None))

                if not is_new and category_id_to_ignore is not None:
                    query = query.filter(
                        ChargeCodeCategory.category_id != category_id_to_ignore
                    )

                if query.first():
                    type_name = "Process" if level == 2 else "Category"
                    parent_info = f" under the selected parent" if parent_id else ""
                    errors.append(
                        f"{type_name} name '{name}' already exists{parent_info}."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"DB error validating category name uniqueness: {e}", exc_info=True
                )
                errors.append("Database error during name validation.")
            finally:
                db_manager().close()  # Corrected line
        return not errors, errors

    def create_charge_code_category(
        self, category_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str, Optional[ChargeCodeCategory]]:
        is_valid, errors = self.validate_charge_code_category_data(
            category_data, is_new=True
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager().get_session()  # Corrected line
        try:
            new_category = ChargeCodeCategory(
                name=category_data["name"].strip(),
                level=category_data["level"],
                parent_id=category_data.get("parent_id"),
                is_active=category_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_category)
            session.commit()
            session.refresh(new_category)
            cat_type = "Process" if new_category.level == 2 else "Category"
            self.logger.info(
                f"Charge Code {cat_type} '{new_category.name}' (ID: {new_category.category_id}, Level: {new_category.level}, ParentID: {new_category.parent_id}) created by {current_user_id}."
            )
            return True, f"{cat_type} created successfully.", new_category
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating charge code category: {str(ie.orig)}",
                exc_info=True,
            )
            return False, f"Database integrity error: {str(ie.orig)}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error creating charge code category: {e}", exc_info=True
            )
            return False, f"Failed to create category/process: {str(e)}", None
        finally:
            db_manager().close()  # Corrected line

    def update_charge_code_category(
        self, category_id: int, category_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            category_to_update = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category_to_update:
                return False, "Category/Process not found."

            validation_data = {
                "name": category_data.get("name", category_to_update.name).strip(),
                "level": category_to_update.level,
                "parent_id": category_to_update.parent_id,
            }

            is_valid, errors = self.validate_charge_code_category_data(
                validation_data, is_new=False, category_id_to_ignore=category_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            changed = False
            if (
                "name" in category_data
                and category_to_update.name != category_data["name"].strip()
            ):
                category_to_update.name = category_data["name"].strip()
                changed = True

            if (
                "is_active" in category_data
                and category_to_update.is_active != category_data["is_active"]
            ):
                category_to_update.is_active = category_data["is_active"]
                changed = True

            if changed:
                category_to_update.modified_by = current_user_id
                session.commit()
                cat_type = "Process" if category_to_update.level == 2 else "Category"
                self.logger.info(
                    f"Charge Code {cat_type} '{category_to_update.name}' (ID: {category_id}) updated by {current_user_id}."
                )
                return True, f"{cat_type} updated successfully."
            else:
                return True, "No changes detected to update."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            return False, f"Database integrity error: {str(ie.orig)}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating category ID {category_id}: {e}", exc_info=True
            )
            return False, f"Failed to update category/process: {str(e)}"
        finally:
            db_manager().close()  # Corrected line

    def toggle_charge_code_category_status(
        self, category_id: int, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        category = None
        try:
            category = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category:
                return False, "Category/Process not found."
            item_type = "Process" if category.level == 2 else "Category"
            original_name = category.name
            category.is_active = not category.is_active
            category.modified_by = current_user_id
            session.commit()
            new_status_str = "active" if category.is_active else "inactive"
            self.logger.info(
                f"{item_type} '{original_name}' (ID: {category.category_id}) status changed to {new_status_str} by {current_user_id}."
            )
            return (
                True,
                f"{item_type} '{original_name}' status set to {new_status_str}.",
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            if session:
                session.rollback()
            err_item_type = "Category/Process"
            err_name = f"ID {category_id}"
            if category:
                err_item_type = "Process" if category.level == 2 else "Category"
                err_name = category.name
            self.logger.error(
                f"Error toggling status for {err_item_type} {err_name}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle {err_item_type} status: {str(e)}"
        finally:
            db_manager().close()  # Corrected line

    def delete_charge_code_category(
        self, category_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        category_to_delete = None
        try:
            category_to_delete = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category_to_delete:
                return False, "Category/Process not found."

            linked_charge_codes_count = (
                session.query(ChargeCode)
                .filter(ChargeCode.category_id == category_id)
                .count()
            )
            if linked_charge_codes_count > 0:
                msg = f"Cannot delete '{category_to_delete.name}'. It is assigned to {linked_charge_codes_count} charge code(s)."
                self.logger.warning(msg)
                return False, msg

            if category_to_delete.level == 1:
                children_count = (
                    session.query(ChargeCodeCategory)
                    .filter(ChargeCodeCategory.parent_id == category_id)
                    .count()
                )
                if children_count > 0:
                    msg = f"Cannot delete Category '{category_to_delete.name}'. It has {children_count} child Process(es). Delete children first."
                    self.logger.warning(msg)
                    return False, msg

            cat_type_name = "Process" if category_to_delete.level == 2 else "Category"
            deleted_name = category_to_delete.name
            session.delete(category_to_delete)
            session.commit()
            self.logger.info(
                f"Charge Code {cat_type_name} '{deleted_name}' (ID: {category_id}) deleted by {current_user_id}."
            )
            return True, f"{cat_type_name} '{deleted_name}' deleted successfully."
        except sqlalchemy_exc.SQLAlchemyError as e:
            if session:
                session.rollback()
            self.logger.error(
                f"Error deleting category ID {category_id}: {e}", exc_info=True
            )
            name_for_error = (
                category_to_delete.name if category_to_delete else f"ID {category_id}"
            )
            if isinstance(e, sqlalchemy_exc.IntegrityError):
                return (
                    False,
                    f"Cannot delete '{name_for_error}'. It might still be referenced by other records. Details: {e.orig}",
                )
            return (
                False,
                f"Failed to delete category/process due to a database error: {str(e)}",
            )
        finally:
            db_manager().close()  # Corrected line

    def get_all_charge_code_categories_hierarchical(
        self,
    ) -> List[ChargeCodeCategory]:
        """Fetches all Level 1 categories, with their Level 2 children (processes) eager-loaded."""
        session = db_manager().get_session()  # Corrected line
        try:
            level1_categories = (
                session.query(ChargeCodeCategory)
                .filter(
                    ChargeCodeCategory.parent_id.is_(None),
                    ChargeCodeCategory.level == 1,
                )
                # MODIFIED: Explicitly eager load the parent of the children
                .options(
                    selectinload(ChargeCodeCategory.children).joinedload(
                        ChargeCodeCategory.parent
                    )
                )
                .order_by(ChargeCodeCategory.name)
                .all()
            )
            return level1_categories
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching hierarchical charge code categories: {e}",
                exc_info=True,
            )
            return []
        finally:
            db_manager().close()  # Corrected line

    def get_charge_code_categories(
        self,
        parent_id: Optional[int] = None,
        level: Optional[int] = None,
        active_only: bool = True,
    ) -> List[ChargeCodeCategory]:
        session = db_manager().get_session()  # Corrected line
        try:
            query = session.query(ChargeCodeCategory)
            if active_only:
                query = query.filter(ChargeCodeCategory.is_active == True)

            if parent_id is None and level == 1:
                query = query.filter(
                    ChargeCodeCategory.parent_id.is_(None),
                    ChargeCodeCategory.level == 1,
                )
            else:
                if parent_id is not None:
                    query = query.filter(ChargeCodeCategory.parent_id == parent_id)
                if level is not None:
                    query = query.filter(ChargeCodeCategory.level == level)

            categories = query.order_by(ChargeCodeCategory.name).all()
            return categories
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code categories: {e}", exc_info=True
            )
            return []
        finally:
            db_manager().close()  # Corrected line

    def get_category_path(self, category_id: Optional[int]) -> List[Dict[str, Any]]:
        """
        Retrieves the hierarchical path for a given category ID.
        Returns a list of dictionaries, each with 'id' and 'name'.
        """
        path_for_display = []
        if category_id is None:
            return path_for_display

        current_cat_id = category_id
        session = db_manager().get_session()  # Corrected line
        try:
            while current_cat_id is not None:
                category = (
                    session.query(
                        ChargeCodeCategory.category_id,
                        ChargeCodeCategory.name,
                        ChargeCodeCategory.parent_id,
                    )
                    .filter(ChargeCodeCategory.category_id == current_cat_id)
                    .first()
                )
                if category:
                    path_for_display.insert(
                        0, {"id": category.category_id, "name": category.name}
                    )
                    current_cat_id = category.parent_id
                else:
                    break
            return path_for_display
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching category path for ID {category_id}: {e}", exc_info=True
            )
            return []
        finally:
            db_manager().close()  # Corrected line


=============== FILE: controllers/company_profile_controller.py ===============

# controllers/company_profile_controller.py
"""
EDSI Veterinary Management System - Company Profile Controller
Version: 1.0.0
Purpose: Business logic for managing the company's profile information.
Last Updated: June 8, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict, Any, Tuple

from sqlalchemy.exc import SQLAlchemyError

from config.database_config import db_manager
from models import CompanyProfile


class CompanyProfileController:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_company_profile(self) -> Optional[CompanyProfile]:
        """
        Retrieves the company profile. Assumes a single profile with id=1.
        """
        session = db_manager().get_session()  # Corrected line
        try:
            profile = (
                session.query(CompanyProfile).filter(CompanyProfile.id == 1).first()
            )
            return profile
        except SQLAlchemyError as e:
            self.logger.error(f"Error retrieving company profile: {e}", exc_info=True)
            return None
        finally:
            db_manager().close()  # Corrected line

    def update_company_profile(
        self, data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        """
        Creates or updates the company profile. Assumes a single profile with id=1.
        """
        session = db_manager().get_session()  # Corrected line
        try:
            profile = (
                session.query(CompanyProfile).filter(CompanyProfile.id == 1).first()
            )

            if not profile:
                self.logger.info("No existing company profile found. Creating new one.")
                profile = CompanyProfile(id=1, created_by=current_user_id)
                session.add(profile)

            for key, value in data.items():
                if hasattr(profile, key):
                    setattr(profile, key, value)

            profile.modified_by = current_user_id
            session.commit()
            self.logger.info(f"Company profile updated by {current_user_id}.")
            return True, "Company profile updated successfully."

        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error updating company profile: {e}", exc_info=True
            )
            return False, f"A database error occurred: {e}"
        finally:
            db_manager().close()  # Corrected line


=============== FILE: controllers/financial_controller.py ===============

# controllers/financial_controller.py
"""
EDSI Veterinary Management System - Financial Controller
Version: 2.4.1
Purpose: Handles business logic for financial operations like creating invoices and recording payments.
Last Updated: June 13, 2025
Author: Gemini

Changelog:
- v2.4.1 (2025-06-13):
    - Fixed DetachedInstanceError in `get_invoice_by_id` by eagerly loading
      the related owner object using `joinedload(Invoice.owner)`. This
      prevents an error during PDF generation.
- v2.4.0 (2025-06-10):
    - Refactored `generate_invoices_from_transactions` to ensure a unique set of
      owners is used for invoice creation for each horse. This prevents a bug
      where duplicate invoices were being generated for each owner.
- v2.3.0 (2025-06-10):
    - Added record_payment method to handle saving a payment transaction. This
      method updates the Owner and Invoice balances, creates an OwnerPayment
      record, and logs the event in OwnerBillingHistory.
- v2.2.0 (2025-06-10):
    - Refactored generate_invoices_from_transactions to be more robust. It now
      explicitly groups charges by horse before processing, ensuring that all
      charges for a single horse are correctly grouped onto one invoice per owner.
"""
# ... (imports remain the same) ...
import logging
from typing import List, Optional, Dict, Any, Tuple
from decimal import Decimal, InvalidOperation
from datetime import date
from collections import defaultdict

from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm import joinedload, selectinload

from config.database_config import db_manager
from models import (
    Transaction,
    Invoice,
    Horse,
    Owner,
    ChargeCode,
    User,
    ChargeCodeCategory,
    OwnerBillingHistory,
    HorseOwner,
    OwnerPayment,
)


class FinancialController:
    # ... (all existing methods like __init__, etc. remain unchanged) ...
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_invoice_by_id(self, invoice_id: int) -> Optional[Invoice]:
        session = db_manager().get_session()  # Corrected line
        try:
            # MODIFIED: Added joinedload to eagerly fetch the owner relationship
            invoice = (
                session.query(Invoice)
                .options(joinedload(Invoice.owner))
                .filter(Invoice.invoice_id == invoice_id)
                .first()
            )
            return invoice
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving invoice {invoice_id}: {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def get_invoices_for_owner(self, owner_id: int) -> List[Invoice]:
        session = db_manager().get_session()  # Corrected line
        try:
            invoices = (
                session.query(Invoice)
                .options(joinedload(Invoice.owner))
                .filter(
                    Invoice.owner_id == owner_id, Invoice.status != "INTERNAL_PROCESSED"
                )
                .order_by(Invoice.invoice_date.desc())
                .all()
            )
            return invoices
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving invoices for owner {owner_id}: {e}", exc_info=True
            )
            return []
        finally:
            db_manager().close()  # Corrected line

    def get_transactions_for_invoice(self, invoice_id: int) -> List[Transaction]:
        session = db_manager().get_session()  # Corrected line
        try:
            transactions = (
                session.query(Transaction)
                .filter(Transaction.invoice_id == invoice_id)
                .options(joinedload(Transaction.charge_code))
                .order_by(Transaction.transaction_date.asc())
                .all()
            )
            return transactions
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving transactions for invoice {invoice_id}: {e}",
                exc_info=True,
            )
            return []
        finally:
            db_manager().close()  # Corrected line

    def generate_invoices_from_transactions(
        self, source_transaction_ids: List[int], current_user_id: str
    ) -> Tuple[bool, str, List[Invoice]]:
        self.logger.info(
            f"--- Starting Invoice Generation for transaction IDs: {source_transaction_ids} ---"
        )
        session = db_manager().get_session()  # Corrected line
        try:
            if not source_transaction_ids:
                return False, "No charges were selected to be invoiced.", []

            source_transactions = (
                session.query(Transaction)
                .filter(Transaction.transaction_id.in_(source_transaction_ids))
                .options(
                    joinedload(Transaction.horse)
                    .selectinload(Horse.owner_associations)
                    .joinedload(HorseOwner.owner)
                )
                .all()
            )

            for t in source_transactions:
                if t.status != "ACTIVE":
                    return (
                        False,
                        f"Charge '{t.description}' (ID: {t.transaction_id}) has already been processed.",
                        [],
                    )

            generated_invoices = []

            transactions_by_horse = defaultdict(list)
            for t in source_transactions:
                transactions_by_horse[t.horse_id].append(t)

            self.logger.info(
                f"Generating invoices for {len(transactions_by_horse)} horse(s)."
            )

            # --- MODIFIED BLOCK START ---
            # Refactored loop to be more robust and prevent duplicate invoice creation.
            for horse_id, transactions_for_horse in transactions_by_horse.items():
                horse = transactions_for_horse[0].horse

                # Use a dictionary to ensure we process each owner only once.
                unique_associations = {
                    assoc.owner_id: assoc for assoc in horse.owner_associations
                }

                if not unique_associations:
                    self.logger.warning(
                        f"Horse '{horse.horse_name}' has no owners assigned, skipping."
                    )
                    continue

                # Now loop through the unique associations
                for owner_id, association in unique_associations.items():
                    owner = association.owner
                    ownership_percentage = association.percentage_ownership / Decimal(
                        "100"
                    )

                    # Create ONE invoice per owner
                    owner_invoice = Invoice(
                        owner_id=owner.owner_id,
                        invoice_date=date.today(),
                        created_by=current_user_id,
                        modified_by=current_user_id,
                        status="Unpaid",
                    )
                    session.add(owner_invoice)
                    session.flush()

                    invoice_total = Decimal("0.00")

                    # Add line items for all transactions for this horse
                    for src_trans in transactions_for_horse:
                        prorated_price = (
                            src_trans.total_price * ownership_percentage
                        ).quantize(Decimal("0.01"))
                        invoice_total += prorated_price

                        line_item_desc = src_trans.description
                        # Add percentage share to description if more than one owner
                        if len(unique_associations) > 1:
                            line_item_desc += (
                                f" ({association.percentage_ownership:.2f}% Share)"
                            )

                        new_line_item = Transaction(
                            horse_id=src_trans.horse_id,
                            owner_id=owner.owner_id,
                            invoice_id=owner_invoice.invoice_id,
                            charge_code_id=src_trans.charge_code_id,
                            administered_by_user_id=src_trans.administered_by_user_id,
                            transaction_date=src_trans.transaction_date,
                            description=line_item_desc,
                            quantity=src_trans.quantity,
                            unit_price=(src_trans.unit_price * ownership_percentage),
                            total_price=prorated_price,
                            taxable=src_trans.taxable,
                            item_notes=src_trans.item_notes,
                            created_by=current_user_id,
                            modified_by=current_user_id,
                            status="BILLED",
                        )
                        session.add(new_line_item)

                    # Finalize the invoice object
                    owner_invoice.subtotal = invoice_total
                    owner_invoice.grand_total = invoice_total
                    owner_invoice.balance_due = invoice_total
                    owner.balance = (owner.balance or Decimal("0.00")) + invoice_total

                    # Create billing history
                    history_entry = OwnerBillingHistory(
                        owner_id=owner.owner_id,
                        description=f"Invoice #{owner_invoice.invoice_id} generated for {horse.horse_name}.",
                        amount_change=invoice_total,
                        new_balance=owner.balance,
                        created_by=current_user_id,
                    )
                    session.add(history_entry)
                    generated_invoices.append(owner_invoice)
            # --- MODIFIED BLOCK END ---

            for src_trans in source_transactions:
                src_trans.status = "PROCESSED"
                self.logger.debug(
                    f"Marking source TXN ID {src_trans.transaction_id} as PROCESSED."
                )

            session.commit()
            self.logger.info(
                f"--- Invoice Generation Complete. {len(generated_invoices)} invoices created. ---"
            )
            return (
                True,
                f"{len(generated_invoices)} invoice(s) created successfully.",
                generated_invoices,
            )

        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error during invoice generation: {e}", exc_info=True
            )
            return False, f"A database error occurred: {e}", []
        finally:
            db_manager().close()  # Corrected line

    def record_payment(self, payment_data: Dict[str, Any]) -> Tuple[bool, str]:
        """Records a payment against an invoice and updates balances."""
        session = db_manager().get_session()  # Corrected line
        try:
            invoice_id = payment_data.get("invoice_id")
            amount = payment_data.get("amount")
            current_user_id = payment_data.get("user_id")

            if not all([invoice_id, amount, current_user_id]):
                return False, "Missing required payment data."

            invoice = (
                session.query(Invoice)
                .options(joinedload(Invoice.owner))
                .filter(Invoice.invoice_id == invoice_id)
                .first()
            )
            if not invoice:
                return False, "Invoice not found."

            owner = invoice.owner
            if not owner:
                return False, "Owner for the invoice could not be found."

            # Create the payment record
            new_payment = OwnerPayment(
                owner_id=invoice.owner_id,
                amount=amount,
                payment_date=payment_data.get("payment_date", date.today()),
                payment_method=payment_data.get("payment_method", "Unknown"),
                reference_number=payment_data.get("reference_number"),
                notes=payment_data.get("notes"),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_payment)

            # Update invoice balances
            invoice.amount_paid = (invoice.amount_paid or Decimal("0.00")) + amount
            invoice.balance_due = (invoice.balance_due or Decimal("0.00")) - amount
            if invoice.balance_due <= Decimal("0.00"):
                invoice.status = "Paid"
                self.logger.info(f"Invoice #{invoice_id} marked as Paid.")

            # Update owner's total balance
            owner.balance = (owner.balance or Decimal("0.00")) - amount

            # Create billing history log for the payment
            history_entry = OwnerBillingHistory(
                owner_id=owner.owner_id,
                description=f"Payment received for Invoice #{invoice.invoice_id}. Ref: {new_payment.reference_number or new_payment.payment_method}",
                amount_change=-amount,
                new_balance=owner.balance,
                created_by=current_user_id,
            )
            session.add(history_entry)

            session.commit()
            self.logger.info(
                f"Payment of ${amount} successfully recorded for Invoice #{invoice_id}."
            )
            return True, "Payment recorded successfully."

        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error recording payment for invoice {invoice_id}: {e}",
                exc_info=True,
            )
            return False, "A database error occurred while recording the payment."
        finally:
            db_manager().close()  # Corrected line

    def get_transactions_for_horse(self, horse_id: int) -> List[Transaction]:
        session = db_manager().get_session()  # Corrected line
        try:
            transactions = (
                session.query(Transaction)
                .filter(
                    Transaction.horse_id == horse_id, Transaction.status == "ACTIVE"
                )
                .options(
                    joinedload(Transaction.charge_code),
                    joinedload(Transaction.administered_by),
                )
                .order_by(Transaction.transaction_date.desc())
                .all()
            )
            self.logger.info(
                f"Retrieved {len(transactions)} ACTIVE transactions for horse ID {horse_id}."
            )
            return transactions
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving transactions for horse ID {horse_id}: {e}",
                exc_info=True,
            )
            return []
        finally:
            db_manager().close()  # Corrected line

    def add_charge_batch_to_horse(
        self,
        horse_id: int,
        owner_id: int,
        charge_items: List[Dict[str, Any]],
        batch_transaction_date: date,
        administered_by_user_id: str,
    ) -> Tuple[bool, str, Optional[List[Transaction]]]:
        session = db_manager().get_session()  # Corrected line
        new_transactions = []
        try:
            for item in charge_items:
                total_price = item.get("quantity", Decimal(0)) * item.get(
                    "unit_price", Decimal(0)
                )
                new_transaction = Transaction(
                    horse_id=horse_id,
                    owner_id=owner_id,
                    charge_code_id=item.get("charge_code_id"),
                    administered_by_user_id=administered_by_user_id,
                    transaction_date=batch_transaction_date,
                    description=item.get("description"),
                    quantity=item.get("quantity"),
                    unit_price=item.get("unit_price"),
                    total_price=total_price,
                    taxable=item.get("taxable", False),
                    item_notes=item.get("item_notes"),
                    created_by=administered_by_user_id,
                    modified_by=administered_by_user_id,
                )
                session.add(new_transaction)
                new_transactions.append(new_transaction)
            session.commit()
            for trans in new_transactions:
                session.refresh(trans)
            self.logger.info(
                f"Successfully added {len(new_transactions)} charges for horse ID {horse_id}."
            )
            return (
                True,
                f"{len(new_transactions)} charges added successfully.",
                new_transactions,
            )
        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error adding charge batch for horse ID {horse_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred: {e}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Unexpected error adding charge batch for horse ID {horse_id}: {e}",
                exc_info=True,
            )
            return False, f"An unexpected error occurred: {e}", None
        finally:
            db_manager().close()  # Corrected line

    def update_charge_transaction(
        self, transaction_id: int, data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            transaction = (
                session.query(Transaction)
                .filter(Transaction.transaction_id == transaction_id)
                .first()
            )
            if not transaction:
                return False, "Transaction not found."
            if transaction.invoice_id:
                return False, "Cannot edit a charge that has already been invoiced."
            transaction.transaction_date = data.get(
                "transaction_date", transaction.transaction_date
            )
            transaction.description = data.get("description", transaction.description)
            transaction.quantity = data.get("quantity", transaction.quantity)
            transaction.unit_price = data.get("unit_price", transaction.unit_price)
            transaction.taxable = data.get("taxable", transaction.taxable)
            transaction.item_notes = data.get("item_notes", transaction.item_notes)
            transaction.total_price = transaction.quantity * transaction.unit_price
            transaction.modified_by = current_user_id
            session.commit()
            self.logger.info(f"Transaction ID {transaction_id} updated successfully.")
            return True, "Charge updated successfully."
        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error updating transaction {transaction_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred: {e}"
        finally:
            db_manager().close()  # Corrected line

    def delete_charge_transaction(self, transaction_id: int) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            transaction_to_delete = (
                session.query(Transaction)
                .filter(Transaction.transaction_id == transaction_id)
                .first()
            )
            if not transaction_to_delete:
                self.logger.warning(
                    f"Delete failed: Transaction ID {transaction_id} not found."
                )
                return False, "Transaction not found."
            if transaction_to_delete.invoice_id is not None:
                self.logger.warning(
                    f"Attempted to delete invoiced transaction ID {transaction_id}."
                )
                return False, "Cannot delete a charge that has already been invoiced."
            session.delete(transaction_to_delete)
            session.commit()
            self.logger.info(f"Transaction ID {transaction_id} deleted successfully.")
            return True, "Charge deleted successfully."
        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting transaction ID {transaction_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred while deleting the charge: {e}"
        finally:
            db_manager().close()  # Corrected line

    def get_transaction_by_id(self, transaction_id: int) -> Optional[Transaction]:
        session = db_manager().get_session()  # Corrected line
        try:
            transaction = (
                session.query(Transaction)
                .options(joinedload(Transaction.charge_code))
                .filter(Transaction.transaction_id == transaction_id)
                .first()
            )
            if transaction:
                self.logger.info(
                    f"Retrieved transaction ID {transaction_id} with its charge code."
                )
            else:
                self.logger.warning(f"Transaction ID {transaction_id} not found.")
            return transaction
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving transaction ID {transaction_id}: {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def delete_invoice(self, invoice_id: int, current_user_id: str) -> Tuple[bool, str]:
        """
        Deletes an invoice and reverses the owner's balance.
        NOTE: This does NOT make the original charges billable again.
        """
        session = db_manager().get_session()  # Corrected line
        try:
            invoice_to_delete = (
                session.query(Invoice)
                .options(joinedload(Invoice.owner))
                .filter(Invoice.invoice_id == invoice_id)
                .first()
            )

            if not invoice_to_delete:
                return False, "Invoice not found."

            if not invoice_to_delete.owner:
                return (
                    False,
                    "Cannot delete invoice: Owner record is missing or detached.",
                )

            owner = invoice_to_delete.owner
            reversal_amount = invoice_to_delete.grand_total

            self.logger.info(
                f"Deleting Invoice #{invoice_id} for owner '{owner.owner_id}'. "
                f"Reversing balance by ${reversal_amount}."
            )

            owner.balance = (owner.balance or Decimal("0.00")) - reversal_amount

            history_entry = OwnerBillingHistory(
                owner_id=owner.owner_id,
                description=f"Invoice #{invoice_id} deleted by user. Reversal of charges.",
                amount_change=-reversal_amount,
                new_balance=owner.balance,
                created_by=current_user_id,
            )
            session.add(history_entry)

            session.delete(invoice_to_delete)
            session.commit()

            self.logger.info(
                f"Successfully deleted Invoice #{invoice_id} and adjusted owner balance."
            )
            return True, f"Invoice #{invoice_id} has been deleted."

        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting invoice {invoice_id}: {e}", exc_info=True
            )
            return False, f"A database error occurred during deletion: {e}"
        finally:
            db_manager().close()  # Corrected line


=============== FILE: controllers/horse_controller.py ===============

# controllers/horse_controller.py
"""
EDSI Veterinary Management System - Horse Controller
Version: 1.5.0
Purpose: Handles business logic related to horses.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v1.5.0 (2025-06-10):
    - Fixed a critical bug in `create_horse` that caused a crash when saving a
      new horse without a location. The creation of a HorseLocation history
      record is now conditional on a location_id being provided.
- v1.4.0 (2025-06-09):
    - Refactored to improve separation of concerns by removing the redundant
      `get_all_locations` method. This functionality correctly belongs to the
      LocationController.
- v1.3.0 (2025-06-09):
    - Bug Fix: In `get_horse_by_id`, added `selectinload(Horse.owner_associations)`
      to the query to prevent DetachedInstanceError during invoice generation.
"""
import logging
from typing import List, Optional, Dict, Any
from datetime import datetime, date

from sqlalchemy import (
    select,
    update,
    delete,
    and_,
    or_,
    func as sql_func,
)
from sqlalchemy.orm import joinedload, selectinload, aliased
from sqlalchemy.exc import SQLAlchemyError

from config.database_config import db_manager
from models import Horse, Owner, HorseOwner, Location, HorseLocation


class HorseController:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def validate_horse_data(
        self,
        data: dict,
        is_new: bool = True,
        horse_id_to_check_for_unique: Optional[int] = None,
    ) -> tuple[bool, list]:
        errors = []
        required_fields = ["horse_name"]

        for field in required_fields:
            if not data.get(field) or not str(data[field]).strip():
                errors.append(f"{field.replace('_', ' ').capitalize()} is required.")

        if data.get("date_of_birth"):
            try:
                dob = data["date_of_birth"]
                if not isinstance(dob, date):
                    errors.append("Date of Birth was not a valid date object.")
                elif dob > date.today():
                    errors.append("Date of Birth cannot be in the future.")
            except Exception:
                errors.append("Invalid Date of Birth provided.")

        if data.get("coggins_date"):
            try:
                coggins_dt = data["coggins_date"]
                if not isinstance(coggins_dt, date):
                    errors.append("Coggins Date was not a valid date object.")
                elif coggins_dt > date.today():
                    errors.append("Coggins Date cannot be in the future.")
            except Exception:
                errors.append("Invalid Coggins Date provided.")

        chip_number = data.get("chip_number")
        if chip_number and str(chip_number).strip():
            session = db_manager().get_session()  # Corrected line
            try:
                query = session.query(Horse).filter(Horse.chip_number == chip_number)
                if not is_new and horse_id_to_check_for_unique:
                    query = query.filter(Horse.horse_id != horse_id_to_check_for_unique)
                if query.first():
                    errors.append(f"Chip number '{chip_number}' already exists.")
            finally:
                db_manager().close()  # Corrected line

        tattoo_number = data.get("tattoo_number")
        if tattoo_number and str(tattoo_number).strip():
            session = db_manager().get_session()  # Corrected line
            try:
                query = session.query(Horse).filter(
                    Horse.tattoo_number == tattoo_number
                )
                if not is_new and horse_id_to_check_for_unique:
                    query = query.filter(Horse.horse_id != horse_id_to_check_for_unique)
                if query.first():
                    errors.append(f"Tattoo number '{tattoo_number}' already exists.")
            finally:
                db_manager().close()  # Corrected line
        return not errors, errors

    def create_horse(
        self, data: dict, created_by_user: str
    ) -> tuple[bool, str, Optional[Horse]]:
        session = db_manager().get_session()  # Corrected line
        try:
            data["created_by"] = created_by_user
            data["modified_by"] = created_by_user

            horse_columns = {col.name for col in Horse.__table__.columns}
            filtered_data = {k: v for k, v in data.items() if k in horse_columns}

            for key in data:
                if key not in horse_columns and key not in ["current_location_id"]:
                    self.logger.warning(
                        f"HorseController.create_horse - Attribute '{key}' present in data but not in Horse model columns. It will be ignored."
                    )

            new_horse = Horse(**filtered_data)
            session.add(new_horse)

            # MODIFIED: Only create a location assignment if a location is provided.
            location_id = data.get("current_location_id")
            if location_id is not None:
                new_horse.current_location_id = location_id

                new_assignment = HorseLocation(
                    horse=new_horse,
                    location_id=location_id,
                    date_arrived=date.today(),
                    is_current_location=True,
                    created_by=created_by_user,
                    modified_by=created_by_user,
                )
                session.add(new_assignment)

            session.commit()
            session.refresh(new_horse)

            self.logger.info(
                f"Horse '{new_horse.horse_name}' (ID: {new_horse.horse_id}) created successfully by {created_by_user}."
            )
            return (
                True,
                f"Horse '{new_horse.horse_name}' created successfully.",
                new_horse,
            )
        except TypeError as te:
            self.logger.error(
                f"TypeError during Horse creation: {te} - Data was: {data}",
                exc_info=True,
            )
            session.rollback()
            return (
                False,
                f"Failed to create horse due to invalid data field: {te}",
                None,
            )
        except SQLAlchemyError as e:
            self.logger.error(
                f"SQLAlchemyError creating horse: {e} - Data was: {data}", exc_info=True
            )
            session.rollback()
            return (
                False,
                f"A database error occurred while creating the horse: {e}",
                None,
            )
        except Exception as e:
            self.logger.error(
                f"Unexpected error creating horse: {e} - Data was: {data}",
                exc_info=True,
            )
            session.rollback()
            return (
                False,
                f"An unexpected error occurred while creating the horse: {e}",
                None,
            )
        finally:
            db_manager().close()  # Corrected line

    def update_horse(
        self, horse_id: int, data: dict, modified_by_user: str
    ) -> tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return False, "Horse not found."

            data["modified_by"] = modified_by_user
            horse_columns = {col.name for col in Horse.__table__.columns}

            for key, value in data.items():
                if key == "current_location_id":
                    if horse.current_location_id != value:
                        horse.current_location_id = value
                elif key in horse_columns:
                    setattr(horse, key, value)
                elif hasattr(horse, key):
                    self.logger.info(
                        f"Setting attribute '{key}' which is not a direct column but exists on Horse model."
                    )
                    setattr(horse, key, value)
                else:
                    self.logger.warning(
                        f"HorseController.update_horse - Attempted to set unknown attribute '{key}' on Horse model."
                    )
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} updated successfully by {modified_by_user}."
            )
            return True, "Horse details updated successfully."
        except SQLAlchemyError as e:
            self.logger.error(
                f"SQLAlchemyError updating horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"A database error occurred while updating the horse: {e}"
        except Exception as e:
            self.logger.error(
                f"Unexpected error updating horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"An unexpected error occurred while updating the horse: {e}"
        finally:
            db_manager().close()  # Corrected line

    def get_horse_by_id(self, horse_id: int) -> Optional[Horse]:
        session = db_manager().get_session()  # Corrected line
        try:
            horse = (
                session.query(Horse)
                .options(
                    selectinload(Horse.owner_associations).joinedload(HorseOwner.owner),
                    selectinload(Horse.owners),
                    joinedload(Horse.location),
                )
                .filter(Horse.horse_id == horse_id)
                .first()
            )
            if horse:
                self.logger.info(f"Retrieved horse ID {horse_id}: {horse.horse_name}")
            else:
                self.logger.warning(f"Horse ID {horse_id} not found.")
            return horse
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving horse ID {horse_id}: {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def search_horses(
        self,
        search_term: str = "",
        status: str = "active",
        owner_name_search: Optional[str] = None,
    ) -> List[Horse]:
        session = db_manager().get_session()  # Corrected line
        try:
            query = session.query(Horse).options(
                selectinload(Horse.owners),
                joinedload(Horse.location),
            )

            if search_term:
                search_term_like = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Horse.horse_name.ilike(search_term_like),
                        Horse.account_number.ilike(search_term_like),
                        Horse.chip_number.ilike(search_term_like),
                        Horse.tattoo_number.ilike(search_term_like),
                    )
                )

            if owner_name_search:
                OwnerAlias = aliased(Owner)
                owner_search_like = f"%{owner_name_search}%"
                query = query.join(Horse.owners.of_type(OwnerAlias)).filter(
                    or_(
                        OwnerAlias.farm_name.ilike(owner_search_like),
                        OwnerAlias.first_name.ilike(owner_search_like),
                        OwnerAlias.last_name.ilike(owner_search_like),
                    )
                )
                query = query.distinct()

            if status == "active":
                query = query.filter(Horse.is_active == True)
            elif status == "inactive":
                query = query.filter(Horse.is_active == False)

            horses = query.order_by(Horse.horse_name).all()
            self.logger.info(
                f"Search for horses (term: '{search_term}', owner: '{owner_name_search}', status: {status}) found {len(horses)} results."
            )
            return horses
        except SQLAlchemyError as e:
            self.logger.error(f"Error searching horses: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            db_manager().close()  # Corrected line

    def deactivate_horse(
        self, horse_id: int, modified_by_user: str
    ) -> tuple[bool, str]:
        return self._toggle_horse_status(horse_id, False, modified_by_user)

    def activate_horse(self, horse_id: int, modified_by_user: str) -> tuple[bool, str]:
        return self._toggle_horse_status(horse_id, True, modified_by_user)

    def _toggle_horse_status(
        self, horse_id: int, is_active: bool, modified_by_user: str
    ) -> tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return False, "Horse not found."
            horse.is_active = is_active
            horse.modified_by = modified_by_user

            session.commit()
            status_text = "activated" if is_active else "deactivated"
            self.logger.info(
                f"Horse ID {horse_id} {status_text} by {modified_by_user}."
            )
            return True, f"Horse {status_text} successfully."
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error toggling horse status for ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, "Database error: Could not change horse status."
        finally:
            db_manager().close()  # Corrected line

    def get_horse_owners(self, horse_id: int) -> List[Dict[str, Any]]:
        session = db_manager().get_session()  # Corrected line
        try:
            associations = (
                session.query(HorseOwner)
                .filter(HorseOwner.horse_id == horse_id)
                .options(joinedload(HorseOwner.owner))
                .all()
            )
            owner_details = []
            for assoc in associations:
                if assoc.owner:
                    owner_name_parts = []
                    if assoc.owner.farm_name:
                        owner_name_parts.append(assoc.owner.farm_name)

                    person_name_parts = []
                    if assoc.owner.first_name:
                        person_name_parts.append(assoc.owner.first_name)
                    if assoc.owner.last_name:
                        person_name_parts.append(assoc.owner.last_name)
                    person_name_str = " ".join(person_name_parts).strip()

                    if person_name_str:
                        owner_name_parts.append(f"({person_name_str})")

                    display_name = " ".join(owner_name_parts).strip()
                    if not display_name:
                        display_name = f"Owner ID: {assoc.owner.owner_id}"

                    owner_details.append(
                        {
                            "owner_id": assoc.owner.owner_id,
                            "owner_name": display_name,
                            "percentage_ownership": assoc.percentage_ownership,
                            "phone_number": assoc.owner.phone,
                        }
                    )
            return owner_details
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owners for horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return []
        finally:
            db_manager().close()  # Corrected line

    def add_owner_to_horse(
        self,
        horse_id: int,
        owner_id: int,
        percentage: Optional[float],
        modified_by_user: str,
    ) -> tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            existing_assoc = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if existing_assoc:
                return False, "Owner is already associated with this horse."
            new_association = HorseOwner(
                horse_id=horse_id, owner_id=owner_id, percentage_ownership=percentage
            )
            session.add(new_association)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Owner ID {owner_id} added to horse ID {horse_id} by {modified_by_user}."
            )
            return True, "Owner successfully added to horse."
        except SQLAlchemyError as e:
            self.logger.error(f"Error adding owner to horse: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not add owner."
        finally:
            db_manager().close()  # Corrected line

    def update_horse_owner_percentage(
        self, horse_id: int, owner_id: int, percentage: float, modified_by_user: str
    ) -> tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            association = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if not association:
                return False, "Owner association not found."
            association.percentage_ownership = percentage

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Ownership percentage updated for horse ID {horse_id}, owner ID {owner_id} by {modified_by_user}."
            )
            return True, "Ownership percentage updated."
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error updating ownership percentage: {e}", exc_info=True
            )
            session.rollback()
            return False, "Database error: Could not update ownership."
        finally:
            db_manager().close()  # Corrected line

    def remove_owner_from_horse(
        self, horse_id: int, owner_id: int, modified_by_user: str
    ) -> tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            association = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if not association:
                return False, "Owner association not found."
            session.delete(association)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Owner ID {owner_id} removed from horse ID {horse_id} by {modified_by_user}."
            )
            return True, "Owner removed from horse successfully."
        except SQLAlchemyError as e:
            self.logger.error(f"Error removing owner from horse: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not remove owner."
        finally:
            db_manager().close()  # Corrected line

    def assign_horse_to_location(
        self,
        horse_id: int,
        location_id: int,
        notes: Optional[str],
        modified_by_user: str,
    ) -> tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            today = date.today()
            previous_assignments = (
                session.query(HorseLocation)
                .filter(
                    HorseLocation.horse_id == horse_id,
                    HorseLocation.is_current_location == True,
                )
                .all()
            )
            for prev_assign in previous_assignments:
                if prev_assign.location_id != location_id:
                    prev_assign.date_departed = today
                    prev_assign.is_current_location = False
                    prev_assign.modified_by = modified_by_user

            new_assignment = HorseLocation(
                horse_id=horse_id,
                location_id=location_id,
                date_arrived=today,
                notes=notes,
                is_current_location=True,
                created_by=modified_by_user,
                modified_by=modified_by_user,
            )
            session.add(new_assignment)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.current_location_id = location_id
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} assigned to location ID {location_id} by {modified_by_user}."
            )
            return True, "Horse location assigned successfully."
        except SQLAlchemyError as e:
            self.logger.error(f"Error assigning horse to location: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not assign location."
        finally:
            db_manager().close()  # Corrected line

    def remove_horse_from_location(
        self,
        horse_id: int,
        location_id: Optional[int] = None,
        modified_by_user: str = "system",
    ) -> tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            query = session.query(HorseLocation).filter(
                HorseLocation.horse_id == horse_id,
                HorseLocation.is_current_location == True,
            )
            if location_id is not None:
                query = query.filter(HorseLocation.location_id == location_id)

            current_assignment = query.first()
            if not current_assignment:
                return (
                    False,
                    "No current location assignment found for this horse (or not at the specified location if one was provided).",
                )

            current_assignment.date_departed = date.today()
            current_assignment.is_current_location = False
            current_assignment.modified_by = modified_by_user

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse and horse.current_location_id == current_assignment.location_id:
                horse.current_location_id = None
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} removed from location (assignment ID: {current_assignment.id}) by {modified_by_user}."
            )
            return True, "Horse removed from location (assignment ended)."
        except SQLAlchemyError as e:
            self.logger.error(f"Error removing horse from location: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not remove horse from location."
        finally:
            db_manager().close()  # Corrected line


=============== FILE: controllers/location_controller.py ===============

# controllers/location_controller.py
"""
EDSI Veterinary Management System - Location Controller
Version: 1.2.0
Purpose: Handles business logic for locations.
         - Added delete_location method with referential integrity check.
         - Modified get_all_locations to accept a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.2.0 (2025-06-05):
    - Added `delete_location` method, which checks for linked horses in
      HorseLocation before allowing deletion.
    - Modified `get_all_locations` to accept a string `status_filter` ('active',
      'inactive', or 'all') instead of a boolean for consistency.
- v1.1.7 (2025-06-05):
    - Reverted `update_location` to return a tuple of two values (bool, str).
"""
import logging
from typing import List, Optional, Tuple, Dict, Any

from sqlalchemy.orm import Session, joinedload
from sqlalchemy import exc as sqlalchemy_exc

from config.database_config import db_manager
from models import Location, StateProvince, HorseLocation


class LocationController:
    """Controller for location management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_locations(self, status_filter: str = "all") -> List[Location]:
        session = db_manager().get_session()  # Corrected line
        try:
            query = session.query(Location).options(joinedload(Location.state))
            if status_filter == "active":
                query = query.filter(Location.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Location.is_active == False)
            locations = query.order_by(Location.location_name).all()
            return locations
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all locations: {e}", exc_info=True)
            return []
        finally:
            db_manager().close()  # Corrected line

    def get_location_by_id(self, location_id: int) -> Optional[Location]:
        session = db_manager().get_session()  # Corrected line
        try:
            return (
                session.query(Location)
                .options(joinedload(Location.state))
                .filter(Location.location_id == location_id)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching location by ID {location_id}: {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def validate_location_data(
        self,
        location_data: dict,
        is_new: bool = True,
        location_id_to_check_for_unique: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        name = location_data.get("location_name", "").strip()

        if not name:
            errors.append("Location Name is required.")
        elif len(name) > 100:
            errors.append("Location Name cannot exceed 100 characters.")
        else:
            session = db_manager().get_session()  # Corrected line
            try:
                query = session.query(Location.location_id).filter(
                    Location.location_name.collate("NOCASE") == name
                )
                if not is_new and location_id_to_check_for_unique is not None:
                    query = query.filter(
                        Location.location_id != location_id_to_check_for_unique
                    )
                if query.first():
                    errors.append(f"Location Name '{name}' already exists.")
            finally:
                db_manager().close()  # Corrected line
        return not errors, errors

    def create_location(
        self, location_data: dict, current_user_id: str
    ) -> Tuple[bool, str, Optional[Location]]:
        is_valid, errors = self.validate_location_data(location_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager().get_session()  # Corrected line
        try:

            def process_string(value: Any) -> Optional[str]:
                return value.strip() if isinstance(value, str) else None

            new_location = Location(
                location_name=location_data.get("location_name", "").strip(),
                address_line1=process_string(location_data.get("address_line1")),
                address_line2=process_string(location_data.get("address_line2")),
                city=process_string(location_data.get("city")),
                state_code=process_string(location_data.get("state_code")),
                zip_code=process_string(location_data.get("zip_code")),
                phone=process_string(location_data.get("phone")),
                contact_person=process_string(location_data.get("contact_person")),
                email=process_string(location_data.get("email")),
                is_active=location_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_location)
            session.commit()
            session.refresh(new_location)
            self.logger.info(
                f"Location '{new_location.location_name}' created by {current_user_id}."
            )
            return True, "Location created successfully.", new_location
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(f"Error creating location: {e.orig}", exc_info=True)
            return False, f"Database integrity error: {e.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating location: {e}", exc_info=True)
            return False, f"Failed to create location: {e}", None
        finally:
            db_manager().close()  # Corrected line

    def update_location(
        self, location_id: int, location_data: dict, current_user_id: str
    ) -> Tuple[bool, str]:
        is_valid, errors = self.validate_location_data(
            location_data, is_new=False, location_id_to_check_for_unique=location_id
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors)

        session = db_manager().get_session()  # Corrected line
        try:
            location = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )
            if not location:
                return False, "Location not found."

            for key, value in location_data.items():
                if hasattr(location, key):
                    processed_value = value.strip() if isinstance(value, str) else value
                    setattr(location, key, processed_value)

            location.modified_by = current_user_id
            session.commit()
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location_id}) updated by {current_user_id}."
            )
            return True, "Location updated successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating location ID {location_id}: {e}", exc_info=True
            )
            return False, f"Failed to update location: {e}"
        finally:
            db_manager().close()  # Corrected line

    def toggle_location_active_status(
        self, location_id: int, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            location = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )
            if not location:
                return False, f"Location with ID {location_id} not found."

            location.is_active = not location.is_active
            location.modified_by = current_user_id

            session.commit()

            new_status = "activated" if location.is_active else "deactivated"
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location_id}) status changed to {new_status} by {current_user_id}."
            )
            return (
                True,
                f"Location '{location.location_name}' has been successfully {new_status}.",
            )

        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error toggling status for location ID {location_id}: {e}",
                exc_info=True,
            )
            return False, "A database error occurred while toggling location status."
        finally:
            db_manager().close()  # Corrected line

    def delete_location(
        self, location_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            linked_horses_count = (
                session.query(HorseLocation)
                .filter(HorseLocation.location_id == location_id)
                .count()
            )

            if linked_horses_count > 0:
                message = f"Cannot delete location. It is currently or was previously assigned to {linked_horses_count} horse(s)."
                self.logger.warning(message)
                return False, message

            location_to_delete = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )

            if not location_to_delete:
                return False, "Location not found."

            location_name = location_to_delete.location_name
            session.delete(location_to_delete)
            session.commit()
            self.logger.info(
                f"Location '{location_name}' (ID: {location_id}) deleted by {current_user_id}."
            )
            return True, f"Location '{location_name}' was deleted."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting location ID {location_id}: {e}", exc_info=True
            )
            return False, f"A database error occurred: {e}"
        finally:
            db_manager().close()  # Corrected line


=============== FILE: controllers/owner_controller.py ===============

# controllers/owner_controller.py
"""
EDSI Veterinary Management System - Owner Controller
Version: 1.4.0
Purpose: Business logic for owner master file operations.
         - Standardized get_all_master_owners filter to use a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.4.0 (2025-06-05):
    - Modified `get_all_master_owners` to accept a string `status_filter` ('active',
      'inactive', 'all') for consistency.
- v1.3.5 (2025-06-04):
    - In `get_all_master_owners`, added `options(joinedload(Owner.state))`
      to eagerly load the related StateProvince object, preventing
      DetachedInstanceError when accessing owner.state in views.
- v1.3.4 (2025-06-02):
    - Added `import re` to resolve NameError during email validation
      in `validate_owner_data`.
- v1.3.3 (2025-06-02):
    - Modified `validate_owner_data` to correctly handle optional fields that
      might be `None` before calling `len()` on them, preventing TypeError.
- v1.3.2 (2025-05-17):
    - Removed `country_name` from Owner instantiation/update and validation.
- v1.3.1 (2025-05-17):
    - Removed phone number requirement from `validate_owner_data`.
    - Added `mobile_phone` handling.
- v1.2.1 (2025-05-15): Removed credit_rating. - v1.2.0 (2025-05-15): Added delete_master_owner method.
"""

import logging
import re
from typing import List, Optional, Tuple, Dict, Any
from decimal import Decimal, InvalidOperation
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import or_, func, exc as sqlalchemy_exc

from config.database_config import db_manager
from models import (
    Owner,
    StateProvince,
    HorseOwner,
)
from datetime import datetime


class OwnerController:
    """Controller for owner master file operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_master_owners(self, status_filter: str = "all") -> List[Owner]:
        session = db_manager().get_session()  # Corrected line
        try:
            query = session.query(Owner).options(joinedload(Owner.state))

            if status_filter == "active":
                query = query.filter(Owner.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Owner.is_active == False)

            owners = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()
            self.logger.info(
                f"Retrieved {len(owners)} master owners (status_filter={status_filter})."
            )
            return owners
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all master owners: {e}", exc_info=True)
            return []
        finally:
            db_manager().close()  # Corrected line

    def get_all_owners_for_lookup(self, search_term: str = "") -> List[Dict[str, Any]]:
        # ... (implementation unchanged) ...
        session = db_manager().get_session()  # Corrected line
        try:
            query = session.query(
                Owner.owner_id,
                Owner.first_name,
                Owner.last_name,
                Owner.farm_name,
                Owner.account_number,
            ).filter(Owner.is_active == True)

            if search_term:
                search_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Owner.first_name.ilike(search_pattern),
                        Owner.last_name.ilike(search_pattern),
                        Owner.farm_name.ilike(search_pattern),
                        Owner.account_number.ilike(search_pattern),
                    )
                )

            owners_data = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()

            lookup_list = []
            for (
                owner_id,
                first_name,
                last_name,
                farm_name,
                account_number,
            ) in owners_data:
                name_parts = [name for name in [first_name, last_name] if name]
                individual_name = " ".join(name_parts)
                display_text = farm_name if farm_name else ""
                if individual_name:
                    display_text = (
                        f"{display_text} ({individual_name})"
                        if farm_name
                        else individual_name
                    )
                if not display_text:
                    display_text = f"Owner ID {owner_id}"  # Fallback if no names
                if account_number:
                    display_text += f" [{account_number}]"
                lookup_list.append({"id": owner_id, "name_account": display_text})
            return lookup_list
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching owners for lookup: {e}", exc_info=True)
            return []
        finally:
            db_manager().close()  # Corrected line

    def get_owner_by_id(self, owner_id: int) -> Optional[Owner]:
        # ... (implementation unchanged) ...
        session = db_manager().get_session()  # Corrected line
        try:
            owner = (
                session.query(Owner)
                .options(joinedload(Owner.state))  # Eager load state here too
                .filter(Owner.owner_id == owner_id)
                .first()
            )
            return owner
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owner by ID '{owner_id}': {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def validate_owner_data(
        self,
        owner_data: dict,
        is_new: bool = True,
        owner_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        # ... (implementation unchanged) ...
        errors = []
        first_name = owner_data.get("first_name")
        last_name = owner_data.get("last_name")
        farm_name = owner_data.get("farm_name")
        account_number_val = owner_data.get("account_number")

        if not owner_data.get("address_line1", "").strip():
            errors.append("Address Line 1 is required.")
        if not owner_data.get("city", "").strip():
            errors.append("City is required.")
        if not owner_data.get("state_code", "").strip():
            errors.append("State is required.")
        if not owner_data.get("zip_code", "").strip():
            errors.append("Zip Code is required.")

        field_max_lengths = {
            "first_name": 50,
            "last_name": 50,
            "farm_name": 100,
            "address_line1": 100,
            "address_line2": 100,
            "city": 50,
            "zip_code": 20,
            "phone": 20,
            "mobile_phone": 20,
            "email": 100,
            "account_number": 20,
            "billing_terms": 50,
        }

        for field, max_len in field_max_lengths.items():
            value = owner_data.get(field)
            if value is not None and isinstance(value, str) and len(value) > max_len:
                errors.append(
                    f"{field.replace('_', ' ').title()} cannot exceed {max_len} characters."
                )

        email_val = owner_data.get("email")
        if email_val and email_val.strip():
            if not re.match(
                r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email_val
            ):
                errors.append("Invalid email format.")

        if account_number_val and account_number_val.strip():
            session = db_manager().get_session()  # Corrected line
            try:
                query = session.query(Owner).filter(
                    Owner.account_number.collate("NOCASE") == account_number_val.strip()
                )
                if not is_new and owner_id_to_ignore is not None:
                    query = query.filter(Owner.owner_id != owner_id_to_ignore)

                existing_owner_with_account = query.first()
                if existing_owner_with_account:
                    errors.append(
                        f"Account Number '{account_number_val}' already exists."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"DB error validating account_number: {e}", exc_info=True
                )
                errors.append("Error validating account number uniqueness.")
            finally:
                db_manager().close()  # Corrected line

        credit_limit_str = owner_data.get("credit_limit")
        if credit_limit_str is not None and str(credit_limit_str).strip() != "":
            try:
                credit_limit_decimal = Decimal(str(credit_limit_str))
                if credit_limit_decimal < Decimal("0.00"):
                    errors.append("Credit Limit cannot be negative.")
            except InvalidOperation:
                errors.append("Credit Limit must be a valid number (e.g., 1000.00).")

        return not errors, errors

    def create_master_owner(
        self, owner_data: dict, current_user: str
    ) -> Tuple[bool, str, Optional[Owner]]:
        # ... (implementation unchanged) ...
        is_valid, errors = self.validate_owner_data(owner_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager().get_session()  # Corrected line
        try:
            new_owner_params = {}
            allowed_keys = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",
                "phone",
                "mobile_phone",
                "email",
                "credit_limit",
                "billing_terms",
                "is_active",
                "balance",
                "service_charge_rate",
                "discount_rate",
                "notes",
            ]
            for key in allowed_keys:
                if key in owner_data:
                    value = owner_data[key]
                    if isinstance(value, str):
                        new_owner_params[key] = value.strip() or None
                    elif (
                        key == "credit_limit"
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            self.logger.warning(
                                f"Invalid decimal for credit_limit: {value}. Setting to None."
                            )
                            new_owner_params[key] = None
                    elif (
                        key == "balance"
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            new_owner_params[key] = Decimal("0.00")
                    elif (
                        key in ["service_charge_rate", "discount_rate"]
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            new_owner_params[key] = None
                    else:
                        new_owner_params[key] = value

            if new_owner_params.get("balance") is None:
                new_owner_params["balance"] = Decimal("0.00")

            if new_owner_params.get("is_active") is None:
                new_owner_params["is_active"] = True

            new_owner = Owner(**new_owner_params)
            new_owner.created_by = current_user
            new_owner.modified_by = current_user

            session.add(new_owner)
            session.commit()
            session.refresh(new_owner)

            log_name_parts = [
                name for name in [new_owner.first_name, new_owner.last_name] if name
            ]
            log_individual_name = " ".join(log_name_parts)
            display_name_for_log = new_owner.farm_name if new_owner.farm_name else ""
            if log_individual_name:
                display_name_for_log = (
                    f"{display_name_for_log} ({log_individual_name})"
                    if new_owner.farm_name
                    else log_individual_name
                )
            if not display_name_for_log:
                display_name_for_log = f"Owner ID {new_owner.owner_id}"

            self.logger.info(
                f"Master Owner '{display_name_for_log}' (ID: {new_owner.owner_id}) created by {current_user}."
            )
            return True, "Owner created successfully.", new_owner
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating master owner: {ie.orig}", exc_info=True
            )
            if "UNIQUE constraint failed: owners.account_number" in str(
                ie.orig
            ).lower() and owner_data.get("account_number"):
                return (
                    False,
                    f"Account Number '{owner_data['account_number']}' already exists.",
                    None,
                )
            return False, f"Database integrity error: {ie.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating master owner: {e}", exc_info=True)
            return False, f"Failed to create owner: {e}", None
        finally:
            db_manager().close()  # Corrected line

    def update_master_owner(
        self, owner_id: int, owner_data: dict, current_user: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager().get_session()  # Corrected line
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return False, f"Owner with ID {owner_id} not found."

            original_account_number = owner.account_number
            if (
                "account_number" in owner_data
                and owner_data["account_number"] != original_account_number
            ):
                is_valid, errors = self.validate_owner_data(
                    owner_data, is_new=False, owner_id_to_ignore=owner_id
                )
            else:
                temp_data_for_validation = owner_data.copy()
                temp_data_for_validation.pop("account_number", None)
                is_valid, errors = self.validate_owner_data(
                    temp_data_for_validation, is_new=False, owner_id_to_ignore=owner_id
                )

            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            updatable_fields = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",
                "phone",
                "mobile_phone",
                "email",
                "is_active",
                "balance",
                "credit_limit",
                "billing_terms",
                "service_charge_rate",
                "discount_rate",
                "notes",
            ]

            for key in updatable_fields:
                if key in owner_data:
                    value = owner_data[key]
                    if isinstance(value, str):
                        setattr(
                            owner,
                            key,
                            (
                                value.strip() or None
                                if key
                                not in [
                                    "last_name",
                                    "address_line1",
                                    "city",
                                    "state_code",
                                    "zip_code",
                                ]
                                else value.strip()
                            ),
                        )
                    elif (
                        key
                        in [
                            "credit_limit",
                            "balance",
                            "service_charge_rate",
                            "discount_rate",
                        ]
                        and value is not None
                    ):
                        if str(value).strip() == "":
                            if key == "balance":
                                setattr(owner, key, Decimal("0.00"))
                            else:
                                setattr(owner, key, None)
                        else:
                            try:
                                setattr(owner, key, Decimal(str(value)))
                            except InvalidOperation:
                                self.logger.warning(
                                    f"Invalid decimal value for {key}: {value} during update. Field not updated."
                                )
                    else:
                        setattr(owner, key, value)

            owner.modified_by = current_user

            session.commit()
            return True, "Owner updated successfully."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError updating owner ID {owner_id}: {ie.orig}", exc_info=True
            )
            if "UNIQUE constraint failed: owners.account_number" in str(
                ie.orig
            ).lower() and owner_data.get("account_number"):
                return (
                    False,
                    f"Account Number '{owner_data['account_number']}' already exists for another owner.",
                )
            return False, f"Database integrity error: {ie.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating master owner ID {owner_id}: {e}", exc_info=True
            )
            return False, f"Failed to update owner: {e}"
        finally:
            db_manager().close()  # Corrected line

    def delete_master_owner(
        self, owner_id_to_delete: int, current_admin_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager().get_session()  # Corrected line
        try:
            owner = (
                session.query(Owner)
                .filter(Owner.owner_id == owner_id_to_delete)
                .first()
            )
            if not owner:
                return False, f"Owner with ID {owner_id_to_delete} not found."

            linked_horses_count = (
                session.query(HorseOwner)
                .filter(HorseOwner.owner_id == owner_id_to_delete)
                .count()
            )
            if linked_horses_count > 0:
                self.logger.warning(
                    f"Attempt to delete owner ID {owner_id_to_delete} who is linked to {linked_horses_count} horse(s)."
                )
                return (
                    False,
                    f"Cannot delete owner. They are currently linked to {linked_horses_count} horse(s). Please unlink them from all horses first.",
                )

            owner_name_for_log_parts = [
                name
                for name in [owner.farm_name, owner.last_name, owner.first_name]
                if name
            ]
            owner_name_for_log = (
                " ".join(owner_name_for_log_parts) or f"ID {owner_id_to_delete}"
            )

            session.delete(owner)
            session.commit()
            self.logger.info(
                f"Master Owner '{owner_name_for_log}' (ID: {owner_id_to_delete}) permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"Owner '{owner_name_for_log}' deleted successfully."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error deleting master owner ID {owner_id_to_delete}: {e}",
                exc_info=True,
            )
            if isinstance(e, sqlalchemy_exc.IntegrityError):
                return (
                    False,
                    f"Cannot delete owner. It might be referenced by other records (e.g., invoices, payments). Details: {e.orig}",
                )
            return False, f"Failed to delete owner due to a database error: {e}"
        finally:
            db_manager().close()  # Corrected line

    def get_owner_form_reference_data(self) -> Dict[str, List[Dict[str, Any]]]:
        # ... (implementation unchanged) ...
        session = db_manager().get_session()  # Corrected line
        try:
            states_query = (
                session.query(
                    StateProvince.state_code,
                    StateProvince.state_name,
                    StateProvince.country_code,
                )
                .filter(StateProvince.is_active == True)
                .order_by(StateProvince.country_code, StateProvince.state_name)
                .all()
            )
            states = [
                {
                    "id": s.state_code,
                    "name": s.state_name,
                    "country_code": s.country_code,
                }
                for s in states_query
            ]
            billing_terms_list = [
                {"id": "NET30", "name": "Net 30 Days"},
                {"id": "NET15", "name": "Net 15 Days"},
                {"id": "NET60", "name": "Net 60 Days"},
                {"id": "COD", "name": "Cash on Delivery"},
                {"id": "PREPAID", "name": "Prepaid"},
                {"id": "EOM", "name": "End of Month"},
                {"id": "ONDELIVERY", "name": "Payment on Delivery"},
            ]
            return {"states": states, "billing_terms": billing_terms_list}
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owner form reference data: {e}", exc_info=True
            )
            return {"states": [], "billing_terms": []}
        finally:
            db_manager().close()  # Corrected line

    def toggle_owner_active_status(
        self, owner_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager().get_session()  # Corrected line
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return False, "Owner not found."
            owner.is_active = not owner.is_active
            owner.modified_by = current_user_id
            session.commit()
            status = "activated" if owner.is_active else "deactivated"
            self.logger.info(f"Owner ID {owner_id} {status} by {current_user_id}.")
            return True, f"Owner {status} successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error toggling active status for owner ID {owner_id}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle owner status: {e}"
        finally:
            db_manager().close()  # Corrected line


=============== FILE: controllers/reports_controller.py ===============

"""
EDSI Veterinary Management System - Reports Controller
Version: 1.7.1
Purpose: Business logic for generating reports.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v1.7.1 (2025-06-12):
    - Fixed an AttributeError in `get_charge_code_usage_data` by correcting the
      SQLAlchemy join condition for ChargeCodeCategory from the incorrect '.id'
      to the correct '.category_id' primary key.
- v1.7.0 (2025-06-12):
    - Upgraded `get_charge_code_usage_data` to be a full-featured method.
    - It now accepts an `options` dictionary to handle UI-driven sorting and grouping.
    - The query now calculates total revenue in addition to usage count.
    - The returned data structure is now richer, including summary, details, and options.
"""

import logging
from typing import List, Dict, Any, Tuple, Optional
from datetime import date
from decimal import Decimal

from sqlalchemy import and_, or_, func
from sqlalchemy.orm import Session, joinedload

from config.database_config import db_manager
from models import (
    Owner,
    Invoice,
    OwnerPayment,
    OwnerBillingHistory,
    Transaction,
    ChargeCode,
    ChargeCodeCategory,
    Horse,
    User,
)
from controllers.company_profile_controller import CompanyProfileController


class ReportsController:
    """Controller for report generation and data fetching."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("ReportsController initialized.")
        self.company_profile = CompanyProfileController().get_company_profile()

    def get_charge_code_usage_data(self, options: Dict[str, Any]) -> Dict[str, Any]:
        """
        Fetches and processes data for the Charge Code Usage report.
        
        Args:
            options: A dictionary of user-selected options from the UI.

        Returns:
            A dictionary containing the processed data ready for the PDF generator.
        """
        session = db_manager.get_session()
        try:
            start_date = options['start_date']
            end_date = options['end_date']

            # Base query to get usage count and revenue
            query = (
                session.query(
                    ChargeCode.code,
                    ChargeCode.description,
                    ChargeCodeCategory.name.label('category_name'),
                    func.count(Transaction.transaction_id).label('usage_count'),
                    func.sum(Transaction.total_price).label('total_revenue')
                )
                .join(ChargeCode, Transaction.charge_code_id == ChargeCode.id)
                # MODIFIED: Corrected ChargeCodeCategory.id to ChargeCodeCategory.category_id
                .join(ChargeCodeCategory, ChargeCodeCategory.category_id == ChargeCode.category_id)
                .filter(and_(
                    Transaction.transaction_date >= start_date,
                    Transaction.transaction_date <= end_date
                ))
                .group_by(ChargeCode.code, ChargeCode.description, ChargeCodeCategory.name)
            )
            
            results = query.all()
            
            if not results:
                return {"details": [], "summary": {}, "options": options}

            details = [
                {
                    "code": r.code,
                    "description": r.description,
                    "category_name": r.category_name,
                    "usage_count": r.usage_count,
                    "total_revenue": float(r.total_revenue) if r.total_revenue else 0.0,
                }
                for r in results
            ]
            
            # Sorting logic
            sort_by = options.get('sort_by', 'Usage Count (High to Low)')
            reverse_sort = True
            sort_key = 'usage_count'
            if sort_by == "Total Revenue (High to Low)":
                sort_key = 'total_revenue'
            elif sort_by == "Charge Code (A-Z)":
                sort_key = 'code'
                reverse_sort = False
            elif sort_by == "Category (A-Z)":
                sort_key = 'category_name'
                reverse_sort = False
                
            details.sort(key=lambda x: x[sort_key], reverse=reverse_sort)

            summary = {
                "unique_codes_used": len(details),
                "total_usage_count": sum(item['usage_count'] for item in details),
                "total_revenue": sum(item['total_revenue'] for item in details),
            }

            return {
                "options": options,
                "summary": summary,
                "details": details,
            }

        except Exception as e:
            self.logger.error(f"Error fetching charge code usage data: {e}", exc_info=True)
            return {"error": str(e)}
        finally:
            session.close()

    def get_horse_transaction_history_data(
        self, horse_id: int, start_date: date, end_date: date
    ) -> Dict[str, Any]:
        """Fetches all transactions for a single horse within a date range."""
        session = db_manager.get_session()
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return {
                    "error": "Horse not found",
                    "horse": None,
                    "transactions": [],
                    "start_date": start_date,
                    "end_date": end_date,
                }

            transactions = (
                session.query(Transaction)
                .filter(
                    Transaction.horse_id == horse_id,
                    Transaction.transaction_date.between(start_date, end_date),
                )
                .options(
                    joinedload(Transaction.charge_code),
                    joinedload(Transaction.administered_by),
                )
                .order_by(Transaction.transaction_date.asc())
                .all()
            )

            return {
                "horse": horse,
                "transactions": transactions,
                "start_date": start_date,
                "end_date": end_date,
            }
        except Exception as e:
            self.logger.error(
                f"Error generating horse transaction history for horse_id {horse_id}: {e}",
                exc_info=True,
            )
            return {
                "error": str(e),
                "horse": None,
                "transactions": [],
                "start_date": start_date,
                "end_date": end_date,
            }
        finally:
            session.close()

    def get_payment_history_data(
        self, start_date: date, end_date: date, owner_id: Optional[Any] = None
    ) -> Dict[str, Any]:
        session = db_manager.get_session()
        try:
            query = (
                session.query(OwnerPayment)
                .filter(OwnerPayment.payment_date.between(start_date, end_date))
                .options(joinedload(OwnerPayment.owner))
                .order_by(OwnerPayment.payment_date, OwnerPayment.owner_id)
            )
            if owner_id and owner_id != "all":
                query = query.filter(OwnerPayment.owner_id == owner_id)
            payments = query.all()
            return {
                "payments": payments,
                "start_date": start_date,
                "end_date": end_date,
            }
        except Exception as e:
            self.logger.error(
                f"Error generating payment history data: {e}", exc_info=True
            )
            return {"payments": [], "start_date": start_date, "end_date": end_date}
        finally:
            session.close()

    def get_invoice_register_data(
        self, start_date: date, end_date: date
    ) -> Dict[str, Any]:
        session = db_manager.get_session()
        try:
            invoices = (
                session.query(Invoice)
                .filter(Invoice.invoice_date.between(start_date, end_date))
                .options(joinedload(Invoice.owner))
                .order_by(Invoice.invoice_date, Invoice.invoice_id)
                .all()
            )
            return {
                "invoices": invoices,
                "start_date": start_date,
                "end_date": end_date,
            }
        except Exception as e:
            self.logger.error(
                f"Error generating invoice register data: {e}", exc_info=True
            )
            return {"invoices": [], "start_date": start_date, "end_date": end_date}
        finally:
            session.close()

    def get_ar_aging_data(self, as_of_date: date) -> Dict[str, Any]:
        session = db_manager.get_session()
        try:
            owners_with_balance = (
                session.query(Owner)
                .filter(Owner.is_active == True, Owner.balance > 0)
                .options(joinedload(Owner.invoices))
                .order_by(Owner.last_name)
                .all()
            )
            report_lines = []
            totals = {
                "current": Decimal("0.00"),
                "31-60": Decimal("0.00"),
                "61-90": Decimal("0.00"),
                "over_90": Decimal("0.00"),
                "total": Decimal("0.00"),
            }
            for owner in owners_with_balance:
                owner_buckets = {
                    "current": Decimal("0.00"),
                    "31-60": Decimal("0.00"),
                    "61-90": Decimal("0.00"),
                    "over_90": Decimal("0.00"),
                }
                unpaid_invoices = [inv for inv in owner.invoices if inv.balance_due > 0]
                for inv in unpaid_invoices:
                    age = (as_of_date - inv.invoice_date).days
                    if age <= 30:
                        owner_buckets["current"] += inv.balance_due
                    elif 31 <= age <= 60:
                        owner_buckets["31-60"] += inv.balance_due
                    elif 61 <= age <= 90:
                        owner_buckets["61-90"] += inv.balance_due
                    else:
                        owner_buckets["over_90"] += inv.balance_due
                owner_total = sum(owner_buckets.values())
                if owner_total > 0:
                    report_lines.append(
                        {
                            "name": owner.farm_name
                            or f"{owner.first_name or ''} {owner.last_name or ''}".strip(),
                            "buckets": owner_buckets,
                            "total": owner_total,
                        }
                    )
                    for key in totals:
                        if key != "total":
                            totals[key] += owner_buckets[key]
                    totals["total"] += owner_total
            return {"lines": report_lines, "totals": totals, "as_of_date": as_of_date}
        except Exception as e:
            self.logger.error(f"Error generating A/R aging data: {e}", exc_info=True)
            return {"lines": [], "totals": {}, "as_of_date": as_of_date}
        finally:
            session.close()

    def get_data_for_all_owner_statements(
        self, start_date: date, end_date: date
    ) -> List[Dict[str, Any]]:
        session = db_manager.get_session()
        try:
            owners_with_invoices = (
                session.query(Invoice.owner_id)
                .filter(Invoice.invoice_date.between(start_date, end_date))
                .distinct()
            )
            owners_with_payments = (
                session.query(OwnerPayment.owner_id)
                .filter(OwnerPayment.payment_date.between(start_date, end_date))
                .distinct()
            )
            owners_with_balance = (
                session.query(Owner.owner_id)
                .filter(Owner.is_active == True, Owner.balance != Decimal("0.00"))
                .distinct()
            )
            owner_ids = {r[0] for r in owners_with_invoices}
            owner_ids.update(r[0] for r in owners_with_payments)
            owner_ids.update(r[0] for r in owners_with_balance)
            all_statements_data = [
                s_data
                for owner_id in owner_ids
                if (
                    s_data := self.get_owner_statement_data(
                        owner_id, start_date, end_date, session
                    )
                )
            ]
            return all_statements_data
        except Exception as e:
            self.logger.error(
                f"Error gathering data for all owner statements: {e}", exc_info=True
            )
            return []
        finally:
            session.close()

    def get_owner_statement_data(
        self,
        owner_id: int,
        start_date: date,
        end_date: date,
        session: Optional[Session] = None,
    ) -> Optional[Dict[str, Any]]:
        close_session = False
        if session is None:
            session = db_manager.get_session()
            close_session = True
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return None
            last_history = (
                session.query(OwnerBillingHistory)
                .filter(
                    OwnerBillingHistory.owner_id == owner_id,
                    OwnerBillingHistory.entry_date < start_date,
                )
                .order_by(OwnerBillingHistory.entry_date.desc())
                .first()
            )
            starting_balance = (
                last_history.new_balance if last_history else Decimal("0.00")
            )
            invoices = (
                session.query(Invoice)
                .filter(
                    Invoice.owner_id == owner_id,
                    Invoice.invoice_date.between(start_date, end_date),
                )
                .all()
            )
            payments = (
                session.query(OwnerPayment)
                .filter(
                    OwnerPayment.owner_id == owner_id,
                    OwnerPayment.payment_date.between(start_date, end_date),
                )
                .all()
            )
            statement_items = []
            for inv in invoices:
                statement_items.append(
                    {
                        "date": inv.invoice_date,
                        "type": "Invoice",
                        "description": f"Invoice #{inv.invoice_id}",
                        "charge": inv.grand_total,
                        "payment": Decimal("0.00"),
                    }
                )
            for pmt in payments:
                ref = f" (Ref: {pmt.reference_number})" if pmt.reference_number else ""
                statement_items.append(
                    {
                        "date": pmt.payment_date,
                        "type": "Payment",
                        "description": f"Payment - {pmt.payment_method}{ref}",
                        "charge": Decimal("0.00"),
                        "payment": pmt.amount,
                    }
                )
            statement_items.sort(key=lambda x: x["date"])
            return {
                "owner": owner,
                "start_date": start_date,
                "end_date": end_date,
                "starting_balance": starting_balance,
                "items": statement_items,
            }
        except Exception as e:
            self.logger.error(
                f"Error generating owner statement data for owner ID {owner_id}: {e}",
                exc_info=True,
            )
            return None
        finally:
            if close_session:
                session.close()

=============== FILE: controllers/reports_screen.py ===============

# views/reports/reports_screen.py
"""
EDSI Veterinary Management System - Main Reports Screen
Version: 1.0.0
Purpose: A central hub for selecting and running various application reports.
Last Updated: June 10, 2025
Author: Gemini
"""

import logging
from typing import Optional

from PySide6.QtWidgets import (
    QWidget,
    QHBoxLayout,
    QVBoxLayout,
    QListWidget,
    QStackedWidget,
    QLabel,
    QPushButton,
    QFrame,
    QListWidgetItem,
)
from PySide6.QtCore import Qt, Signal, QSize
from PySide6.QtGui import QFont, QIcon

from views.base_view import BaseView
from config.app_config import AppConfig
from controllers import ReportsController


class ReportsScreen(BaseView):
    """The main screen for accessing all reports."""

    back_to_main_menu = Signal()

    def __init__(self, current_user_id: str, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.current_user_id = current_user_id
        self.reports_controller = ReportsController()

        self.setWindowTitle("Reports and Billing")
        self.resize(1000, 700)
        self.setup_ui()

    def setup_ui(self):
        # Main Layout
        main_layout = QHBoxLayout(self.central_widget)
        main_layout.setSpacing(0)
        main_layout.setContentsMargins(0, 0, 0, 0)

        # Left Panel: Report List
        left_panel = QFrame()
        left_panel.setFixedWidth(250)
        left_panel.setObjectName("LeftPanel")
        left_panel.setStyleSheet(
            f"""
            #LeftPanel {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                border-right: 1px solid {AppConfig.DARK_BORDER};
            }}
        """
        )
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(10, 10, 10, 10)

        report_list_label = QLabel("Available Reports")
        report_list_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        )
        report_list_label.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-bottom: 10px;"
        )

        self.report_list_widget = QListWidget()
        self.report_list_widget.setStyleSheet(
            f"""
            QListWidget {{
                border: 1px solid {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
            }}
            QListWidget::item {{
                padding: 12px;
            }}
            QListWidget::item:selected {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
                border: none;
            }}
            """
        )
        self.populate_report_list()

        left_layout.addWidget(report_list_label)
        left_layout.addWidget(self.report_list_widget, 1)

        # Right Panel: Options and Preview
        right_panel = QFrame()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(20, 20, 20, 20)

        self.options_stack = QStackedWidget()
        right_layout.addWidget(self.options_stack, 1)

        # Placeholder widget for when no report is selected
        placeholder_widget = QLabel("Select a report from the list to see options.")
        placeholder_widget.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder_widget.setStyleSheet(f"color: {AppConfig.DARK_TEXT_SECONDARY};")
        self.options_stack.addWidget(placeholder_widget)

        # Action Buttons
        action_layout = QHBoxLayout()
        self.back_button = QPushButton("Back to Main Menu")
        self.back_button.clicked.connect(self.back_to_main_menu.emit)

        self.run_report_button = QPushButton("Run Report")
        self.run_report_button.setEnabled(False)  # Disabled until a report is selected

        action_layout.addWidget(self.back_button)
        action_layout.addStretch()
        action_layout.addWidget(self.run_report_button)
        right_layout.addLayout(action_layout)

        main_layout.addWidget(left_panel)
        main_layout.addWidget(right_panel, 1)

    def populate_report_list(self):
        """Adds the report names to the list widget."""
        # These are placeholders for now. We will build each one.
        reports = [
            "Owner Statement",
            "A/R Aging",
            "Invoice Register",
            "Payment History",
            "Charge Code Usage",
            "Horse Transaction History",
        ]
        for report_name in reports:
            item = QListWidgetItem(report_name)
            item.setFont(QFont(AppConfig.DEFAULT_FONT_FAMILY, 11))
            self.report_list_widget.addItem(item)


=============== FILE: controllers/user_controller.py ===============

# controllers/user_controller.py
"""
EDSI Veterinary Management System - User Controller
Version: 1.3.0
Purpose: Handles user authentication, CRUD operations.
         - Standardized get_all_users filter to use a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-05):
    - Modified `get_all_users` to accept a string `status_filter` ('active',
      'inactive', 'all') for consistency with other controllers.
- v1.2.8 (2025-06-05):
    - In `toggle_user_active_status`, added a check to prevent a user from
      deactivating their own account, moving this business rule from the
      view into the controller for better enforcement.
- v1.2.7 (2025-06-05):
    - Added `toggle_user_active_status` method to handle activating and
      deactivating users, including a safeguard to prevent deactivating the
      last active ADMIN account.
"""

import logging
from typing import List, Optional, Tuple, Dict, Any
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func, exc as sqlalchemy_exc
from datetime import datetime

from config.database_config import db_manager
from models.user_models import User, Role, UserRole


class UserController:
    """Controller for user management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def authenticate_user(
        self, login_id_attempt: str, password_attempt: str
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        try:
            self.logger.info(
                f"UserController.authenticate_user received login_id: '{login_id_attempt}', "
                f"password_attempt (first 3 chars): '{password_attempt[:3] if password_attempt else ''}...'"
            )
            session = db_manager().get_session()  # Corrected line
            try:
                user = (
                    session.query(User)
                    .filter(User.user_id.collate("NOCASE") == login_id_attempt)
                    .first()
                )
                if not user:
                    self.logger.warning(
                        f"Login ID '{login_id_attempt}' not found during authentication."
                    )
                    return False, "Invalid Login ID or Password.", None
                if not user.check_password(password_attempt):
                    self.logger.warning(
                        f"Incorrect password attempt for login ID '{user.user_id}' (input was '{login_id_attempt}')."
                    )
                    return False, "Invalid Login ID or Password.", None
                if not user.is_active:
                    self.logger.warning(
                        f"Login attempt for inactive user '{user.user_id}'."
                    )
                    return (
                        False,
                        f"User account '{user.user_id}' is inactive.",
                        {
                            "user_id": user.user_id,
                            "user_name": user.user_name,
                            "is_active": user.is_active,
                        },
                    )
                if hasattr(user, "last_login"):
                    user.last_login = datetime.utcnow()
                session.commit()
                self.logger.info(f"User '{user.user_id}' authenticated successfully.")
                return (
                    True,
                    "Login successful.",
                    {
                        "user_id": user.user_id,
                        "user_name": user.user_name,
                        "is_active": user.is_active,
                    },
                )
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                session.rollback()
                self.logger.error(
                    f"Database error during authentication for '{login_id_attempt}': {e_db}",
                    exc_info=True,
                )
                return False, "An error occurred during login. Please try again.", None
            finally:
                db_manager().close()  # Corrected line
        except Exception as e_outer:
            self.logger.error(
                f"Outer unexpected error during authentication for '{login_id_attempt}': {e_outer}",
                exc_info=True,
            )
            return False, "An unexpected server error occurred. Please try again.", None

    def get_all_users(self, status_filter: str = "all") -> List[User]:
        session = db_manager().get_session()  # Corrected line
        try:
            query = session.query(User).options(joinedload(User.roles))
            if status_filter == "active":
                query = query.filter(User.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(User.is_active == False)

            users = query.order_by(User.user_id).all()
            return users
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all users: {e}", exc_info=True)
            return []
        finally:
            db_manager().close()  # Corrected line

    def get_user_by_login_id(self, login_id_str: str) -> Optional[User]:
        session = db_manager().get_session()  # Corrected line
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            return user
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching user by login_id '{login_id_str}': {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def validate_user_data(
        self,
        user_data: Dict[str, Any],
        is_new: bool = True,
        original_login_id_to_ignore: Optional[str] = None,
    ) -> Tuple[bool, List[str]]:
        try:
            from views.admin.dialogs.add_edit_user_dialog import AddEditUserDialog

            available_roles_in_dialog = AddEditUserDialog.USER_ROLES
        except ImportError:
            self.logger.warning(
                "Could not import AddEditUserDialog for role validation. Role list might be incomplete."
            )
            available_roles_in_dialog = []
        errors = []
        login_id = user_data.get("user_id", "").strip()
        display_name = user_data.get("user_name", "").strip()
        password = user_data.get("password", "")
        email_value = user_data.get("email")
        email = email_value.strip() if isinstance(email_value, str) else None
        if not login_id:
            errors.append("Login ID (Username) is required.")
        elif len(login_id) > 20:
            errors.append("Login ID (Username) cannot exceed 20 characters.")
        elif " " in login_id:
            errors.append("Login ID (Username) cannot contain spaces.")
        else:
            session = db_manager().get_session()  # Corrected line
            try:
                query = session.query(User).filter(
                    User.user_id.collate("NOCASE") == login_id
                )
                if not is_new and original_login_id_to_ignore is not None:
                    query = query.filter(
                        User.user_id.collate("NOCASE") != original_login_id_to_ignore
                    )
                if query.first():
                    errors.append(f"Login ID (Username) '{login_id}' already exists.")
                if email:
                    email_query = session.query(User).filter(User.email == email)
                    user_to_exclude_from_email_check = None
                    if not is_new and original_login_id_to_ignore:
                        original_user = (
                            session.query(User)
                            .filter(
                                User.user_id.collate("NOCASE")
                                == original_login_id_to_ignore
                            )
                            .first()
                        )
                        if original_user:
                            user_to_exclude_from_email_check = original_user.user_id
                    if user_to_exclude_from_email_check:
                        email_query = email_query.filter(
                            User.user_id != user_to_exclude_from_email_check
                        )
                    if email_query.first():
                        errors.append(f"Email '{email}' is already in use.")
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                self.logger.error(
                    f"DB error validating login_id/email uniqueness: {e_db}",
                    exc_info=True,
                )
                errors.append("Error validating login_id/email uniqueness.")
            finally:
                db_manager().close()  # Corrected line
        if not display_name:
            errors.append("Full Name (User Name) is required.")
        elif len(display_name) > 100:
            errors.append("Full Name (User Name) cannot exceed 100 characters.")
        if is_new:
            if not password:
                errors.append("Password is required for new users.")
            elif len(password) < 6:
                errors.append("Password must be at least 6 characters long.")
        elif password and len(password) < 6:
            errors.append("New password must be at least 6 characters long.")
        if email and (
            len(email) > 100 or ("@" not in email or "." not in email.split("@")[-1])
        ):
            errors.append(
                "Invalid email format or email too long (max 100 characters)."
            )
        role_str = user_data.get("role")
        if not role_str and is_new:
            errors.append("Role is required for new users.")
        if role_str:
            session = db_manager().get_session()  # Corrected line
            try:
                if not session.query(Role).filter(Role.name == role_str).first():
                    errors.append(f"Role '{role_str}' does not exist in the database.")
            finally:
                db_manager().close()  # Corrected line
        return not errors, errors

    def create_user(
        self, user_data: Dict[str, Any], current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[User]]:
        login_id_to_store = user_data.get("user_id", "").strip()
        if not login_id_to_store:
            return False, "Login ID (Username) cannot be empty.", None
        if login_id_to_store.upper() == "ADMIN":
            login_id_to_store = "ADMIN"
        data_for_model = {
            "user_id": login_id_to_store,
            "user_name": user_data.get("user_name", "").strip(),
            "email": user_data.get("email"),
            "is_active": user_data.get("is_active", True),
            "created_by": current_admin_id,
            "modified_by": current_admin_id,
            "printer_id": user_data.get("printer_id"),
            "default_screen_colors": user_data.get("default_screen_colors"),
        }
        password_to_set = user_data.get("password", "")
        role_name_to_assign = user_data.get("role")
        validation_payload = {
            **data_for_model,
            "password": password_to_set,
            "role": role_name_to_assign,
        }
        is_valid, errors = self.validate_user_data(validation_payload, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None
        session = db_manager().get_session()  # Corrected line
        try:
            processed_email = data_for_model["email"]
            if isinstance(processed_email, str):
                processed_email = processed_email.strip()
                if not processed_email:
                    processed_email = None
            data_for_model["email"] = processed_email
            new_user = User(**data_for_model)
            new_user.set_password(password_to_set)
            if role_name_to_assign:
                role_obj = (
                    session.query(Role).filter(Role.name == role_name_to_assign).first()
                )
                if role_obj:
                    new_user.roles.append(role_obj)
                else:
                    self.logger.error(
                        f"Role '{role_name_to_assign}' for new user '{new_user.user_id}' not found in DB during create. Validation might have missed this."
                    )
            session.add(new_user)
            session.commit()
            session.refresh(new_user)
            self.logger.info(
                f"User '{new_user.user_id}' created successfully by {current_admin_id}."
            )
            return True, "User created successfully.", new_user
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e.orig}",
                exc_info=True,
            )
            error_str = str(e.orig).lower()
            if "unique constraint failed: users.user_id" in error_str:
                return (
                    False,
                    f"Login ID (Username) '{data_for_model['user_id']}' already exists.",
                    None,
                )
            elif (
                "unique constraint failed: users.email" in error_str
                and data_for_model["email"]
            ):
                return (
                    False,
                    f"Email '{data_for_model['email']}' is already in use.",
                    None,
                )
            return False, f"Database integrity error: {e.orig}", None
        except AttributeError as ae:
            session.rollback()
            self.logger.error(
                f"AttributeError during user creation for '{data_for_model.get('user_id')}': {ae}",
                exc_info=True,
            )
            return False, f"Failed to set user attribute during creation: {ae}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e}",
                exc_info=True,
            )
            return False, f"Failed to create user: {e}", None
        finally:
            db_manager().close()  # Corrected line

    def update_user(
        self,
        user_id_to_update: str,
        user_data: Dict[str, Any],
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == user_id_to_update)
                .first()
            )
            if not user:
                return False, f"User with Login ID '{user_id_to_update}' not found."
            validation_data = {
                "user_id": user.user_id,
                "user_name": user_data.get("user_name", user.user_name),
                "email": user_data.get("email", user.email),
                "role": user_data.get("role"),
            }
            if "password" in user_data and user_data["password"]:
                validation_data["password"] = user_data["password"]
            is_valid, errors = self.validate_user_data(
                validation_data, is_new=False, original_login_id_to_ignore=user.user_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)
            roles_modified = False
            if "user_name" in user_data:
                user.user_name = user_data["user_name"].strip()
            if "email" in user_data:
                email_val = user_data["email"]
                user.email = email_val.strip() if isinstance(email_val, str) else None
                if user.email == "":
                    user.email = None
            if "password" in user_data and user_data["password"]:
                user.set_password(user_data["password"])
            if "is_active" in user_data:
                if user.user_id.upper() == "ADMIN" and not user_data["is_active"]:
                    active_admin_query = session.query(User).filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    if user.is_active:
                        if active_admin_query.count() <= 1:
                            self.logger.warning(
                                f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') was prevented."
                            )
                            return (
                                False,
                                "Cannot deactivate the last active ADMIN user.",
                            )
                    user.is_active = user_data["is_active"]
                else:
                    user.is_active = user_data["is_active"]
            new_role_name_from_data = user_data.get("role")
            if new_role_name_from_data is not None:
                current_role_names = {r.name for r in user.roles}
                if not (
                    len(current_role_names) == 1
                    and new_role_name_from_data in current_role_names
                ):
                    roles_modified = True
                    user.roles.clear()
                    if new_role_name_from_data:
                        role_obj = (
                            session.query(Role)
                            .filter(Role.name == new_role_name_from_data)
                            .first()
                        )
                        if role_obj:
                            user.roles.append(role_obj)
                        else:
                            self.logger.error(
                                f"Role object for '{new_role_name_from_data}' not found during update. User '{user.user_id}' will have no roles."
                            )
            if "printer_id" in user_data:
                user.printer_id = user_data["printer_id"]
            if "default_screen_colors" in user_data:
                user.default_screen_colors = user_data["default_screen_colors"]
            user.modified_by = current_admin_id
            if roles_modified:
                session.add(user)
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' updated successfully by {current_admin_id}."
            )
            return True, "User updated successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e.orig}", exc_info=True
            )
            if "unique constraint failed: users.email" in str(
                e.orig
            ).lower() and validation_data.get("email"):
                return (
                    False,
                    f"Email '{validation_data['email']}' is already in use by another user.",
                )
            return False, f"Database integrity error: {e.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e}", exc_info=True
            )
            return False, f"Failed to update user: {str(e)}"
        finally:
            db_manager().close()  # Corrected line

    def change_password(
        self,
        login_id_str: str,
        new_password: str,
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        if not new_password or len(new_password) < 6:
            return False, "New password must be at least 6 characters long."
        session = db_manager().get_session()  # Corrected line
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if not user:
                return False, f"User '{login_id_str}' not found."
            user.set_password(new_password)
            user.modified_by = current_admin_id
            session.commit()
            self.logger.info(
                f"Password changed successfully for user '{user.user_id}' by {current_admin_id}."
            )
            return True, "Password changed successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error changing password for user '{login_id_str}': {e}", exc_info=True
            )
            return False, f"Failed to change password: {str(e)}"
        finally:
            db_manager().close()  # Corrected line

    def get_user_roles(self, login_id_str: str) -> List[str]:
        session = db_manager().get_session()  # Corrected line
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if user and user.roles:
                return [role.name for role in user.roles]
            return []
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching roles for user '{login_id_str}': {e}", exc_info=True
            )
            return []
        finally:
            db_manager().close()  # Corrected line

    def delete_user_permanently(
        self, user_id_to_delete: str, current_admin_id: str
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_id_to_delete)
                .first()
            )
            if not user:
                return False, f"User '{user_id_to_delete}' not found."
            if user.user_id.upper() == "ADMIN":
                active_admin_count = (
                    session.query(User)
                    .filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    .count()
                )
                if active_admin_count <= 1 and user.is_active:
                    self.logger.warning(
                        f"Attempt to delete the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                    )
                    return (
                        False,
                        "Cannot delete the primary ADMIN account if it's the last active one.",
                    )
            session.delete(user)
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"User '{user.user_id}' deleted successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Database integrity error deleting user '{user_id_to_delete}': {e.orig}",
                exc_info=True,
            )
            return (
                False,
                f"Cannot delete user. They may be referenced by other records. ({e.orig})",
            )
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error deleting user '{user_id_to_delete}': {e}", exc_info=True
            )
            return False, f"Failed to delete user: {str(e)}"
        finally:
            db_manager().close()  # Corrected line

    def toggle_user_active_status(
        self, user_login_id: str, current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager().get_session()  # Corrected line
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_login_id)
                .first()
            )
            if not user:
                return False, f"User '{user_login_id}' not found."

            is_deactivating = user.is_active
            if is_deactivating:
                # Rule 1: Cannot deactivate yourself
                if user.user_id == current_admin_id:
                    self.logger.warning(
                        f"User '{current_admin_id}' attempted to deactivate their own account. Operation prevented."
                    )
                    return False, "You cannot deactivate your own account."

                # Rule 2: Cannot deactivate the last active admin
                if user.has_role("ADMIN"):
                    active_admin_count = (
                        session.query(User)
                        .join(User.roles)
                        .filter(Role.name == "ADMIN", User.is_active == True)
                        .count()
                    )
                    if active_admin_count <= 1:
                        self.logger.warning(
                            f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                        )
                        return False, "Cannot deactivate the last active ADMIN user."

            # Toggle the status
            new_status = not user.is_active
            user.is_active = new_status
            user.modified_by = current_admin_id

            session.commit()

            status_str = "activated" if new_status else "deactivated"
            self.logger.info(
                f"User '{user.user_id}' has been {status_str} by {current_admin_id}."
            )
            return True, f"User '{user.user_id}' has been successfully {status_str}."

        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error toggling status for user '{user_login_id}': {e}",
                exc_info=True,
            )
            return False, "A database error occurred."
        finally:
            db_manager().close()  # Corrected line

    def get_all_roles(self) -> List[Role]:
        session = db_manager().get_session()  # Corrected line
        try:
            roles = session.query(Role).order_by(Role.name).all()
            self.logger.info(f"Retrieved {len(roles)} roles.")
            return roles
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error retrieving roles: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            db_manager().close()  # Corrected line


=============== FILE: controllers/veterinarian_controller.py ===============

# controllers/veterinarian_controller.py
"""
EDSI Veterinary Management System - Veterinarian Controller
Version: 1.1.0
Purpose: Handles business logic for veterinarian records.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-09):
    - Replaced placeholder with a full implementation providing CRUD operations.
- v1.0.0 (2025-06-09):
    - Initial placeholder file created.
"""

import logging
import re
from typing import List, Optional, Tuple, Dict, Any

from sqlalchemy.orm import Session
from sqlalchemy import exc as sqlalchemy_exc

from config.database_config import db_manager
from models import Veterinarian


class VeterinarianController:
    """Controller for veterinarian management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_veterinarians(self, status_filter: str = "all") -> List[Veterinarian]:
        session = db_manager().get_session()  # Corrected line
        try:
            query = session.query(Veterinarian)
            if status_filter == "active":
                query = query.filter(Veterinarian.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Veterinarian.is_active == False)

            vets = query.order_by(Veterinarian.last_name, Veterinarian.first_name).all()
            return vets
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all veterinarians: {e}", exc_info=True)
            return []
        finally:
            db_manager().close()  # Corrected line

    def get_veterinarian_by_id(self, vet_id: int) -> Optional[Veterinarian]:
        session = db_manager().get_session()  # Corrected line
        try:
            return (
                session.query(Veterinarian)
                .filter(Veterinarian.vet_id == vet_id)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching veterinarian by ID {vet_id}: {e}", exc_info=True
            )
            return None
        finally:
            db_manager().close()  # Corrected line

    def validate_veterinarian_data(
        self,
        vet_data: Dict[str, Any],
        is_new: bool,
        vet_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        """Validates veterinarian data for creation or update."""
        errors = []
        required_fields = ["first_name", "last_name", "license_number"]
        for field in required_fields:
            if not vet_data.get(field) or not str(vet_data[field]).strip():
                errors.append(f"{field.replace('_', ' ').title()} is required.")

        license_number = vet_data.get("license_number", "").strip()
        email = vet_data.get("email", "").strip()

        session = db_manager().get_session()  # Corrected line
        try:
            # Check license number uniqueness
            if license_number:
                query = session.query(Veterinarian).filter(
                    Veterinarian.license_number == license_number
                )
                if not is_new and vet_id_to_ignore is not None:
                    query = query.filter(Veterinarian.vet_id != vet_id_to_ignore)
                if query.first():
                    errors.append(
                        f"License Number '{license_number}' is already in use."
                    )

            # Check email format and uniqueness
            if email:
                if not re.match(
                    r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email
                ):
                    errors.append("Invalid email format.")
                else:
                    query = session.query(Veterinarian).filter(
                        Veterinarian.email == email
                    )
                    if not is_new and vet_id_to_ignore is not None:
                        query = query.filter(Veterinarian.vet_id != vet_id_to_ignore)
                    if query.first():
                        errors.append(f"Email '{email}' is already in use.")
        finally:
            db_manager().close()  # Corrected line

        return not errors, errors

    def create_veterinarian(
        self, vet_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str, Optional[Veterinarian]]:
        """Creates a new veterinarian record."""
        is_valid, errors = self.validate_veterinarian_data(vet_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager().get_session()  # Corrected line
        try:
            new_vet = Veterinarian(
                first_name=vet_data["first_name"],
                last_name=vet_data["last_name"],
                license_number=vet_data["license_number"],
                specialty=vet_data.get("specialty"),
                phone=vet_data.get("phone"),
                email=vet_data.get("email"),
                is_active=vet_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_vet)
            session.commit()
            session.refresh(new_vet)
            self.logger.info(
                f"Veterinarian '{new_vet.first_name} {new_vet.last_name}' created by {current_user_id}."
            )
            return True, "Veterinarian created successfully.", new_vet
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(f"Error creating veterinarian: {e.orig}", exc_info=True)
            return False, f"Database integrity error: {e.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating veterinarian: {e}", exc_info=True)
            return False, f"Failed to create veterinarian: {e}", None
        finally:
            db_manager().close()  # Corrected line

    def update_veterinarian(
        self, vet_id: int, vet_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        """Updates an existing veterinarian record."""
        is_valid, errors = self.validate_veterinarian_data(
            vet_data, is_new=False, vet_id_to_ignore=vet_id
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors)

        session = db_manager().get_session()  # Corrected line
        try:
            vet = (
                session.query(Veterinarian)
                .filter(Veterinarian.vet_id == vet_id)
                .first()
            )
            if not vet:
                return False, "Veterinarian not found."

            for key, value in vet_data.items():
                if hasattr(vet, key):
                    setattr(vet, key, value)

            vet.modified_by = current_user_id
            session.commit()
            self.logger.info(f"Veterinarian ID {vet_id} updated by {current_user_id}.")
            return True, "Veterinarian updated successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating veterinarian ID {vet_id}: {e}", exc_info=True
            )
            return False, f"Failed to update veterinarian: {e}"
        finally:
            db_manager().close()  # Corrected line

    def toggle_veterinarian_status(
        self, vet_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        """Toggles the active status of a veterinarian."""
        session = db_manager().get_session()  # Corrected line
        try:
            vet = (
                session.query(Veterinarian)
                .filter(Veterinarian.vet_id == vet_id)
                .first()
            )
            if not vet:
                return False, "Veterinarian not found."

            vet.is_active = not vet.is_active
            vet.modified_by = current_user_id
            new_status = "activated" if vet.is_active else "deactivated"
            session.commit()
            self.logger.info(
                f"Veterinarian '{vet.first_name} {vet.last_name}' status changed to {new_status} by {current_user_id}."
            )
            return True, f"Veterinarian has been {new_status}."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error toggling status for vet ID {vet_id}: {e}", exc_info=True
            )
            return False, f"Failed to toggle status: {e}"
        finally:
            db_manager().close()  # Corrected line


=============== FILE: models/__init__.py ===============

# models/__init__.py
"""
EDSI Veterinary Management System - Models Package
"""

from .base_model import Base, BaseModel
from .user_models import User, Role, UserRole
from .horse_models import Horse, HorseOwner, HorseLocation
from .owner_models import Owner, OwnerBillingHistory, OwnerPayment
from .reference_models import (
    StateProvince,
    ChargeCodeCategory,
    ChargeCode,
    Veterinarian,
    Location,
    Procedure,
    Drug,
    TreatmentLog,
    CommunicationLog,
    Document,
    Reminder,
    Appointment,
)
from .financial_models import Transaction, Invoice
from .company_profile_model import CompanyProfile  # ADDED

__all__ = [
    "Base",
    "BaseModel",
    "User",
    "Role",
    "UserRole",
    "Horse",
    "HorseOwner",
    "HorseLocation",
    "Owner",
    "OwnerBillingHistory",
    "OwnerPayment",
    "StateProvince",
    "ChargeCodeCategory",
    "ChargeCode",
    "Veterinarian",
    "Location",
    "Procedure",
    "Drug",
    "TreatmentLog",
    "CommunicationLog",
    "Document",
    "Reminder",
    "Appointment",
    "Transaction",
    "Invoice",
    "CompanyProfile",  # ADDED
]


=============== FILE: models/base_model.py ===============

# models/base_model.py

"""
EDSI Veterinary Management System - Base Model Definition
Version: 2.0.0
Purpose: Simplified base model with essential audit fields and clean declarative base.
         Removed over-complexity and focused on stable foundation.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Removed circular import issues by importing Base from database_config
    - Simplified BaseModel with essential audit fields only
    - Clean datetime handling without over-engineering
    - Removed unnecessary complexity in __repr__ method
    - Clear separation between Base and BaseModel
    - Focused on stable, working foundation
    - Consistent audit field naming and types
"""

from datetime import datetime
from sqlalchemy import Column, DateTime, String
from config.database_config import Base


class BaseModel(Base):
    """
    Abstract base model providing common audit fields for all database tables.

    Provides:
    - created_date: When the record was created
    - modified_date: When the record was last modified
    - created_by: User ID who created the record
    - modified_by: User ID who last modified the record
    """

    __abstract__ = True  # This class should not be mapped to a database table

    # Audit fields
    created_date = Column(
        DateTime,
        default=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was created",
    )

    modified_date = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was last modified",
    )

    created_by = Column(
        String(50), nullable=True, doc="User ID who created this record"
    )

    modified_by = Column(
        String(50), nullable=True, doc="User ID who last modified this record"
    )

    def __repr__(self):
        """
        Simple string representation of the model instance.
        Uses the first primary key column for identification.
        """
        try:
            # Get the primary key column name and value
            primary_key = self.__mapper__.primary_key[0]
            pk_name = primary_key.name
            pk_value = getattr(self, pk_name, "Unknown")

            return f"<{self.__class__.__name__}({pk_name}={pk_value})>"

        except (IndexError, AttributeError):
            # Fallback if primary key detection fails
            return f"<{self.__class__.__name__}(id=Unknown)>"

    def update_modified_by(self, user_id: str) -> None:
        """
        Update the modified_by field with the given user_id.

        Args:
            user_id: The ID of the user making the modification
        """
        self.modified_by = user_id
        # Note: modified_date will be automatically updated by SQLAlchemy onupdate

    def set_created_by(self, user_id: str) -> None:
        """
        Set the created_by field with the given user_id.
        This should only be called when creating new records.

        Args:
            user_id: The ID of the user creating the record
        """
        self.created_by = user_id
        if not self.modified_by:
            self.modified_by = user_id


=============== FILE: models/company_profile_model.py ===============

# models/company_profile_model.py
"""
EDSI Veterinary Management System - Company Profile Model
Version: 1.0.0
Purpose: Defines the data model for storing the clinic's own profile information.
Last Updated: June 8, 2025
Author: Gemini
"""

from sqlalchemy import Column, Integer, String, Text
from .base_model import BaseModel


class CompanyProfile(BaseModel):
    """
    Represents the company's profile information.
    This table is expected to contain only a single row (id=1).
    """

    __tablename__ = "company_profile"

    id = Column(Integer, primary_key=True)
    company_name = Column(String(255), nullable=False)
    address_line1 = Column(String(255), nullable=True)
    address_line2 = Column(String(255), nullable=True)
    city = Column(String(100), nullable=True)
    state = Column(String(100), nullable=True)
    zip_code = Column(String(20), nullable=True)
    phone = Column(String(50), nullable=True)
    email = Column(String(255), nullable=True)
    website = Column(String(255), nullable=True)
    logo_path = Column(String(512), nullable=True)
    notes = Column(Text, nullable=True)

    def __repr__(self):
        return f"<CompanyProfile(id={self.id}, name='{self.company_name}')>"


=============== FILE: models/financial_models.py ===============

# models/financial_models.py
"""
EDSI Veterinary Management System - Financial Data Models
Version: 1.3.0
Purpose: Defines SQLAlchemy models for financial records like Transactions and Invoices.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-09):
    - Set `autoincrement=True` on the Invoice.invoice_id primary key to ensure
      the database engine never reuses an invoice number after it has been deleted.
- v1.2.0 (2025-06-09):
    - Added a `status` column to the `Transaction` model to explicitly track
      whether a charge is active or has been processed into an invoice.
- v1.1.0 (2025-06-05):
    - Added `taxable` (Boolean) and `item_notes` (Text) columns to the `Transaction` model.
    - Added `tax_total` (Numeric) column to the `Invoice` model.
"""

from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Text,
    ForeignKey,
    Date,
    Numeric,
    DateTime,
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import date

from .base_model import BaseModel


class Transaction(BaseModel):
    """
    Represents a single billable line item for a horse.
    This is the core of all financial activity.
    """

    __tablename__ = "transactions"

    transaction_id = Column(Integer, primary_key=True, index=True)
    horse_id = Column(
        Integer, ForeignKey("horses.horse_id"), nullable=False, index=True
    )
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    invoice_id = Column(
        Integer, ForeignKey("invoices.invoice_id"), nullable=True, index=True
    )

    charge_code_id = Column(
        Integer, ForeignKey("charge_codes.id"), nullable=False, index=True
    )

    administered_by_user_id = Column(
        String(20), ForeignKey("users.user_id"), nullable=True
    )

    transaction_date = Column(Date, nullable=False, default=date.today)
    description = Column(String(255), nullable=False)
    quantity = Column(Numeric(10, 2), nullable=False, default=1)
    unit_price = Column(Numeric(10, 2), nullable=False)
    total_price = Column(Numeric(10, 2), nullable=False)
    taxable = Column(Boolean, default=False, nullable=False)
    item_notes = Column(Text, nullable=True)

    status = Column(String(50), nullable=False, default="ACTIVE", index=True)

    # Relationships
    horse = relationship("Horse")
    owner = relationship("Owner")
    invoice = relationship("Invoice", back_populates="transactions")
    charge_code = relationship("ChargeCode")
    administered_by = relationship("User")

    def __repr__(self):
        return f"<Transaction(id={self.transaction_id}, horse_id={self.horse_id}, total={self.total_price})>"


class Invoice(BaseModel):
    """
    Represents a bill sent to an owner, grouping multiple transactions.
    """

    __tablename__ = "invoices"

    invoice_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )

    invoice_date = Column(Date, nullable=False, default=date.today)
    due_date = Column(Date, nullable=True)

    subtotal = Column(Numeric(10, 2), nullable=False, default=0.00)
    tax_total = Column(Numeric(10, 2), nullable=True)
    grand_total = Column(Numeric(10, 2), nullable=False, default=0.00)
    amount_paid = Column(Numeric(10, 2), nullable=False, default=0.00)
    balance_due = Column(Numeric(10, 2), nullable=False, default=0.00)

    status = Column(String(50), nullable=False, default="Unpaid", index=True)

    # Relationships
    owner = relationship("Owner", backref="invoices")
    transactions = relationship(
        "Transaction", back_populates="invoice", cascade="all, delete-orphan"
    )

    def __repr__(self):
        return f"<Invoice(id={self.invoice_id}, owner_id={self.owner_id}, total={self.grand_total}, status='{self.status}')>"


=============== FILE: models/horse_models.py ===============

# models/horse_models.py
"""
EDSI Veterinary Management System - Horse Related SQLAlchemy Models
Version: 1.3.0
Purpose: Defines the data models for horses, owners, and their relationships.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-10):
    - Added missing columns to the Horse model: `reg_number`, `brand`, `band_tag`.
      This resolves warnings during horse creation and ensures all form data is saved.
- v1.2.17 (2025-05-25):
    - Reverted `back_populates` on HorseLocation.location relationship
      to "current_horses" to match expected relationship name on Location model.
- v1.2.16 (2025-05-25):
    - HorseLocation model: Added `is_current_location` (Boolean) column.
- v1.2.15 (2025-05-23):
    - Horse model: Removed `species_id` column and `species` relationship.
"""
from sqlalchemy import Column, Integer, String, Date, Boolean, ForeignKey, Numeric, Text
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property
from datetime import date

from .base_model import Base, BaseModel


class HorseOwner(Base):
    __tablename__ = "horse_owners"
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), primary_key=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), primary_key=True)
    percentage_ownership = Column(Numeric(5, 2), nullable=True)

    horse = relationship("Horse", back_populates="owner_associations")
    owner = relationship("Owner", back_populates="horse_associations")


class HorseLocation(BaseModel):
    __tablename__ = "horse_locations"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=False)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=False)
    date_arrived = Column(Date, nullable=False, default=date.today)
    date_departed = Column(Date, nullable=True)
    notes = Column(Text, nullable=True)
    is_current_location = Column(Boolean, default=False, nullable=False, index=True)

    horse = relationship("Horse", back_populates="location_history")
    location = relationship("Location", back_populates="current_horses")


class Horse(BaseModel):
    __tablename__ = "horses"

    horse_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    horse_name = Column(String(255), nullable=False, index=True)
    account_number = Column(String(50), index=True, nullable=True)
    breed = Column(String(100), nullable=True)
    color = Column(String(50), nullable=True)
    sex = Column(String(20), nullable=True)
    date_of_birth = Column(Date, nullable=True)
    height_hands = Column(Numeric(4, 2), nullable=True)

    chip_number = Column(String(50), nullable=True, unique=True)
    tattoo_number = Column(String(50), nullable=True, unique=True)

    # ADDED Missing columns
    reg_number = Column(String(50), nullable=True)
    brand = Column(String(50), nullable=True)
    band_tag = Column(String(50), nullable=True)

    description = Column(Text, nullable=True)

    is_active = Column(Boolean, default=True, nullable=False)
    date_deceased = Column(Date, nullable=True)
    coggins_date = Column(Date, nullable=True)

    current_location_id = Column(
        Integer, ForeignKey("locations.location_id"), nullable=True
    )

    owner_associations = relationship(
        "HorseOwner", back_populates="horse", cascade="all, delete-orphan"
    )
    owners = relationship(
        "Owner",
        secondary="horse_owners",
        back_populates="horses",
        viewonly=True,
        lazy="selectin",
    )

    location_history = relationship(
        "HorseLocation",
        back_populates="horse",
        order_by="desc(HorseLocation.date_arrived)",
        cascade="all, delete-orphan",
        lazy="selectin",
    )
    location = relationship(
        "Location", foreign_keys=[current_location_id], lazy="joined"
    )

    @hybrid_property
    def age(self):
        if self.date_of_birth:
            today = date.today()
            return (
                today.year
                - self.date_of_birth.year
                - (
                    (today.month, today.day)
                    < (self.date_of_birth.month, self.date_of_birth.day)
                )
            )
        return None

    @validates("chip_number", "tattoo_number")
    def convert_empty_to_none(self, key, value):
        if isinstance(value, str) and not value.strip():
            return None
        return value


=============== FILE: models/owner_models.py ===============

# models/owner_models.py
"""
EDSI Veterinary Management System - Owner Related Models
Version: 1.1.7
Purpose: Defines SQLAlchemy models for Owner and related entities.
         - Removed the placeholder Invoice model to avoid conflict with the
           definitive Invoice model in financial_models.py.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.7 (2025-06-04):
    - Removed the placeholder `Invoice` class definition. The definitive `Invoice`
      model is now in `models/financial_models.py`.
      The backref from Owner to the new Invoice model is handled in financial_models.py.
- v1.1.6 (2025-05-23):
    - Ensured the `Invoice` class is correctly defined.
    - Imported `sqlalchemy.sql.func` for `func.current_date()` default in `Invoice.invoice_date`.
# ... (rest of previous changelog)
"""

from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Numeric,
    Text,
    ForeignKey,
    Date,
    DateTime,
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import datetime

from .base_model import BaseModel


class Owner(BaseModel):
    """Model for horse owners (master list)."""

    __tablename__ = "owners"

    # Changed owner_id to id for potential consistency, but will keep owner_id if it's deeply embedded.
    # For now, keeping owner_id as per existing structure.
    # If financial_models.Transaction.owner_id refers to 'owners.id', then this needs to be 'id'.
    # Checking financial_models.py: owner_id = Column(Integer, ForeignKey("owners.owner_id") ...
    # So, owner_id is correct here.
    owner_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    account_number = Column(String(20), unique=True, nullable=True, index=True)
    farm_name = Column(String(100), nullable=True, index=True)
    first_name = Column(String(50), nullable=True)
    last_name = Column(String(50), nullable=True, index=True)

    address_line1 = Column(String(100))
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50))

    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), index=True
    )

    zip_code = Column(String(20))

    phone = Column(String(20), nullable=True)
    mobile_phone = Column(String(20), nullable=True)
    email = Column(String(100), nullable=True, index=True)

    is_active = Column(Boolean, default=True, nullable=False)

    balance = Column(Numeric(10, 2), default=0.00)
    credit_limit = Column(Numeric(10, 2), nullable=True)
    billing_terms = Column(String(50), nullable=True)
    service_charge_rate = Column(Numeric(5, 2), nullable=True)
    discount_rate = Column(Numeric(5, 2), nullable=True)

    notes = Column(Text, nullable=True)

    state = relationship("StateProvince", foreign_keys=[state_code], backref="owners")

    horse_associations = relationship(
        "HorseOwner", back_populates="owner", cascade="all, delete-orphan"
    )

    horses = relationship(
        "Horse", secondary="horse_owners", back_populates="owners", viewonly=True
    )

    billing_history = relationship(
        "OwnerBillingHistory", back_populates="owner", cascade="all, delete-orphan"
    )
    payments_made = relationship(
        "OwnerPayment", back_populates="owner", cascade="all, delete-orphan"
    )

    # The 'invoices' backref is now defined in financial_models.Invoice linking to this Owner model.
    # No need for: # invoices = relationship("Invoice", back_populates="owner")

    def __repr__(self):
        display_name = (
            self.farm_name
            or f"{self.first_name or ''} {self.last_name or ''}".strip()
            or f"ID:{self.owner_id}"
        )
        return f"<Owner(owner_id={self.owner_id}, name='{display_name}')>"


class OwnerBillingHistory(BaseModel):
    """Billing history entries for an owner."""

    __tablename__ = "owner_billing_history"

    history_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    entry_date = Column(DateTime, default=datetime.utcnow)
    description = Column(String(255), nullable=False)
    amount_change = Column(Numeric(10, 2), nullable=False)  # Made non-nullable
    new_balance = Column(Numeric(10, 2), nullable=False)  # Made non-nullable

    owner = relationship("Owner", back_populates="billing_history")

    def __repr__(self):
        return f"<OwnerBillingHistory(owner_id={self.owner_id}, date='{self.entry_date}', desc='{self.description}')>"


class OwnerPayment(BaseModel):
    """Payments made by an owner."""

    __tablename__ = "owner_payments"

    payment_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    payment_date = Column(Date, nullable=False, default=func.current_date)
    amount = Column(Numeric(10, 2), nullable=False)
    payment_method = Column(String(50), nullable=False)  # Made non-nullable
    reference_number = Column(String(100), nullable=True)
    notes = Column(Text, nullable=True)  # Nullable is fine for notes

    owner = relationship(
        "Owner", foreign_keys=[owner_id], back_populates="payments_made"
    )

    def __repr__(self):
        return f"<OwnerPayment(owner_id={self.owner_id}, date='{self.payment_date}', amount={self.amount})>"


# class Invoice(BaseModel): # REMOVED - Definitive model is in financial_models.py
#    pass


=============== FILE: models/reference_models.py ===============

# models/reference_models.py
"""
EDSI Veterinary Management System - Reference Data Models
Version: 1.1.23
Purpose: Defines SQLAlchemy models for various reference data entities.
         - Removed placeholder Transaction and TransactionDetail models
           to avoid conflict with definitive models in financial_models.py.
Last Updated: June 10, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.23 (2025-06-10):
    - Set `lazy="joined"` on the `ChargeCodeCategory.parent` relationship to
      prevent `DetachedInstanceError` when accessing the parent of a category
      that is no longer in a session.
- v1.1.22 (2025-06-04):
    - Removed placeholder `Transaction` and `TransactionDetail` class definitions
      as these are now fully defined in `models/financial_models.py`.
- v1.1.21 (2025-06-03):
    - In `Location` model: Uncommented the `current_horses` relationship to
      `HorseLocation` and ensured `back_populates="location"` is correct.
      This fixes the `InvalidRequestError: Mapper 'Mapper[Location(locations)]'
      has no property 'current_horses'` during mapper configuration.
# ... (rest of previous changelog)
"""
from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Text,
    ForeignKey,
    Date,
    Numeric,
    DateTime,
    Table,
)
from sqlalchemy.orm import (
    relationship,
    backref,
)
from sqlalchemy.sql import func

from .base_model import (
    Base,
    BaseModel,
)


class StateProvince(BaseModel, Base):
    __tablename__ = "state_provinces"
    state_province_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )
    state_code = Column(String(10), nullable=False, unique=True, index=True)
    state_name = Column(String(50), nullable=False)
    country_code = Column(String(10), nullable=False, default="USA")
    is_active = Column(Boolean, default=True, nullable=False)

    def __repr__(self):
        return (
            f"<StateProvince(state_code='{self.state_code}', name='{self.state_name}')>"
        )


class ChargeCodeCategory(BaseModel, Base):
    __tablename__ = "charge_code_categories"

    category_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique category identifier",
    )
    name = Column(
        String(100),
        nullable=False,
        index=True,
        doc="Name of the category level (e.g., 'Anthelmintics', 'Administered')",
    )
    parent_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
        doc="ID of the parent category, if any",
    )
    level = Column(
        Integer,
        nullable=False,
        index=True,
        doc="Hierarchy level (e.g., 1 for main Category, 2 for Process)",
    )
    is_active = Column(Boolean, default=True, nullable=False, index=True)

    # MODIFIED: Added lazy="joined" to prevent DetachedInstanceError
    parent = relationship(
        "ChargeCodeCategory",
        remote_side=[category_id],
        backref=backref("children"),
        lazy="joined",
    )

    charge_codes = relationship("ChargeCode", back_populates="category")

    def __repr__(self):
        return f"<ChargeCodeCategory(id={self.category_id}, name='{self.name}', level={self.level}, parent_id={self.parent_id})>"


class ChargeCode(BaseModel, Base):
    __tablename__ = "charge_codes"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    code = Column(String(20), nullable=False, unique=True, index=True)
    alternate_code = Column(String(50), nullable=True, index=True)
    description = Column(String(255), nullable=False)

    category_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
    )

    standard_charge = Column(Numeric(10, 2), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    taxable = Column(Boolean, default=False)

    category = relationship("ChargeCodeCategory", back_populates="charge_codes")

    def __repr__(self):
        return f"<ChargeCode(code='{self.code}', description='{self.description}')>"


class Veterinarian(BaseModel, Base):
    __tablename__ = "veterinarians"
    vet_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    first_name = Column(String(50), nullable=False)
    last_name = Column(String(50), nullable=False, index=True)
    license_number = Column(String(50), unique=True)
    specialty = Column(String(100))
    phone = Column(String(20))
    email = Column(String(100), unique=True)
    is_active = Column(Boolean, default=True)

    def __repr__(self):
        return f"<Veterinarian(vet_id={self.vet_id}, name='{self.first_name} {self.last_name}')>"


class Location(BaseModel, Base):
    __tablename__ = "locations"
    location_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    location_name = Column(String(100), nullable=False, unique=True, index=True)
    address_line1 = Column(String(100), nullable=True)
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50), nullable=True)
    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), nullable=True, index=True
    )
    zip_code = Column(String(20), nullable=True)
    country_code = Column(String(10), default="USA", nullable=True)
    phone = Column(String(20), nullable=True)
    contact_person = Column(String(100), nullable=True)
    email = Column(String(100), nullable=True, index=True)
    is_active = Column(Boolean, default=True, nullable=False)

    state = relationship("StateProvince")
    current_horses = relationship("HorseLocation", back_populates="location")

    def __repr__(self):
        return (
            f"<Location(location_id={self.location_id}, name='{self.location_name}')>"
        )


class Procedure(BaseModel, Base):
    __tablename__ = "procedures"
    procedure_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class Drug(BaseModel, Base):
    __tablename__ = "drugs"
    drug_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class TreatmentLog(BaseModel, Base):
    __tablename__ = "treatment_logs"
    log_id = Column(Integer, primary_key=True)
    details = Column(String(255))


class CommunicationLog(BaseModel, Base):
    __tablename__ = "communication_logs"
    log_id = Column(Integer, primary_key=True)
    summary = Column(String(255))


class Document(BaseModel, Base):
    __tablename__ = "documents"
    document_id = Column(Integer, primary_key=True)
    file_path = Column(String(255))


class Reminder(BaseModel, Base):
    __tablename__ = "reminders"
    reminder_id = Column(Integer, primary_key=True)
    due_date = Column(Date)


class Appointment(BaseModel, Base):
    __tablename__ = "appointments"
    appointment_id = Column(Integer, primary_key=True, index=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), nullable=True)
    vet_id = Column(Integer, ForeignKey("veterinarians.vet_id"), nullable=True)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=True)
    appointment_datetime = Column(DateTime, nullable=False, server_default=func.now())
    duration_minutes = Column(Integer, default=30)
    reason = Column(String(255))
    notes = Column(Text)
    status = Column(String(50), default="Scheduled")
    is_confirmed = Column(Boolean, default=False)

    def __repr__(self):
        return f"<Appointment(id={self.appointment_id}, datetime='{self.appointment_datetime}', reason='{self.reason}')>"


=============== FILE: models/user_models.py ===============

# models/user_models.py

"""
EDSI Veterinary Management System - User and Authentication Models
Version: 2.0.1
Purpose: Simplified user authentication models with clean relationships.
         Added password hashing and verification methods to User model.
Last Updated: May 29, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.1 (2025-05-29):
    - Added bcrypt import for password hashing.
    - Added set_password(self, password) method to User class to hash
      and store passwords using bcrypt.
    - Added check_password(self, password) method to User class to verify
      passwords against the stored bcrypt hash.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Simplified User model with essential fields only
    - Clean Role and UserRole relationship management
    - Removed SystemConfig (deferred to future phases)
    - Fixed circular import issues
    - Clean inheritance from BaseModel and Base
    - Simplified field definitions and constraints
    - Focused on working authentication foundation
    - Consistent naming and documentation
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
import bcrypt  # Added for password hashing

from config.database_config import Base
from models.base_model import BaseModel


class Role(BaseModel):
    """
    User roles for permission management.
    """

    __tablename__ = "roles"

    role_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique role identifier",
    )

    name = Column(
        String(50),
        unique=True,
        index=True,
        nullable=False,
        doc="Role name (e.g., 'ADMIN', 'USER', 'VETERINARIAN')",  # Doc updated
    )

    description = Column(String(255), nullable=True, doc="Role description")

    # Relationships
    users = relationship(
        "User",
        secondary="user_roles",
        back_populates="roles",
        doc="Users assigned to this role",
    )

    def __repr__(self):
        return f"<Role(role_id={self.role_id}, name='{self.name}')>"


class UserRole(Base):
    """
    Association table for User-Role many-to-many relationship.
    This is a simple link table without audit fields.
    """

    __tablename__ = "user_roles"

    user_id = Column(
        String(20), ForeignKey("users.user_id"), primary_key=True, doc="User identifier"
    )

    role_id = Column(
        Integer, ForeignKey("roles.role_id"), primary_key=True, doc="Role identifier"
    )

    def __repr__(self):
        return f"<UserRole(user_id='{self.user_id}', role_id={self.role_id})>"


class User(BaseModel):
    """
    User account for authentication and system access.
    """

    __tablename__ = "users"

    user_id = Column(
        String(20), primary_key=True, index=True, doc="Unique user login identifier"
    )

    password_hash = Column(
        String(255),  # bcrypt hashes are typically 60 chars, 255 is ample
        nullable=False,
        doc="Hashed password for authentication",
    )

    user_name = Column(String(100), nullable=True, doc="Display name for the user")

    email = Column(
        String(100), unique=True, index=True, nullable=True, doc="User email address"
    )

    is_active = Column(
        Boolean,
        default=True,
        nullable=False,
        index=True,
        doc="Whether the user account is active",
    )

    last_login = Column(
        DateTime, nullable=True, doc="Timestamp of last successful login"
    )

    # Optional user preferences (simplified)
    printer_id = Column(String(20), nullable=True, doc="Default printer for this user")

    default_screen_colors = Column(
        String(100), nullable=True, doc="User's preferred screen color scheme"
    )

    # Relationships
    roles = relationship(
        "Role",
        secondary="user_roles",
        back_populates="users",
        doc="Roles assigned to this user",
    )

    def set_password(self, password: str):
        """
        Hashes the provided password and stores it.
        """
        if not password:
            # Or raise an error, depending on policy for empty passwords
            # For now, assuming controller validates non-empty password for new users.
            # If an empty password is to be disallowed universally, raise ValueError here.
            return
        # Generate a salt and hash the password
        salt = bcrypt.gensalt()
        hashed_password = bcrypt.hashpw(password.encode("utf-8"), salt)
        # Store the hash as a string
        self.password_hash = hashed_password.decode("utf-8")

    def check_password(self, password: str) -> bool:
        """
        Checks the provided password against the stored hash.
        """
        if not self.password_hash or not password:
            return False
        return bcrypt.checkpw(
            password.encode("utf-8"), self.password_hash.encode("utf-8")
        )

    def __repr__(self):
        return f"<User(user_id='{self.user_id}', user_name='{self.user_name}', active={self.is_active})>"

    def has_role(self, role_name: str) -> bool:
        """
        Check if user has a specific role.

        Args:
            role_name: Name of the role to check

        Returns:
            True if user has the role, False otherwise
        """
        return any(
            role.name.upper() == role_name.upper() for role in self.roles
        )  # Made case-insensitive for robustness

    def is_admin(self) -> bool:
        """
        Check if user has admin privileges.

        Returns:
            True if user is an admin, False otherwise
        """
        return self.has_role("ADMIN")  # Ensure "ADMIN" matches the actual role name

    def update_last_login(self) -> None:
        """
        Update the last login timestamp to current time.
        """
        self.last_login = datetime.utcnow()

    def deactivate(self) -> None:
        """
        Deactivate the user account.
        """
        self.is_active = False

    def activate(self) -> None:
        """
        Activate the user account.
        """
        self.is_active = True


=============== FILE: views/__init__.py ===============

# views/__init__.py

"""Views package for EDSI application"""


=============== FILE: views/base_view.py ===============

# views/base_view.py
"""
EDSI Veterinary Management System - Base View Class
Version: 1.3.5
Purpose: Provides a base class for all main views/screens in the application,
         handling common UI setup like dark theme and status messages.
Last Updated: June 14, 2025
Author: Gemini

Changelog:
- v1.3.5 (2025-06-14):
    - Enabled Rich Text formatting in the `show_question` method's QMessageBox
      to ensure HTML tags like `<b>` are rendered correctly.
- v1.3.4 (2025-06-13):
    - Reverted `show_info` and `show_question` to use the standard QMessageBox
      to fix application instability after closing dialogs.
    - Implemented direct button styling on QMessageBox to achieve the custom
      look without needing unstable custom dialog classes.
    - Removed dependencies on the deleted CustomInfoDialog and
      CustomQuestionDialog files.
- v1.3.3 (2025-06-13):
    - Modified `show_info` to use the new `CustomInfoDialog` for consistently
      styled dialog boxes, replacing the standard QMessageBox.
- v1.3.2 (2025-06-08):
    - Corrected the import path for CustomQuestionDialog to point to the
      `views.horse.widgets` sub-package, resolving the ModuleNotFoundError.
- v1.3.1 (2025-06-08):
    - Bug Fix: Changed the import for CustomQuestionDialog to a relative path.
- v1.3.0 (2025-06-08):
    - Refactored `show_question` to use a new `CustomQuestionDialog`.
"""

import logging
from PySide6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QLabel,
    QApplication,
    QMessageBox,
    QStatusBar,
    QDialog,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer

from config.app_config import (
    DARK_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_WIDGET_BACKGROUND,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DEFAULT_FONT_FAMILY,
    DARK_HEADER_FOOTER,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
    DARK_TEXT_TERTIARY,
    DARK_SUCCESS_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
)


class BaseView(QMainWindow):
    """
    Base class for all main views/screens in the application.
    Handles common setup like dark theme, status messages, and basic layout.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} started.")

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.logger.info(
            f"BaseView __init__ for {self.__class__.__name__}: central_widget created."
        )

        if hasattr(self, "setup_ui") and callable(self.setup_ui):
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Calling overridden setup_ui()."
            )
            self.setup_ui()
        else:
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Using default BaseView setup_ui()."
            )
            default_layout = QVBoxLayout(self.central_widget)
            default_label = QLabel(f"Welcome to {self.__class__.__name__}")
            default_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            default_layout.addWidget(default_label)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QVBoxLayout set on central_widget."
            )

        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: BEFORE apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        self.apply_dark_theme_palette_and_global_styles()

        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: AFTER apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        if not hasattr(self, "status_bar") or self.status_bar is None:
            self.status_bar = QStatusBar()
            self.setStatusBar(self.status_bar)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QStatusBar created and set."
            )
        self.update_status("Ready", 0)

        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} finished.")

    def set_title(self, title: str):
        self.setWindowTitle(title)

    def apply_dark_theme_palette_and_global_styles(self):
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: START. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )

        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Text,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.ButtonText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.WindowText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Base,
            QColor(DARK_HEADER_FOOTER),
        )

        QApplication.setPalette(palette)
        QApplication.instance().setPalette(palette)

        QApplication.instance().setStyleSheet(
            f"""
            QMainWindow, QDialog, QWidget {{
                font-family: "{DEFAULT_FONT_FAMILY}";
                font-size: 13px;
                color: {DARK_TEXT_PRIMARY};
                background-color: {DARK_BACKGROUND};
            }}
            """
        )
        self.logger.info(
            f"Dark theme palette and global styles applied for {self.__class__.__name__}."
        )
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: END. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

    def update_status(self, message: str, timeout: int = 5000):
        """Displays a message on the status bar for a specified duration."""
        if hasattr(self, "status_bar") and self.status_bar:
            self.status_bar.showMessage(message, timeout)
            self.logger.info(f"Status update: {message}")
        else:
            self.logger.warning(
                f"Attempted to update status for {self.__class__.__name__}, but no status_bar attribute found or it is None."
            )

    def show_info(self, title: str, message: str):
        self.logger.info(f"Displaying Info: {title} - {message}")
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setIcon(QMessageBox.Icon.Information)
        ok_button = msg_box.addButton("OK", QMessageBox.ButtonRole.AcceptRole)
        ok_button.setStyleSheet(
            f"""
            QPushButton {{
                border: 1px solid white; border-radius: 4px; padding: 8px 16px;
                min-width: 80px; font-weight: bold;
                background-color: {DARK_SUCCESS_ACTION}; color: white;
            }}
            QPushButton:hover {{ background-color: {QColor(DARK_SUCCESS_ACTION).lighter(115).name()}; }}
        """
        )
        msg_box.exec()

    def show_warning(self, title: str, message: str):
        self.logger.warning(f"Displaying Warning: {title} - {message}")
        QMessageBox.warning(self, title, message)

    def show_error(self, title: str, message: str):
        self.logger.error(f"Displaying Error: {title} - {message}")
        QMessageBox.critical(self, title, message)

    def show_question(self, title: str, message: str) -> bool:
        self.logger.info(f"Asking Question: {title} - {message}")
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setTextFormat(Qt.RichText)
        msg_box.setIcon(QMessageBox.Icon.Question)

        yes_button = msg_box.addButton("Yes", QMessageBox.ButtonRole.YesRole)
        no_button = msg_box.addButton("No", QMessageBox.ButtonRole.NoRole)
        msg_box.setDefaultButton(no_button)

        yes_button.setStyleSheet(
            f"""
            QPushButton {{
                border: 1px solid white; border-radius: 4px; padding: 8px 16px;
                min-width: 80px; font-weight: bold;
                background-color: {DARK_SUCCESS_ACTION}; color: white;
            }}
            QPushButton:hover {{ background-color: {QColor(DARK_SUCCESS_ACTION).lighter(115).name()}; }}
        """
        )
        no_button.setStyleSheet(
            f"""
            QPushButton {{
                border: 1px solid white; border-radius: 4px; padding: 8px 16px;
                min-width: 80px; font-weight: bold;
                background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY};
            }}
            QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }}
        """
        )

        msg_box.exec()
        return msg_box.clickedButton() == yes_button


=============== FILE: views/main_menu.py ===============

# views/main_menu.py

"""
EDSI Veterinary Management System - Main Menu
Version: 1.0.2
Purpose: Modern unified main menu with consolidated management screens.
         Fixed PyQt6 to PySide6 imports for consistency.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v1.0.2 (2025-05-24):
    - Fixed imports from PyQt6 to PySide6 for consistency with rest of application
    - Changed pyqtSignal to Signal from PySide6.QtCore
- v1.0.1 (2025-05-12): Updated for unified management approach
  - Replaced separate horse operations (Add, Edit, Delete) with single "Horse Management"
  - Removed horse_review_update_selected, add_new_horse_selected, delete_horse_selected signals
  - Added horse_management_selected signal for unified interface
  - Updated menu options to reflect modern management screens
  - Simplified menu structure for better user experience
- v1.0.0 (2025-05-12): Initial implementation
  - Created complete main menu matching COBOL layout
  - Implemented all menu option signals
  - Added keyboard navigation support
  - Included proper styling and layout
"""

from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QGridLayout,
    QLabel,
    QPushButton,
    QFrame,
    QSpacerItem,
    QSizePolicy,
    QGroupBox,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QFont
from views.base_view import BaseView
from config.app_config import AppConfig
import logging


class MainMenu(BaseView):
    """Primary menu screen with unified management approach"""

    # Signals for menu selections
    horse_management_selected = Signal()  # Option 1 - Unified horse operations
    table_maintenance_selected = Signal()  # Option 2
    print_reports_selected = Signal()  # Option 3
    owners_ar_selected = Signal()  # Option 4
    system_utilities_selected = Signal()  # Option 5
    mass_update_selected = Signal()  # Option 6
    logoff_exit_selected = Signal()  # Option 9
    logoff_no_exit_selected = Signal()  # Option X

    def __init__(self, current_user=None):
        self.current_user = current_user or "Unknown"
        super().__init__()
        self.setup_main_menu_ui()
        self.logger = logging.getLogger(self.__class__.__name__)

    def setup_main_menu_ui(self):
        """Setup the main menu UI"""
        self.set_title("Primary Menu")
        self.resize(700, 600)
        self.center_on_screen()

        # Header section
        self.setup_header()

        # Main menu options
        self.setup_menu_options()

        # Footer section
        self.setup_footer()

    def setup_header(self):
        """Setup header with title and user info"""
        header_frame = QFrame()
        header_layout = QVBoxLayout(header_frame)

        # Main title
        title_label = QLabel("EDSI Primary Menu")
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 24, QFont.Weight.Bold)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_PRIMARY_ACTION};
            padding: 10px;
        """
        )

        # User info
        user_info_label = QLabel(f"Current User: {self.current_user}")
        user_info_label.setAlignment(Qt.AlignmentFlag.AlignRight)
        user_info_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_TEXT_SECONDARY};
            font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
            padding: 5px;
        """
        )

        header_layout.addWidget(title_label)
        header_layout.addWidget(user_info_label)

        # Set up the main window layout instead of using the base view methods
        if not hasattr(self, "main_layout"):
            self.main_layout = QVBoxLayout(self.central_widget)
            self.main_layout.setContentsMargins(20, 20, 20, 20)

        self.main_layout.addWidget(header_frame)

    def setup_menu_options(self):
        """Setup main menu options grid"""
        # Create menu group box
        menu_group = QGroupBox("Select an option:")
        menu_group.setStyleSheet(
            f"""
            QGroupBox {{
                font-size: {AppConfig.DEFAULT_FONT_SIZE + 2}pt;
                font-weight: bold;
                color: {AppConfig.DARK_TEXT_PRIMARY};
                padding-top: 15px;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
            }}
        """
        )

        # Create grid layout for menu options
        menu_layout = QGridLayout(menu_group)
        menu_layout.setSpacing(15)
        menu_layout.setContentsMargins(20, 20, 20, 20)

        # Define menu options (number, text, signal) - Updated for unified approach
        menu_options = [
            ("1.", "Horse Management", self.horse_management_selected),
            ("2.", "Table Maintenance", self.table_maintenance_selected),
            ("3.", "Print Reports & Billing", self.print_reports_selected),
            ("4.", "Owners A/R", self.owners_ar_selected),
            ("5.", "System Utilities", self.system_utilities_selected),
            ("6.", "Mass Update", self.mass_update_selected),
            ("9.", "Logoff & Exit", self.logoff_exit_selected),
            ("X.", "Logoff, No Exit", self.logoff_no_exit_selected),
        ]

        # Create buttons for each option
        self.menu_buttons = {}
        row = 0
        col = 0
        max_cols = 2

        for number, text, signal in menu_options:
            button = self.create_menu_button(number, text, signal)
            menu_layout.addWidget(button, row, col)
            self.menu_buttons[number] = button

            col += 1
            if col >= max_cols:
                col = 0
                row += 1

        # Add the menu group to content area
        self.main_layout.addWidget(menu_group, 1)  # Take up most space

    def create_menu_button(self, number, text, signal):
        """Create a styled menu button"""
        button = QPushButton(f"{number} {text}")
        button.setMinimumHeight(50)
        button.setMinimumWidth(280)

        # Special styling for exit options
        if number in ["9.", "X."]:
            button.setStyleSheet(
                f"""
                QPushButton {{
                    background-color: {AppConfig.DARK_DANGER_ACTION};
                    color: white;
                    border: none;
                    padding: 10px;
                    text-align: left;
                    font-size: {AppConfig.DEFAULT_FONT_SIZE + 1}pt;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background-color: #5a6268;
                }}
                QPushButton:pressed {{
                    background-color: #495057;
                }}
            """
            )
        else:
            button.setStyleSheet(
                f"""
                QPushButton {{
                    background-color: {AppConfig.DARK_PRIMARY_ACTION};
                    color: white;
                    border: none;
                    padding: 10px;
                    text-align: left;
                    font-size: {AppConfig.DEFAULT_FONT_SIZE + 1}pt;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background-color: #106ebe;
                }}
                QPushButton:pressed {{
                    background-color: #005a9e;
                }}
            """
            )

        button.clicked.connect(lambda checked, s=signal: s.emit())
        return button

    def setup_footer(self):
        """Setup footer with instructions"""
        footer_frame = QFrame()
        footer_layout = QHBoxLayout(footer_frame)

        instruction_label = QLabel(
            "Select an option by clicking or pressing the corresponding number/letter"
        )
        instruction_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        instruction_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_TEXT_SECONDARY};
            font-style: italic;
            font-size: {AppConfig.SMALL_FONT_SIZE + 1}pt;
            padding: 10px;
        """
        )

        footer_layout.addWidget(instruction_label)
        self.main_layout.addWidget(footer_frame)

    def center_on_screen(self):
        """Center the main menu on the display"""
        screen = self.screen().availableGeometry()
        size = self.geometry()
        self.move(
            (screen.width() - size.width()) // 2, (screen.height() - size.height()) // 2
        )

    def keyPressEvent(self, event):
        """Handle keyboard shortcuts for menu options"""
        key = event.text().upper()

        # Map keys to signals - Updated for unified approach
        key_mappings = {
            "1": self.horse_management_selected,
            "2": self.table_maintenance_selected,
            "3": self.print_reports_selected,
            "4": self.owners_ar_selected,
            "5": self.system_utilities_selected,
            "6": self.mass_update_selected,
            "9": self.logoff_exit_selected,
            "X": self.logoff_no_exit_selected,
        }

        if key in key_mappings:
            self.logger.info(f"Menu option {key} selected via keyboard")
            key_mappings[key].emit()
        else:
            super().keyPressEvent(event)


=============== FILE: views/admin/user_management_screen.py ===============

# views/admin/user_management_screen.py
"""
EDSI Veterinary Management System - User Management Screen
Version: 1.8.0
Purpose: Admin screen for managing users, locations, veterinarians, charge codes,
         categories, owners, company profile, configurable application paths,
         and now backup/restore operations.
Last Updated: June 23, 2025
Author: Gemini

Changelog:
- v1.8.0 (2025-06-23):
    - Added a new tab: "Backup and Restore" (`BackupRestoreTab`).
    - Defined `BACKUP_RESTORE_TAB_INDEX` constant.
    - Imported `BackupRestoreTab` from `views.admin.tabs`.
    - Instantiated `BackupRestoreTab` and added it to the `QTabWidget`.
    - Updated `_on_tab_changed` and `_refresh_current_tab_data` to handle the new tab.
    - Connected `BackupRestoreTab.operation_completed` signal to `_on_backup_restore_completed` slot.
- v1.7.0 (2025-06-23):
    - Added a new tab: "Application Paths" (`ApplicationPathsTab`).
    - Defined `APP_PATHS_TAB_INDEX` constant.
    - Imported `ApplicationPathsTab` from `views.admin.tabs`.
    - Instantiated `ApplicationPathsTab` and added it to the `QTabWidget`.
    - Updated `_on_tab_changed` and `_refresh_current_tab_data` to handle the new tab.
- v1.6.5 (2025-06-13):
    - Removed unused import for the deleted CustomQuestionDialog to fix a
      ModuleNotFoundError on application startup.
# ... (previous changelog entries)
"""

import logging
from typing import Optional, List, Dict, Any, Union

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QTabWidget,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QHeaderView,
    QAbstractItemView,
    QLabel,
    QFrame,
    QMessageBox,
    QMenu,
    QTreeWidget,
    QTreeWidgetItem,
    QComboBox,
    QDialog,
)
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QAction, QColor, QFont

from views.base_view import BaseView
from config.app_config import AppConfig

from controllers import (
    UserController,
    LocationController,
    ChargeCodeController,
    OwnerController,
    CompanyProfileController,
    VeterinarianController,
)

from models import (
    User,
    Location,
    ChargeCode,
    Owner as OwnerModel,
    ChargeCodeCategory,
    Veterinarian,
)

# Import dialogs and other tabs
from .dialogs.add_edit_user_dialog import AddEditUserDialog
from .dialogs.add_edit_location_dialog import AddEditLocationDialog
from .dialogs.add_edit_charge_code_dialog import AddEditChargeCodeDialog
from .dialogs.add_edit_owner_dialog import AddEditOwnerDialog
from .dialogs.add_edit_charge_code_category_dialog import (
    AddEditChargeCodeCategoryDialog,
)
from .dialogs.add_edit_veterinarian_dialog import AddEditVeterinarianDialog
from .dialogs.company_profile_dialog import CompanyProfileDialog

# Import custom tabs
from .tabs.application_paths_tab import ApplicationPathsTab
from .tabs.backup_restore_tab import BackupRestoreTab  # NEW: Import BackupRestoreTab


class UserManagementScreen(BaseView):
    back_to_main_menu = Signal()
    entity_updated = Signal(str)

    # Tab Indices
    USER_TAB_INDEX = 0
    LOCATION_TAB_INDEX = 1
    VETERINARIAN_TAB_INDEX = 2
    CATEGORY_PROCESS_TAB_INDEX = 3
    CHARGE_CODE_TAB_INDEX = 4
    OWNER_TAB_INDEX = 5
    PROFILE_TAB_INDEX = 6
    APP_PATHS_TAB_INDEX = 7
    BACKUP_RESTORE_TAB_INDEX = 8  # NEW: Index for the Backup/Restore tab

    def __init__(
        self,
        current_user_id: str,
        parent: Optional[QWidget] = None,
        config_manager_instance=None,
        backup_manager_instance=None,
    ):  # MODIFIED: Added config_manager_instance and backup_manager_instance
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(
            f"UserManagementScreen __init__ called for user: {current_user_id}"
        )

        self.current_user_id = current_user_id
        if not self.current_user_id:
            self.logger.error(
                "UserManagementScreen initialized without a current_user_id!"
            )

        self._config_manager = config_manager_instance  # Store the injected instance
        self._backup_manager = backup_manager_instance  # Store the injected instance

        self.user_controller = UserController()
        self.location_controller = LocationController()
        self.veterinarian_controller = VeterinarianController()
        self.charge_code_controller = ChargeCodeController()
        self.owner_controller = OwnerController()
        self.company_profile_controller = CompanyProfileController()

        # Widget Attributes (existing tabs)
        self.users_table: Optional[QTableWidget] = None
        self.add_user_btn: Optional[QPushButton] = None
        self.edit_user_btn: Optional[QPushButton] = None
        self.toggle_user_active_btn: Optional[QPushButton] = None
        self.delete_user_btn: Optional[QPushButton] = None
        self.user_status_filter_combo: Optional[QComboBox] = None

        self.locations_table: Optional[QTableWidget] = None
        self.add_location_btn: Optional[QPushButton] = None
        self.edit_location_btn: Optional[QPushButton] = None
        self.toggle_location_active_btn: Optional[QPushButton] = None
        self.delete_location_btn: Optional[QPushButton] = None
        self.location_status_filter_combo: Optional[QComboBox] = None

        self.vets_table: Optional[QTableWidget] = None
        self.add_vet_btn: Optional[QPushButton] = None
        self.edit_vet_btn: Optional[QPushButton] = None
        self.toggle_vet_active_btn: Optional[QPushButton] = None
        self.vet_status_filter_combo: Optional[QComboBox] = None

        self.categories_tree: Optional[QTreeWidget] = None
        self.add_category_btn: Optional[QPushButton] = None
        self.add_process_btn: Optional[QPushButton] = None
        self.edit_category_process_btn: Optional[QPushButton] = None
        self.toggle_category_process_active_btn: Optional[QPushButton] = None
        self.delete_category_process_btn: Optional[QPushButton] = None
        self.category_filter_combo: Optional[QComboBox] = None

        self.charge_codes_table: Optional[QTableWidget] = None
        self.add_charge_code_btn: Optional[QPushButton] = None
        self.edit_charge_code_btn: Optional[QPushButton] = None
        self.toggle_charge_code_active_btn: Optional[QPushButton] = None
        self.delete_charge_code_btn: Optional[QPushButton] = None
        self.charge_code_status_filter_combo: Optional[QComboBox] = None

        self.owners_table: Optional[QTableWidget] = None
        self.add_owner_btn: Optional[QPushButton] = None
        self.edit_owner_btn: Optional[QPushButton] = None
        self.toggle_owner_active_btn: Optional[QPushButton] = None
        self.delete_owner_btn: Optional[QPushButton] = None
        self.owner_status_filter_combo: Optional[QComboBox] = None

        self.edit_profile_btn: Optional[QPushButton] = None

        # Tab instances
        self.app_paths_tab: Optional[ApplicationPathsTab] = None
        self.backup_restore_tab: Optional[BackupRestoreTab] = (
            None  # NEW: BackupRestoreTab instance
        )

        self.tab_widget: Optional[QTabWidget] = None

        self._active_filters: Dict[int, str] = {
            self.USER_TAB_INDEX: "active",
            self.LOCATION_TAB_INDEX: "active",
            self.VETERINARIAN_TAB_INDEX: "active",
            self.CATEGORY_PROCESS_TAB_INDEX: "active",
            self.CHARGE_CODE_TAB_INDEX: "active",
            self.OWNER_TAB_INDEX: "active",
            # No filter needed for PROFILE, APP_PATHS, or BACKUP_RESTORE tabs initially
        }

        super().__init__(parent)

        self.refresh_timer = QTimer(self)
        self.refresh_timer.setSingleShot(True)
        self.refresh_timer.timeout.connect(self._refresh_current_tab_data)

        self.setWindowTitle("User and System Management")
        self.resize(1200, 800)
        self.logger.info("UserManagementScreen __init__ completed.")

    def setup_ui(self):
        self.logger.info("Setting up UserManagementScreen UI...")

        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet(self._get_tab_widget_style())

        # Existing tabs
        users_tab_widget = self._create_users_tab()
        locations_tab_widget = self._create_locations_tab()
        veterinarians_tab_widget = self._create_veterinarians_tab()
        categories_processes_tab_widget = self._create_categories_processes_tab()
        charge_codes_tab_widget = self._create_charge_codes_tab()
        owners_tab_widget = self._create_owners_tab()
        company_profile_tab_widget = self._create_company_profile_tab()

        # Custom tabs created in separate files
        self.app_paths_tab = ApplicationPathsTab(
            parent_view=self, config_manager_instance=self._config_manager
        )  # Pass config_manager_instance
        self.backup_restore_tab = BackupRestoreTab(
            parent_view=self,
            backup_manager_instance=self._backup_manager,  # Pass backup_manager_instance
        )  # NEW: Instantiate BackupRestoreTab

        self.tab_widget.addTab(users_tab_widget, "👤 Manage Users")
        self.tab_widget.addTab(locations_tab_widget, "📍 Manage Locations")
        self.tab_widget.addTab(veterinarians_tab_widget, "🧑‍⚕️ Manage Veterinarians")
        self.tab_widget.addTab(
            categories_processes_tab_widget, "🗂️ Manage Categories/Processes"
        )
        self.tab_widget.addTab(charge_codes_tab_widget, "💲 Manage Charge Codes")
        self.tab_widget.addTab(owners_tab_widget, "🤝 Manage Master Owners")
        self.tab_widget.addTab(company_profile_tab_widget, "🏢 Company Profile")
        self.tab_widget.addTab(self.app_paths_tab, "📁 Application Paths")
        self.tab_widget.addTab(
            self.backup_restore_tab, "💾 Backup / Restore"
        )  # NEW: Add Backup/Restore tab

        main_layout.addWidget(self.tab_widget)

        self._setup_connections()
        if self.tab_widget:
            self.tab_widget.setCurrentIndex(0)  # Default to first tab
            self._refresh_current_tab_data()  # Load data for the first tab

        self.logger.info("UserManagementScreen UI setup complete.")

    def _get_tab_widget_style(self) -> str:
        return f"""
            QTabWidget::pane {{
                border: 1px solid {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                border-radius: 6px;
                margin-top: -1px;
            }}
            QTabBar::tab {{
                padding: 10px 20px;
                margin-right: 2px;
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-bottom: none;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                min-width: 120px;
                font-size: 13px; font-weight: 500;
            }}
            QTabBar::tab:selected {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border-color: {AppConfig.DARK_BORDER};
                border-bottom-color: {AppConfig.DARK_WIDGET_BACKGROUND};
            }}
            QTabBar::tab:!selected:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QTabWidget::tab-bar {{
                alignment: left;
                border: none;
                background-color: transparent;
                margin-bottom: 0px;
            }}
        """

    def _create_standard_button_layout(self) -> QHBoxLayout:
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        return button_layout

    def _apply_standard_button_style(
        self, button: QPushButton, button_type: str = "standard"
    ):
        base_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 15px;
                font-size: 12px;
                font-weight: 500;
                min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
            }}
            QPushButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
            }}
        """
        if button_type == "add":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_SUCCESS_ACTION
                )
                + "color: white;"
            )
        elif button_type == "edit":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_PRIMARY_ACTION
                )
                + "color: white;"
            )
        elif button_type == "delete" or button_type == "toggle_inactive":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_DANGER_ACTION
                )
                + "color: white;"
            )
        else:
            button.setStyleSheet(base_style)

    def get_form_input_style(self) -> str:
        return f"""
            QComboBox {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 20px;
            }}
            QComboBox:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QComboBox::drop-down {{
                border: none;
                background-color: transparent;
            }}
            QComboBox QAbstractItemView {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                selection-background-color: {AppConfig.DARK_HIGHLIGHT_BG};
                selection-color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _setup_connections(self):
        self.logger.debug("Setting up connections for UserManagementScreen.")
        if self.tab_widget:
            self.tab_widget.currentChanged.connect(self._on_tab_changed)

        if self.add_user_btn:
            self.add_user_btn.clicked.connect(self._add_user)
        if self.edit_user_btn:
            self.edit_user_btn.clicked.connect(self._edit_selected_user)
        if self.toggle_user_active_btn:
            self.toggle_user_active_btn.clicked.connect(
                self._toggle_selected_user_active_status
            )
        if self.delete_user_btn:
            self.delete_user_btn.clicked.connect(self._delete_selected_user)
        if self.users_table:
            self.users_table.itemSelectionChanged.connect(
                self._update_user_action_buttons_state
            )
        if self.user_status_filter_combo:
            self.user_status_filter_combo.currentIndexChanged.connect(
                self._on_user_filter_changed
            )

        if self.add_location_btn:
            self.add_location_btn.clicked.connect(self._add_location)
        if self.edit_location_btn:
            self.edit_location_btn.clicked.connect(self._edit_selected_location)
        if self.toggle_location_active_btn:
            self.toggle_location_active_btn.clicked.connect(
                self._toggle_selected_location_active_status
            )
        if self.delete_location_btn:
            self.delete_location_btn.clicked.connect(self._delete_selected_location)
        if self.locations_table:
            self.locations_table.itemSelectionChanged.connect(
                self._update_location_action_buttons_state
            )
        if self.location_status_filter_combo:
            self.location_status_filter_combo.currentIndexChanged.connect(
                self._on_location_filter_changed
            )

        if self.add_vet_btn:
            self.add_vet_btn.clicked.connect(self._add_veterinarian)
        if self.edit_vet_btn:
            self.edit_vet_btn.clicked.connect(self._edit_selected_veterinarian)
        if self.toggle_vet_active_btn:
            self.toggle_vet_active_btn.clicked.connect(
                self._toggle_selected_veterinarian_status
            )
        if self.vets_table:
            self.vets_table.itemSelectionChanged.connect(
                self._update_veterinarian_action_buttons_state
            )
        if self.vet_status_filter_combo:
            self.vet_status_filter_combo.currentIndexChanged.connect(
                self._on_vet_filter_changed
            )

        if self.add_category_btn:
            self.add_category_btn.clicked.connect(self._add_category_or_process)
        if self.add_process_btn:
            self.add_process_btn.clicked.connect(
                lambda: self._add_category_or_process(is_process=True)
            )
        if self.edit_category_process_btn:
            self.edit_category_process_btn.clicked.connect(
                self._edit_selected_category_process
            )
        if self.toggle_category_process_active_btn:
            self.toggle_category_process_active_btn.clicked.connect(
                self._toggle_selected_category_process_active_status
            )
        if self.delete_category_process_btn:
            self.delete_category_process_btn.clicked.connect(
                self._delete_selected_category_process
            )
        if self.categories_tree:
            self.categories_tree.itemSelectionChanged.connect(
                self._update_category_action_buttons_state
            )
        if self.category_filter_combo:
            self.category_filter_combo.currentIndexChanged.connect(
                self._on_category_filter_changed
            )

        if self.add_charge_code_btn:
            self.add_charge_code_btn.clicked.connect(self._add_charge_code)
        if self.edit_charge_code_btn:
            self.edit_charge_code_btn.clicked.connect(self._edit_selected_charge_code)
        if self.toggle_charge_code_active_btn:
            self.toggle_charge_code_active_btn.clicked.connect(
                self._toggle_selected_charge_code_active_status
            )
        if self.delete_charge_code_btn:
            self.delete_charge_code_btn.clicked.connect(
                self._delete_selected_charge_code
            )
        if self.charge_codes_table:
            self.charge_codes_table.itemSelectionChanged.connect(
                self._update_charge_code_action_buttons_state
            )
        if self.charge_code_status_filter_combo:
            self.charge_code_status_filter_combo.currentIndexChanged.connect(
                self._on_charge_code_filter_changed
            )

        if self.add_owner_btn:
            self.add_owner_btn.clicked.connect(self._add_owner)
        if self.edit_owner_btn:
            self.edit_owner_btn.clicked.connect(self._edit_selected_owner)
        if self.toggle_owner_active_btn:
            self.toggle_owner_active_btn.clicked.connect(
                self._toggle_selected_owner_active_status
            )
        if self.delete_owner_btn:
            self.delete_owner_btn.clicked.connect(self._delete_selected_owner)
        if self.owners_table:
            self.owners_table.itemSelectionChanged.connect(
                self._update_owner_action_buttons_state
            )
        if self.owner_status_filter_combo:
            self.owner_status_filter_combo.currentIndexChanged.connect(
                self._on_owner_filter_changed
            )

        if self.edit_profile_btn:
            self.edit_profile_btn.clicked.connect(self._launch_company_profile_dialog)

        if self.app_paths_tab:
            self.app_paths_tab.paths_saved.connect(self._on_app_paths_saved)

        # NEW: Connect the operation_completed signal from the BackupRestoreTab
        if self.backup_restore_tab:
            self.backup_restore_tab.operation_completed.connect(
                self._on_backup_restore_completed
            )

        self.logger.debug("Connections setup complete.")

    def _on_tab_changed(self, index: int):
        self.logger.info(
            f"Tab changed to index: {index}, new tab title: {self.tab_widget.tabText(index) if self.tab_widget else 'N/A'}"
        )
        self._refresh_current_tab_data()

    def _refresh_current_tab_data(self, force_reload: bool = False):
        if not self.tab_widget:
            self.logger.warning("Tab widget not available for refresh.")
            return
        current_index = self.tab_widget.currentIndex()
        self.logger.debug(f"Refreshing data for tab index: {current_index}")

        if current_index == self.USER_TAB_INDEX:
            self.load_users_data()
        elif current_index == self.LOCATION_TAB_INDEX:
            self.load_locations_data()
        elif current_index == self.VETERINARIAN_TAB_INDEX:
            self.load_veterinarians_data()
        elif current_index == self.CATEGORY_PROCESS_TAB_INDEX:
            self.load_categories_processes_data()
        elif current_index == self.CHARGE_CODE_TAB_INDEX:
            self.load_charge_codes_data()
        elif current_index == self.OWNER_TAB_INDEX:
            self.load_owners_data()
        elif current_index == self.PROFILE_TAB_INDEX:
            pass  # No direct data load needed for this tab (dialog-driven)
        elif current_index == self.APP_PATHS_TAB_INDEX:
            if self.app_paths_tab:
                self.app_paths_tab._load_current_paths()
            else:
                self.logger.warning("Application Paths tab is not initialized.")
        elif current_index == self.BACKUP_RESTORE_TAB_INDEX:  # NEW: Handle the new tab
            if self.backup_restore_tab:
                self.backup_restore_tab.update_button_states()  # Ensure buttons are in correct state
            else:
                self.logger.warning("Backup/Restore tab is not initialized.")
        else:
            self.logger.warning(
                f"No data loading action defined for tab index {current_index}"
            )

    def _create_table_widget(self, headers: List[str]) -> QTableWidget:
        table = QTableWidget()
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        table.verticalHeader().setVisible(False)
        table.setShowGrid(True)
        table.setStyleSheet(
            f"""
            QTableWidget {{
                gridline-color: {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
            }}
            QHeaderView::section {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                padding: 5px;
                border: none;
                border-bottom: 1px solid {AppConfig.DARK_BORDER};
                font-weight: 500;
            }}
            QTableWidget::item {{ padding: 5px; }}
            QTableWidget::item:selected {{ background-color: {AppConfig.DARK_HIGHLIGHT_BG}; color: {AppConfig.DARK_HIGHLIGHT_TEXT}; }}
            """
        )
        table.horizontalHeader().setStretchLastSection(True)
        for i in range(len(headers) - 1):
            table.horizontalHeader().setSectionResizeMode(
                i, QHeaderView.ResizeMode.ResizeToContents
            )
        return table

    # --- Users Tab Methods ---
    def _create_users_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_user_btn = QPushButton("➕ Add New User")
        self._apply_standard_button_style(self.add_user_btn, "add")
        self.edit_user_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_user_btn, "edit")
        self.toggle_user_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_user_active_btn)
        self.delete_user_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_user_btn, "delete")
        button_layout.addWidget(self.add_user_btn)
        button_layout.addWidget(self.edit_user_btn)
        button_layout.addWidget(self.toggle_user_active_btn)
        button_layout.addWidget(self.delete_user_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.user_status_filter_combo = QComboBox()
        self.user_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.user_status_filter_combo.setCurrentText(
            self._active_filters.get(self.USER_TAB_INDEX, "active")
        )
        self.user_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.user_status_filter_combo)
        layout.addLayout(top_bar_layout)
        self.users_table = self._create_table_widget(
            ["Login ID", "Full Name", "Email", "Roles", "Active", "Last Login"]
        )
        layout.addWidget(self.users_table)
        self._update_user_action_buttons_state()
        return tab

    def load_users_data(self):
        self.logger.info("Loading users data for tab...")
        if not self.users_table or not self.user_status_filter_combo:
            self.logger.error("Users table or filter combo not initialized.")
            return
        try:
            status_filter = self.user_status_filter_combo.currentText().lower()
            self._active_filters[self.USER_TAB_INDEX] = status_filter
            users = self.user_controller.get_all_users(status_filter=status_filter)
            self.users_table.setRowCount(0)
            for user_obj in users:
                row_position = self.users_table.rowCount()
                self.users_table.insertRow(row_position)
                self.users_table.setItem(
                    row_position, 0, QTableWidgetItem(user_obj.user_id)
                )
                self.users_table.setItem(
                    row_position, 1, QTableWidgetItem(user_obj.user_name or "")
                )
                self.users_table.setItem(
                    row_position, 2, QTableWidgetItem(user_obj.email or "")
                )
                roles_str = ", ".join([role.name for role in user_obj.roles])
                self.users_table.setItem(row_position, 3, QTableWidgetItem(roles_str))
                active_str = "Yes" if user_obj.is_active else "No"
                self.users_table.setItem(row_position, 4, QTableWidgetItem(active_str))
                last_login_str = (
                    user_obj.last_login.strftime("%Y-%m-%d %H:%M")
                    if user_obj.last_login
                    else "Never"
                )
                self.users_table.setItem(
                    row_position, 5, QTableWidgetItem(last_login_str)
                )
                self.users_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, user_obj.user_id
                )
            self.logger.info(f"Loaded {len(users)} users.")
        except Exception as e:
            self.logger.error(f"Error loading users: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load users: {e}")
        self._update_user_action_buttons_state()

    def _on_user_filter_changed(self, index: int):
        self.load_users_data()

    def _add_user(self):
        dialog = AddEditUserDialog(
            self,
            user_controller=self.user_controller,
            current_user_object=None,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_users_data()
            self.entity_updated.emit("user")

    def _edit_selected_user(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Edit User", "Please select a user to edit.")
            return
        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        if not user_id_item:
            self.show_error("Error", "Could not retrieve user ID for selected row.")
            return
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )
        user_to_edit = self.user_controller.get_user_by_login_id(user_login_id)
        if user_to_edit:
            dialog = AddEditUserDialog(
                self,
                user_controller=self.user_controller,
                current_user_object=user_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_users_data()
                self.entity_updated.emit("user")
        else:
            self.show_error("Error", f"User with Login ID '{user_login_id}' not found.")
            self.load_users_data()

    def _toggle_selected_user_active_status(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a user.")
            return
        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )
        user_obj = self.user_controller.get_user_by_login_id(user_login_id)
        if not user_obj:
            self.show_error("Error", f"User {user_login_id} not found.")
            return
        action = "deactivate" if user_obj.is_active else "activate"
        name_display = user_obj.user_name or user_obj.user_id
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} user '{name_display}'?",
        ):
            success, message = self.user_controller.toggle_user_active_status(
                user_login_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_users_data()
                self.entity_updated.emit("user")
            else:
                self.show_error("Error", message)

    def _delete_selected_user(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Delete User", "Please select a user to delete.")
            return
        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )
        user_name_item = self.users_table.item(selected_row, 1)
        display_name = user_name_item.text() if user_name_item else user_login_id
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete user '{display_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.user_controller.delete_user_permanently(
                user_login_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_users_data()
                self.entity_updated.emit("user_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_user_action_buttons_state(self):
        has_selection = (
            self.users_table is not None and self.users_table.currentItem() is not None
        )
        if self.edit_user_btn:
            self.edit_user_btn.setEnabled(has_selection)
        if self.toggle_user_active_btn:
            self.toggle_user_active_btn.setEnabled(has_selection)
        if self.delete_user_btn:
            self.delete_user_btn.setEnabled(has_selection)
        if has_selection and self.toggle_user_active_btn and self.users_table:
            selected_row = self.users_table.currentRow()
            user_id_item = self.users_table.item(selected_row, 0)
            if not user_id_item:
                return
            user_login_id = (
                user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
            )
            user_obj = self.user_controller.get_user_by_login_id(user_login_id)
            if user_obj:
                action_text = "Deactivate" if user_obj.is_active else "Activate"
                self.toggle_user_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_user_active_btn,
                    "toggle_inactive" if user_obj.is_active else "standard",
                )

    # --- Locations Tab Methods ---
    def _create_locations_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_location_btn = QPushButton("➕ Add New Location")
        self._apply_standard_button_style(self.add_location_btn, "add")
        self.edit_location_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_location_btn, "edit")
        self.toggle_location_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_location_active_btn)
        self.delete_location_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_location_btn, "delete")
        button_layout.addWidget(self.add_location_btn)
        button_layout.addWidget(self.edit_location_btn)
        button_layout.addWidget(self.toggle_location_active_btn)
        button_layout.addWidget(self.delete_location_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.location_status_filter_combo = QComboBox()
        self.location_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.location_status_filter_combo.setCurrentText(
            self._active_filters.get(self.LOCATION_TAB_INDEX, "active")
        )
        self.location_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.location_status_filter_combo)
        layout.addLayout(top_bar_layout)
        self.locations_table = self._create_table_widget(
            ["Name", "Address", "City", "State", "Zip", "Contact", "Active"]
        )
        layout.addWidget(self.locations_table)
        self._update_location_action_buttons_state()
        return tab

    def load_locations_data(self):
        self.logger.info("Loading locations data for tab...")
        if not self.locations_table or not self.location_status_filter_combo:
            self.logger.error("Locations table or filter combo not initialized.")
            return
        try:
            status_filter = self.location_status_filter_combo.currentText().lower()
            self._active_filters[self.LOCATION_TAB_INDEX] = status_filter
            locations = self.location_controller.get_all_locations(
                status_filter=status_filter
            )
            self.locations_table.setRowCount(0)
            for loc_obj in locations:
                row_position = self.locations_table.rowCount()
                self.locations_table.insertRow(row_position)
                self.locations_table.setItem(
                    row_position, 0, QTableWidgetItem(loc_obj.location_name)
                )
                address_parts = [loc_obj.address_line1, loc_obj.address_line2]
                self.locations_table.setItem(
                    row_position,
                    1,
                    QTableWidgetItem(" ".join(filter(None, address_parts))),
                )
                self.locations_table.setItem(
                    row_position, 2, QTableWidgetItem(loc_obj.city or "")
                )
                state_display = loc_obj.state_code or ""
                if (
                    hasattr(loc_obj, "state")
                    and loc_obj.state
                    and hasattr(loc_obj.state, "state_code")
                ):
                    state_display = loc_obj.state.state_code
                self.locations_table.setItem(
                    row_position, 3, QTableWidgetItem(state_display)
                )
                self.locations_table.setItem(
                    row_position, 4, QTableWidgetItem(loc_obj.zip_code or "")
                )
                self.locations_table.setItem(
                    row_position, 5, QTableWidgetItem(loc_obj.contact_person or "")
                )
                self.locations_table.setItem(
                    row_position,
                    6,
                    QTableWidgetItem("Yes" if loc_obj.is_active else "No"),
                )
                self.locations_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, loc_obj.location_id
                )
            self.logger.info(f"Loaded {len(locations)} locations.")
        except Exception as e:
            self.logger.error(f"Error loading locations: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load locations: {e}")
        self._update_location_action_buttons_state()

    def _on_location_filter_changed(self, index: int):
        self.load_locations_data()

    def _add_location(self):
        dialog = AddEditLocationDialog(
            self,
            controller=self.location_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_locations_data()
            self.entity_updated.emit("location")

    def _edit_selected_location(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Edit Location", "Please select a location to edit.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        location_to_edit = self.location_controller.get_location_by_id(location_id)
        if location_to_edit:
            dialog = AddEditLocationDialog(
                self,
                controller=self.location_controller,
                location=location_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_locations_data()
                self.entity_updated.emit("location")
        else:
            self.show_error("Error", f"Location with ID '{location_id}' not found.")
            self.load_locations_data()

    def _toggle_selected_location_active_status(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a location.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        loc_obj = self.location_controller.get_location_by_id(location_id)
        if not loc_obj:
            self.show_error("Error", f"Location {location_id} not found.")
            return
        action = "deactivate" if loc_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} location '{loc_obj.location_name}'?",
        ):
            success, message = self.location_controller.toggle_location_active_status(
                location_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_locations_data()
                self.entity_updated.emit("location")
            else:
                self.show_error("Error", message)

    def _delete_selected_location(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Delete Location", "Please select a location to delete.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        location_name = location_id_item.text()
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete location '{location_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.location_controller.delete_location(
                location_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_locations_data()
                self.entity_updated.emit("location_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_location_action_buttons_state(self):
        has_selection = (
            self.locations_table is not None
            and self.locations_table.currentItem() is not None
        )
        if self.edit_location_btn:
            self.edit_location_btn.setEnabled(has_selection)
        if self.toggle_location_active_btn:
            self.toggle_location_active_btn.setEnabled(has_selection)
        if self.delete_location_btn:
            self.delete_location_btn.setEnabled(has_selection)
        if has_selection and self.toggle_location_active_btn and self.locations_table:
            selected_row = self.locations_table.currentRow()
            location_id_item = self.locations_table.item(selected_row, 0)
            if not location_id_item:
                return
            loc_id = (
                location_id_item.data(Qt.ItemDataRole.UserRole)
                or location_id_item.text()
            )
            loc_obj = self.location_controller.get_location_by_id(loc_id)
            if loc_obj:
                action_text = "Deactivate" if loc_obj.is_active else "Activate"
                self.toggle_location_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_location_active_btn,
                    "toggle_inactive" if loc_obj.is_active else "standard",
                )

    # --- Veterinarians Tab Methods ---
    def _create_veterinarians_tab(self):
        tab_widget = QWidget()
        main_layout = QVBoxLayout(tab_widget)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_vet_btn = QPushButton("➕ Add New Veterinarian")
        self._apply_standard_button_style(self.add_vet_btn, "add")
        self.edit_vet_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_vet_btn, "edit")
        self.toggle_vet_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_vet_active_btn)
        button_layout.addWidget(self.add_vet_btn)
        button_layout.addWidget(self.edit_vet_btn)
        button_layout.addWidget(self.toggle_vet_active_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.vet_status_filter_combo = QComboBox()
        self.vet_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.vet_status_filter_combo.setCurrentText(
            self._active_filters.get(self.VETERINARIAN_TAB_INDEX, "active")
        )
        self.vet_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.vet_status_filter_combo)
        main_layout.addLayout(top_bar_layout)
        self.vets_table = self._create_table_widget(
            ["Name", "License #", "Specialty", "Phone", "Email", "Status"]
        )
        main_layout.addWidget(self.vets_table)
        self._update_veterinarian_action_buttons_state()
        return tab_widget

    def load_veterinarians_data(self):
        self.logger.info("Loading veterinarians data for tab...")
        if not self.vets_table or not self.vet_status_filter_combo:
            self.logger.error("Veterinarians table or filter combo not initialized.")
            return
        try:
            status_filter = self.vet_status_filter_combo.currentText().lower()
            self._active_filters[self.VETERINARIAN_TAB_INDEX] = status_filter
            vets = self.veterinarian_controller.get_all_veterinarians(
                status_filter=status_filter
            )
            self.vets_table.setRowCount(0)
            for vet in vets:
                row_position = self.vets_table.rowCount()
                self.vets_table.insertRow(row_position)
                name_item = QTableWidgetItem(f"{vet.first_name} {vet.last_name}")
                name_item.setData(Qt.ItemDataRole.UserRole, vet.vet_id)
                status_item = QTableWidgetItem(
                    "Active" if vet.is_active else "Inactive"
                )
                status_item.setForeground(
                    QColor("#68D391") if vet.is_active else QColor("#FC8181")
                )
                self.vets_table.setItem(row_position, 0, name_item)
                self.vets_table.setItem(
                    row_position, 1, QTableWidgetItem(vet.license_number or "")
                )
                self.vets_table.setItem(
                    row_position, 2, QTableWidgetItem(vet.specialty or "")
                )
                self.vets_table.setItem(
                    row_position, 3, QTableWidgetItem(vet.phone or "")
                )
                self.vets_table.setItem(
                    row_position, 4, QTableWidgetItem(vet.email or "")
                )
                self.vets_table.setItem(row_position, 5, status_item)
            self.logger.info(f"Loaded {len(vets)} veterinarians.")
        except Exception as e:
            self.logger.error(f"Error loading veterinarians: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load veterinarians: {e}")
        self._update_veterinarian_action_buttons_state()

    def _on_vet_filter_changed(self, index: int):
        self.load_veterinarians_data()

    def _add_veterinarian(self):
        dialog = AddEditVeterinarianDialog(
            parent_view=self,
            controller=self.veterinarian_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_veterinarians_data()
            self.entity_updated.emit("veterinarian")
            self.show_info("Success", "Veterinarian added successfully.")

    def _edit_selected_veterinarian(self):
        selected_rows = self.vets_table.selectionModel().selectedRows()
        if not selected_rows:
            self.show_info("Edit Veterinarian", "Please select a veterinarian to edit.")
            return
        vet_id = selected_rows[0].data(Qt.ItemDataRole.UserRole)
        vet_to_edit = self.veterinarian_controller.get_veterinarian_by_id(vet_id)
        if not vet_to_edit:
            self.show_error("Error", "Could not retrieve veterinarian details.")
            return
        dialog = AddEditVeterinarianDialog(
            parent_view=self,
            controller=self.veterinarian_controller,
            current_user_id=self.current_user_id,
            veterinarian=vet_to_edit,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_veterinarians_data()
            self.entity_updated.emit("veterinarian")
            self.show_info("Success", "Veterinarian updated successfully.")

    def _toggle_selected_veterinarian_status(self):
        selected_rows = self.vets_table.selectionModel().selectedRows()
        if not selected_rows:
            self.show_info("Toggle Status", "Please select a veterinarian.")
            return
        vet_id = selected_rows[0].data(Qt.ItemDataRole.UserRole)
        vet_name = self.vets_table.item(selected_rows[0].row(), 0).text()
        current_status_text = self.vets_table.item(selected_rows[0].row(), 5).text()
        action_text = "deactivate" if current_status_text == "Active" else "activate"
        if self.show_question(
            "Confirm Status Change",
            f"Are you sure you want to {action_text} {vet_name}?",
        ):
            success, message = self.veterinarian_controller.toggle_veterinarian_status(
                vet_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_veterinarians_data()
            else:
                self.show_error("Error", message)

    def _update_veterinarian_action_buttons_state(self):
        has_selection = bool(
            self.vets_table is not None
            and self.vets_table.selectionModel().hasSelection()
        )
        if self.edit_vet_btn:
            self.edit_vet_btn.setEnabled(has_selection)
        if self.toggle_vet_active_btn:
            self.toggle_vet_active_btn.setEnabled(has_selection)
        if has_selection:
            selected_row = self.vets_table.currentRow()
            status_text = self.vets_table.item(selected_row, 5).text()
            action_text = "Deactivate" if status_text == "Active" else "Activate"
            self.toggle_vet_active_btn.setText(f"🔄 {action_text} Selected")
            self._apply_standard_button_style(
                self.toggle_vet_active_btn,
                "toggle_inactive" if status_text == "Active" else "standard",
            )

    # --- Categories/Processes Tab Methods ---
    def _create_categories_processes_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        self.add_category_btn = QPushButton("➕ Add Category (L1)")
        self._apply_standard_button_style(self.add_category_btn, "add")
        self.add_process_btn = QPushButton("➕ Add Process (L2)")
        self._apply_standard_button_style(self.add_process_btn, "add")
        self.edit_category_process_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_category_process_btn, "edit")
        self.toggle_category_process_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_category_process_active_btn)
        self.delete_category_process_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_category_process_btn, "delete")
        top_bar_layout.addWidget(self.add_category_btn)
        top_bar_layout.addWidget(self.add_process_btn)
        top_bar_layout.addWidget(self.edit_category_process_btn)
        top_bar_layout.addWidget(self.toggle_category_process_active_btn)
        top_bar_layout.addWidget(self.delete_category_process_btn)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.category_filter_combo = QComboBox()
        self.category_filter_combo.addItems(["Active", "Inactive", "All"])
        self.category_filter_combo.setCurrentText(
            self._active_filters.get(self.CATEGORY_PROCESS_TAB_INDEX, "active")
        )
        self.category_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.category_filter_combo)
        layout.addLayout(top_bar_layout)
        self.categories_tree = QTreeWidget()
        self.categories_tree.setHeaderLabels(
            ["Category/Process Name", "Level", "Status", "ID"]
        )
        self.categories_tree.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.categories_tree.setStyleSheet(
            f"""QTreeWidget {{ background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_BORDER}; border-radius: 4px; }} QHeaderView::section {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; color: {AppConfig.DARK_TEXT_SECONDARY}; padding: 5px; border: none; border-bottom: 1px solid {AppConfig.DARK_BORDER}; font-weight: 500; }} QTreeWidget::item:selected {{ background-color: {AppConfig.DARK_HIGHLIGHT_BG}; color: {AppConfig.DARK_HIGHLIGHT_TEXT}; }} QTreeWidget::item {{ padding: 3px; }}"""
        )
        header = self.categories_tree.header()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        for i in range(1, 4):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)
        layout.addWidget(self.categories_tree)
        self._update_category_action_buttons_state()
        return tab

    def load_categories_processes_data(self):
        self.logger.info("Loading charge code categories/processes data...")
        if not self.categories_tree or not self.category_filter_combo:
            self.logger.error("Categories tree or filter combo not initialized.")
            return
        self.categories_tree.clear()
        try:
            level1_categories = (
                self.charge_code_controller.get_all_charge_code_categories_hierarchical()
            )
            ui_status_filter = self.category_filter_combo.currentText().lower()
            self._active_filters[self.CATEGORY_PROCESS_TAB_INDEX] = ui_status_filter
            for cat_l1 in level1_categories:
                has_visible_children = False
                child_items = []
                for cat_l2 in cat_l1.children:
                    if (
                        ui_status_filter == "all"
                        or (ui_status_filter == "active" and cat_l2.is_active)
                        or (ui_status_filter == "inactive" and not cat_l2.is_active)
                    ):
                        l2_item = QTreeWidgetItem()
                        l2_item.setText(0, cat_l2.name)
                        l2_item.setText(1, str(cat_l2.level))
                        l2_item.setText(2, "Active" if cat_l2.is_active else "Inactive")
                        l2_item.setText(3, str(cat_l2.category_id))
                        l2_item.setData(
                            0,
                            Qt.ItemDataRole.UserRole,
                            {"id": cat_l2.category_id, "level": 2, "obj": cat_l2},
                        )
                        child_items.append(l2_item)
                        has_visible_children = True
                is_l1_visible = (
                    ui_status_filter == "all"
                    or (ui_status_filter == "active" and cat_l1.is_active)
                    or (ui_status_filter == "inactive" and not cat_l1.is_active)
                )
                if is_l1_visible or has_visible_children:
                    l1_item = QTreeWidgetItem(self.categories_tree)
                    l1_item.setText(0, cat_l1.name)
                    l1_item.setText(1, str(cat_l1.level))
                    l1_item.setText(2, "Active" if cat_l1.is_active else "Inactive")
                    l1_item.setText(3, str(cat_l1.category_id))
                    l1_item.setData(
                        0,
                        Qt.ItemDataRole.UserRole,
                        {"id": cat_l1.category_id, "level": 1, "obj": cat_l1},
                    )
                    l1_item.addChildren(child_items)
            self.categories_tree.expandAll()
            self.logger.info(
                f"Displayed categories in tree (UI filter: '{ui_status_filter}')."
            )
        except Exception as e:
            self.logger.error(f"Error loading categories/processes: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load categories: {e}")
        self._update_category_action_buttons_state()

    def _on_category_filter_changed(self, index: int):
        self.load_categories_processes_data()

    def _add_category_or_process(self, is_process: bool = False):
        selected_item = (
            self.categories_tree.currentItem() if self.categories_tree else None
        )
        parent_category: Optional[ChargeCodeCategory] = None
        if is_process:
            if not selected_item:
                self.show_warning(
                    "Add Process",
                    "Please select a Level 1 Category to add a Process under.",
                )
                return
            item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
            if item_data.get("level") != 1:
                self.show_warning(
                    "Add Process",
                    "Processes (Level 2) can only be added under a Level 1 Category.",
                )
                return
            parent_category = item_data.get("obj")
        dialog = AddEditChargeCodeCategoryDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
            category_to_edit=None,
            parent_category=parent_category,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_categories_processes_data()
            self.entity_updated.emit("charge_code_category")

    def _edit_selected_category_process(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Edit Item", "Please select a category or process to edit.")
            return
        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        category_to_edit: Optional[ChargeCodeCategory] = item_data.get("obj")
        if not category_to_edit:
            self.show_error("Error", "Could not retrieve item details to edit.")
            self.load_categories_processes_data()
            return

        # MODIFIED: Logic to safely get parent category
        parent_for_dialog = None
        if category_to_edit.level == 2:
            # The .parent attribute is now eager-loaded by the controller query
            parent_for_dialog = category_to_edit.parent

        dialog = AddEditChargeCodeCategoryDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
            category_to_edit=category_to_edit,
            parent_category=parent_for_dialog,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_categories_processes_data()
            self.entity_updated.emit("charge_code_category")

    def _toggle_selected_category_process_active_status(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Toggle Status", "Please select an item.")
            return
        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        item_id = item_data.get("id")
        item_obj: Optional[ChargeCodeCategory] = item_data.get("obj")
        if not item_obj:
            self.show_error("Error", f"Item with ID {item_id} not found.")
            return
        action = "deactivate" if item_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} '{item_obj.name}'?",
        ):
            success, message = (
                self.charge_code_controller.toggle_charge_code_category_status(
                    item_id, self.current_user_id
                )
            )
            if success:
                self.show_info("Success", message)
                self.load_categories_processes_data()
            else:
                self.show_error("Error", message)

    def _delete_selected_category_process(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Delete Item", "Please select an item to delete.")
            return
        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        item_id = item_data.get("id")
        item_name = selected_item.text(0)
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete '{item_name}'?\nThis may fail if it is in use.\nThis action cannot be undone.",
        ):
            success, message = self.charge_code_controller.delete_charge_code_category(
                item_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_categories_processes_data()
            else:
                self.show_error("Delete Failed", message)

    def _update_category_action_buttons_state(self):
        if not self.categories_tree:
            return
        has_selection = self.categories_tree.currentItem() is not None
        is_l1_selected = False
        item_obj: Optional[ChargeCodeCategory] = None
        if has_selection:
            item_data = self.categories_tree.currentItem().data(
                0, Qt.ItemDataRole.UserRole
            )
            if item_data:
                is_l1_selected = item_data.get("level") == 1
                item_obj = item_data.get("obj")
        if self.add_category_btn:
            self.add_category_btn.setEnabled(True)
        if self.add_process_btn:
            self.add_process_btn.setEnabled(is_l1_selected)
        if self.edit_category_process_btn:
            self.edit_category_process_btn.setEnabled(has_selection)
        if self.toggle_category_process_active_btn:
            self.toggle_category_process_active_btn.setEnabled(has_selection)
        if self.delete_category_process_btn:
            self.delete_category_process_btn.setEnabled(has_selection)
        if has_selection and self.toggle_category_process_active_btn and item_obj:
            action_text = "Deactivate" if item_obj.is_active else "Activate"
            self.toggle_category_process_active_btn.setText(
                f"🔄 {action_text} Selected"
            )
            self._apply_standard_button_style(
                self.toggle_category_process_active_btn,
                "toggle_inactive" if item_obj.is_active else "standard",
            )

    # --- Charge Codes Tab Methods ---
    def _create_charge_codes_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_charge_code_btn = QPushButton("➕ Add New Charge Code")
        self._apply_standard_button_style(self.add_charge_code_btn, "add")
        self.edit_charge_code_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_charge_code_btn, "edit")
        self.toggle_charge_code_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_charge_code_active_btn)
        self.delete_charge_code_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_charge_code_btn, "delete")
        button_layout.addWidget(self.add_charge_code_btn)
        button_layout.addWidget(self.edit_charge_code_btn)
        button_layout.addWidget(self.toggle_charge_code_active_btn)
        button_layout.addWidget(self.delete_charge_code_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.charge_code_status_filter_combo = QComboBox()
        self.charge_code_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.charge_code_status_filter_combo.setCurrentText(
            self._active_filters.get(self.CHARGE_CODE_TAB_INDEX, "active")
        )
        self.charge_code_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.charge_code_status_filter_combo)
        layout.addLayout(top_bar_layout)
        self.charge_codes_table = self._create_table_widget(
            [
                "Code",
                "Alternate Code",
                "Category",
                "Description",
                "Std. Price",
                "Active",
            ]
        )
        if self.charge_codes_table:
            self.charge_codes_table.horizontalHeader().setSectionResizeMode(
                3, QHeaderView.ResizeMode.Stretch
            )
        for i in [0, 1, 2, 4, 5]:
            self.charge_codes_table.horizontalHeader().setSectionResizeMode(
                i, QHeaderView.ResizeMode.ResizeToContents
            )
        layout.addWidget(self.charge_codes_table)
        self._update_charge_code_action_buttons_state()
        return tab

    def load_charge_codes_data(self):
        self.logger.info("Loading charge codes data for tab...")
        if not self.charge_codes_table or not self.charge_code_status_filter_combo:
            self.logger.error("Charge codes table or filter combo not initialized.")
            return
        try:
            status_filter = self.charge_code_status_filter_combo.currentText().lower()
            self.logger.info(f"Charge code status filter: {status_filter}")
            self._active_filters[self.CHARGE_CODE_TAB_INDEX] = status_filter
            charge_codes = self.charge_code_controller.get_all_charge_codes(
                status_filter=status_filter
            )
            self.charge_codes_table.setRowCount(0)
            for c_obj in charge_codes:
                row_position = self.charge_codes_table.rowCount()
                self.charge_codes_table.insertRow(row_position)
                self.charge_codes_table.setItem(
                    row_position, 0, QTableWidgetItem(c_obj.code)
                )
                self.charge_codes_table.setItem(
                    row_position, 1, QTableWidgetItem(c_obj.alternate_code or "")
                )
                category_path_str = "N/A"
                if c_obj.category_id:
                    path_objects = self.charge_code_controller.get_category_path(
                        c_obj.category_id
                    )
                    if path_objects:
                        category_path_str = " > ".join(
                            [p["name"] for p in path_objects]
                        )
                self.charge_codes_table.setItem(
                    row_position, 2, QTableWidgetItem(category_path_str)
                )
                self.charge_codes_table.setItem(
                    row_position, 3, QTableWidgetItem(c_obj.description)
                )
                price_str = (
                    f"${c_obj.standard_charge:.2f}"
                    if c_obj.standard_charge is not None
                    else "$0.00"
                )
                price_item = QTableWidgetItem(price_str)
                price_item.setTextAlignment(
                    Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
                )
                self.charge_codes_table.setItem(row_position, 4, price_item)
                self.charge_codes_table.setItem(
                    row_position,
                    5,
                    QTableWidgetItem("Yes" if c_obj.is_active else "No"),
                )
                self.charge_codes_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, c_obj.id
                )
            self.logger.info(
                f"Loaded {len(charge_codes)} charge codes based on filter '{status_filter}'."
            )
        except AttributeError as ae:
            self.logger.error(f"Error loading charge codes: {ae}", exc_info=True)
            self.show_error("Load Error", f"Could not load charge codes: {ae}")
        except Exception as e:
            self.logger.error(f"General error loading charge codes: {e}", exc_info=True)
            self.show_error("Load Error", f"An unexpected error occurred: {e}")
        self._update_charge_code_action_buttons_state()

    def _on_charge_code_filter_changed(self, index: int):
        self.load_charge_codes_data()

    def _add_charge_code(self):
        dialog = AddEditChargeCodeDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_charge_codes_data()
            self.entity_updated.emit("charge_code")

    def _edit_selected_charge_code(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info("Edit Charge Code", "Please select a charge code to edit.")
            return
        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        charge_code_to_edit = self.charge_code_controller.get_charge_code_by_id(
            charge_code_id
        )
        if charge_code_to_edit:
            dialog = AddEditChargeCodeDialog(
                self,
                controller=self.charge_code_controller,
                charge_code=charge_code_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code")
        else:
            self.show_error(
                "Error", f"Charge code with ID '{charge_code_id}' not found."
            )
            self.load_charge_codes_data()

    def _toggle_selected_charge_code_active_status(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a charge code.")
            return
        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        cc_obj = self.charge_code_controller.get_charge_code_by_id(charge_code_id)
        if not cc_obj:
            self.show_error("Error", f"Charge code {charge_code_id} not found.")
            return
        action = "deactivate" if cc_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} charge code '{cc_obj.code} - {cc_obj.description}'?",
        ):
            success, message = self.charge_code_controller.toggle_charge_code_status(
                charge_code_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code")
            else:
                self.show_error("Error", message)

    def _delete_selected_charge_code(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info(
                "Delete Charge Code", "Please select a charge code to delete."
            )
            return
        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        charge_code_name = self.charge_codes_table.item(selected_row, 0).text()
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete charge code '{charge_code_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.charge_code_controller.delete_charge_code(
                charge_code_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_charge_code_action_buttons_state(self):
        has_selection = (
            self.charge_codes_table is not None
            and self.charge_codes_table.currentItem() is not None
        )
        if self.edit_charge_code_btn:
            self.edit_charge_code_btn.setEnabled(has_selection)
        if self.toggle_charge_code_active_btn:
            self.toggle_charge_code_active_btn.setEnabled(has_selection)
        if self.delete_charge_code_btn:
            self.delete_charge_code_btn.setEnabled(has_selection)
        if (
            has_selection
            and self.toggle_charge_code_active_btn
            and self.charge_codes_table
        ):
            selected_row = self.charge_codes_table.currentRow()
            charge_code_id_item = self.charge_codes_table.item(selected_row, 0)
            if not charge_code_id_item:
                return
            charge_code_id = charge_code_id_item.data(Qt.ItemDataRole.UserRole)
            cc_obj = self.charge_code_controller.get_charge_code_by_id(charge_code_id)
            if cc_obj:
                action_text = "Deactivate" if cc_obj.is_active else "Activate"
                self.toggle_charge_code_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_charge_code_active_btn,
                    "toggle_inactive" if cc_obj.is_active else "standard",
                )

    # --- Owners Tab Methods ---
    def _create_owners_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_owner_btn = QPushButton("➕ Add New Owner")
        self._apply_standard_button_style(self.add_owner_btn, "add")
        self.edit_owner_btn = QPushButton("✏️ Edit Selected")
        self._apply_standard_button_style(self.edit_owner_btn, "edit")
        self.toggle_owner_active_btn = QPushButton("🔄 Toggle Active Status")
        self._apply_standard_button_style(self.toggle_owner_active_btn)
        self.delete_owner_btn = QPushButton("🗑️ Delete Selected")
        self._apply_standard_button_style(self.delete_owner_btn, "delete")
        button_layout.addWidget(self.add_owner_btn)
        button_layout.addWidget(self.edit_owner_btn)
        button_layout.addWidget(self.toggle_owner_active_btn)
        button_layout.addWidget(self.delete_owner_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.owner_status_filter_combo = QComboBox()
        self.owner_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.owner_status_filter_combo.setCurrentText(
            self._active_filters.get(self.OWNER_TAB_INDEX, "active")
        )
        self.owner_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.owner_status_filter_combo)
        layout.addLayout(top_bar_layout)
        self.owners_table = self._create_table_widget(
            [
                "Account #",
                "Farm Name",
                "Last Name",
                "First Name",
                "City",
                "State",
                "Phone",
                "Active",
            ]
        )
        if self.owners_table:
            self.owners_table.horizontalHeader().setSectionResizeMode(
                1, QHeaderView.ResizeMode.Stretch
            )
            self.owners_table.horizontalHeader().setSectionResizeMode(
                2, QHeaderView.ResizeMode.Stretch
            )
        layout.addWidget(self.owners_table)
        self._update_owner_action_buttons_state()
        return tab

    def load_owners_data(self):
        self.logger.info("Loading owners data for tab...")
        if not self.owners_table or not self.owner_status_filter_combo:
            self.logger.error("Owners table or filter combo not initialized.")
            return
        try:
            status_filter = self.owner_status_filter_combo.currentText().lower()
            self._active_filters[self.OWNER_TAB_INDEX] = status_filter
            owners = self.owner_controller.get_all_master_owners(
                status_filter=status_filter
            )
            self.owners_table.setRowCount(0)
            for owner_obj in owners:
                row_pos = self.owners_table.rowCount()
                self.owners_table.insertRow(row_pos)
                self.owners_table.setItem(
                    row_pos, 0, QTableWidgetItem(owner_obj.account_number or "")
                )
                self.owners_table.setItem(
                    row_pos, 1, QTableWidgetItem(owner_obj.farm_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 2, QTableWidgetItem(owner_obj.last_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 3, QTableWidgetItem(owner_obj.first_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 4, QTableWidgetItem(owner_obj.city or "")
                )
                state_display = owner_obj.state_code or ""
                if (
                    hasattr(owner_obj, "state")
                    and owner_obj.state
                    and hasattr(owner_obj.state, "state_code")
                ):
                    state_display = owner_obj.state.state_code
                self.owners_table.setItem(row_pos, 5, QTableWidgetItem(state_display))
                self.owners_table.setItem(
                    row_pos, 6, QTableWidgetItem(owner_obj.phone or "")
                )
                self.owners_table.setItem(
                    row_pos, 7, QTableWidgetItem("Yes" if owner_obj.is_active else "No")
                )
                self.owners_table.item(row_pos, 0).setData(
                    Qt.ItemDataRole.UserRole, owner_obj.owner_id
                )
            self.logger.info(f"Loaded {len(owners)} owners.")
        except Exception as e:
            self.logger.error(f"Error loading owners: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load owners: {e}")
        self._update_owner_action_buttons_state()

    def _on_owner_filter_changed(self, index: int):
        self.load_owners_data()

    def _add_owner(self):
        dialog = AddEditOwnerDialog(
            self,
            owner_controller=self.owner_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_owners_data()
            self.entity_updated.emit("owner")

    def _edit_selected_owner(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Edit Owner", "Please select an owner.")
            return
        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
        owner_to_edit = self.owner_controller.get_owner_by_id(owner_id)
        if owner_to_edit:
            dialog = AddEditOwnerDialog(
                self,
                owner_controller=self.owner_controller,
                owner_object=owner_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_owners_data()
                self.entity_updated.emit("owner")
        else:
            self.show_error("Error", f"Owner ID '{owner_id}' not found.")
            self.load_owners_data()

    def _toggle_selected_owner_active_status(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Toggle Status", "Please select an owner.")
            return
        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
        owner_obj = self.owner_controller.get_owner_by_id(owner_id)
        if not owner_obj:
            self.show_error("Error", f"Owner ID {owner_id} not found.")
            return
        action = "deactivate" if owner_obj.is_active else "activate"
        name_display = (
            owner_obj.farm_name
            or f"{owner_obj.first_name or ''} {owner_obj.last_name or ''}".strip()
            or f"ID: {owner_obj.owner_id}"
        )
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} owner '{name_display}'?",
        ):
            success, message = self.owner_controller.toggle_owner_active_status(
                owner_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_owners_data()
                self.entity_updated.emit("owner")
            else:
                self.show_error("Error", message)

    def _delete_selected_owner(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Delete Owner", "Please select an owner to delete.")
            return
        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole)
        display_name = (
            self.owners_table.item(selected_row, 1).text()
            or self.owners_table.item(selected_row, 2).text()
        )
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete owner '{display_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.owner_controller.delete_master_owner(
                owner_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_owners_data()
                self.entity_updated.emit("owner_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_owner_action_buttons_state(self):
        has_selection = (
            self.owners_table is not None
            and self.owners_table.currentItem() is not None
        )
        if self.edit_owner_btn:
            self.edit_owner_btn.setEnabled(has_selection)
        if self.toggle_owner_active_btn:
            self.toggle_owner_active_btn.setEnabled(has_selection)
        if self.delete_owner_btn:
            self.delete_owner_btn.setEnabled(has_selection)
        if has_selection and self.toggle_owner_active_btn and self.owners_table:
            selected_row = self.owners_table.currentRow()
            owner_id_item = self.owners_table.item(selected_row, 0)
            if not owner_id_item:
                return
            owner_id = (
                owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
            )
            owner_obj = self.owner_controller.get_owner_by_id(owner_id)
            if owner_obj:
                action_text = "Deactivate" if owner_obj.is_active else "Activate"
                self.toggle_owner_active_btn.setText(f"🔄 {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_owner_active_btn,
                    "toggle_inactive" if owner_obj.is_active else "standard",
                )

    # --- Company Profile Tab ---
    def _create_company_profile_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(25, 25, 25, 25)
        layout.setSpacing(15)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        title = QLabel("Company Profile Management")
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 14, QFont.Weight.Bold)
        title.setFont(title_font)
        title.setStyleSheet(f"color: {AppConfig.DARK_TEXT_PRIMARY};")
        description = QLabel(
            "Here you can set your company's information, which will be used on invoices and other reports."
        )
        description.setStyleSheet(f"color: {AppConfig.DARK_TEXT_SECONDARY};")
        description.setWordWrap(True)
        self.edit_profile_btn = QPushButton("✏️ Edit Company Profile")
        self._apply_standard_button_style(self.edit_profile_btn, "edit")
        self.edit_profile_btn.setMinimumHeight(40)
        self.edit_profile_btn.setFixedWidth(250)
        layout.addWidget(title)
        layout.addWidget(description)
        layout.addSpacing(20)
        layout.addWidget(self.edit_profile_btn)
        return tab

    def _launch_company_profile_dialog(self):
        dialog = CompanyProfileDialog(self, self.current_user_id)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.entity_updated.emit("company_profile")
            self.show_info("Success", "Company profile has been updated.")

    def _on_app_paths_saved(self):
        self.logger.info(
            "Application paths saved successfully. Emitting entity_updated signal."
        )
        self.entity_updated.emit("app_paths")

    # NEW: Slot to handle operation_completed signal from BackupRestoreTab
    def _on_backup_restore_completed(self, operation_status: str):
        self.logger.info(
            f"Backup/Restore operation completed with status: {operation_status}"
        )
        # This signal could trigger a general refresh or a specific status bar update
        self.entity_updated.emit(
            operation_status
        )  # e.g., "backup_success", "restore_success"


=============== FILE: views/admin/dialogs/__init__.py ===============

# views/admin/dialogs/__init__.py
"""
EDSI Veterinary Management System - Admin Dialogs Package
"""
from .add_edit_user_dialog import AddEditUserDialog
from .add_edit_location_dialog import AddEditLocationDialog
from .add_edit_charge_code_dialog import AddEditChargeCodeDialog
from .add_edit_charge_code_category_dialog import AddEditChargeCodeCategoryDialog
from .add_edit_owner_dialog import AddEditOwnerDialog
from .company_profile_dialog import CompanyProfileDialog
from .add_edit_veterinarian_dialog import AddEditVeterinarianDialog

__all__ = [
    "AddEditUserDialog",
    "AddEditLocationDialog",
    "AddEditChargeCodeDialog",
    "AddEditChargeCodeCategoryDialog",
    "AddEditOwnerDialog",
    "CompanyProfileDialog",
    "AddEditVeterinarianDialog",
]


=============== FILE: views/admin/dialogs/add_edit_charge_code_category_dialog.py ===============

# views/admin/dialogs/add_edit_charge_code_category_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Category/Process Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing charge code categories (Level 1)
         and processes (Level 2).
Last Updated: June 3, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCodeCategory

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeCategoryDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        category_to_edit: Optional[ChargeCodeCategory] = None,
        parent_category: Optional[
            ChargeCodeCategory
        ] = None,  # For adding a new Level 2 Process
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.category_to_edit = category_to_edit
        self.parent_category = (
            parent_category  # Will be None if adding/editing a Level 1 Category
        )

        self.is_edit_mode = self.category_to_edit is not None

        # Determine level
        if self.is_edit_mode:
            self.current_level = self.category_to_edit.level
            self.current_parent_id = self.category_to_edit.parent_id
            if (
                self.current_parent_id and not self.parent_category
            ):  # Fetch parent if editing L2 and not passed
                self.parent_category = self.controller.get_category_by_id_internal(
                    self.current_parent_id
                )

        elif self.parent_category:  # Adding a new Level 2 Process
            self.current_level = 2
            self.current_parent_id = self.parent_category.category_id
        else:  # Adding a new Level 1 Category
            self.current_level = 1
            self.current_parent_id = None

        self.item_type_name = "Process" if self.current_level == 2 else "Category"

        self.setWindowTitle(
            f"{'Edit' if self.is_edit_mode else 'Add New'} {self.item_type_name}"
        )
        self.setMinimumWidth(450)

        # Input Fields
        self.name_input: Optional[QLineEdit] = None
        self.parent_name_label: Optional[QLabel] = None  # To display parent name
        self.level_label: Optional[QLabel] = None  # To display level
        self.is_active_checkbox: Optional[QCheckBox] = None

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.category_to_edit:
            self._populate_fields()
        else:  # New item
            self.is_active_checkbox.setChecked(True)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {base_bg};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px;
                padding: 6px 10px; font-size: 13px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled {{ 
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QCheckBox::indicator {{ width: 13px; height: 13px; }}
            QCheckBox {{ color: {DARK_TEXT_PRIMARY}; background-color: transparent; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        # ... (rest of palette setup - can be copied from another dialog) ...
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str, is_field_value: bool = False) -> QLabel:
        label = QLabel(text)
        style = f"color: {DARK_TEXT_PRIMARY if is_field_value else DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        if is_field_value:
            style += f" padding-left: 5px; border: 1px solid {DARK_BORDER}; border-radius: 4px; background-color: {DARK_HEADER_FOOTER}; min-height: 20px;"

        label.setStyleSheet(style)
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText(f"Enter {self.item_type_name} Name")

        # Display Parent Category Name (if applicable)
        parent_display_name = (
            self.parent_category.name if self.parent_category else "N/A (Top Level)"
        )
        self.parent_name_label = self._create_label(
            parent_display_name, is_field_value=True
        )

        # Display Level
        self.level_label = self._create_label(
            str(self.current_level), is_field_value=True
        )

        self.is_active_checkbox = QCheckBox("Is Active")

        form_layout.addRow(
            self._create_label(f"{self.item_type_name} Name*:"), self.name_input
        )
        if self.current_level == 2:  # Only show parent for Processes (Level 2)
            form_layout.addRow(
                self._create_label("Parent Category:"), self.parent_name_label
            )
        form_layout.addRow(self._create_label("Level:"), self.level_label)
        form_layout.addRow(self._create_label("Status:"), self.is_active_checkbox)

        input_style = self._get_form_input_style()
        self.name_input.setStyleSheet(input_style)
        self.is_active_checkbox.setStyleSheet(input_style)  # For QCheckBox part

        layout.addLayout(form_layout)
        layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        if self.category_to_edit:
            self.name_input.setText(self.category_to_edit.name)
            self.is_active_checkbox.setChecked(self.category_to_edit.is_active)
            # Parent and Level are already set in __init__ and displayed by labels

    def get_data(self) -> Optional[Dict[str, Any]]:
        name = self.name_input.text().strip()
        if not name:
            QMessageBox.warning(
                self, "Input Error", f"{self.item_type_name} Name is required."
            )
            return None

        return {
            "name": name,
            "is_active": self.is_active_checkbox.isChecked(),
            "level": self.current_level,
            "parent_id": self.current_parent_id,
        }

    def validate_and_accept(self):
        data = self.get_data()
        if data is None:
            return

        # Use the controller's validation method
        is_valid, errors = self.controller.validate_charge_code_category_data(
            data,
            is_new=(not self.is_edit_mode),
            category_id=(
                self.category_to_edit.category_id if self.is_edit_mode else None
            ),
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Validation Error",
                "Please correct errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.category_to_edit:
                success, message = self.controller.update_charge_code_category(
                    self.category_to_edit.category_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code_category(
                    data, self.current_user_id
                )

            if success:
                if hasattr(
                    self.parent_view, "show_info"
                ):  # Check if parent_view has show_info
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error saving category/process: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {str(e)}"
            )


=============== FILE: views/admin/dialogs/add_edit_charge_code_dialog.py ===============

# views/admin/dialogs/add_edit_charge_code_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Dialog
Version: 1.1.12
Purpose: Dialog for creating and editing charge codes.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.1.12 (2025-06-09):
    - Bug Fix: In `validate_and_accept`, correctly pass the `charge_code_id_to_ignore`
      parameter to the validation method to allow saving of edited records.
- v1.1.11 (2025-06-05):
    - Bug Fix: Corrected dictionary key access for category path population.
"""

import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QTextEdit,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QHBoxLayout,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer, Slot

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCode as ChargeCodeModel
from models import ChargeCodeCategory

from config.app_config import AppConfig
import os

try:
    current_script_path_for_assets = os.path.dirname(os.path.abspath(__file__))
    project_root_for_assets = os.path.abspath(
        os.path.join(current_script_path_for_assets, "..", "..", "..")
    )
    assets_path = os.path.join(project_root_for_assets, "assets", "icons")
    if not os.path.exists(os.path.join(assets_path, "checkmark_light.svg")):
        assets_path = "assets/icons"
except Exception:
    assets_path = "assets/icons"


from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        charge_code: Optional[ChargeCodeModel] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.charge_code = charge_code
        self.is_edit_mode = charge_code is not None

        self.code_input: Optional[QLineEdit] = None
        self.alt_code_input: Optional[QLineEdit] = None
        self.description_input: Optional[QTextEdit] = None
        self.main_category_combo: Optional[QComboBox] = None
        self.sub_category_combo: Optional[QComboBox] = None
        self.standard_charge_input: Optional[QDoubleSpinBox] = None
        self.taxable_checkbox: Optional[QCheckBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Charge Code")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_main_categories()

        if self.is_edit_mode and self.charge_code:
            self._populate_fields()
        else:
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(True)
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(False)
            if self.sub_category_combo:
                self.sub_category_combo.setEnabled(False)

        if self.is_active_checkbox:
            self.is_active_checkbox.setEnabled(False)
        if self.taxable_checkbox:
            self.taxable_checkbox.setEnabled(False)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        checkmark_path = os.path.join(assets_path, "checkmark_light.svg").replace(
            os.sep, "/"
        )
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY};
            border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled, QTextEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER};
            color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER};
            }}
            QLineEdit[readOnly="true"] {{ background-color: {DARK_HEADER_FOOTER};
            color: {DARK_TEXT_TERTIARY}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent;
            }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY};
            }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
            border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
            QCheckBox::indicator:disabled {{ background-color: {DARK_INPUT_FIELD_BACKGROUND};
            border: 1px solid {DARK_TEXT_TERTIARY}; }}
            QCheckBox::indicator:checked:disabled {{ background-color: {DARK_PRIMARY_ACTION};
            border: 1px solid {DARK_PRIMARY_ACTION}; image: url({checkmark_path}); }}
            QCheckBox:disabled {{ color: {DARK_TEXT_SECONDARY};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)
        self.code_input = QLineEdit()
        self.code_input.setPlaceholderText("Unique code (e.g., EXAM01)")
        self.alt_code_input = QLineEdit()
        self.alt_code_input.setPlaceholderText("Alternative code (optional)")
        if self.alt_code_input:
            self.alt_code_input.textEdited.connect(self._on_alt_code_text_edited)

        self.main_category_combo = QComboBox()
        self.main_category_combo.setPlaceholderText("Select Main Category")
        self.sub_category_combo = QComboBox()
        self.sub_category_combo.setPlaceholderText("Select Sub-Category")
        self.description_input = QTextEdit()
        self.description_input.setPlaceholderText("Detailed description")
        self.description_input.setFixedHeight(70)
        self.standard_charge_input = QDoubleSpinBox()
        self.standard_charge_input.setDecimals(2)
        self.standard_charge_input.setRange(0.00, 99999.99)
        self.standard_charge_input.setPrefix("$ ")
        self.standard_charge_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.taxable_checkbox = QCheckBox("Taxable")
        self.taxable_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )
        self.is_active_checkbox = QCheckBox("Active")
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Alt. Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.alt_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Main Category*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.main_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Sub-Category:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.sub_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Standard Charge*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.standard_charge_input, row, 1)
        status_layout = QHBoxLayout()
        status_layout.addWidget(self.taxable_checkbox)
        status_layout.addSpacing(20)
        status_layout.addWidget(self.is_active_checkbox)
        status_layout.addStretch()
        grid_layout.addLayout(
            status_layout,
            row,
            2,
            1,
            2,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )
        row += 1
        grid_layout.addWidget(
            self._create_label("Description*:"),
            row,
            0,
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight,
        )
        grid_layout.addWidget(self.description_input, row, 1, 1, 3)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        fields_to_style = [
            self.code_input,
            self.alt_code_input,
            self.description_input,
            self.main_category_combo,
            self.sub_category_combo,
            self.standard_charge_input,
        ]
        for field in fields_to_style:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_style = (
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
                button.setStyleSheet(ok_style)
        overall_layout.addWidget(self.button_box)
        if self.main_category_combo:
            self.main_category_combo.currentIndexChanged.connect(
                self._on_main_category_changed
            )

    @Slot(str)
    def _on_alt_code_text_edited(self, text: str):
        if self.alt_code_input:
            current_text = text
            uppercase_text = current_text.upper()
            if current_text != uppercase_text:
                self.alt_code_input.blockSignals(True)
                cursor_pos = self.alt_code_input.cursorPosition()
                self.alt_code_input.setText(uppercase_text)
                self.alt_code_input.setCursorPosition(cursor_pos)
                self.alt_code_input.blockSignals(False)

    def _load_main_categories(self):
        if not self.main_category_combo:
            return
        self.main_category_combo.clear()
        self.main_category_combo.addItem("Select Main Category...", None)
        try:
            categories = self.controller.get_charge_code_categories(level=1)
            for cat in categories:
                self.main_category_combo.addItem(cat.name, cat.category_id)
        except Exception as e:
            self.logger.error(f"Error loading main categories: {e}", exc_info=True)

    def _on_main_category_changed(self, index: int):
        if not self.main_category_combo or not self.sub_category_combo:
            return
        self.sub_category_combo.clear()
        self.sub_category_combo.addItem("Select Sub-Category...", None)
        parent_id = self.main_category_combo.itemData(index)
        if parent_id is not None:
            try:
                sub_categories = self.controller.get_charge_code_categories(
                    parent_id=parent_id, level=2
                )
                if sub_categories:
                    for cat in sub_categories:
                        self.sub_category_combo.addItem(cat.name, cat.category_id)
                    self.sub_category_combo.setEnabled(True)
                else:
                    self.sub_category_combo.setEnabled(False)
            except Exception as e:
                self.logger.error(
                    f"Error loading sub-categories for parent_id {parent_id}: {e}",
                    exc_info=True,
                )
                self.sub_category_combo.setEnabled(False)
        else:
            self.sub_category_combo.setEnabled(False)

    def _populate_fields(self):
        if self.is_edit_mode and self.charge_code:
            self.code_input.setText(self.charge_code.code)
            self.code_input.setReadOnly(True)
            self.code_input.setStyleSheet(
                self._get_form_input_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
            )
            self.alt_code_input.setText(self.charge_code.alternate_code or "")
            self.description_input.setPlainText(self.charge_code.description)
            self.standard_charge_input.setValue(
                float(self.charge_code.standard_charge)
                if self.charge_code.standard_charge is not None
                else 0.0
            )
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(self.charge_code.taxable or False)
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(self.charge_code.is_active)
            if self.charge_code.category_id is not None:
                path = self.controller.get_category_path(self.charge_code.category_id)
                if path:
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(True)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(True)
                    if len(path) > 0 and self.main_category_combo:
                        main_cat_id = path[0]["id"]
                        index = self.main_category_combo.findData(main_cat_id)
                        if index >= 0:
                            self.main_category_combo.setCurrentIndex(index)
                        self._on_main_category_changed(
                            self.main_category_combo.currentIndex()
                        )
                    if len(path) > 1 and self.sub_category_combo:
                        sub_cat_id = path[1]["id"]
                        QTimer.singleShot(
                            0,
                            lambda: self._select_combo_item(
                                self.sub_category_combo, sub_cat_id, False
                            ),
                        )
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(False)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(False)
            else:
                if self.sub_category_combo:
                    self.sub_category_combo.setEnabled(False)

    def _select_combo_item(
        self, combo: QComboBox, item_id_to_select: int, trigger_next_load: bool
    ):
        if not combo:
            return
        index = combo.findData(item_id_to_select)
        if index >= 0:
            combo.setCurrentIndex(index)

    def get_data(self) -> Optional[Dict[str, Any]]:
        code = self.code_input.text().strip().upper()
        description = self.description_input.toPlainText().strip()
        standard_charge_value = self.standard_charge_input.value()
        errors = []
        if not code:
            errors.append("Code is required.")
        if not description:
            errors.append("Description is required.")
        charge_decimal: Optional[Decimal] = None
        try:
            charge_decimal = Decimal(str(standard_charge_value))
            if charge_decimal < Decimal("0.00"):
                errors.append("Standard Charge cannot be negative.")
        except InvalidOperation:
            errors.append("Standard Charge must be a valid number (e.g., 25.00).")
        selected_category_id: Optional[int] = None
        if (
            self.sub_category_combo
            and self.sub_category_combo.currentIndex() > 0
            and self.sub_category_combo.isEnabled()
        ):
            selected_category_id = self.sub_category_combo.currentData()
        elif self.main_category_combo and self.main_category_combo.currentIndex() > 0:
            selected_category_id = self.main_category_combo.currentData()
        if selected_category_id is None:
            errors.append(
                "A category selection (Main Category, or Sub-Category if applicable) is required."
            )
        if errors:
            QMessageBox.warning(self, "Input Error", "\n".join(errors))
            return None
        return {
            "code": code,
            "alternate_code": self.alt_code_input.text().strip().upper() or None,
            "description": description,
            "category_id": selected_category_id,
            "standard_charge": charge_decimal,
        }

    def validate_and_accept(self):
        data = self.get_data()
        if data is None:
            return

        charge_code_id_to_ignore = (
            self.charge_code.id if self.is_edit_mode and self.charge_code else None
        )

        is_valid, errors = self.controller.validate_charge_code_data(
            data,
            is_new=(not self.is_edit_mode),
            charge_code_id_to_ignore=charge_code_id_to_ignore,
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.charge_code:
                success, message = self.controller.update_charge_code(
                    self.charge_code.id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code(
                    data, self.current_user_id
                )

            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(
                f"Error during charge code save/update: {e}", exc_info=True
            )
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views/admin/dialogs/add_edit_location_dialog.py ===============

# views/admin/dialogs/add_edit_location_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Location Dialog
Version: 1.1.6
Purpose: Dialog for creating and editing practice locations with detailed address fields,
         phone, email, contact person, and auto-populating country code.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.1.6 (2025-06-05):
    - In `validate_and_accept`, corrected the tuple unpacking for the `update_location`
      call to expect two return values (success, message) instead of three,
      resolving a ValueError.
- v1.1.5 (2025-06-02):
    - Added QLineEdit fields for Phone, Email, and Contact Person.
    - Updated QGridLayout in _setup_ui to include new fields.
    - Updated _populate_fields to load data for new fields.
    - Updated get_data to collect data from new fields.
    - Implemented _on_state_changed slot to auto-populate Country Code.
    - Modified _load_states_into_combobox to store country_code with state_code.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.location_controller import LocationController
from models import Location as LocationModel
from models import StateProvince as StateProvinceModel

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditLocationDialog(QDialog):
    def __init__(
        self,
        parent_view,
        controller: LocationController,
        current_user_id: str,
        location: Optional[LocationModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.controller = controller
        self.current_user_id = current_user_id
        self.location = location
        self.is_edit_mode = location is not None

        self.location_name_input: Optional[QLineEdit] = None
        self.contact_person_input: Optional[QLineEdit] = None
        self.address_line1_input: Optional[QLineEdit] = None
        self.address_line2_input: Optional[QLineEdit] = None
        self.city_input: Optional[QLineEdit] = None
        self.state_combo: Optional[QComboBox] = None
        self.zip_code_input: Optional[QLineEdit] = None
        self.country_code_input: Optional[QLineEdit] = None
        self.phone_input: Optional[QLineEdit] = None
        self.email_input: Optional[QLineEdit] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Location")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_states_into_combobox()
        if self.is_edit_mode and self.location:
            self._populate_fields()

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {base_bg};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; 
                border-radius: 4px;
                padding: 6px 10px; 
                font-size: 13px; 
                min-height: 20px; 
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled {{ 
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QComboBox::drop-down {{ 
                border: none;
                background-color: transparent;
            }}
            QComboBox::down-arrow {{ 
                color: {DARK_TEXT_SECONDARY}; 
            }}
            QComboBox QAbstractItemView {{ 
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)

        self.location_name_input = QLineEdit()
        self.location_name_input.setPlaceholderText("e.g., Main Barn, Paddock A")

        self.contact_person_input = QLineEdit()
        self.contact_person_input.setPlaceholderText("Name of contact person")

        self.address_line1_input = QLineEdit()
        self.address_line1_input.setPlaceholderText("Street Address")

        self.address_line2_input = QLineEdit()
        self.address_line2_input.setPlaceholderText("Apartment, Suite, etc. (Optional)")

        self.city_input = QLineEdit()
        self.city_input.setPlaceholderText("City/Town")

        self.state_combo = QComboBox()
        self.state_combo.setPlaceholderText("Select State/Province")
        self.state_combo.currentIndexChanged.connect(self._on_state_changed)

        self.zip_code_input = QLineEdit()
        self.zip_code_input.setPlaceholderText("Zip/Postal Code")

        self.country_code_input = QLineEdit()
        self.country_code_input.setPlaceholderText("e.g., USA, CAN")
        self.country_code_input.setMaxLength(10)

        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText("Primary phone number")

        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Contact email address")

        self.is_active_checkbox = QCheckBox("Location is Active")
        self.is_active_checkbox.setChecked(True)
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        grid_layout.addWidget(
            self._create_label("Location Name*:"), 0, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.location_name_input, 0, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Contact Person:"), 1, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.contact_person_input, 1, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Address Line 1:"), 2, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line1_input, 2, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Address Line 2:"), 3, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line2_input, 3, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("City:"), 4, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.city_input, 4, 1)
        grid_layout.addWidget(
            self._create_label("State/Province:"), 4, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.state_combo, 4, 3)
        grid_layout.addWidget(
            self._create_label("Zip/Postal Code:"), 5, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.zip_code_input, 5, 1)
        grid_layout.addWidget(
            self._create_label("Country Code:"), 5, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.country_code_input, 5, 3)
        grid_layout.addWidget(
            self._create_label("Phone:"), 6, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.phone_input, 6, 1)
        grid_layout.addWidget(
            self._create_label("Email:"), 6, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.email_input, 6, 3)
        grid_layout.addWidget(
            self.is_active_checkbox, 7, 1, 1, 1, Qt.AlignmentFlag.AlignLeft
        )

        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        for field in [
            self.location_name_input,
            self.contact_person_input,
            self.address_line1_input,
            self.address_line2_input,
            self.city_input,
            self.state_combo,
            self.zip_code_input,
            self.country_code_input,
            self.phone_input,
            self.email_input,
        ]:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_button_specific_style = (
                    f"background-color: {DARK_SUCCESS_ACTION}; color: white;"
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ {ok_button_specific_style} }}"
                )

        overall_layout.addWidget(self.button_box)

    def _load_states_into_combobox(self):
        if not self.state_combo:
            return
        self.state_combo.addItem("", None)
        session = None
        try:
            from config.database_config import db_manager

            session = db_manager.get_session()
            states: List[StateProvinceModel] = (
                session.query(StateProvinceModel)
                .filter(StateProvinceModel.is_active == True)
                .order_by(
                    StateProvinceModel.country_code, StateProvinceModel.state_name
                )
                .all()
            )
            for state in states:
                display_name = f"{state.state_name} ({state.state_code})"
                self.state_combo.addItem(
                    display_name,
                    {
                        "state_code": state.state_code,
                        "country_code": state.country_code,
                    },
                )
            self.logger.info(f"Loaded {len(states)} states into combobox.")
        except Exception as e:
            self.logger.error(f"Error loading states into combobox: {e}", exc_info=True)
            QMessageBox.warning(
                self, "Data Load Error", "Could not load states for selection."
            )
        finally:
            if session:
                session.close()

    def _on_state_changed(self, index: int):
        if not self.state_combo or not self.country_code_input:
            return
        selected_data = self.state_combo.itemData(index)
        if selected_data and isinstance(selected_data, dict):
            country_code = selected_data.get("country_code", "")
            self.country_code_input.setText(country_code)
        else:
            self.country_code_input.clear()

    def _populate_fields(self):
        if self.location:
            self.location_name_input.setText(self.location.location_name or "")
            self.contact_person_input.setText(self.location.contact_person or "")
            self.address_line1_input.setText(self.location.address_line1 or "")
            self.address_line2_input.setText(self.location.address_line2 or "")
            self.city_input.setText(self.location.city or "")
            if self.location.state_code:
                for i in range(self.state_combo.count()):
                    item_data = self.state_combo.itemData(i)
                    if (
                        item_data
                        and isinstance(item_data, dict)
                        and item_data.get("state_code") == self.location.state_code
                    ):
                        self.state_combo.setCurrentIndex(i)
                        break
                else:
                    self.logger.warning(
                        f"State code '{self.location.state_code}' not found in combobox. Location: {self.location.location_name}"
                    )
            else:
                self.state_combo.setCurrentIndex(0)
            self.zip_code_input.setText(self.location.zip_code or "")
            self.country_code_input.setText(self.location.country_code or "")
            self.phone_input.setText(self.location.phone or "")
            self.email_input.setText(self.location.email or "")
            self.is_active_checkbox.setChecked(self.location.is_active)

    def get_data(self) -> Dict[str, Any]:
        selected_state_code = None
        if self.state_combo.currentIndex() > 0:
            item_data = self.state_combo.currentData()
            if item_data and isinstance(item_data, dict):
                selected_state_code = item_data.get("state_code")

        return {
            "location_name": self.location_name_input.text(),
            "contact_person": self.contact_person_input.text(),
            "address_line1": self.address_line1_input.text(),
            "address_line2": self.address_line2_input.text(),
            "city": self.city_input.text(),
            "state_code": selected_state_code,
            "zip_code": self.zip_code_input.text(),
            "country_code": self.country_code_input.text(),
            "phone": self.phone_input.text(),
            "email": self.email_input.text(),
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        data = self.get_data()
        is_valid, errors = self.controller.validate_location_data(
            data,
            is_new=(not self.is_edit_mode),
            location_id_to_check_for_unique=(
                self.location.location_id
                if self.is_edit_mode and self.location
                else None
            ),
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.location:
                # MODIFIED: Correctly unpack the two return values from update_location
                success, message = self.controller.update_location(
                    self.location.location_id, data, self.current_user_id
                )
            else:
                # create_location returns three values
                success, message, _ = self.controller.create_location(
                    data, self.current_user_id
                )

            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    self.logger.warning(
                        "parent_view does not have show_info method. Using local QMessageBox."
                    )
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during location save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views/admin/dialogs/add_edit_owner_dialog.py ===============

# views/admin/dialogs/add_edit_owner_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Owner Dialog
Version: 1.1.0
Purpose: Dialog for creating and editing Owner master file records,
         including contact, address, and financial information.
         Styled to match HorseUnifiedManagement forms, using QGridLayout.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-09):
    - Fixed validation logic to correctly ignore the current record's own
      account number when checking for duplicates in edit mode.
    - Updated the main action button text to display "Save Owner" in edit mode
      and "Create Owner" in add mode for better clarity.
- v1.0.0 (2025-06-02):
    - Initial implementation.
    - Includes fields for account info, name, address (with state dropdown
      and auto-populated, read-only country), contact details, and financial info
      (Balance (display-only), Credit Limit, Billing Terms dropdown).
    - Uses QGridLayout for layout.
    - Styled using _get_form_input_style (adapted from HorseUnifiedManagement)
      and _create_label helper.
    - Populates states from OwnerController and billing terms from a predefined list.
    - Implements _on_state_changed to auto-populate country code.
    - Implements _populate_fields, get_data, and validate_and_accept methods.
"""

import logging
from typing import Optional, Dict, Any, List
from decimal import Decimal, InvalidOperation

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QDoubleSpinBox,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController
from models import Owner as OwnerModel

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)

PREDEFINED_BILLING_TERMS = [
    "Net 30 Days",
    "Net 60 Days",
    "Net 90 Days",
    "Due on Receipt",
    "COD",
    "Prepay",
    "Monthly Statement",
]


class AddEditOwnerDialog(QDialog):
    def __init__(
        self,
        parent_view,
        owner_controller: OwnerController,
        current_user_id: str,
        owner_object: Optional[OwnerModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.owner_controller = owner_controller
        self.current_user_id = current_user_id
        self.owner = owner_object
        self.is_edit_mode = owner_object is not None

        self.account_number_input: Optional[QLineEdit] = None
        self.farm_name_input: Optional[QLineEdit] = None
        self.first_name_input: Optional[QLineEdit] = None
        self.last_name_input: Optional[QLineEdit] = None
        self.address_line1_input: Optional[QLineEdit] = None
        self.address_line2_input: Optional[QLineEdit] = None
        self.city_input: Optional[QLineEdit] = None
        self.state_combo: Optional[QComboBox] = None
        self.zip_code_input: Optional[QLineEdit] = None
        self.country_code_input: Optional[QLineEdit] = None
        self.phone_input: Optional[QLineEdit] = None
        self.mobile_phone_input: Optional[QLineEdit] = None
        self.email_input: Optional[QLineEdit] = None
        self.balance_display_input: Optional[QLineEdit] = None
        self.credit_limit_input: Optional[QDoubleSpinBox] = None
        self.billing_terms_combo: Optional[QComboBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Owner")
        self.setMinimumWidth(700)

        self._setup_palette()
        self._setup_ui()
        self._load_reference_data_into_combos()
        if self.is_edit_mode and self.owner:
            self._populate_fields()

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox, QDoubleSpinBox {{
                background-color: {base_bg}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px;
                padding: 6px 10px; font-size: 13px; min-height: 20px; 
            }}
            QLineEdit:focus, QComboBox:focus, QDoubleSpinBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled, QDoubleSpinBox:disabled {{ 
                background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
            }}
            QComboBox::drop-down {{ border: none; background-color: transparent; }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QComboBox QAbstractItemView {{ 
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)

        self.account_number_input = QLineEdit()
        self.account_number_input.setPlaceholderText("e.g., SMIJ01")
        self.farm_name_input = QLineEdit()
        self.farm_name_input.setPlaceholderText("Optional")
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Contact's First Name")
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Contact's Last Name")
        self.address_line1_input = QLineEdit()
        self.address_line1_input.setPlaceholderText("Street address, P.O. box")
        self.address_line2_input = QLineEdit()
        self.address_line2_input.setPlaceholderText("Apt, suite, etc. (Optional)")
        self.city_input = QLineEdit()
        self.city_input.setPlaceholderText("City/Town")
        self.state_combo = QComboBox()
        self.state_combo.setPlaceholderText("Select State/Province")
        self.zip_code_input = QLineEdit()
        self.zip_code_input.setPlaceholderText("Zip/Postal Code")
        self.country_code_input = QLineEdit()
        self.country_code_input.setPlaceholderText("Auto (e.g. USA, CAN)")
        self.country_code_input.setReadOnly(True)
        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText("(xxx) xxx-xxxx")
        self.mobile_phone_input = QLineEdit()
        self.mobile_phone_input.setPlaceholderText("Optional")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("example@domain.com")
        self.balance_display_input = QLineEdit("0.00")
        self.balance_display_input.setReadOnly(True)
        self.balance_display_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.credit_limit_input = QDoubleSpinBox()
        self.credit_limit_input.setDecimals(2)
        self.credit_limit_input.setRange(0.00, 9999999.99)
        self.credit_limit_input.setPrefix("$ ")
        self.credit_limit_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.credit_limit_input.setValue(0.00)
        self.billing_terms_combo = QComboBox()
        self.is_active_checkbox = QCheckBox("Owner is Active")
        self.is_active_checkbox.setChecked(True)
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Account #:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.account_number_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Farm Name:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.farm_name_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("First Name:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.first_name_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Last Name:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.last_name_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Address Line 1*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line1_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Address Line 2:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line2_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("City*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.city_input, row, 1)
        grid_layout.addWidget(
            self._create_label("State/Province*:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.state_combo, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Zip/Postal Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.zip_code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Country Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.country_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Phone:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.phone_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Mobile Phone:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.mobile_phone_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Email:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.email_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Balance:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.balance_display_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Credit Limit:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.credit_limit_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Billing Terms:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.billing_terms_combo, row, 1)
        grid_layout.addWidget(
            self.is_active_checkbox, row, 3, Qt.AlignmentFlag.AlignLeft
        )

        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 120)
        grid_layout.setColumnMinimumWidth(2, 120)

        form_style = self._get_form_input_style()
        all_fields = [
            self.account_number_input,
            self.farm_name_input,
            self.first_name_input,
            self.last_name_input,
            self.address_line1_input,
            self.address_line2_input,
            self.city_input,
            self.state_combo,
            self.zip_code_input,
            self.country_code_input,
            self.phone_input,
            self.mobile_phone_input,
            self.email_input,
            self.balance_display_input,
            self.credit_limit_input,
            self.billing_terms_combo,
        ]
        for field in all_fields:
            if field:
                field.setStyleSheet(form_style)

        read_only_style_addon = f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        if self.balance_display_input:
            self.balance_display_input.setStyleSheet(form_style + read_only_style_addon)
        if self.country_code_input:
            self.country_code_input.setStyleSheet(form_style + read_only_style_addon)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )

        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Save Owner" if self.is_edit_mode else "Create Owner")

        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_button_specific_style = (
                    f"background-color: {DARK_SUCCESS_ACTION}; color: white;"
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ {ok_button_specific_style} }}"
                )
        overall_layout.addWidget(self.button_box)

        self.state_combo.currentIndexChanged.connect(self._on_state_changed)

    def _load_reference_data_into_combos(self):
        if not self.state_combo:
            self.logger.error("State combo not initialized.")
            return
        self.state_combo.addItem("", None)
        try:
            ref_data = self.owner_controller.get_owner_form_reference_data()
            states = ref_data.get("states", [])
            for state_data in states:
                display_name = f"{state_data['name']} ({state_data['id']})"
                country_code = state_data.get("country_code", "USA")
                if country_code.upper() != "USA":
                    display_name += f" - {country_code}"
                self.state_combo.addItem(
                    display_name,
                    {"state_code": state_data["id"], "country_code": country_code},
                )
            self.logger.info(f"Loaded {len(states)} states into combobox.")
        except Exception as e:
            self.logger.error(
                f"Error loading states from controller: {e}", exc_info=True
            )
            QMessageBox.warning(
                self, "Data Load Error", "Could not load states for selection."
            )

        if not self.billing_terms_combo:
            self.logger.error("Billing terms combo not initialized.")
            return
        self.billing_terms_combo.addItem("", "")
        self.billing_terms_combo.addItems(PREDEFINED_BILLING_TERMS)
        self.billing_terms_combo.setCurrentIndex(0)
        self.logger.info(f"Loaded {len(PREDEFINED_BILLING_TERMS)} billing terms.")

    def _on_state_changed(self, index: int):
        if not self.state_combo or not self.country_code_input:
            return
        selected_data = self.state_combo.itemData(index)
        if selected_data and isinstance(selected_data, dict):
            country_code = selected_data.get("country_code", "")
            self.country_code_input.setText(country_code)
        else:
            self.country_code_input.clear()

    def _populate_fields(self):
        if self.owner:
            self.account_number_input.setText(self.owner.account_number or "")
            if self.is_edit_mode:
                self.account_number_input.setReadOnly(True)
                self.account_number_input.setStyleSheet(
                    self._get_form_input_style()
                    + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
                )

            self.farm_name_input.setText(self.owner.farm_name or "")
            self.first_name_input.setText(self.owner.first_name or "")
            self.last_name_input.setText(self.owner.last_name or "")
            self.address_line1_input.setText(self.owner.address_line1 or "")
            self.address_line2_input.setText(self.owner.address_line2 or "")
            self.city_input.setText(self.owner.city or "")

            current_state_code = self.owner.state_code
            if current_state_code:
                for i in range(self.state_combo.count()):
                    item_data = self.state_combo.itemData(i)
                    if (
                        item_data
                        and isinstance(item_data, dict)
                        and item_data.get("state_code") == current_state_code
                    ):
                        self.state_combo.setCurrentIndex(i)
                        break
            else:
                self.state_combo.setCurrentIndex(0)
                self.country_code_input.clear()

            self.zip_code_input.setText(self.owner.zip_code or "")

            self.phone_input.setText(self.owner.phone or "")
            self.mobile_phone_input.setText(self.owner.mobile_phone or "")
            self.email_input.setText(self.owner.email or "")

            self.balance_display_input.setText(
                f"{self.owner.balance:.2f}"
                if self.owner.balance is not None
                else "0.00"
            )
            self.credit_limit_input.setValue(
                float(self.owner.credit_limit)
                if self.owner.credit_limit is not None
                else 0.00
            )

            if self.owner.billing_terms:
                index = self.billing_terms_combo.findText(
                    self.owner.billing_terms, Qt.MatchFlag.MatchExactly
                )
                if index >= 0:
                    self.billing_terms_combo.setCurrentIndex(index)
                else:
                    self.billing_terms_combo.addItem(self.owner.billing_terms)
                    self.billing_terms_combo.setCurrentText(self.owner.billing_terms)
            else:
                if self.billing_terms_combo.count() > 0:
                    self.billing_terms_combo.setCurrentIndex(0)

            self.is_active_checkbox.setChecked(self.owner.is_active)

    def get_data(self) -> Optional[Dict[str, Any]]:
        selected_state_item_data = self.state_combo.currentData()
        selected_state_code = None
        if selected_state_item_data and isinstance(selected_state_item_data, dict):
            selected_state_code = selected_state_item_data.get("state_code")

        credit_limit_val = self.credit_limit_input.value()
        credit_limit_decimal: Optional[Decimal] = None
        try:
            credit_limit_decimal = Decimal(str(credit_limit_val))
        except InvalidOperation:
            self.logger.warning(
                f"Invalid decimal value for credit limit: {credit_limit_val}, treating as None."
            )

        data = {
            "account_number": self.account_number_input.text().strip() or None,
            "farm_name": self.farm_name_input.text().strip() or None,
            "first_name": self.first_name_input.text().strip() or None,
            "last_name": self.last_name_input.text().strip() or None,
            "address_line1": self.address_line1_input.text().strip() or None,
            "address_line2": self.address_line2_input.text().strip() or None,
            "city": self.city_input.text().strip() or None,
            "state_code": selected_state_code,
            "zip_code": self.zip_code_input.text().strip() or None,
            "phone": self.phone_input.text().strip() or None,
            "mobile_phone": self.mobile_phone_input.text().strip() or None,
            "email": self.email_input.text().strip() or None,
            "credit_limit": credit_limit_decimal,
            "billing_terms": (
                self.billing_terms_combo.currentText()
                if self.billing_terms_combo.currentIndex() > 0
                else None
            ),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        return data

    def validate_and_accept(self):
        owner_data = self.get_data()
        if owner_data is None:
            return

        owner_id_to_ignore = (
            self.owner.owner_id if self.is_edit_mode and self.owner else None
        )

        is_valid, errors = self.owner_controller.validate_owner_data(
            owner_data,
            is_new=(not self.is_edit_mode),
            owner_id_to_ignore=owner_id_to_ignore,
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.owner:
                success, message = self.owner_controller.update_master_owner(
                    self.owner.owner_id, owner_data, self.current_user_id
                )
            else:
                success, message, _ = self.owner_controller.create_master_owner(
                    owner_data, self.current_user_id
                )
            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during owner save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views/admin/dialogs/add_edit_user_dialog.py ===============

# views/admin/dialogs/add_edit_user_dialog.py
"""
EDSI Veterinary Management System - Add/Edit User Dialog
Version: 1.0.5
Purpose: Dialog for creating new users and editing existing user details.
         - Added current_user_id parameter to __init__ for auditing.
Last Updated: June 3, 2025
Author: Gemini (Modified by User's AI Assistant)

Changelog:
- v1.0.5 (2025-06-03):
    - Added `current_user_id: Optional[str] = None` to the `__init__`
      method signature to correctly accept the auditing user ID passed
      from UserManagementScreen. Stored as `self.audit_user_id`.
- v1.0.4 (2025-05-29):
    - Corrected attribute access in _populate_fields method:
        - Changed self.current_user_object.username to self.current_user_object.user_id.
        - Changed self.current_user_object.full_name to self.current_user_object.user_name.
- v1.0.3 (2025-05-29):
    - Modified USER_ROLES list to ["ADMIN", "VETERINARIAN"].
- v1.0.2 (2025-05-29):
    - Refactored _get_dialog_button_style() to use a triple-quoted f-string.
- v1.0.1 (2025-05-27):
    - Modified get_user_data() to return 'user_id' and 'user_name'.
    - Changed 'vet' to 'VETERINARIAN' in USER_ROLES.
- v1.0.0 (2025-05-20):
    - Initial implementation.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QComboBox,
    QCheckBox,
    QDialogButtonBox,
    QLabel,
    QMessageBox,
)
from PySide6.QtGui import QPalette, QColor, QFont  # Added QFont
from PySide6.QtCore import Qt

from controllers.user_controller import UserController
from models.user_models import User
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_BORDER,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_SUCCESS_ACTION,
    DARK_HEADER_FOOTER,
    DEFAULT_FONT_FAMILY,  # Added
)


class AddEditUserDialog(QDialog):
    """Dialog for adding or editing user information."""

    USER_ROLES = [
        "ADMIN",
        "VETERINARIAN",
        "MANAGER",
        "TECHNICIAN",
        "RECEPTIONIST",
    ]  # Restored full list for now

    def __init__(
        self,
        parent_view,
        user_controller: UserController,
        current_user_object: Optional[User] = None,
        current_user_id: Optional[
            str
        ] = None,  # MODIFIED: Added current_user_id for auditing
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.user_controller = user_controller
        self.current_user_object = current_user_object
        self.audit_user_id = current_user_id  # MODIFIED: Store the audit user ID

        self.is_edit_mode = self.current_user_object is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} User")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.current_user_object:
            self._populate_fields()

        self.logger.info(
            f"AddEditUserDialog initialized. Edit mode: {self.is_edit_mode}, Audit User: {self.audit_user_id}"
        )

    def _setup_palette(self):
        # ... (method remains unchanged from v1.0.4) ...
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(
            QPalette.ColorRole.AlternateBase, QColor(DARK_WIDGET_BACKGROUND)
        )  # Was DARK_ITEM_HOVER, check consistency
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(
            QPalette.ColorRole.Highlight, QColor(DARK_PRIMARY_ACTION)
        )  # Or DARK_HIGHLIGHT_BG
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_TEXT_PRIMARY)
        )  # Or DARK_HIGHLIGHT_TEXT
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _get_input_field_style(self) -> str:
        # ... (method remains unchanged from v1.0.4) ...
        return f"""
            QLineEdit, QComboBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {QColor(DARK_PRIMARY_ACTION).darker(130).name()}; /* Adjusted for better visibility */
            }}
            QCheckBox {{
                color: {DARK_TEXT_PRIMARY};
                background-color: transparent;
            }}
            QCheckBox::indicator {{
                width: 13px;
                height: 13px;
            }}
        """

    def _get_dialog_button_style(self) -> str:
        # ... (method remains unchanged from v1.0.4) ...
        return f"""
            QPushButton {{
                background-color: {DARK_BUTTON_BG};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px;
                font-size: 12px; font-weight: 500; min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: {DARK_BUTTON_HOVER};
            }}
            QPushButton:disabled {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
            }}
        """

    def _setup_ui(self):
        # ... (method remains unchanged from v1.0.4) ...
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        form_layout = QFormLayout()
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setFieldGrowthPolicy(
            QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow
        )

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter unique username (Login ID)")
        self.full_name_input = QLineEdit()
        self.full_name_input.setPlaceholderText("Enter user's full name (Display Name)")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Enter user's email address")
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText(
            "Enter password (leave blank to keep current)"
        )
        self.confirm_password_input = QLineEdit()
        self.confirm_password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.confirm_password_input.setPlaceholderText("Confirm new password")
        self.role_combo = QComboBox()
        self.role_combo.addItems(self.USER_ROLES)
        self.is_active_checkbox = QCheckBox("User is Active")
        self.is_active_checkbox.setChecked(True)

        input_style = self._get_input_field_style()
        for field in [
            self.username_input,
            self.full_name_input,
            self.email_input,
            self.password_input,
            self.confirm_password_input,
            self.role_combo,
            self.is_active_checkbox,
        ]:
            if field:
                field.setStyleSheet(input_style)

        form_layout.addRow(QLabel("Login ID*:"), self.username_input)
        form_layout.addRow(QLabel("Full Name*:"), self.full_name_input)
        form_layout.addRow(QLabel("Email:"), self.email_input)
        form_layout.addRow(
            QLabel("Password:" if self.is_edit_mode else "Password*:"),
            self.password_input,
        )
        form_layout.addRow(QLabel("Confirm Password:"), self.confirm_password_input)
        form_layout.addRow(QLabel("Role*:"), self.role_combo)
        form_layout.addRow(QLabel("Status:"), self.is_active_checkbox)

        for i in range(form_layout.rowCount()):
            label_widget = form_layout.labelForField(
                form_layout.itemAt(i, QFormLayout.ItemRole.FieldRole).widget()
            )
            if label_widget:
                label_widget.setStyleSheet(
                    f"color: {DARK_TEXT_SECONDARY}; background: transparent; padding-top: 3px; font-family: {DEFAULT_FONT_FAMILY};"
                )
                # label_widget.setFont(QFont(DEFAULT_FONT_FAMILY)) # Ensure font consistency

        layout.addLayout(form_layout)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Save User" if self.is_edit_mode else "Add User")
        dialog_button_style = self._get_dialog_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(dialog_button_style)
        ok_button.setStyleSheet(
            dialog_button_style
            + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
        )
        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        # ... (method remains unchanged from v1.0.4) ...
        if self.current_user_object:
            self.username_input.setText(self.current_user_object.user_id)
            self.username_input.setReadOnly(True)
            self.username_input.setStyleSheet(
                self._get_input_field_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; }}"
            )
            self.full_name_input.setText(self.current_user_object.user_name or "")
            self.email_input.setText(self.current_user_object.email or "")
            user_role_name_to_select = ""
            if self.current_user_object.roles:
                for role_obj in self.current_user_object.roles:
                    if role_obj.name in self.USER_ROLES:
                        user_role_name_to_select = role_obj.name
                        break
                if not user_role_name_to_select:
                    self.logger.warning(
                        f"User {self.current_user_object.user_id} has roles, but none match current dialog options: {[r.name for r in self.current_user_object.roles]}. Defaulting selection."
                    )
            role_index = -1
            if user_role_name_to_select:
                role_index = self.role_combo.findText(
                    user_role_name_to_select, Qt.MatchFlag.MatchExactly
                )
            if role_index >= 0:
                self.role_combo.setCurrentIndex(role_index)
            else:
                self.logger.warning(
                    f"Role '{user_role_name_to_select}' for user '{self.current_user_object.user_id}' not found in USER_ROLES dropdown. Defaulting."
                )
                if self.role_combo.count() > 0:
                    self.role_combo.setCurrentIndex(0)
                else:
                    self.logger.error(
                        "USER_ROLES is empty, cannot set default role index."
                    )
            self.is_active_checkbox.setChecked(self.current_user_object.is_active)

    def _validate_input(self) -> bool:
        # ... (method remains unchanged from v1.0.4) ...
        login_id = self.username_input.text().strip()
        user_name_val = self.full_name_input.text().strip()
        password = self.password_input.text()
        confirm_password = self.confirm_password_input.text()
        if not login_id:
            QMessageBox.warning(self, "Validation Error", "Login ID cannot be empty.")
            self.username_input.setFocus()
            return False
        if not user_name_val:
            QMessageBox.warning(self, "Validation Error", "Full Name cannot be empty.")
            self.full_name_input.setFocus()
            return False
        if not self.is_edit_mode and not password:
            QMessageBox.warning(
                self, "Validation Error", "Password cannot be empty for new users."
            )
            self.password_input.setFocus()
            return False
        if password and password != confirm_password:
            QMessageBox.warning(self, "Validation Error", "Passwords do not match.")
            self.confirm_password_input.setFocus()
            return False
        email = self.email_input.text().strip()
        if email and ("@" not in email or "." not in email.split("@")[-1]):
            QMessageBox.warning(
                self, "Validation Error", "Please enter a valid email address."
            )
            self.email_input.setFocus()
            return False
        if self.role_combo.currentIndex() == -1 and self.USER_ROLES:
            QMessageBox.warning(self, "Validation Error", "A role must be selected.")
            self.role_combo.setFocus()
            return False
        return True

    def get_user_data(self) -> Optional[Dict]:
        # ... (method remains unchanged from v1.0.4) ...
        if not self._validate_input():
            return None
        data = {
            "user_id": self.username_input.text().strip(),
            "user_name": self.full_name_input.text().strip(),
            "email": self.email_input.text().strip() or None,
            "role": self.role_combo.currentText(),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        password = self.password_input.text()
        if password:
            data["password"] = password
        return data

    def _on_accept(self):
        user_data = self.get_user_data()
        if user_data is None:
            return

        try:
            # Use self.audit_user_id for who is performing the action
            performing_user_id = self.audit_user_id

            if self.is_edit_mode and self.current_user_object:
                self.logger.info(
                    f"Attempting to update user ID: {self.current_user_object.user_id} by {performing_user_id}"
                )
                success, message = self.user_controller.update_user(
                    self.current_user_object.user_id, user_data, performing_user_id
                )
            else:
                self.logger.info(
                    f"Attempting to create new user: {user_data['user_id']} by {performing_user_id}"
                )
                success, message, _ = self.user_controller.create_user(
                    user_data, performing_user_id
                )

            if success:
                self.logger.info(f"User operation successful: {message}")
                self.accept()
            else:
                self.logger.warning(f"User operation failed: {message}")
                QMessageBox.critical(self, "Operation Failed", message)
        except Exception as e:
            self.logger.error(f"Error during user save/update: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")


=============== FILE: views/admin/dialogs/add_edit_veterinarian_dialog.py ===============

# views/admin/dialogs/add_edit_veterinarian_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Veterinarian Dialog
Version: 1.1.0
Purpose: UI dialog for creating and editing veterinarian records.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-09):
    - Replaced placeholder with a full UI implementation for data entry.
    - Added validation and interaction with VeterinarianController.
- v1.0.0 (2025-06-09):
    - Initial placeholder file created.
"""
import logging
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers import VeterinarianController
from models import Veterinarian
from config.app_config import AppConfig


class AddEditVeterinarianDialog(QDialog):
    """A dialog for creating or editing veterinarian records."""

    def __init__(
        self,
        parent_view,
        controller: VeterinarianController,
        current_user_id: str,
        veterinarian: Optional[Veterinarian] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.controller = controller
        self.current_user_id = current_user_id
        self.veterinarian = veterinarian
        self.is_edit_mode = veterinarian is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Veterinarian")
        self.setMinimumWidth(500)

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode:
            self._populate_fields()

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(
            QPalette.ColorRole.Window, QColor(AppConfig.DARK_WIDGET_BACKGROUND)
        )
        palette.setColor(
            QPalette.ColorRole.WindowText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        palette.setColor(
            QPalette.ColorRole.Base, QColor(AppConfig.DARK_INPUT_FIELD_BACKGROUND)
        )
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _get_input_field_style(self) -> str:
        return f"""
            QLineEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
        """

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setSpacing(10)

        input_style = self._get_input_field_style()

        self.first_name_input = QLineEdit()
        self.last_name_input = QLineEdit()
        self.license_number_input = QLineEdit()
        self.specialty_input = QLineEdit()
        self.phone_input = QLineEdit()
        self.email_input = QLineEdit()
        self.is_active_checkbox = QCheckBox("Veterinarian is Active")
        self.is_active_checkbox.setChecked(True)

        for field in [
            self.first_name_input,
            self.last_name_input,
            self.license_number_input,
            self.specialty_input,
            self.phone_input,
            self.email_input,
        ]:
            field.setStyleSheet(input_style)

        form_layout.addRow("First Name*:", self.first_name_input)
        form_layout.addRow("Last Name*:", self.last_name_input)
        form_layout.addRow("License #*:", self.license_number_input)
        form_layout.addRow("Specialty:", self.specialty_input)
        form_layout.addRow("Phone:", self.phone_input)
        form_layout.addRow("Email:", self.email_input)
        form_layout.addRow("", self.is_active_checkbox)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        main_layout.addLayout(form_layout)
        main_layout.addWidget(self.button_box)

    def _populate_fields(self):
        if self.veterinarian:
            self.first_name_input.setText(self.veterinarian.first_name)
            self.last_name_input.setText(self.veterinarian.last_name)
            self.license_number_input.setText(self.veterinarian.license_number)
            self.specialty_input.setText(self.veterinarian.specialty or "")
            self.phone_input.setText(self.veterinarian.phone or "")
            self.email_input.setText(self.veterinarian.email or "")
            self.is_active_checkbox.setChecked(self.veterinarian.is_active)

    def get_data(self) -> Dict[str, Any]:
        """Collects data from the form fields."""
        return {
            "first_name": self.first_name_input.text().strip(),
            "last_name": self.last_name_input.text().strip(),
            "license_number": self.license_number_input.text().strip(),
            "specialty": self.specialty_input.text().strip() or None,
            "phone": self.phone_input.text().strip() or None,
            "email": self.email_input.text().strip() or None,
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        vet_data = self.get_data()
        vet_id_to_ignore = self.veterinarian.vet_id if self.is_edit_mode else None

        is_valid, errors = self.controller.validate_veterinarian_data(
            vet_data, self.is_edit_mode, vet_id_to_ignore
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Validation Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode:
                success, message = self.controller.update_veterinarian(
                    self.veterinarian.vet_id, vet_data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_veterinarian(
                    vet_data, self.current_user_id
                )

            if success:
                QMessageBox.information(self, "Success", message)
                self.accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error saving veterinarian: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views/admin/dialogs/company_profile_dialog.py ===============

# views/admin/dialogs/company_profile_dialog.py
"""
EDSI Veterinary Management System - Company Profile Dialog
Version: 1.0.1
Purpose: Dialog for editing the main company profile information.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-06-09):
    - Bug Fix: Added QHBoxLayout to the PySide6.QtWidgets import list to resolve
      a NameError during UI setup.
- v1.0.0 (2025-06-08):
    - Initial creation of the dialog.
"""
import logging
from typing import Optional

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QFormLayout,
    QLineEdit,
    QTextEdit,
    QPushButton,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QFileDialog,
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QPalette, QColor

from controllers.company_profile_controller import CompanyProfileController
from config.app_config import AppConfig


class CompanyProfileDialog(QDialog):
    def __init__(self, parent, current_user_id: str):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.current_user_id = current_user_id
        self.controller = CompanyProfileController()

        self.setWindowTitle("Manage Company Profile")
        self.setMinimumWidth(600)

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()
        self._load_profile()

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.company_name_input = QLineEdit()
        self.address1_input = QLineEdit()
        self.address2_input = QLineEdit()
        self.city_input = QLineEdit()
        self.state_input = QLineEdit()
        self.zip_input = QLineEdit()
        self.phone_input = QLineEdit()
        self.email_input = QLineEdit()
        self.website_input = QLineEdit()
        self.logo_path_input = QLineEdit()
        self.browse_logo_btn = QPushButton("Browse...")

        logo_layout = QHBoxLayout()
        logo_layout.addWidget(self.logo_path_input)
        logo_layout.addWidget(self.browse_logo_btn)

        form_layout.addRow("Company Name*:", self.company_name_input)
        form_layout.addRow("Address 1:", self.address1_input)
        form_layout.addRow("Address 2:", self.address2_input)
        form_layout.addRow("City:", self.city_input)
        form_layout.addRow("State:", self.state_input)
        form_layout.addRow("Zip Code:", self.zip_input)
        form_layout.addRow("Phone:", self.phone_input)
        form_layout.addRow("Email:", self.email_input)
        form_layout.addRow("Website:", self.website_input)
        form_layout.addRow("Logo Path:", logo_layout)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Save
            | QDialogButtonBox.StandardButton.Cancel
        )

        layout.addLayout(form_layout)
        layout.addWidget(self.button_box)

    def _apply_styles(self):
        field_style = f"""
            QLineEdit, QTextEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QTextEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
        """
        for widget in self.findChildren(QLineEdit):
            widget.setStyleSheet(field_style)

    def _setup_connections(self):
        self.button_box.accepted.connect(self._save_profile)
        self.button_box.rejected.connect(self.reject)
        self.browse_logo_btn.clicked.connect(self._browse_for_logo)

    def _load_profile(self):
        profile = self.controller.get_company_profile()
        if profile:
            self.company_name_input.setText(profile.company_name or "")
            self.address1_input.setText(profile.address_line1 or "")
            self.address2_input.setText(profile.address_line2 or "")
            self.city_input.setText(profile.city or "")
            self.state_input.setText(profile.state or "")
            self.zip_input.setText(profile.zip_code or "")
            self.phone_input.setText(profile.phone or "")
            self.email_input.setText(profile.email or "")
            self.website_input.setText(profile.website or "")
            self.logo_path_input.setText(profile.logo_path or "")

    def _browse_for_logo(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Select Logo Image", "", "Image Files (*.png *.jpg *.jpeg *.bmp)"
        )
        if file_path:
            self.logo_path_input.setText(file_path)

    def _save_profile(self):
        if not self.company_name_input.text().strip():
            QMessageBox.warning(self, "Validation Error", "Company Name is required.")
            return

        data = {
            "company_name": self.company_name_input.text().strip(),
            "address_line1": self.address1_input.text().strip(),
            "address_line2": self.address2_input.text().strip(),
            "city": self.city_input.text().strip(),
            "state": self.state_input.text().strip(),
            "zip_code": self.zip_input.text().strip(),
            "phone": self.phone_input.text().strip(),
            "email": self.email_input.text().strip(),
            "website": self.website_input.text().strip(),
            "logo_path": self.logo_path_input.text().strip(),
        }

        success, message = self.controller.update_company_profile(
            data, self.current_user_id
        )
        if success:
            QMessageBox.information(self, "Success", message)
            self.accept()
        else:
            QMessageBox.critical(self, "Error", message)


=============== FILE: views/admin/tabs/__init__.py ===============

# views/admin/tabs/__init__.py
"""
EDSI Veterinary Management System - Admin Tabs Package
"""
# CORRECTED: Changed imports to point to the 'dialogs' subdirectory
from ..dialogs.add_edit_user_dialog import AddEditUserDialog
from ..dialogs.add_edit_location_dialog import AddEditLocationDialog
from ..dialogs.add_edit_charge_code_dialog import AddEditChargeCodeDialog
from ..dialogs.add_edit_charge_code_category_dialog import (
    AddEditChargeCodeCategoryDialog,
)
from ..dialogs.add_edit_owner_dialog import AddEditOwnerDialog
from ..dialogs.company_profile_dialog import CompanyProfileDialog
from ..dialogs.add_edit_veterinarian_dialog import AddEditVeterinarianDialog
from .application_paths_tab import ApplicationPathsTab
from .backup_restore_tab import BackupRestoreTab  # NEW: Import the new BackupRestoreTab


__all__ = [
    "AddEditUserDialog",
    "AddEditLocationDialog",
    "AddEditChargeCodeDialog",
    "AddEditChargeCodeCategoryDialog",
    "AddEditOwnerDialog",
    "CompanyProfileDialog",
    "AddEditVeterinarianDialog",
    "ApplicationPathsTab",
    "BackupRestoreTab",  # NEW: Add the new tab to __all__
]


=============== FILE: views/admin/tabs/application_paths_tab.py ===============

# views/admin/tabs/application_paths_tab.py

"""
EDSI Veterinary Management System - Application Paths Tab
Version: 1.0.3
Purpose: UI for configuring user-defined paths for the database, logs, invoices, and statements.
         Now receives ConfigManager via dependency injection.
Last Updated: June 23, 2025
Author: Gemini

Changelog:
- v1.0.3 (2025-06-23):
    - **CRITICAL BUG FIX (Finalizing Dependency Injection):** Removed all direct
      imports of `config_manager` and `ConfigManager` from this file.
    - Modified `__init__` to accept `config_manager_instance` as an argument
      and store it as `self._config_manager`.
    - All calls to `config_manager.get_path` and `config_manager.set_path`
      now use `self._config_manager`.
    - This completes the dependency injection for `ApplicationPathsTab`.
- v1.0.2 (2025-06-23):
    - **BUG FIX & UX IMPROVEMENT:** Modified `_browse_for_file` method.
      For the database file path, if the path in the QLineEdit already points
      to an existing file, it now uses `QFileDialog.getOpenFileName` to avoid
      the confusing "Do you want to replace it?" prompt.
- v1.0.1 (2025-06-23):
    - **BUG FIX:** Added `from typing import List` to resolve `NameError: name 'List' is not defined`
      in the `_validate_paths` method signature.
# ... (previous changelog entries)
"""

import os
import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QFormLayout,
    QLineEdit,
    QPushButton,
    QLabel,
    QFileDialog,
    QMessageBox,
    QApplication,  # For showing info/error via parent view
)
from PySide6.QtCore import Qt, Signal, QTimer, QCoreApplication
from PySide6.QtGui import QFont, QPalette, QColor

from config.app_config import AppConfig

# REMOVED: Direct import of config_manager and ConfigManager - now injected
# from config.config_manager import config_manager, ConfigManager


class ApplicationPathsTab(QWidget):
    """
    A tab widget for the UserManagementScreen allowing users to configure
    application-specific file and directory paths.
    """

    # Signal emitted when paths are successfully saved
    paths_saved = Signal()

    def __init__(
        self, parent_view: Optional[QWidget] = None, config_manager_instance=None
    ):  # NEW: Accept instance
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = (
            parent_view  # Reference to UserManagementScreen for message boxes
        )

        self._config_manager = config_manager_instance  # NEW: Store injected instance

        # Store initial paths to check for changes and for discard functionality
        self._initial_paths: Dict[str, str] = {}

        # UI Elements
        self.db_path_input: QLineEdit
        self.log_dir_input: QLineEdit
        self.invoices_dir_input: QLineEdit
        self.statements_dir_input: QLineEdit

        self.save_button: QPushButton
        self.discard_button: QPushButton

        self._has_unsaved_changes: bool = False
        self._suppress_data_changed_signal = (
            False  # To prevent signal emission during programmatic updates
        )

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()
        self._load_current_paths()
        self.update_buttons_state()  # Initial state of buttons

    def _get_input_field_style(self) -> str:
        """Generates the standard style for input fields."""
        return (
            f"QLineEdit {{ background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND}; "
            f"color: {AppConfig.DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {AppConfig.DARK_BORDER}; border-radius: 4px; "
            f"padding: 6px 10px; font-size: 13px; min-height: 22px; }}"
            f"QLineEdit:focus {{ border-color: {AppConfig.DARK_PRIMARY_ACTION}; }}"
            f"QLineEdit:read-only {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; "
            f"color: {AppConfig.DARK_TEXT_TERTIARY}; }}"
        )

    def _get_button_style(self, btn_type: str = "standard") -> str:
        """Generates button styles based on type."""
        base_style = (
            f"QPushButton {{ background-color: {AppConfig.DARK_BUTTON_BG}; "
            f"color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_BORDER}; "
            f"border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; "
            f"min-height: 28px; }}"
            f"QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}"
            f"QPushButton:disabled {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; "
            f"color: {AppConfig.DARK_TEXT_TERTIARY}; border-color: {AppConfig.DARK_HEADER_FOOTER}; }}"
        )
        if btn_type == "save":
            return (
                f"{base_style} QPushButton {{ background-color: {AppConfig.DARK_SUCCESS_ACTION}; "
                f"color: white; border-color: {AppConfig.DARK_SUCCESS_ACTION}; }}"
                f"QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}"
            )
        elif btn_type == "browse":
            return (
                f"{base_style} QPushButton {{ background-color: {AppConfig.DARK_PRIMARY_ACTION}; "
                f"color: white; border-color: {AppConfig.DARK_PRIMARY_ACTION}; }}"
                f"QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_PRIMARY_ACTION).lighter(115).name()}; }}"
            )
        return base_style

    def _setup_ui(self):
        """Initializes and lays out the UI widgets."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        main_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        description_label = QLabel(
            "Configure the main file and directory paths for the application data. "
            "Changing these paths will require an application restart to take full effect."
        )
        description_label.setWordWrap(True)
        description_label.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-bottom: 10px;"
        )
        main_layout.addWidget(description_label)

        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setSpacing(10)
        form_layout.setContentsMargins(0, 0, 0, 0)  # No extra margins for form

        # Database File Path
        self.db_path_input = QLineEdit()
        self.db_path_input.setPlaceholderText("e.g., C:/EDMS_Data/edsi_database.db")
        self.db_browse_btn = QPushButton("Browse...")
        db_h_layout = QHBoxLayout()
        db_h_layout.addWidget(self.db_path_input)
        db_h_layout.addWidget(self.db_browse_btn)
        form_layout.addRow(QLabel("Database File:"), db_h_layout)

        # Log Directory
        self.log_dir_input = QLineEdit()
        self.log_dir_input.setPlaceholderText("e.g., C:/EDMS_Data/logs")
        self.log_browse_btn = QPushButton("Browse...")
        log_h_layout = QHBoxLayout()
        log_h_layout.addWidget(self.log_dir_input)
        log_h_layout.addWidget(self.log_browse_btn)
        form_layout.addRow(QLabel("Logs Directory:"), log_h_layout)

        # Invoices Directory
        self.invoices_dir_input = QLineEdit()
        self.invoices_dir_input.setPlaceholderText("e.g., C:/EDMS_Data/invoices")
        self.invoices_browse_btn = QPushButton("Browse...")
        invoices_h_layout = QHBoxLayout()
        invoices_h_layout.addWidget(self.invoices_dir_input)
        invoices_h_layout.addWidget(self.invoices_browse_btn)
        form_layout.addRow(QLabel("Invoices Directory:"), invoices_h_layout)

        # Statements Directory (NEW)
        self.statements_dir_input = QLineEdit()
        self.statements_dir_input.setPlaceholderText("e.g., C:/EDMS_Data/statements")
        self.statements_browse_btn = QPushButton("Browse...")
        statements_h_layout = QHBoxLayout()
        statements_h_layout.addWidget(self.statements_dir_input)
        statements_h_layout.addWidget(self.statements_browse_btn)
        form_layout.addRow(QLabel("Statements Directory:"), statements_h_layout)

        main_layout.addLayout(form_layout)

        # Spacer to push buttons to the bottom if content is sparse
        main_layout.addStretch(1)

        # Action Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch(1)  # Push buttons to the right

        self.discard_button = QPushButton("Discard Changes")
        self.save_button = QPushButton("Save Paths")

        button_layout.addWidget(self.discard_button)
        button_layout.addWidget(self.save_button)

        main_layout.addLayout(button_layout)

    def _apply_styles(self):
        """Applies consistent styling to the widgets."""
        # Labels
        for label in self.findChildren(QLabel):
            label.setStyleSheet(f"color: {AppConfig.DARK_TEXT_PRIMARY};")
            label.setFont(QFont(AppConfig.DEFAULT_FONT_FAMILY, 10))

        # Line Edits
        for line_edit in self.findChildren(QLineEdit):
            line_edit.setStyleSheet(self._get_input_field_style())
            line_edit.setFont(QFont(AppConfig.DEFAULT_FONT_FAMILY, 10))

        # Buttons
        self.db_browse_btn.setStyleSheet(self._get_button_style("browse"))
        self.log_browse_btn.setStyleSheet(self._get_button_style("browse"))
        self.invoices_browse_btn.setStyleSheet(self._get_button_style("browse"))
        self.statements_browse_btn.setStyleSheet(self._get_button_style("browse"))

        self.save_button.setStyleSheet(self._get_button_style("save"))
        self.discard_button.setStyleSheet(self._get_button_style("standard"))

    def _setup_connections(self):
        """Connects signals to slots."""
        self.db_browse_btn.clicked.connect(
            lambda: self._browse_for_file(self.db_path_input, file_mode=True)
        )
        self.log_browse_btn.clicked.connect(
            lambda: self._browse_for_file(self.log_dir_input, file_mode=False)
        )
        self.invoices_browse_btn.clicked.connect(
            lambda: self._browse_for_file(self.invoices_dir_input, file_mode=False)
        )
        self.statements_browse_btn.clicked.connect(
            lambda: self._browse_for_file(self.statements_dir_input, file_mode=False)
        )

        # Connect textChanged signals for input fields to detect unsaved changes
        self.db_path_input.textChanged.connect(self._on_input_changed)
        self.log_dir_input.textChanged.connect(self._on_input_changed)
        self.invoices_dir_input.textChanged.connect(self._on_input_changed)
        self.statements_dir_input.textChanged.connect(self._on_input_changed)

        self.save_button.clicked.connect(self._save_paths)
        self.discard_button.clicked.connect(self._discard_changes)

    def _load_current_paths(self):
        """Loads the current paths from ConfigManager and populates inputs."""
        self._suppress_data_changed_signal = (
            True  # Suppress signals during programmatic update
        )

        # Use the injected _config_manager instance
        self.db_path_input.setText(
            self._config_manager.get_path(self._config_manager.DB_PATH_KEY) or ""
        )
        self.log_dir_input.setText(
            self._config_manager.get_path(self._config_manager.LOG_DIR_KEY) or ""
        )
        self.invoices_dir_input.setText(
            self._config_manager.get_path(self._config_manager.INVOICES_DIR_KEY) or ""
        )
        self.statements_dir_input.setText(
            self._config_manager.get_path(self._config_manager.STATEMENTS_DIR_KEY) or ""
        )

        # Store these as initial paths to check for changes
        self._initial_paths = self._get_current_input_paths()

        self._suppress_data_changed_signal = False
        self._has_unsaved_changes = False  # No changes immediately after loading
        self.update_buttons_state()

    def _get_current_input_paths(self) -> Dict[str, str]:
        """Helper to get current text from all input fields."""
        # Use the injected _config_manager instance for keys
        return {
            self._config_manager.DB_PATH_KEY: self.db_path_input.text().strip(),
            self._config_manager.LOG_DIR_KEY: self.log_dir_input.text().strip(),
            self._config_manager.INVOICES_DIR_KEY: self.invoices_dir_input.text().strip(),
            self._config_manager.STATEMENTS_DIR_KEY: self.statements_dir_input.text().strip(),
        }

    def _on_input_changed(self):
        """Slot to mark that there are unsaved changes."""
        if self._suppress_data_changed_signal:
            return

        current_paths = self._get_current_input_paths()
        # Compare current paths with initial paths to determine if there are actual changes
        if current_paths != self._initial_paths:
            if not self._has_unsaved_changes:
                self.logger.debug("Changes detected in path inputs.")
                self._has_unsaved_changes = True
                self.update_buttons_state()
        else:
            if self._has_unsaved_changes:
                self.logger.debug("Changes reverted in path inputs.")
                self._has_unsaved_changes = False
                self.update_buttons_state()

    def _browse_for_file(self, line_edit: QLineEdit, file_mode: bool = False):
        """
        Opens a file dialog for selecting a file or directory.
        For file selection (database), it now intelligently switches between
        getOpenFileName (if file exists) and getSaveFileName (if new file).
        """
        initial_path = line_edit.text() if line_edit.text() else os.path.expanduser("~")

        if file_mode:  # This is specifically for the database file
            selected_path = None

            # Check if the current path in the QLineEdit points to an existing file
            if os.path.exists(initial_path) and os.path.isfile(initial_path):
                self.logger.debug(
                    f"Browsing for existing database file at: {initial_path}"
                )
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Existing Database File",
                    initial_path,
                    "SQLite Database Files (*.db);;All Files (*.*)",
                )
                if file_path:
                    selected_path = file_path
            else:
                self.logger.debug(
                    f"Browsing to create/select new database file. Initial: {initial_path}"
                )
                # If the path is empty or does not exist, use getSaveFileName
                # This is where the "replace" prompt will appear if user types an existing name,
                # but it's appropriate for *creating* new files.
                file_path, _ = QFileDialog.getSaveFileName(
                    self,
                    "Create or Select Database File",
                    initial_path,
                    "SQLite Database Files (*.db);;All Files (*.*)",
                )
                if file_path:
                    selected_path = file_path

            if selected_path:
                line_edit.setText(selected_path)

        else:  # This is for directory selection (logs, invoices, statements)
            self.logger.debug(f"Browsing for directory. Initial: {initial_path}")
            dir_path = QFileDialog.getExistingDirectory(
                self, "Select Directory", initial_path
            )
            if dir_path:
                line_edit.setText(dir_path)

    def _save_paths(self):
        """Validates and saves the configured paths."""
        paths_to_save = self._get_current_input_paths()
        errors = self._validate_paths(paths_to_save)

        if errors:
            self._show_message(
                "Validation Error", "\n".join(errors), QMessageBox.Warning
            )
            return

        try:
            # Use the injected _config_manager instance
            self._config_manager.set_path(
                self._config_manager.DB_PATH_KEY,
                paths_to_save[self._config_manager.DB_PATH_KEY],
            )
            self._config_manager.set_path(
                self._config_manager.LOG_DIR_KEY,
                paths_to_save[self._config_manager.LOG_DIR_KEY],
            )
            self._config_manager.set_path(
                self._config_manager.INVOICES_DIR_KEY,
                paths_to_save[self._config_manager.INVOICES_DIR_KEY],
            )
            self._config_manager.set_path(
                self._config_manager.STATEMENTS_DIR_KEY,
                paths_to_save[self._config_manager.STATEMENTS_DIR_KEY],
            )

            self._initial_paths = (
                paths_to_save  # Update initial paths after successful save
            )
            self._has_unsaved_changes = False
            self.update_buttons_state()
            self._show_message(
                "Paths Saved",
                "Application paths saved successfully. Restart the application for changes to take full effect.",
                QMessageBox.Information,
            )
            self.paths_saved.emit()  # Emit signal on successful save
        except Exception as e:
            self.logger.error(f"Error saving application paths: {e}", exc_info=True)
            self._show_message(
                "Save Error",
                f"An unexpected error occurred while saving paths: {e}",
                QMessageBox.Critical,
            )

    def _validate_paths(self, paths: Dict[str, str]) -> List[str]:
        """Performs basic validation on the paths."""
        validation_errors = []

        # Use the injected _config_manager instance for keys
        if not paths[self._config_manager.DB_PATH_KEY]:
            validation_errors.append("Database File path cannot be empty.")
        elif not os.path.isabs(paths[self._config_manager.DB_PATH_KEY]):
            validation_errors.append("Database File path must be an absolute path.")

        for key in [
            self._config_manager.LOG_DIR_KEY,
            self._config_manager.INVOICES_DIR_KEY,
            self._config_manager.STATEMENTS_DIR_KEY,
        ]:
            if not paths[key]:
                validation_errors.append(
                    f"{key.replace('_', ' ').title()} cannot be empty."
                )
            elif not os.path.isabs(paths[key]):
                validation_errors.append(
                    f"{key.replace('_', ' ').title()} must be an absolute path."
                )

        return validation_errors

    def _discard_changes(self):
        """Discards unsaved changes and reloads initial paths."""
        if self._has_unsaved_changes:
            reply = self._show_message(
                "Discard Changes",
                "Are you sure you want to discard all unsaved changes to paths?",
                QMessageBox.Question,
                QMessageBox.Yes | QMessageBox.No,
            )
            if reply == QMessageBox.No:
                return

        self.logger.info("Discarding changes to application paths.")
        self._load_current_paths()  # Reloads from config_manager or previous _initial_paths
        self.update_buttons_state()
        self._show_message(
            "Changes Discarded",
            "All unsaved changes to application paths have been discarded.",
            QMessageBox.Information,
        )

    def update_buttons_state(self):
        """Updates the enabled/disabled state of Save and Discard buttons."""
        self.save_button.setEnabled(self._has_unsaved_changes)
        self.discard_button.setEnabled(self._has_unsaved_changes)
        self.logger.debug(
            f"Buttons state updated: Save={self.save_button.isEnabled()}, Discard={self.discard_button.isEnabled()}"
        )

    def _show_message(
        self,
        title: str,
        message: str,
        icon: QMessageBox.Icon,
        buttons: QMessageBox.StandardButtons = QMessageBox.Ok,
    ) -> QMessageBox.StandardButton:
        if (
            self.parent_view
            and hasattr(self.parent_view, "show_info")
            and hasattr(self.parent_view, "show_warning")
            and hasattr(self.parent_view, "show_error")
            and hasattr(self.parent_view, "show_question")
        ):

            if icon == QMessageBox.Information:
                self.parent_view.show_info(title, message)
            elif icon == QMessageBox.Warning:
                self.parent_view.show_warning(title, message)
            elif icon == QMessageBox.Critical:
                self.parent_view.show_error(title, message)
            elif icon == QMessageBox.Question:
                result = self.parent_view.show_question(title, message)
                return QMessageBox.Yes if result else QMessageBox.No
            return QMessageBox.Ok
        else:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle(title)
            msg_box.setText(message)
            msg_box.setIcon(icon)
            msg_box.setStandardButtons(buttons)
            return msg_box.exec()


=============== FILE: views/admin/tabs/backup_restore_tab.py ===============

# views/admin/tabs/backup_restore_tab.py

"""
EDSI Veterinary Management System - Backup and Restore Tab
Version: 1.0.7
Purpose: UI for managing application data backups and restores.
         Now receives BackupManager via dependency injection.
Last Updated: June 23, 2025
Author: Gemini

Changelog:
- v1.0.7 (2025-06-23):
    - **CRITICAL BUG FIX (Finalizing Dependency Injection):** Removed all direct
      imports of `sys`, `os`, and `backup_manager` from this file.
    - Modified `__init__` to accept `backup_manager_instance` as an argument
      and store it as `self._backup_manager`.
    - All calls to `backup_manager.create_backup` and `backup_manager.restore_backup`
      now use `self._backup_manager`.
    - This completes the dependency injection for `BackupRestoreTab`,
      eliminating the `ModuleNotFoundError` by ensuring the manager is passed,
      not imported locally.
- v1.0.6 (2025-06-23):
    - **CRITICAL BUG FIX (Final Attempt for ModuleNotFoundError):** Ensured `sys.path` manipulation
      is the *very first operation* in this module to guarantee the project root is added
      before *any* other imports are processed. This should definitively resolve the
      `ModuleNotFoundError: No module named 'services'`.
- v1.0.5 (2025-06-23):
    - **CRITICAL BUG FIX:** Re-introduced explicit `sys.path` manipulation at the
      very top of this file to ensure the project root is always discoverable
      before any imports.
# ... (previous changelog entries)
"""

# Removed local sys.path manipulation
import logging
import os  # Added import for 'os'
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFileDialog,
    QMessageBox,
    QApplication,
)
from PySide6.QtCore import Qt, Signal, QTimer, QCoreApplication
from PySide6.QtGui import QFont, QPalette, QColor

from config.app_config import AppConfig

# REMOVED: Direct import of backup_manager - now injected
# from services.backup_manager import backup_manager


class BackupRestoreTab(QWidget):
    """
    A tab widget for the UserManagementScreen allowing users to perform
    backup and restore operations.
    """

    # Signal emitted when a significant backup/restore action completes
    operation_completed = Signal(str)

    def __init__(
        self, parent_view: Optional[QWidget] = None, backup_manager_instance=None
    ):  # NEW: Accept instance
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view

        self._backup_manager = backup_manager_instance  # NEW: Store injected instance

        self.create_backup_btn: QPushButton
        self.restore_backup_btn: QPushButton

        self.current_user_id = "UNKNOWN_USER"

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()
        self.update_button_states()

    def _get_button_style(self, btn_type: str = "standard") -> str:
        base_style = (
            f"QPushButton {{ background-color: {AppConfig.DARK_BUTTON_BG}; "
            f"color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_BORDER}; "
            f"border-radius: 4px; padding: 8px 15px; font-size: 12px; font-weight: 500; "
            f"min-height: 36px; }}"
            f"QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}"
            f"QPushButton:disabled {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; "
            f"color: {AppConfig.DARK_TEXT_TERTIARY}; border-color: {AppConfig.DARK_HEADER_FOOTER}; }}"
        )
        if btn_type == "primary":
            return (
                f"{base_style} QPushButton {{ background-color: {AppConfig.DARK_PRIMARY_ACTION}; "
                f"color: white; border-color: {AppConfig.DARK_PRIMARY_ACTION}; }}"
                f"QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_PRIMARY_ACTION).lighter(115).name()}; }}"
            )
        elif btn_type == "danger":
            return (
                f"{base_style} QPushButton {{ background-color: {AppConfig.DARK_DANGER_ACTION}; "
                f"color: white; border-color: {AppConfig.DARK_DANGER_ACTION}; }}"
                f"QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_DANGER_ACTION).lighter(115).name()}; }}"
            )
        return base_style

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        main_layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)

        description_label = QLabel(
            "Manage your application's data by creating backups or restoring from a previous backup. "
            "Backups include your database, invoices, statements, logs, and application settings."
        )
        description_label.setWordWrap(True)
        description_label.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-bottom: 10px;"
        )
        main_layout.addWidget(description_label)

        backup_group_layout = QVBoxLayout()
        backup_group_layout.setContentsMargins(0, 0, 0, 0)

        self.create_backup_btn = QPushButton("📦 Create New Backup")
        backup_group_layout.addWidget(self.create_backup_btn)

        main_layout.addLayout(backup_group_layout)

        main_layout.addSpacing(20)

        restore_group_layout = QVBoxLayout()
        restore_group_layout.setContentsMargins(0, 0, 0, 0)

        self.restore_backup_btn = QPushButton("↩️ Restore from Backup")
        restore_group_layout.addWidget(self.restore_backup_btn)

        main_layout.addLayout(restore_group_layout)

        main_layout.addStretch(1)

    def _apply_styles(self):
        for label in self.findChildren(QLabel):
            label.setStyleSheet(f"color: {AppConfig.DARK_TEXT_PRIMARY};")
            label.setFont(QFont(AppConfig.DEFAULT_FONT_FAMILY, 10))

        self.create_backup_btn.setStyleSheet(self._get_button_style("primary"))
        self.restore_backup_btn.setStyleSheet(self._get_button_style("danger"))

    def _setup_connections(self):
        self.create_backup_btn.clicked.connect(self._handle_create_backup)
        self.restore_backup_btn.clicked.connect(self._handle_restore_backup)

    def update_button_states(self):
        self.create_backup_btn.setEnabled(True)
        self.restore_backup_btn.setEnabled(True)

    def _get_current_user_id(self) -> str:
        if (
            self.parent_view
            and hasattr(self.parent_view, "current_user_id")
            and self.parent_view.current_user_id
        ):
            return self.parent_view.current_user_id
        self.logger.warning(
            "Could not retrieve current_user_id from parent view. Using 'system'."
        )
        return "system"

    def _handle_create_backup(self):
        self.logger.info("Initiating backup creation process.")

        default_backup_dir = os.path.join(  # `os` is now imported
            os.path.expanduser("~"), "Documents", "EDMS_Backups"
        )
        os.makedirs(default_backup_dir, exist_ok=True)

        backup_destination_root = QFileDialog.getExistingDirectory(
            self, "Select Destination for Backup", default_backup_dir
        )

        if not backup_destination_root:
            self.logger.info("Backup destination selection cancelled by user.")
            self._show_message(
                "Backup Cancelled",
                "Backup operation was cancelled.",
                QMessageBox.Information,
            )
            return

        self._show_message(
            "Backup In Progress",
            "Creating backup... This may take a moment. The application may become unresponsive.",
            QMessageBox.Information,
        )
        QCoreApplication.processEvents()

        current_user_id = self._get_current_user_id()
        # Use the injected _backup_manager
        success, message = self._backup_manager.create_backup(
            backup_destination_root, current_user_id
        )

        if success:
            self._show_message("Backup Successful", message, QMessageBox.Information)
            self.operation_completed.emit("backup_success")
        else:
            self._show_message("Backup Failed", message, QMessageBox.Critical)
            self.operation_completed.emit("backup_failed")

    def _handle_restore_backup(self):
        self.logger.info("Initiating restore from backup process.")

        confirmation = self._show_message(
            "Confirm Data Restore",
            "WARNING: Restoring from a backup will OVERWRITE ALL CURRENT APPLICATION DATA (database, invoices, statements, logs, and settings).\n\n"
            "This action is IRREVERSIBLE. It is highly recommended to create a fresh backup BEFORE proceeding with a restore.\n\n"
            "Do you wish to continue?",
            QMessageBox.Warning,
            QMessageBox.Yes | QMessageBox.No,
        )

        if confirmation == QMessageBox.StandardButton.No:
            self.logger.info("Restore operation cancelled by user.")
            self._show_message(
                "Restore Cancelled",
                "Restore operation was cancelled.",
                QMessageBox.Information,
            )
            return

        default_backup_dir = os.path.join(
            os.path.expanduser("~"), "Documents", "EDMS_Backups"
        )

        backup_source_path = QFileDialog.getExistingDirectory(
            self, "Select Backup Folder to Restore From", default_backup_dir
        )

        if not backup_source_path:
            self.logger.info("Backup source selection cancelled by user.")
            self._show_message(
                "Restore Cancelled",
                "Restore operation was cancelled.",
                QMessageBox.Information,
            )
            return

        self._show_message(
            "Restore In Progress",
            "Restoring data... This may take a moment. The application will restart automatically after completion.",
            QMessageBox.Information,
        )
        QCoreApplication.processEvents()

        current_user_id = self._get_current_user_id()
        # Use the injected _backup_manager
        success, message = self._backup_manager.restore_backup(
            backup_source_path, current_user_id
        )

        if success:
            self._show_message("Restore Successful", message, QMessageBox.Information)
            self.operation_completed.emit("restore_success")
            self.logger.info("Restore successful. Initiating application restart.")
            QMessageBox.information(
                None,
                "Application Restart Required",
                "Data restore complete. The application will now restart for changes to take full effect.",
            )
            QApplication.instance().quit()
        else:
            self._show_message("Restore Failed", message, QMessageBox.Critical)
            self.operation_completed.emit("restore_failed")

    def _show_message(
        self,
        title: str,
        message: str,
        icon: QMessageBox.Icon,
        buttons: QMessageBox.StandardButtons = QMessageBox.StandardButton.Ok,
    ) -> QMessageBox.StandardButton:
        if (
            self.parent_view
            and hasattr(self.parent_view, "show_info")
            and hasattr(self.parent_view, "show_warning")
            and hasattr(self.parent_view, "show_error")
            and hasattr(self.parent_view, "show_question")
        ):

            if icon == QMessageBox.Information:
                self.parent_view.show_info(title, message)
            elif icon == QMessageBox.Warning:
                self.parent_view.show_warning(title, message)
            elif icon == QMessageBox.Critical:
                self.parent_view.show_error(title, message)
            elif icon == QMessageBox.Question:
                result = self.parent_view.show_question(title, message)
                return QMessageBox.Yes if result else QMessageBox.No
            return QMessageBox.StandardButton.Ok
        else:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle(title)
            msg_box.setText(message)
            msg_box.setIcon(icon)
            msg_box.setStandardButtons(buttons)
            return msg_box.exec()


=============== FILE: views/auth/login_screen.py ===============

# views/auth/login_screen.py

"""
EDSI Veterinary Management System - Login Screen
Version: 1.1.2
Purpose: Handles user authentication (username and password).
Last Updated: May 12, 2025
Author: Claude Assistant

Changelog:
- v1.1.2 (2025-05-12): Debug password validation and fix styling.
  - Added detailed logging in `validate_credentials` to compare input hash vs stored hash.
  - Removed unsupported 'box-shadow' property from input field focus style.
- v1.1.1 (2025-05-12): Fixed TypeError on layout initialization.
  - Changed layout creation in setup_ui from `QVBoxLayout(parent)`
    to `QVBoxLayout()` followed by `parent.setLayout()`.
- v1.1.0 (2025-05-12): Refactored for Username/Password and PySide6
- v1.0.0 (2025-05-12): Initial implementation (PyQt6, User ID only)
"""

import logging
import hashlib
from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QFrame,
    QSpacerItem,
    QSizePolicy,
    QWidget,
    QMessageBox,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import (
    QFont,
    QPalette,
    QColor,
    QScreen,
)  # Added imports for styling if needed

from views.base_view import BaseView
from config.app_config import AppConfig
from config.database_config import db_manager
from models import User


class LoginScreen(BaseView):
    """User login screen for authentication with username and password."""

    login_successful = Signal(str)
    exit_requested = Signal()

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(self.__class__.__name__)
        # Apply specific palette/styling for this screen if needed,
        # otherwise it inherits from BaseView
        self.apply_login_screen_styling()

    def apply_login_screen_styling(self):
        """Apply styles specific to the Login Screen, potentially overriding BaseView."""
        # Example: Set a specific background if different from BaseView
        # palette = self.palette()
        # palette.setColor(QPalette.ColorRole.Window, QColor("#e9ecef")) # Light grey example
        # self.setPalette(palette)
        # self.setAutoFillBackground(True)
        pass  # No specific overrides for now, using BaseView style

    def setup_ui(self):
        """Setup the login screen UI elements."""
        self.set_title("Login")
        self.setMinimumSize(450, 400)
        self.center_on_screen()

        # Main login layout for the central widget
        login_layout = QVBoxLayout()
        self.central_widget.setLayout(login_layout)  # Correct way to set layout

        login_layout.setContentsMargins(30, 30, 30, 30)
        login_layout.setSpacing(20)
        login_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Login form frame
        form_frame = QFrame()
        form_frame.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        # Use object name for more specific styling if needed later
        form_frame.setObjectName("LoginFormFrame")
        form_frame.setStyleSheet(
            f"""
            #LoginFormFrame {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                border: 1px solid #dee2e6;
                border-radius: 8px;
                padding: 30px;
                max-width: 400px;
            }}
            """
        )

        form_layout = QVBoxLayout(form_frame)  # Layout for the frame's content
        form_layout.setSpacing(15)
        form_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Title
        title_label = QLabel(AppConfig.APP_NAME)
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 20, QFont.Weight.Bold)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            f"color: {AppConfig.PRIMARY_COLOR}; margin-bottom: 5px; background: transparent;"
        )
        form_layout.addWidget(title_label)

        # Version Label
        version_label = QLabel(f"Version {AppConfig.APP_VERSION}")
        version_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 10)
        version_label.setFont(version_font)
        version_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        version_label.setStyleSheet(
            f"color: {AppConfig.TEXT_SECONDARY}; margin-bottom: 20px; background: transparent;"
        )
        form_layout.addWidget(version_label)

        # Username label and input
        username_label = QLabel("Username:")
        username_label.setStyleSheet(self.get_label_style())
        form_layout.addWidget(username_label)

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter your username")
        self.username_input.setFixedHeight(40)
        self.username_input.setStyleSheet(self.get_input_style())  # Apply input style
        self.username_input.returnPressed.connect(self.handle_login)
        form_layout.addWidget(self.username_input)

        # Password label and input
        password_label = QLabel("Password:")
        password_label.setStyleSheet(self.get_label_style())
        form_layout.addWidget(password_label)

        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText("Enter your password")
        self.password_input.setFixedHeight(40)
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setStyleSheet(self.get_input_style())  # Apply input style
        self.password_input.returnPressed.connect(self.handle_login)
        form_layout.addWidget(self.password_input)

        # Spacer
        spacer = QSpacerItem(
            20, 20, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )
        form_layout.addItem(spacer)

        # Button layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)

        self.login_button = QPushButton("Login")
        self.login_button.clicked.connect(self.handle_login)
        self.login_button.setMinimumHeight(40)
        self.login_button.setStyleSheet(self.get_button_style(AppConfig.PRIMARY_COLOR))

        self.exit_button = QPushButton("Exit")
        self.exit_button.clicked.connect(self.handle_exit)
        self.exit_button.setMinimumHeight(40)
        self.exit_button.setStyleSheet(self.get_button_style(AppConfig.SECONDARY_COLOR))

        button_layout.addWidget(self.login_button)
        button_layout.addWidget(self.exit_button)
        form_layout.addLayout(button_layout)

        # Add the form frame to the main layout
        login_layout.addWidget(form_frame)

        # Set focus
        self.username_input.setFocus()

        # Set modality
        self.setWindowModality(Qt.WindowModality.ApplicationModal)

    def get_label_style(self):
        """Returns the standard style for labels."""
        # Ensure background is transparent to inherit window background
        return f"""
            QLabel {{
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                font-weight: bold;
                color: {AppConfig.TEXT_COLOR};
                margin-bottom: 2px;
                background-color: transparent;
            }}
        """

    def get_input_style(self):
        """Returns the standard style for input fields, removing box-shadow."""
        # Inherits from BaseView stylesheet, but we define focus explicitly here
        # to ensure box-shadow is removed from this specific context too.
        return f"""
            QLineEdit {{
                border: 1px solid #ced4da;
                border-radius: 4px;
                padding: 8px 12px;
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                background-color: white;
                color: {AppConfig.TEXT_COLOR}; /* Ensure text color is set */
            }}
            QLineEdit:focus {{
                border-color: {AppConfig.PRIMARY_COLOR};
                /* Removed unsupported box-shadow */
            }}
        """

    def get_button_style(self, background_color, hover_color=None):
        """Returns the standard style for buttons."""
        # Calculate hover color if not provided
        if hover_color is None:
            try:
                r = int(background_color[1:3], 16)
                g = int(background_color[3:5], 16)
                b = int(background_color[5:7], 16)
                hover_color = f"#{max(0, r-20):02x}{max(0, g-20):02x}{max(0, b-20):02x}"
            except:
                hover_color = background_color

        return f"""
            QPushButton {{
                background-color: {background_color};
                color: white;
                border: none;
                padding: 10px 16px;
                border-radius: 4px;
                font-family: "{AppConfig.DEFAULT_FONT_FAMILY}";
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: {hover_color};
            }}
            QPushButton:pressed {{
                background-color: {background_color};
            }}
            QPushButton:disabled {{
                background-color: #adb5bd;
                color: #f8f9fa;
            }}
        """

    def handle_login(self):
        """Handle login attempt using username and password."""
        username = self.username_input.text().strip()
        password = self.password_input.text()

        if not username:
            self.show_warning("Login Failed", "Please enter a username.")
            self.username_input.setFocus()
            return
        if not password:
            self.show_warning("Login Failed", "Please enter a password.")
            self.password_input.setFocus()
            return

        is_valid, user_id = self.validate_credentials(username, password)

        if is_valid:
            self.logger.info(f"User '{user_id}' logged in successfully")
            self.login_successful.emit(user_id)
            self.close()
        else:
            self.show_error("Login Failed", "Invalid username or password.")
            self.password_input.clear()
            self.username_input.setFocus()
            self.username_input.selectAll()

    def validate_credentials(self, username, password):
        """Validate username and password against the database."""
        session = None
        target_user_id = username.upper()  # Standardize username for query
        self.logger.debug(f"Attempting validation for user: {target_user_id}")
        try:
            session = db_manager.get_session()
            user = session.query(User).filter(User.user_id == target_user_id).first()

            if user:
                self.logger.debug(
                    f"User found in DB: ID={user.user_id}, Active={user.is_active}"
                )
                if user.is_active:
                    # Hash the entered password using SHA-256
                    entered_password_hash = hashlib.sha256(
                        password.encode("utf-8")
                    ).hexdigest()

                    # --- DEBUG LOGGING START ---
                    self.logger.debug(f"Comparing Hashes for user '{user.user_id}':")
                    self.logger.debug(f"  Entered Hash: {entered_password_hash}")
                    self.logger.debug(f"  Stored Hash : {user.password_hash}")
                    # --- DEBUG LOGGING END ---

                    # Compare the hash with the stored hash
                    if entered_password_hash == user.password_hash:
                        self.logger.info(
                            f"Password validation successful for user '{user.user_id}'."
                        )
                        return True, user.user_id
                    else:
                        self.logger.warning(
                            f"Password hash mismatch for user '{user.user_id}'."
                        )
                        return False, None
                else:
                    self.logger.warning(f"User '{user.user_id}' is inactive.")
                    return False, None
            else:
                self.logger.warning(f"User '{target_user_id}' not found in database.")
                return False, None

        except Exception as e:
            self.logger.error(
                f"Error during credential validation for '{target_user_id}': {e}",
                exc_info=True,
            )
            self.show_error(
                "Login Error", "An error occurred during login. Please check logs."
            )
            return False, None
        finally:
            if session:
                db_manager.close_session()

    def handle_exit(self):
        """Handle exit button click."""
        self.logger.info("Exit requested from login screen.")
        self.exit_requested.emit()
        self.close()

    def keyPressEvent(self, event):
        """Handle key press events (e.g., ESC to exit)."""
        if event.key() == Qt.Key.Key_Escape:
            self.handle_exit()
        else:
            super().keyPressEvent(event)

    # --- Message Box Helpers (Inherited from BaseView) ---
    # No need to override if BaseView uses PySide6 QMessageBox correctly.
    # def show_error(self, title, message): ...
    # def show_warning(self, title, message): ...
    # def show_info(self, title, message): ...


=============== FILE: views/auth/small_login_dialog.py ===============

# views/auth/small_login_dialog.py

"""
EDSI Veterinary Management System - Simplified Login Dialog
Version: 2.0.4
Purpose: Clean, simple login dialog using UserController for authentication.
         Ensures consistent authentication mechanism (bcrypt) across the application.
Last Updated: May 29, 2025
Author: Claude Assistant (Refactored by Gemini)

Changelog:
- v2.0.4 (2025-05-29):
    - Refactored to use UserController.authenticate_user() for login attempts.
    - Removed internal _authenticate_user and _verify_password methods.
    - Removed hashlib import and direct database session usage for authentication.
    - Login ID is now passed to UserController without uppercasing;
      controller handles case-insensitive lookup.
    - User feedback messages now sourced from UserController.
- v2.0.3 (2025-05-24):
    - Fixed RuntimeError: Internal C++ object already deleted
    - Added early return on successful login to prevent widget access after dialog closure
    - Added proper error handling for widget cleanup
- v2.0.2 (2025-05-24):
    - Updated database session handling for login attempts
    - Added last login timestamp update on successful authentication
- v2.0.1 (2025-05-24):
    - Fixed authentication to work with simplified database structure
    - Improved error handling and user feedback
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Removed UserController dependency and complex validation
    - Simplified to direct database authentication
    - Clean signal handling without over-engineering
    - Proper error handling and user feedback
    - Consistent dark theme styling
    - Focused on working login flow
    - Removed circular import issues
    - Clear separation of concerns
"""

import logging

# REMOVED: import hashlib - No longer used
from typing import Optional

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QMessageBox,
    QDialogButtonBox,
    QHBoxLayout,  # Retained, though not explicitly used in this version's example layout
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QPalette, QColor

from config.app_config import AppConfig

# REMOVED: from config.database_config import get_db_session - Controller handles session
# REMOVED: from models.user_models import User - Controller returns user info
from controllers.user_controller import UserController  # ADDED


class SmallLoginDialog(QDialog):
    """
    Simple login dialog for user authentication.
    Displays over the splash screen and handles user login.
    """

    # Signals
    login_successful = Signal(str)  # Emits user_id on successful login
    dialog_closed = Signal()  # Emits when dialog is closed

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.user_controller = UserController()  # ADDED UserController instance

        self.setWindowTitle("EDSI Login")
        self.setModal(True)
        self.setFixedSize(380, 250)

        self._setup_ui()
        self._apply_theme()

    def _setup_ui(self):
        """Setup the login dialog UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        title_label = QLabel("User Login")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            """
            QLabel {
                font-size: 16px;
                font-weight: bold;
                padding: 10px;
            }
        """
        )
        layout.addWidget(title_label)

        self.user_id_input = QLineEdit()
        self.user_id_input.setPlaceholderText("Login ID")
        self.user_id_input.setMaxLength(20)
        layout.addWidget(self.user_id_input)

        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText("Password")
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setMaxLength(255)  # Max length for input field
        layout.addWidget(self.password_input)

        self.password_input.returnPressed.connect(self._attempt_login)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )

        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Login")

        self.button_box.accepted.connect(self._attempt_login)
        self.button_box.rejected.connect(self.reject)

        layout.addWidget(self.button_box)
        self.user_id_input.setFocus()

    def _apply_theme(self):
        """Apply dark theme to the dialog"""
        palette = QPalette()
        palette.setColor(
            QPalette.ColorRole.Window, QColor(AppConfig.DARK_WIDGET_BACKGROUND)
        )
        palette.setColor(
            QPalette.ColorRole.WindowText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        palette.setColor(
            QPalette.ColorRole.Base, QColor(AppConfig.DARK_INPUT_FIELD_BACKGROUND)
        )
        palette.setColor(QPalette.ColorRole.Text, QColor(AppConfig.DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(AppConfig.DARK_BUTTON_BG))
        palette.setColor(
            QPalette.ColorRole.ButtonText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        palette.setColor(
            QPalette.ColorRole.PlaceholderText, QColor(AppConfig.DARK_TEXT_TERTIARY)
        )
        self.setPalette(palette)

        self.setStyleSheet(
            f"""
            QDialog {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QLineEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px;
                font-size: 14px;
            }}
            QLineEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 15px;
                font-size: 13px;
                min-width: 80px;
            }}
            QPushButton:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
            }}
            QPushButton:pressed {{
                background-color: {AppConfig.DARK_ITEM_HOVER};
            }}
            QPushButton[text="Login"] {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
            QPushButton[text="Login"]:hover {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION}dd; /* Assuming alpha modification if supported */
            }}
        """
        )

    def _attempt_login(self):
        """Attempt to authenticate the user using UserController"""
        login_id = self.user_id_input.text().strip()  # REMOVED .upper()
        password = self.password_input.text()

        if not login_id:
            self._show_error("Login ID is required.")
            self.user_id_input.setFocus()
            return

        if not password:
            self._show_error("Password is required.")
            self.password_input.setFocus()
            return

        # Authenticate user via UserController
        try:
            # UserController.authenticate_user returns -> Tuple[bool, str, Optional[Dict[str, Any]]]
            success, message, user_info = self.user_controller.authenticate_user(
                login_id, password
            )

            if success and user_info:
                actual_user_id = user_info.get(
                    "user_id", login_id
                )  # Use actual user_id from DB
                self.logger.info(f"User '{actual_user_id}' logged in successfully")
                # UserController's authenticate_user now handles updating last_login and committing
                self.login_successful.emit(actual_user_id)
                # self.accept() # No need to call accept() here, login_successful signal triggers closure in main.py
                return  # Exit immediately on success

            else:
                # Display the message from UserController (e.g., "Invalid login ID or password", "User inactive")
                self._show_error(
                    message or "Login failed. Please check your credentials."
                )
                self.logger.warning(
                    f"Failed login attempt for user input: {login_id}. Reason: {message}"
                )

        except Exception as e:  # Catch any unexpected errors from controller call
            self.logger.error(
                f"Login error during controller interaction: {e}", exc_info=True
            )
            self._show_error(
                "An unexpected error occurred during login. Please try again."
            )

        # Only clear password on failed login (we return early on success)
        try:
            self.password_input.clear()
            self.password_input.setFocus()
        except RuntimeError:
            self.logger.debug(
                "Password input widget might be deleted, skipping clear/focus."
            )

    # REMOVED: _authenticate_user(self, login_id: str, password: str) -> Optional[User]:
    # REMOVED: _verify_password(self, plain_password: str, password_hash: str) -> bool:

    def _show_error(self, message: str):
        """Show error message to user"""
        # Ensure widget exists before showing message box, in case dialog is closing.
        if self.isVisible():
            QMessageBox.critical(self, "Login Failed", message)
        else:
            self.logger.warning(
                f"Login dialog not visible, error not shown to user: {message}"
            )

    def reject(self):
        """Handle dialog rejection (Cancel button or Esc key)"""
        self.logger.debug("Login dialog cancelled by user")
        self.dialog_closed.emit()
        super().reject()

    # accept() is implicitly handled by login_successful signal flow in main.py;
    # direct call to self.accept() after emitting login_successful is removed
    # to let main.py manage the dialog closure after successful signal processing.
    # If accept() is needed for other QDialogButtonBox scenarios, it could be:
    # def accept(self):
    #     # This might be called if _attempt_login directly calls self.accept()
    #     # For now, _attempt_login calls return on success.
    #     self.logger.debug("Login dialog accepted (e.g. if OK directly called accept)")
    #     super().accept()

    def closeEvent(self, event):
        """Handle dialog close event (e.g., window 'X' button)"""
        # Check if login was successful; if so, accept() might have already been called
        # or login_successful emitted. If not, it's like a reject.
        self.logger.debug("Login dialog closed via closeEvent (e.g., X button)")
        self.dialog_closed.emit()  # Ensure dialog_closed is emitted
        super().closeEvent(event)


=============== FILE: views/auth/splash_screen.py ===============

# views/auth/splash_screen.py

"""
EDSI Veterinary Management System - Image-Based Splash Screen with Interactive Areas
Version: 1.3.2
Purpose: Displays an image-based splash screen with clickable login/exit areas.
         Corrected signal names to match usage in main.py.
         Updated AppConfig usage for asset path.
Last Updated: May 24, 2025
Author: Claude Assistant (Correcting user's v1.3.0, further modified by Gemini)

Changelog:
- v1.3.2 (2025-05-24):
    - Changed image_path construction in setup_splash_ui to use AppConfig.ASSETS_DIR
      resolving AttributeError for AppConfig.get_app_dir().
- v1.3.1 (2025-05-18):
    - Renamed signal `login_area_clicked` to `login_requested`.
    - Renamed signal `exit_area_clicked` to `exit_requested`.
- v1.3.0 (2025-05-16): (User's Base Version)
    - Implemented interactive image splash screen.
    - Loads splash_screen.jpg from assets.
    - Overlays transparent QPushButtons for "Login" and "Exit" areas based on coordinates.
    - Emits `login_area_clicked` or `exit_area_clicked` signals.
    - Removed old timer and generic key/mouse press handlers.
- v1.2.0 (2025-05-15): Attempted image display (placeholder).
- v1.1.0 (2025-05-12): Original text-based splash screen.
"""

import os
import logging
from typing import Optional

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton, QApplication
from PySide6.QtCore import (
    Qt,
    Signal,
    QSize,
    QRect,
    QTimer,
)
from PySide6.QtGui import QPixmap, QPalette, QColor

from config.app_config import AppConfig


class SplashScreen(QWidget):
    """EDSI splash screen that appears on startup, image-based with interactive areas."""

    login_requested = Signal()
    exit_requested = Signal()

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setWindowFlags(
            Qt.WindowType.SplashScreen
            | Qt.WindowType.FramelessWindowHint
            | Qt.WindowType.WindowStaysOnTopHint
        )

        self.pixmap: Optional[QPixmap] = None
        self.image_label: Optional[QLabel] = None
        self.login_button_overlay: Optional[QPushButton] = None
        self.exit_button_overlay: Optional[QPushButton] = None

        self.setup_splash_ui()

    def setup_splash_ui(self):
        try:
            # MODIFIED: Use AppConfig.ASSETS_DIR directly
            image_path = os.path.join(AppConfig.ASSETS_DIR, "splash_screen.jpg")
            self.logger.info(f"Attempting to load splash image from: {image_path}")

            if not os.path.exists(image_path):
                self.logger.error(
                    f"Splash screen image not found at {image_path}. Using fallback."
                )
                self._setup_fallback_ui()
                return

            self.pixmap = QPixmap(image_path)

            if self.pixmap.isNull():
                self.logger.error(
                    f"CRITICAL: Could not load splash image from {image_path}. Using fallback."
                )
                self._setup_fallback_ui()
                return

            self.setFixedSize(self.pixmap.size())
            self.center_on_screen()

            self.image_label = QLabel(self)
            self.image_label.setPixmap(self.pixmap)
            self.image_label.setGeometry(
                0, 0, self.pixmap.width(), self.pixmap.height()
            )
            self.image_label.setScaledContents(True)

            login_coords = QRect(280, 340, 95, 35)
            exit_coords = QRect(380, 340, 95, 35)

            self.login_button_overlay = QPushButton(self.image_label)
            self.login_button_overlay.setGeometry(login_coords)
            self.login_button_overlay.setFlat(True)
            self.login_button_overlay.setStyleSheet(
                "QPushButton { background-color: transparent; border: none; }"
            )
            self.login_button_overlay.setCursor(Qt.CursorShape.PointingHandCursor)
            self.login_button_overlay.clicked.connect(self.login_requested.emit)
            self.login_button_overlay.setToolTip("Login to EDSI System")

            self.exit_button_overlay = QPushButton(self.image_label)
            self.exit_button_overlay.setGeometry(exit_coords)
            self.exit_button_overlay.setFlat(True)
            self.exit_button_overlay.setStyleSheet(
                "QPushButton { background-color: transparent; border: none; }"
            )
            self.exit_button_overlay.setCursor(Qt.CursorShape.PointingHandCursor)
            self.exit_button_overlay.clicked.connect(self.exit_requested.emit)
            self.exit_button_overlay.setToolTip("Exit Application")

            v_layout = QVBoxLayout(self)
            v_layout.addWidget(self.image_label)
            v_layout.setContentsMargins(0, 0, 0, 0)
            self.setLayout(v_layout)

            self.logger.info("Splash screen UI setup complete.")

        except Exception as e:
            self.logger.error(f"Error setting up splash screen UI: {e}", exc_info=True)
            self._setup_fallback_ui()
            QTimer.singleShot(0, self.show)

    def _setup_fallback_ui(self):
        self.logger.info("Setting up fallback UI for splash screen.")
        if self.image_label:
            self.image_label.deleteLater()
            self.image_label = None
        if self.login_button_overlay:
            self.login_button_overlay.deleteLater()
            self.login_button_overlay = None
        if self.exit_button_overlay:
            self.exit_button_overlay.deleteLater()
            self.exit_button_overlay = None

        current_layout = self.layout()
        if current_layout is not None:
            while current_layout.count():
                child = current_layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()

        self.setFixedSize(350, 150)
        fallback_label = QLabel("EDSI Loading...", self)
        fallback_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        fallback_label.setStyleSheet(
            "background-color: #2D3748; color: white; font-size: 18px; padding: 20px; border-radius: 5px;"
        )
        main_layout = QVBoxLayout(self)
        main_layout.addWidget(fallback_label)
        self.setLayout(main_layout)
        self.center_on_screen()

    def center_on_screen(self):
        primary_screen = QApplication.primaryScreen()
        if primary_screen:
            screen_geometry = primary_screen.availableGeometry()
            self.move(screen_geometry.center() - self.rect().center())
        else:
            self.logger.warning(
                "Primary screen not available for centering splash, using default position."
            )
            self.move(100, 100)

    def showEvent(self, event):
        self.logger.debug("Splash screen shown.")
        super().showEvent(event)

    def closeEvent(self, event):
        self.logger.debug("Splash screen closed.")
        super().closeEvent(event)


=============== FILE: views/horse/__init__.py ===============

# views/horse/__init__.py

"""Horse views package"""


=============== FILE: views/horse/horse_unified_management.py ===============

# views/horse/horse_unified_management.py
"""
EDSI Veterinary Management System - Unified Horse Management Screen (Dark Theme)
Version: 1.13.3
Purpose: Unified interface for horse management, including invoice history.
Last Updated: June 13, 2025
Author: Gemini

Changelog:
- v1.13.3 (2025-06-13):
    - Fixed vertical text cutoff in the horse list by setting an explicit item
      size hint in the populate_horse_list method, overriding the incorrect
      default size hint.
- v1.13.2 (2025-06-13):
    - Reverted unauthorized simplification of the details header to restore original functionality.
- v1.13.1 (2025-06-13):
    - Implemented the previously documented simplification of the horse details header.
    - Modified _update_horse_info_line to only display the horse's account number.
    - Increased header spacing for better visual separation.
- v1.13.0 (2025-06-11):
    - Added a new 'Reports' tab to the main tab widget to serve as a central
      hub for all reporting, per user request.
- v1.12.5 (2025-06-10):
    - Simplified the horse information line in the header to only show the
      account number, reducing clutter.
    - Increased spacing in the header between the horse name and the info line.
- v1.12.4 (2025-06-10):
    - Removed a call to a non-existent `data_modified` signal in the
      `_on_tab_data_modified` slot to fix an `AttributeError`.
"""

import logging
from datetime import (
    datetime,
    date,
)
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QFrame,
    QListWidgetItem,
    QTabWidget,
    QWidget,
    QSplitter,
    QRadioButton,
    QButtonGroup,
    QApplication,
    QMenu,
    QDialog,
    QMessageBox,
    QStatusBar,
)
from PySide6.QtCore import Qt, Signal, QTimer, QDate, QSize
from PySide6.QtGui import (
    QFont,
    QPalette,
    QColor,
    QAction,
    QKeyEvent,
    QShowEvent,
    QCloseEvent,
)
from sqlalchemy.orm.exc import DetachedInstanceError

from views.base_view import BaseView
from config.app_config import (
    AppConfig,
    DARK_BACKGROUND,
    DARK_WIDGET_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_BORDER,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_ITEM_HOVER,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_INPUT_FIELD_BACKGROUND,
    DEFAULT_FONT_FAMILY,
    DARK_SUCCESS_ACTION,
    DARK_DANGER_ACTION,
)
from controllers.horse_controller import HorseController
from controllers.owner_controller import OwnerController
from controllers.location_controller import LocationController
from controllers.financial_controller import FinancialController
from models import (
    Horse,
    Location as LocationModel,
    Owner as OwnerModel,
)

from .tabs.basic_info_tab import BasicInfoTab
from .tabs.owners_tab import OwnersTab
from .tabs.location_tab import LocationTab
from .tabs.billing_tab import BillingTab
from .tabs.invoice_history_tab import InvoiceHistoryTab
from .tabs.reports_tab import ReportsTab  # ADDED


class HorseUnifiedManagement(BaseView):
    horse_selection_changed = Signal(int)
    exit_requested = Signal()
    setup_requested = Signal()
    closing = Signal()

    def __init__(self, current_user=None):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(
            f"HorseUnifiedManagement __init__ started for user: {current_user}"
        )
        self.current_user = current_user or "ADMIN"
        self.horse_controller = HorseController()
        self.owner_controller = OwnerController()
        self.location_controller = LocationController()
        self.financial_controller = FinancialController()

        self.tab_widget: Optional[QTabWidget] = None
        self.basic_info_tab: Optional[BasicInfoTab] = None
        self.owners_tab: Optional[OwnersTab] = None
        self.location_tab: Optional[LocationTab] = None
        self.billing_tab: Optional[BillingTab] = None
        self.invoice_history_tab: Optional[InvoiceHistoryTab] = None
        self.reports_tab: Optional[ReportsTab] = None  # ADDED

        self.horse_list: Optional[QWidget] = None
        self.empty_frame: Optional[QFrame] = None
        self.horse_details_content_widget: Optional[QWidget] = None
        self.horse_title: Optional[QLabel] = None
        self.horse_info_line: Optional[QLabel] = None
        self.add_horse_btn: Optional[QPushButton] = None
        self.edit_horse_btn: Optional[QPushButton] = None
        self.refresh_btn: Optional[QPushButton] = None
        self.help_btn: Optional[QPushButton] = None
        self.print_btn: Optional[QPushButton] = None
        self.setup_icon_btn: Optional[QPushButton] = None
        self.user_menu_button: Optional[QPushButton] = None
        self.user_menu: Optional[QMenu] = None
        self.active_only_radio: Optional[QRadioButton] = None
        self.all_horses_radio: Optional[QRadioButton] = None
        self.deactivated_radio: Optional[QRadioButton] = None
        self.filter_group: Optional[QButtonGroup] = None
        self.search_input: Optional[QLineEdit] = None
        self.splitter: Optional[QSplitter] = None
        self.list_widget_container: Optional[QWidget] = None
        self.details_widget: Optional[QWidget] = None
        self.details_layout: Optional[QVBoxLayout] = None
        self.status_bar: Optional[QStatusBar] = None
        self.status_label: Optional[QLabel] = None
        self.footer_horse_count_label: Optional[QLabel] = None
        self.shortcut_label: Optional[QLabel] = None

        super().__init__()

        self.horses_list_data: List[Horse] = []
        self.current_horse: Optional[Horse] = None
        self._has_changes_in_active_tab: bool = False
        self._is_new_mode: bool = False

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self.perform_search)

        self.logger.debug("Scheduling load_initial_data with QTimer.singleShot(0).")
        QTimer.singleShot(0, self.load_initial_data)
        self.logger.info(
            "HorseUnifiedManagement screen __init__ finished (initial data load deferred)."
        )

    def setup_ui(self):
        self.logger.info("HorseUnifiedManagement.setup_ui: EXECUTION CONFIRMED.")

        self.set_title("Horse Management")
        self.resize(1200, 800)

        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.setup_header(main_layout)
        self.setup_action_bar(main_layout)
        self.setup_main_content(main_layout)
        self.setup_footer(main_layout)
        self.setup_connections()

        self.logger.info("HorseUnifiedManagement.setup_ui: All components initialized.")

    def showEvent(self, event: QShowEvent):
        self.logger.info("HorseUnifiedManagement showEvent: START")
        super().showEvent(event)

        self.logger.debug(
            "showEvent: Checking core UI elements (empty_frame, horse_details_content_widget)..."
        )
        if (
            not hasattr(self, "empty_frame")
            or not self.empty_frame
            or not hasattr(self, "horse_details_content_widget")
            or not self.horse_details_content_widget
        ):
            self.logger.error(
                "showEvent: Core UI elements for displaying state are NOT ready. UI setup might be incomplete. Aborting showEvent further processing."
            )
            return
        self.logger.debug("showEvent: Core UI elements check PASSED.")

        if self.current_horse:
            self.logger.debug(
                "showEvent: current_horse exists. Calling display_details_state."
            )
            self.display_details_state()
            self.logger.debug("showEvent: display_details_state call completed.")
            if (
                self.basic_info_tab
                and not self._is_new_mode
                and hasattr(self.basic_info_tab, "_is_editing")
                and not self.basic_info_tab._is_editing
            ):
                self.logger.debug("showEvent: Setting basic_info_tab to read-only.")
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.basic_info_tab.set_form_read_only(True)
                self.logger.debug("showEvent: basic_info_tab set to read-only.")
        else:
            self.logger.debug(
                "showEvent: No current_horse. Calling display_empty_state."
            )
            self.display_empty_state()
            self.logger.debug("showEvent: display_empty_state call completed.")

        self.logger.debug("showEvent: Calling update_main_action_buttons_state.")
        self.update_main_action_buttons_state()
        self.logger.debug("showEvent: update_main_action_buttons_state call completed.")

        self.logger.info(
            "HorseUnifiedManagement showEvent: FINISHED - screen should be visible."
        )

    def display_details_state(self):
        """Hides the empty state frame and shows the main details content widget."""
        self.logger.debug("display_details_state: START")

        if hasattr(self, "empty_frame") and self.empty_frame:
            self.logger.debug("display_details_state: Hiding empty_frame.")
            self.empty_frame.hide()
        else:
            self.logger.warning(
                "display_details_state: empty_frame not available or not valid."
            )

        if (
            hasattr(self, "horse_details_content_widget")
            and self.horse_details_content_widget
        ):
            self.logger.debug(
                "display_details_state: Showing horse_details_content_widget."
            )
            self.horse_details_content_widget.show()
        else:
            self.logger.warning(
                "display_details_state: horse_details_content_widget not available."
            )
        self.logger.debug("display_details_state: FINISHED")

    def display_empty_state(self):
        self.logger.debug("display_empty_state: START")

        if hasattr(self, "empty_frame") and self.empty_frame:
            self.logger.debug("display_empty_state: Showing empty_frame.")
            self.empty_frame.show()
        else:
            self.logger.warning(
                "display_empty_state: empty_frame not available or not valid."
            )

        if (
            hasattr(self, "horse_details_content_widget")
            and self.horse_details_content_widget
        ):
            self.logger.debug(
                "display_empty_state: Hiding horse_details_content_widget."
            )
            self.horse_details_content_widget.hide()
        else:
            self.logger.warning(
                "display_empty_state: horse_details_content_widget not available."
            )

        self.current_horse = None
        self._is_new_mode = False
        self._has_changes_in_active_tab = False
        self.logger.debug("display_empty_state: Basic state flags reset.")

        if self.basic_info_tab:
            self.logger.debug(
                "display_empty_state: Calling basic_info_tab.clear_fields()."
            )
            try:
                self.basic_info_tab.clear_fields()
                self.logger.debug(
                    "display_empty_state: basic_info_tab.clear_fields() successful."
                )
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.logger.debug(
                        "display_empty_state: Attempting basic_info_tab.set_form_read_only(True)."
                    )
                    self.basic_info_tab.set_form_read_only(True)
                    self.logger.debug(
                        "display_empty_state: basic_info_tab.set_form_read_only(True) done."
                    )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in basic_info_tab.clear_fields or set_form_read_only: {e}",
                    exc_info=True,
                )
        else:
            self.logger.error("display_empty_state: BasicInfoTab is None.")

        if hasattr(self.basic_info_tab, "update_buttons_state"):
            self.logger.debug(
                "display_empty_state: Calling basic_info_tab.update_buttons_state(...)."
            )
            try:
                self.basic_info_tab.update_buttons_state(
                    is_editing_or_new=False, has_selection=False, has_changes=False
                )
                self.logger.debug(
                    "display_empty_state: basic_info_tab.update_buttons_state() successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in basic_info_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.owners_tab and hasattr(self.owners_tab, "load_owners_for_horse"):
            self.logger.debug(
                "display_empty_state: Calling owners_tab.load_owners_for_horse(None)."
            )
            try:
                self.owners_tab.load_owners_for_horse(None)
                self.logger.debug(
                    "display_empty_state: owners_tab.load_owners_for_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in owners_tab.load_owners_for_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: OwnersTab is None or missing method."
            )

        if self.location_tab and hasattr(self.location_tab, "load_location_for_horse"):
            self.logger.debug(
                "display_empty_state: Calling location_tab.load_location_for_horse(None)."
            )
            try:
                self.location_tab.load_location_for_horse(None)
                self.logger.debug(
                    "display_empty_state: location_tab.load_location_for_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in location_tab.load_location_for_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: LocationTab is None or missing method."
            )

        if self.billing_tab and hasattr(self.billing_tab, "set_current_horse"):
            self.logger.debug(
                "display_empty_state: Calling billing_tab.set_current_horse(None)."
            )
            try:
                self.billing_tab.set_current_horse(None)
                self.logger.debug(
                    "display_empty_state: billing_tab.set_current_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in billing_tab.set_current_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: BillingTab is None or missing set_current_horse method."
            )

        if hasattr(self, "horse_title") and self.horse_title:
            self.logger.debug("display_empty_state: Setting horse_title text.")
            self.horse_title.setText("No Horse Selected")
        else:
            self.logger.warning(
                "display_empty_state: horse_title QLabel not available."
            )

        self.logger.debug("display_empty_state: Calling _update_horse_info_line(None).")
        self._update_horse_info_line(None)
        self.logger.debug(
            "display_empty_state: _update_horse_info_line(None) call completed."
        )

        self.logger.debug("display_empty_state: Calling update_status.")
        self.update_status("No horse selected. Add a new horse or select from list.")
        self.logger.info("display_empty_state: FINISHED")

    def update_main_action_buttons_state(self):
        self.logger.debug("update_main_action_buttons_state: START")
        can_add_new = not self._is_new_mode and not self._has_changes_in_active_tab
        if hasattr(self, "add_horse_btn") and self.add_horse_btn:
            self.add_horse_btn.setEnabled(can_add_new)
            self.logger.debug(
                f"update_main_action_buttons_state: add_horse_btn enabled: {can_add_new}"
            )
        else:
            self.logger.warning(
                "add_horse_btn not initialized in update_main_action_buttons_state"
            )

        form_is_editable_by_tab = False
        if self.basic_info_tab and hasattr(self.basic_info_tab, "_is_editing"):
            form_is_editable_by_tab = self.basic_info_tab._is_editing

        can_edit_selected = (
            self.current_horse is not None
            and not self._is_new_mode
            and not self._has_changes_in_active_tab
            and not form_is_editable_by_tab
        )

        if hasattr(self, "edit_horse_btn") and self.edit_horse_btn:
            self.edit_horse_btn.setEnabled(can_edit_selected)
            self.logger.debug(
                f"update_main_action_buttons_state: edit_horse_btn enabled: {can_edit_selected}"
            )
        else:
            self.logger.warning(
                "edit_horse_btn not initialized in update_main_action_buttons_state"
            )

        if self.basic_info_tab and hasattr(self.basic_info_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating basic_info_tab buttons."
            )
            try:
                is_editing_or_new_val = self._is_new_mode or form_is_editable_by_tab
                has_selection_val = self.current_horse is not None
                has_changes_val = self._has_changes_in_active_tab
                self.basic_info_tab.update_buttons_state(
                    is_editing_or_new_val, has_selection_val, has_changes_val
                )
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling basic_info_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.owners_tab and hasattr(self.owners_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating owners_tab buttons."
            )
            try:
                self.owners_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling owners_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.location_tab and hasattr(self.location_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating location_tab buttons."
            )
            try:
                self.location_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling location_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.billing_tab and hasattr(self.billing_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating billing_tab buttons."
            )
            try:
                self.billing_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling billing_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        self.logger.debug("update_main_action_buttons_state: FINISHED")

    def discard_changes(self):
        self.logger.debug("discard_changes: START")
        if not self._is_new_mode and not self._has_changes_in_active_tab:
            if (
                self.current_horse
                and self.basic_info_tab
                and hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing
            ):
                self.logger.info(
                    "discard_changes: Form in edit mode, no data changes. Reverting to read-only."
                )
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.basic_info_tab.set_form_read_only(True)
                self.update_main_action_buttons_state()
                self.update_status(
                    f"Viewing: {self.current_horse.horse_name or 'horse'}"
                )
                self.logger.debug("discard_changes: FINISHED (no actual changes)")
                return
            self.update_status("No changes to discard.")
            self.logger.debug("discard_changes: FINISHED (no changes to discard)")
            return

        if self.show_question("Confirm Discard", "Discard unsaved changes?"):
            self.logger.info("discard_changes: User confirmed discard.")
            was_in_new_mode = self._is_new_mode
            self._is_new_mode = False
            self._has_changes_in_active_tab = False
            if self.basic_info_tab:
                self.logger.debug("discard_changes: Clearing BasicInfoTab.")
                try:
                    self.basic_info_tab.clear_fields()
                    if hasattr(self.basic_info_tab, "set_form_read_only"):
                        self.basic_info_tab.set_form_read_only(True)
                except Exception as e:
                    self.logger.error(
                        f"discard_changes: Error in basic_info_tab.clear_fields/set_form_read_only: {e}",
                        exc_info=True,
                    )

            if self.current_horse and not was_in_new_mode:
                self.logger.debug(
                    f"discard_changes: Reloading horse ID {self.current_horse.horse_id}."
                )
                self.load_horse_details(self.current_horse.horse_id)
            else:
                self.logger.debug(
                    "discard_changes: Was new or no current horse. Selecting first in list or empty state."
                )
                if self.horse_list and self.horse_list.count() > 0:
                    self.horse_list.setCurrentRow(0)
                else:
                    self.display_empty_state()
            self.update_main_action_buttons_state()
            self.update_status("Changes discarded.")
        else:
            self.logger.info("discard_changes: User cancelled discard.")
        self.logger.debug("discard_changes: FINISHED")

    def load_initial_data(self):
        self.logger.info("load_initial_data: START - Attempting to load horses.")
        try:
            self.load_horses()
            self.logger.info(
                "load_initial_data: FINISHED - load_horses call completed."
            )
        except Exception as e:
            self.logger.error(
                f"load_initial_data: CRITICAL ERROR during load_horses: {e}",
                exc_info=True,
            )
            self.show_error(
                "Initial Data Load Failed", f"Could not load initial horse data: {e}"
            )

    def closeEvent(self, event: QCloseEvent):
        self.logger.warning(f"HorseUnifiedManagement closeEvent. Type: {event.type()}")
        self.closing.emit()
        super().closeEvent(event)
        self.logger.warning("HorseUnifiedManagement finished processing closeEvent.")

    def get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND):
        return f"""
            QLineEdit, QComboBox, QDateEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; }}
            QLineEdit:focus, QComboBox:focus, QDateEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QLineEdit:disabled, QComboBox:disabled, QDateEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; width: 15px; }} QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QDateEdit::up-button, QDateEdit::down-button {{ width: 18px; }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
        """

    def get_generic_button_style(self):
        return f"""
            QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px; }} 
            QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} 
            QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}
        """

    def get_toolbar_button_style(self, bg_color_hex, text_color_hex="#ffffff"):
        if len(bg_color_hex) == 4 and bg_color_hex.startswith("#"):
            bg_color_hex = f"#{bg_color_hex[1]*2}{bg_color_hex[2]*2}{bg_color_hex[3]*2}"
        try:
            base_qcolor = QColor(bg_color_hex)
            hover_bg = base_qcolor.lighter(115).name()
            pressed_bg = base_qcolor.darker(110).name()
        except ValueError:
            hover_bg, pressed_bg = DARK_BUTTON_HOVER, DARK_BUTTON_BG
            self.logger.warning(
                f"Could not parse color: {bg_color_hex} for button style."
            )
        return f"""
            QPushButton {{ background-color: {bg_color_hex}; color: {text_color_hex}; border: none; border-radius: 4px; padding: 8px 16px; font-size: 13px; font-weight: 500; }} 
            QPushButton:hover {{ background-color: {hover_bg}; }} QPushButton:pressed {{ background-color: {pressed_bg}; }} 
            QPushButton:disabled {{ background-color: #adb5bd; color: #f8f9fa; }}
        """

    def setup_header(self, parent_layout):
        self.logger.debug("setup_header: START")
        header_frame = QFrame()
        header_frame.setObjectName("HeaderFrame")
        header_frame.setFixedHeight(55)
        header_frame.setStyleSheet(
            f"""#HeaderFrame{{background-color:{DARK_HEADER_FOOTER};border:none;padding:0 20px;}} QLabel{{color:{DARK_TEXT_PRIMARY};background-color:transparent;}} QPushButton#UserMenuButton{{color:{DARK_TEXT_SECONDARY};font-size:12px;background-color:transparent;border:none;padding:5px;text-align:right;}} QPushButton#UserMenuButton::menu-indicator{{image:none;}} QPushButton#UserMenuButton:hover{{color:{DARK_TEXT_PRIMARY};background-color:{QColor(DARK_ITEM_HOVER).lighter(110).name(QColor.NameFormat.HexRgb)}33;}}"""
        )
        header_layout = QHBoxLayout(header_frame)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(15)
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setSpacing(8)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addStretch()
        title_label = QLabel("EDSI - Horse Management")
        title_label.setFont(QFont(DEFAULT_FONT_FAMILY, 15, QFont.Weight.Bold))
        left_layout.addWidget(title_label)
        breadcrumb_label = QLabel("🏠 Horse Management")
        breadcrumb_label.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:11px;background:transparent;"
        )
        left_layout.addWidget(breadcrumb_label)
        left_layout.addStretch()
        right_widget = QWidget()
        right_layout = QHBoxLayout(right_widget)
        right_layout.setSpacing(10)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.refresh_btn = QPushButton("🔄")
        self.refresh_btn.setToolTip("Refresh Data (F5)")
        self.help_btn = QPushButton("❓")
        self.help_btn.setToolTip("Help (F1)")
        self.print_btn = QPushButton("🖨️")
        self.print_btn.setToolTip("Print Options")
        self.setup_icon_btn = QPushButton("⚙️")
        self.setup_icon_btn.setToolTip("System Setup")
        header_button_style = f"""QPushButton{{background-color:{DARK_BUTTON_BG};color:{DARK_TEXT_PRIMARY};border:1px solid {DARK_BORDER};border-radius:4px;padding:5px;font-size:14px;min-width:28px;max-width:28px;min-height:28px;max-height:28px;}} QPushButton:hover{{background-color:{DARK_BUTTON_HOVER};}} QPushButton:pressed{{background-color:{DARK_BUTTON_BG};}}"""
        for btn in [
            self.refresh_btn,
            self.help_btn,
            self.print_btn,
            self.setup_icon_btn,
        ]:
            if btn:
                btn.setStyleSheet(header_button_style)
        self.user_menu_button = QPushButton(f"👤 User: {self.current_user}")
        self.user_menu_button.setObjectName("UserMenuButton")
        self.user_menu_button.setToolTip("User options")
        self.user_menu_button.setFlat(True)
        self.user_menu = QMenu(self)
        self.user_menu.setStyleSheet(
            f"""QMenu{{background-color:{DARK_WIDGET_BACKGROUND};color:{DARK_TEXT_PRIMARY};border:1px solid {DARK_BORDER};padding:5px;}} QMenu::item{{padding:5px 20px 5px 20px;min-width:100px;}} QMenu::item:selected{{background-color:{DARK_HIGHLIGHT_BG}70;color:{DARK_HIGHLIGHT_TEXT};}} QMenu::separator{{height:1px;background:{DARK_BORDER};margin-left:5px;margin-right:5px;}}"""
        )
        logout_action = QAction("Log Out", self)
        logout_action.triggered.connect(self.handle_logout_request_from_menu)
        self.user_menu.addAction(logout_action)
        if self.user_menu_button:
            self.user_menu_button.setMenu(self.user_menu)
        for btn in [
            self.refresh_btn,
            self.help_btn,
            self.print_btn,
            self.setup_icon_btn,
            self.user_menu_button,
        ]:
            if btn:
                right_layout.addWidget(btn)
        header_layout.addWidget(left_widget)
        header_layout.addStretch()
        header_layout.addWidget(right_widget)
        parent_layout.addWidget(header_frame)
        self.logger.debug("setup_header: END")

    def setup_action_bar(self, parent_layout):
        self.logger.debug("setup_action_bar: START")
        action_bar_frame = QFrame()
        action_bar_frame.setObjectName("ActionBarFrame")
        action_bar_frame.setFixedHeight(50)
        action_bar_frame.setStyleSheet(
            f"""#ActionBarFrame{{background-color:{DARK_BACKGROUND};border:none;border-bottom:1px solid {DARK_BORDER};padding:0 20px;}} QPushButton{{min-height:30px;}} QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;}} QRadioButton::indicator{{width:13px;height:13px;}} QRadioButton{{color:{DARK_TEXT_SECONDARY};background:transparent;padding:5px;}}"""
        )
        action_bar_layout = QHBoxLayout(action_bar_frame)
        action_bar_layout.setContentsMargins(0, 0, 0, 0)
        action_bar_layout.setSpacing(12)
        action_bar_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.add_horse_btn = QPushButton("➕ Add Horse")
        self.edit_horse_btn = QPushButton("✓ Edit Selected")
        action_button_style_str = self.get_generic_button_style()
        add_btn_bg_color = DARK_PRIMARY_ACTION
        if len(add_btn_bg_color) == 4:
            add_btn_bg_color = f"#{add_btn_bg_color[1]*2}{add_btn_bg_color[2]*2}{add_btn_bg_color[3]*2}"
        if self.add_horse_btn:
            self.add_horse_btn.setStyleSheet(
                action_button_style_str.replace(
                    DARK_BUTTON_BG, add_btn_bg_color + "B3"
                ).replace(f"color:{DARK_TEXT_PRIMARY}", "color:white;")
            )
        if self.edit_horse_btn:
            self.edit_horse_btn.setStyleSheet(action_button_style_str)
        action_bar_layout.addWidget(self.add_horse_btn)
        action_bar_layout.addWidget(self.edit_horse_btn)
        self.filter_group = QButtonGroup(self)
        self.active_only_radio = QRadioButton("Active Only")
        self.all_horses_radio = QRadioButton("All Horses")
        self.deactivated_radio = QRadioButton("Deactivated")
        for btn in [
            self.active_only_radio,
            self.all_horses_radio,
            self.deactivated_radio,
        ]:
            if btn:
                self.filter_group.addButton(btn)
                action_bar_layout.addWidget(btn)
        if self.active_only_radio:
            self.active_only_radio.setChecked(True)
        action_bar_layout.addStretch()
        self.search_input = QLineEdit()
        if self.search_input:
            self.search_input.setPlaceholderText("🔍 Search...")
            self.search_input.setFixedHeight(30)
            self.search_input.setFixedWidth(220)
            self.search_input.setStyleSheet(
                self.get_form_input_style(base_bg=DARK_HEADER_FOOTER)
            )
        action_bar_layout.addWidget(self.search_input)
        if self.edit_horse_btn:
            self.edit_horse_btn.setEnabled(False)
        parent_layout.addWidget(action_bar_frame)
        self.logger.debug("setup_action_bar: END")

    def setup_main_content(self, parent_layout):
        self.logger.debug("setup_main_content: START")
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        self.splitter.setHandleWidth(1)
        self.splitter.setStyleSheet(
            f"""QSplitter{{background-color:{DARK_BACKGROUND};border:none;}} QSplitter::handle{{background-color:{DARK_BORDER};}} QSplitter::handle:horizontal{{width:1px;}} QSplitter::handle:pressed{{background-color:{DARK_TEXT_SECONDARY};}}"""
        )
        self.setup_horse_list_panel()
        self.setup_horse_details_panel()
        self.splitter.setSizes([300, 850])
        self.splitter.setStretchFactor(0, 0)
        self.splitter.setStretchFactor(1, 1)
        self.splitter.setCollapsible(0, False)
        self.splitter.setCollapsible(1, False)
        parent_layout.addWidget(self.splitter, 1)
        self.logger.debug("setup_main_content: END")

    def setup_horse_list_panel(self):
        from .widgets.horse_list_widget import (
            HorseListWidget,
        )

        self.list_widget_container = QWidget()
        self.list_widget_container.setStyleSheet(
            f"background-color:{DARK_BACKGROUND};border:none;border-right:1px solid {DARK_BORDER};"
        )
        list_layout = QVBoxLayout(self.list_widget_container)
        list_layout.setContentsMargins(0, 0, 0, 0)
        list_layout.setSpacing(0)
        self.horse_list = HorseListWidget()
        if self.horse_list:
            self.horse_list.setMinimumWidth(250)
        list_layout.addWidget(self.horse_list, 1)
        if self.splitter:
            self.splitter.addWidget(self.list_widget_container)

    def setup_horse_details_panel(self):
        self.logger.debug("setup_horse_details_panel: START")
        self.details_widget = QWidget()
        self.details_widget.setStyleSheet(
            f"background-color:{DARK_BACKGROUND};border:none;"
        )
        self.details_layout = QVBoxLayout(self.details_widget)
        self.details_layout.setContentsMargins(15, 10, 15, 10)
        self.details_layout.setSpacing(15)
        self.horse_details_content_widget = QWidget()
        details_content_layout = QVBoxLayout(self.horse_details_content_widget)
        details_content_layout.setContentsMargins(0, 0, 0, 0)
        details_content_layout.setSpacing(15)
        self.setup_horse_header_details(details_content_layout)
        self.setup_horse_tabs(details_content_layout)
        self.setup_empty_state()
        if self.details_layout and self.empty_frame:
            self.details_layout.addWidget(self.empty_frame)
        if self.details_layout and self.horse_details_content_widget:
            self.details_layout.addWidget(self.horse_details_content_widget)
        if self.horse_details_content_widget:
            self.horse_details_content_widget.hide()
        if self.splitter:
            self.splitter.addWidget(self.details_widget)
        self.logger.debug("setup_horse_details_panel: END")

    def setup_empty_state(self):
        self.logger.debug("setup_empty_state (frame creation): START")
        self.empty_frame = QFrame()
        self.empty_frame.setObjectName("EmptyFrame")
        self.empty_frame.setStyleSheet(
            "#EmptyFrame{background-color:transparent;border:none;}"
        )
        empty_layout = QVBoxLayout(self.empty_frame)
        empty_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        empty_layout.setSpacing(15)
        empty_label = QLabel("Select a horse from the list, or click 'Add Horse'.")
        empty_label.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:16px;background:transparent;"
        )
        empty_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        empty_layout.addWidget(empty_label)
        self.logger.debug("setup_empty_state (frame creation): FINISHED")

    def setup_horse_header_details(self, parent_layout):
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(8)
        self.horse_title = QLabel("Horse Name")
        self.horse_title.setFont(QFont(DEFAULT_FONT_FAMILY, 18, QFont.Weight.Bold))
        self.horse_title.setStyleSheet(
            f"color:{DARK_TEXT_PRIMARY};background:transparent;"
        )
        self.horse_info_line = QLabel(" ")
        self.horse_info_line.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:12px;background:transparent;"
        )
        self.horse_info_line.setWordWrap(True)
        header_layout.addWidget(self.horse_title)
        header_layout.addWidget(self.horse_info_line)
        parent_layout.addWidget(header_widget)

    def setup_horse_tabs(self, parent_layout_for_tabs):
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_HORSE_TABS START ---")
        try:
            self.tab_widget = QTabWidget()
            self.tab_widget.setObjectName("DetailsTabWidget")
            self.tab_widget.setStyleSheet(
                f"""QTabWidget#DetailsTabWidget::pane{{border:1px solid {AppConfig.DARK_BORDER};background-color:{AppConfig.DARK_WIDGET_BACKGROUND};border-radius:6px;margin-top:-1px;}} QTabBar::tab{{padding:8px 15px;margin-right:2px;background-color:{AppConfig.DARK_BUTTON_BG};color:{AppConfig.DARK_TEXT_SECONDARY};border:1px solid {AppConfig.DARK_BORDER};border-bottom:none;border-top-left-radius:5px;border-top-right-radius:5px;min-width:90px;font-size:13px;font-weight:500;}} QTabBar::tab:selected{{background-color:{AppConfig.DARK_WIDGET_BACKGROUND};color:{AppConfig.DARK_TEXT_PRIMARY};border-color:{AppConfig.DARK_BORDER};border-bottom-color:{AppConfig.DARK_WIDGET_BACKGROUND};}} QTabBar::tab:!selected:hover{{background-color:{AppConfig.DARK_BUTTON_HOVER};color:{AppConfig.DARK_TEXT_PRIMARY};}} QTabBar{{border:none;background-color:transparent;margin-bottom:0px;}}"""
            )

            self.basic_info_tab = BasicInfoTab(
                horse_controller=self.horse_controller, parent=self
            )
            self.tab_widget.addTab(self.basic_info_tab, "📋 Basic Info")
            self.logger.info("BasicInfoTab created.")

            self.owners_tab = OwnersTab(
                parent_view=self,
                horse_controller=self.horse_controller,
                owner_controller=self.owner_controller,
            )
            self.tab_widget.addTab(self.owners_tab, "👥 Owners")
            self.logger.info("OwnersTab created.")

            self.location_tab = LocationTab(
                parent_view=self,
                horse_controller=self.horse_controller,
                location_controller=self.location_controller,
            )
            self.tab_widget.addTab(self.location_tab, "📍 Location")
            self.logger.info("LocationTab created.")

            self.billing_tab = BillingTab(
                financial_controller=self.financial_controller, parent=self
            )
            self.tab_widget.addTab(self.billing_tab, "💰 Billing")
            self.logger.info("BillingTab created.")

            self.invoice_history_tab = InvoiceHistoryTab(
                financial_controller=self.financial_controller, parent=self
            )
            self.tab_widget.addTab(self.invoice_history_tab, "🧾 Invoice History")
            self.logger.info("InvoiceHistoryTab created.")

            # MODIFIED: Add ReportsTab
            self.reports_tab = ReportsTab(parent=self)
            self.tab_widget.addTab(self.reports_tab, "📊 Reports")
            self.logger.info("ReportsTab created.")

            parent_layout_for_tabs.addWidget(self.tab_widget, 1)
            self.logger.info("Tabs added.")
        except Exception as e:
            self.logger.error(f"ERROR setup_horse_tabs: {e}", exc_info=True)
            if hasattr(self, "tab_widget") and self.tab_widget:
                self.tab_widget.deleteLater()
            self.tab_widget = None
            self.basic_info_tab = None
            self.owners_tab = None
            self.location_tab = None
            self.billing_tab = None
            self.invoice_history_tab = None
            self.reports_tab = None  # ADDED

    def _handle_location_assignment_change(self, location_data: Dict):
        self.logger.info(f"Received location_assignment_changed: {location_data}")
        if self.current_horse and self.current_horse.horse_id is not None:
            horse_id_that_changed = self.current_horse.horse_id
            self.logger.info(
                f"Location changed for horse ID {horse_id_that_changed}. Reloading details."
            )
            self.load_horse_details(horse_id_that_changed)
            if self.current_horse:
                current_loc_name = "[N/A - Error]"
                try:
                    current_loc_name = (
                        self.current_horse.location.location_name
                        if self.current_horse.location
                        and hasattr(self.current_horse.location, "location_name")
                        else "N/A"
                    )
                except DetachedInstanceError:
                    current_loc_name = "[Location N/A - Session Issue]"
                self.update_status(
                    f"Location updated to '{current_loc_name}' for {self.current_horse.horse_name or 'horse'}."
                )
        else:
            self.logger.warning(
                "Location assignment changed, but no current_horse or valid horse_id to refresh."
            )

    def _get_display_owner_name(self, horse: Optional[Horse]) -> str:
        if not horse:
            return "No Owner"
        owner_name_display = "No Owner"
        try:
            if horse.owners and len(horse.owners) > 0:
                actual_owner = horse.owners[0]
                if actual_owner:
                    name_parts: List[str] = []
                    if (
                        hasattr(actual_owner, "farm_name")
                        and actual_owner.farm_name
                        and actual_owner.farm_name.strip()
                    ):
                        name_parts.append(actual_owner.farm_name.strip())
                    person_name_parts: List[str] = []
                    if (
                        hasattr(actual_owner, "first_name")
                        and actual_owner.first_name
                        and actual_owner.first_name.strip()
                    ):
                        person_name_parts.append(actual_owner.first_name.strip())
                    if (
                        hasattr(actual_owner, "last_name")
                        and actual_owner.last_name
                        and actual_owner.last_name.strip()
                    ):
                        person_name_parts.append(actual_owner.last_name.strip())
                    person_name_str = " ".join(person_name_parts).strip()
                    if person_name_str:
                        if name_parts:
                            name_parts.append(f"({person_name_str})")
                        else:
                            name_parts.append(person_name_str)
                    if name_parts:
                        owner_name_display = " ".join(name_parts)
                    elif hasattr(actual_owner, "owner_id"):
                        owner_name_display = f"Owner ID: {actual_owner.owner_id}"
                    else:
                        owner_name_display = "Owner Data Incomplete"
                else:
                    owner_name_display = "Owner Data Missing"
        except DetachedInstanceError:
            logger_obj = getattr(self, "logger", logging.getLogger(__name__))
            logger_obj.warning(
                f"Detached: horse.owners, Horse ID {horse.horse_id if horse else 'N/A'}."
            )
            owner_name_display = "[Own N/A - Detached]"
        except Exception as e:
            self.logger.error(
                f"Error constructing owner display name: {e}", exc_info=True
            )
            owner_name_display = "[Owner Display Error]"
        return owner_name_display

    def _get_display_location_name(self, horse: Optional[Horse]) -> str:
        if not horse:
            return "N/A"
        location_name_str = "N/A"
        try:
            if horse.location and hasattr(horse.location, "location_name"):
                location_name_str = horse.location.location_name or "N/A"
        except DetachedInstanceError:
            logger_obj = getattr(self, "logger", logging.getLogger(__name__))
            logger_obj.warning(
                f"Detached: horse.location, ID {horse.horse_id if horse else 'N/A'}."
            )
            location_name_str = "[Loc N/A - Detached]"
        except Exception as e:
            self.logger.error(f"Error getting location name: {e}", exc_info=True)
            location_name_str = "[Location Error]"
        return location_name_str

    def _update_horse_info_line(self, horse: Optional[Horse]):
        """Restores the detailed info line with icons, per user request."""
        if not hasattr(self, "horse_info_line") or self.horse_info_line is None:
            self.logger.error(
                "_update_horse_info_line: horse_info_line QLabel is None."
            )
            return

        if not horse:
            self.horse_info_line.setText("Acct: N/A | 🍇 Owner: N/A | 📍 Location: N/A")
            return

        age_str = "Age N/A"
        if hasattr(self.horse_list, "_calculate_age") and self.horse_list:
            age_str = self.horse_list._calculate_age(horse.date_of_birth)

        owner_name = self._get_display_owner_name(horse)
        location_name = self._get_display_location_name(horse)

        info_parts = [
            f"Acct: {horse.account_number or 'N/A'}",
            f"🍇 {owner_name}",
            f"Breed: {horse.breed or 'N/A'}",
            f"Color: {horse.color or 'N/A'}",
            f"Sex: {horse.sex or 'N/A'}",
            f"Age: {age_str}",
            f"📍 {location_name}",
        ]
        self.horse_info_line.setText(" | ".join(info_parts))

    def load_horse_details(self, horse_id: int):
        self.logger.info(f"load_horse_details: START for horse ID: {horse_id}")
        horse = self.horse_controller.get_horse_by_id(horse_id)
        if not horse:
            self.show_error("Error", f"Could not load horse ID {horse_id}.")
            self.display_empty_state()
            self.logger.info("load_horse_details: FINISHED (horse not found)")
            return
        self.current_horse = horse
        self._is_new_mode = False
        self._has_changes_in_active_tab = False
        if hasattr(self, "horse_title") and self.horse_title:
            self.horse_title.setText(horse.horse_name or "Unnamed Horse")
        self._update_horse_info_line(horse)
        if self.basic_info_tab:
            self.basic_info_tab.populate_form_data(horse)
        if self.owners_tab:
            self.owners_tab.load_owners_for_horse(horse)
        if self.location_tab:
            self.location_tab.load_location_for_horse(horse)
        if self.billing_tab:
            self.billing_tab.set_current_horse(horse)
        if self.invoice_history_tab:
            self.invoice_history_tab.set_current_horse(horse)

        self.display_details_state()
        self.update_main_action_buttons_state()
        self.update_status(f"Viewing: {horse.horse_name or 'Unnamed Horse'}")
        self.logger.info(f"load_horse_details: FINISHED for horse ID: {horse_id}")

    def add_new_horse(self):
        self.logger.info("add_new_horse: START")
        if self._has_changes_in_active_tab and not self.show_question(
            "Unsaved Changes", "Discard current changes and start new horse record?"
        ):
            self.logger.info("add_new_horse: Aborted due to unsaved changes.")
            return
        self._is_new_mode = True
        self._has_changes_in_active_tab = False
        self.current_horse = None
        if self.horse_list and self.horse_list.selectionModel():
            self.logger.debug("add_new_horse: Clearing horse list selection.")
            self.horse_list.blockSignals(True)
            self.horse_list.selectionModel().clear()
            self.horse_list.blockSignals(False)
        if self.basic_info_tab and hasattr(self.basic_info_tab, "set_new_mode"):
            self.logger.debug("add_new_horse: Setting BasicInfoTab to new mode.")
            self.basic_info_tab.set_new_mode(is_new=True)
        else:
            self.logger.error("add_new_horse: BasicInfoTab missing or no set_new_mode.")
            self.show_error("UI Error", "Details form unavailable.")
            self._is_new_mode = False
            return
        if self.owners_tab:
            self.owners_tab.load_owners_for_horse(None)
        if self.location_tab:
            self.location_tab.load_location_for_horse(None)
        if self.billing_tab:
            self.billing_tab.set_current_horse(None)
        if self.invoice_history_tab:
            self.invoice_history_tab.set_current_horse(None)

        if hasattr(self, "horse_title") and self.horse_title:
            self.horse_title.setText("New Horse Record")
        self._update_horse_info_line(None)
        self.display_details_state()
        if self.tab_widget and self.basic_info_tab:
            self.logger.debug("add_new_horse: Setting current tab to BasicInfoTab.")
            self.tab_widget.setCurrentWidget(self.basic_info_tab)
        self.update_main_action_buttons_state()
        self.update_status("Enter details for new horse.")
        self.logger.info("add_new_horse: FINISHED")

    def _on_tab_data_modified(self):
        if (
            self.basic_info_tab
            and hasattr(self.basic_info_tab, "horse_name_input")
            and self.basic_info_tab.horse_name_input
            and not self.basic_info_tab.horse_name_input.isReadOnly()
        ):
            if not self._has_changes_in_active_tab:
                self._has_changes_in_active_tab = True
                self.logger.debug("Data modified. Flag set.")
            self.update_main_action_buttons_state()
        else:
            self.logger.debug(
                "_on_tab_data_modified: Signal received, but form read-only or input missing."
            )

    def _on_owner_association_changed(self, message: str):
        self.logger.info(f"_on_owner_association_changed: {message}")
        self.update_status(message)
        if self.current_horse and self.current_horse.horse_id is not None:
            self.load_horse_details(self.current_horse.horse_id)
        self.update_main_action_buttons_state()

    def handle_toggle_active_status_from_tab(self, new_active_status_requested: bool):
        self.logger.info(
            f"handle_toggle_active_status_from_tab: Requested: {new_active_status_requested}"
        )
        if self.current_horse:
            self.handle_toggle_active_status()
        else:
            self.logger.warning(
                "handle_toggle_active_status_from_tab: No current horse."
            )

    def setup_footer(self, parent_layout):
        self.logger.debug("setup_footer: START")
        self.status_bar = QStatusBar()
        self.status_bar.setFixedHeight(28)
        self.status_bar.setStyleSheet(
            f"""QStatusBar{{background-color:{DARK_HEADER_FOOTER};color:{DARK_TEXT_SECONDARY};border:none;border-top:1px solid {DARK_BORDER};padding:0 15px;font-size:11px;}}QStatusBar::item{{border:none;}}QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;font-size:11px;}}"""
        )
        parent_layout.addWidget(self.status_bar)
        self.status_label = QLabel("Ready")
        self.footer_horse_count_label = QLabel("Showing 0 of 0 horses")

        self.status_bar.addWidget(self.status_label, 1)
        self.status_bar.addPermanentWidget(self.footer_horse_count_label)

        self.logger.debug("setup_footer: FINISHED")

    def save_changes(self):
        self.logger.info("save_changes: START")
        if not self.basic_info_tab:
            self.logger.error("save_changes: BasicInfoTab missing.")
            self.show_error("Save Error", "UI component missing.")
            return
        if not self._has_changes_in_active_tab and not self._is_new_mode:
            self.update_status("No changes to save.")
            if (
                hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing
                and hasattr(self.basic_info_tab, "set_form_read_only")
            ):
                self.basic_info_tab.set_form_read_only(True)
                self.update_main_action_buttons_state()
            return
        horse_data = self.basic_info_tab.get_data_from_form()
        if (
            self.current_horse
            and self.current_horse.current_location_id is not None
            and not self._is_new_mode
        ):
            horse_data["current_location_id"] = self.current_horse.current_location_id
        elif "current_location_id" not in horse_data:
            horse_data["current_location_id"] = None
        self.logger.debug(
            f"save_changes: Validating data. New: {self._is_new_mode}. Data: {horse_data}"
        )
        is_valid, errors = self.horse_controller.validate_horse_data(
            horse_data,
            is_new=self._is_new_mode,
            horse_id_to_check_for_unique=(
                self.current_horse.horse_id
                if not self._is_new_mode and self.current_horse
                else None
            ),
        )
        if not is_valid:
            self.show_warning(
                "Validation Error", "Correct errors:\n\n- " + "\n- ".join(errors)
            )
            self.logger.info("save_changes: Validation failed.")
            return
        try:
            saved_id: Optional[int] = None
            success: bool = False
            msg: str = ""
            if not self._is_new_mode and self.current_horse:
                self.logger.debug(
                    f"save_changes: Updating horse ID {self.current_horse.horse_id}"
                )
                success, msg = self.horse_controller.update_horse(
                    self.current_horse.horse_id, horse_data, self.current_user
                )
                if success:
                    saved_id = self.current_horse.horse_id
            else:
                self.logger.debug("save_changes: Creating new horse")
                success, msg, new_horse_obj = self.horse_controller.create_horse(
                    horse_data, self.current_user
                )
                if success and new_horse_obj:
                    saved_id = new_horse_obj.horse_id
                elif success and not new_horse_obj:
                    self.logger.error(
                        f"save_changes: Horse creation success={success}, but new_horse_obj is None. Msg: {msg}"
                    )
            if success:
                self.logger.info(f"save_changes: Save successful. Message: {msg}")
                self.show_info("Success", msg)
                self._has_changes_in_active_tab = False
                if self.basic_info_tab and hasattr(
                    self.basic_info_tab, "mark_as_saved"
                ):
                    self.basic_info_tab.mark_as_saved()
                if self._is_new_mode and saved_id is not None:
                    newly_saved_horse = self.horse_controller.get_horse_by_id(saved_id)
                    if newly_saved_horse:
                        self.current_horse = newly_saved_horse
                        self._is_new_mode = False
                        self.logger.debug(
                            f"save_changes: New horse {saved_id} set as current."
                        )
                    else:
                        self.logger.error(
                            f"save_changes: Failed to re-fetch new horse {saved_id}."
                        )
                        self.display_empty_state()
                        self.load_horses()
                        return
                self.load_horses()
                if saved_id is not None and self.horse_list:
                    self.logger.debug(
                        f"save_changes: Verifying selection for horse ID {saved_id} in list after load_horses."
                    )
                    found_and_selected = False
                    for i in range(self.horse_list.count()):
                        item = self.horse_list.item(i)
                        if item and item.data(Qt.ItemDataRole.UserRole) == saved_id:
                            if self.horse_list.currentRow() != i:
                                self.horse_list.setCurrentRow(i)
                            else:
                                self.load_horse_details(saved_id)
                            found_and_selected = True
                            self.logger.debug(
                                f"save_changes: Verified/reselected row {i} for ID {saved_id}."
                            )
                            break
                    if not found_and_selected:
                        self.logger.debug(
                            f"save_changes: Horse ID {saved_id} not found in list after save/refresh for final reselection attempt."
                        )
                        if self.horse_list.count() > 0:
                            self.horse_list.setCurrentRow(0)
                        else:
                            self.display_empty_state()
                elif self.horse_list and self.horse_list.count() > 0:
                    self.horse_list.setCurrentRow(0)
                elif not self.horse_list or self.horse_list.count() == 0:
                    self.display_empty_state()
            else:
                self.logger.error(f"save_changes: Save failed. Message: {msg}")
                self.show_error("Save Failed", msg or "Unknown error.")
        except Exception as e:
            self.logger.error(f"save_changes: Exception: {e}", exc_info=True)
            self.show_error("Save Error", f"Unexpected error: {e}")
        self.logger.info("save_changes: FINISHED")

    def populate_horse_list(self):
        self.logger.debug("populate_horse_list: START")
        if not hasattr(self, "horse_list") or not self.horse_list:
            self.logger.error("populate_horse_list: horse_list widget not ready.")
            return
        current_selected_id = None
        if self.horse_list.currentItem():
            current_selected_id = self.horse_list.currentItem().data(
                Qt.ItemDataRole.UserRole
            )
        self.logger.debug(
            f"populate_horse_list: Clearing list. Previously selected ID: {current_selected_id}"
        )
        self.horse_list.clear()
        for horse_obj in self.horses_list_data:
            item = QListWidgetItem()
            item_widget = self.horse_list.create_horse_list_item_widget(horse_obj)
            item.setSizeHint(QSize(item_widget.sizeHint().width(), 70))
            item.setData(Qt.ItemDataRole.UserRole, horse_obj.horse_id)
            self.horse_list.addItem(item)
            self.horse_list.setItemWidget(item, item_widget)
        self.logger.debug(
            f"populate_horse_list: List populated with {len(self.horses_list_data)} items."
        )
        if hasattr(self, "footer_horse_count_label") and self.footer_horse_count_label:
            total_horses_in_db = len(
                self.horse_controller.search_horses(status="all", search_term="")
            )
            self.footer_horse_count_label.setText(
                f"Showing {self.horse_list.count()} of {total_horses_in_db} total horses"
            )
        if current_selected_id is not None:
            for i in range(self.horse_list.count()):
                if (
                    self.horse_list.item(i).data(Qt.ItemDataRole.UserRole)
                    == current_selected_id
                ):
                    self.horse_list.setCurrentRow(i)
                    self.logger.debug(
                        f"populate_horse_list: Reselected row {i} for ID {current_selected_id}"
                    )
                    break
        self.logger.debug("populate_horse_list: FINISHED")

    def load_horses(self):
        self.logger.debug("load_horses: START")
        try:
            if (
                not hasattr(self, "search_input")
                or self.search_input is None
                or not hasattr(self, "active_only_radio")
                or self.active_only_radio is None
                or not hasattr(self, "all_horses_radio")
                or self.all_horses_radio is None
                or not hasattr(self, "deactivated_radio")
                or self.deactivated_radio is None
            ):
                self.logger.error("load_horses: Search/filter UI elements not ready.")
                return
            search_term = self.search_input.text()
            status_filter = "active"
            if self.all_horses_radio.isChecked():
                status_filter = "all"
            elif self.deactivated_radio.isChecked():
                status_filter = "inactive"
            self.logger.info(
                f"load_horses: Filter status: '{status_filter}', Search: '{search_term}'"
            )
            previously_selected_id = None
            if self.current_horse and not self._is_new_mode:
                previously_selected_id = self.current_horse.horse_id
            elif self.horse_list and self.horse_list.currentItem():
                current_item_data = self.horse_list.currentItem().data(
                    Qt.ItemDataRole.UserRole
                )
                if isinstance(current_item_data, int):
                    previously_selected_id = current_item_data
            self.logger.debug(
                f"load_horses: Previously selected ID to try and reselect: {previously_selected_id}"
            )
            self.horses_list_data = self.horse_controller.search_horses(
                search_term=search_term, status=status_filter
            )
            self.logger.debug(
                f"load_horses: {len(self.horses_list_data)} horses found by controller."
            )
            self.populate_horse_list()
            if not self.horses_list_data:
                self.logger.debug(
                    "load_horses: No horses found, displaying empty state."
                )
                self.display_empty_state()
                self.logger.debug("load_horses: FINISHED (no horses)")
                return
            reselected_successfully = False
            if previously_selected_id is not None and self.horse_list:
                for i in range(self.horse_list.count()):
                    item = self.horse_list.item(i)
                    if (
                        item
                        and item.data(Qt.ItemDataRole.UserRole)
                        == previously_selected_id
                    ):
                        self.logger.debug(
                            f"load_horses: Attempting to reselect ID {previously_selected_id} at row {i}."
                        )
                        self.horse_list.setCurrentRow(i)
                        reselected_successfully = True
                        self.logger.debug(
                            "load_horses: Reselected row. on_selection_changed will handle details load."
                        )
                        break
            if (
                not reselected_successfully
                and self.horse_list
                and self.horse_list.count() > 0
            ):
                self.logger.debug(
                    "load_horses: No reselection or previous ID not found, selecting row 0."
                )
                self.horse_list.setCurrentRow(0)
            elif not self.horse_list or self.horse_list.count() == 0:
                self.logger.debug(
                    "load_horses: List is empty after populate, displaying empty state."
                )
                self.display_empty_state()
            if not (self.horse_list and self.horse_list.currentItem()):
                self.update_main_action_buttons_state()
        except Exception as e:
            self.logger.error(f"load_horses: ERROR: {e}", exc_info=True)
            self.show_error("Load Horses Error", f"{e}")
            self.horses_list_data = []
            if hasattr(self, "horse_list") and self.horse_list:
                self.populate_horse_list()
            self.display_empty_state()
        self.logger.debug("load_horses: FINISHED")

    def on_search_text_changed(self):
        if hasattr(self.search_timer, "isActive") and self.search_timer.isActive():
            self.search_timer.stop()
        self.search_timer.start(350)

    def perform_search(self):
        self.logger.debug(
            f"perform_search: Term: '{self.search_input.text() if self.search_input else ''}'"
        )
        self.load_horses()

    def on_filter_changed(self):
        sender_widget = self.sender()
        if isinstance(sender_widget, QRadioButton) and sender_widget.isChecked():
            self.logger.info(f"on_filter_changed: To {sender_widget.text()}")
        self.load_horses()

    def on_selection_changed(self):
        self.logger.debug("on_selection_changed: START")
        if not self.horse_list:
            self.logger.warning("on_selection_changed: horse_list is None.")
            return
        selected_items = self.horse_list.selectedItems()
        if not selected_items:
            self.logger.debug("on_selection_changed: No items selected.")
            if not self._is_new_mode and not self._has_changes_in_active_tab:
                self.display_empty_state()
            return
        selected_item = selected_items[0]
        newly_selected_horse_id = selected_item.data(Qt.ItemDataRole.UserRole)
        self.logger.debug(
            f"on_selection_changed: Newly selected ID: {newly_selected_horse_id}"
        )
        current_horse_id = self.current_horse.horse_id if self.current_horse else None
        self.logger.debug(
            f"on_selection_changed: Current horse ID: {current_horse_id}, New mode: {self._is_new_mode}, Has changes: {self._has_changes_in_active_tab}"
        )
        if (self._has_changes_in_active_tab or self._is_new_mode) and (
            newly_selected_horse_id != current_horse_id
            or (self._is_new_mode and newly_selected_horse_id is not None)
        ):
            self.logger.debug(
                "on_selection_changed: Unsaved changes detected. Prompting user."
            )
            if not self.show_question(
                "Unsaved Changes",
                f"Discard unsaved {'new horse record' if self._is_new_mode else 'changes to current horse'}?",
            ):
                self.logger.debug(
                    "on_selection_changed: User chose NOT to discard. Reverting selection."
                )
                self.horse_list.blockSignals(True)
                if current_horse_id is not None and not self._is_new_mode:
                    for i in range(self.horse_list.count()):
                        if (
                            self.horse_list.item(i).data(Qt.ItemDataRole.UserRole)
                            == current_horse_id
                        ):
                            self.horse_list.setCurrentRow(i)
                            break
                else:
                    self.horse_list.clearSelection()
                self.horse_list.blockSignals(False)
                self.logger.debug("on_selection_changed: FINISHED (reverted selection)")
                return
            self.logger.debug("on_selection_changed: User chose to discard changes.")
            self._has_changes_in_active_tab = False
            self._is_new_mode = False
            self.logger.debug(
                "on_selection_changed: Flags reset (_has_changes_in_active_tab, _is_new_mode)."
            )
        if newly_selected_horse_id is not None:
            if newly_selected_horse_id == current_horse_id and not self._is_new_mode:
                self.logger.debug(
                    f"on_selection_changed: Same horse ID ({current_horse_id}) re-selected. Ensuring read-only state."
                )
                if (
                    self.basic_info_tab
                    and hasattr(self.basic_info_tab, "_is_editing")
                    and self.basic_info_tab._is_editing
                    and not self._has_changes_in_active_tab
                    and hasattr(self.basic_info_tab, "set_form_read_only")
                ):
                    self.basic_info_tab.set_form_read_only(True)
                self.update_main_action_buttons_state()
                self.logger.debug(
                    "on_selection_changed: FINISHED (same horse, no load unless it was new mode that got discarded)"
                )
                return
            self.load_horse_details(newly_selected_horse_id)
        else:
            self.logger.debug(
                "on_selection_changed: newly_selected_horse_id is None, displaying empty state."
            )
            self.display_empty_state()
        self.logger.debug("on_selection_changed: FINISHED")

    def edit_selected_horse(self, item=None):
        self.logger.info(f"edit_selected_horse triggered. Item: {item}")
        if self.current_horse and not self._is_new_mode:
            if not self.tab_widget:
                self.logger.error("edit_selected_horse: Tab widget missing.")
                self.show_error("UI Error", "Tabs unavailable.")
                return
            current_tab_widget = self.tab_widget.currentWidget()
            self.logger.debug(
                f"edit_selected_horse: Current tab: {current_tab_widget.objectName() if current_tab_widget else 'None'}"
            )
            if (
                current_tab_widget == self.basic_info_tab
                and self.basic_info_tab
                and hasattr(self.basic_info_tab, "set_edit_mode")
            ):
                self.logger.debug(
                    "edit_selected_horse: Setting BasicInfoTab to edit mode."
                )
                self.basic_info_tab.set_edit_mode(True)
                self._has_changes_in_active_tab = False
            elif hasattr(current_tab_widget, "set_edit_mode"):
                self.logger.debug(
                    f"edit_selected_horse: Setting current tab {current_tab_widget.objectName()} to edit mode."
                )
                current_tab_widget.set_edit_mode(True)
                self._has_changes_in_active_tab = False
            else:
                self.logger.info(
                    f"edit_selected_horse: Current tab does not support direct edit. Defaulting to BasicInfoTab edit mode."
                )
                if self.basic_info_tab and hasattr(
                    self.basic_info_tab, "set_edit_mode"
                ):
                    self.basic_info_tab.set_edit_mode(True)
                    self._has_changes_in_active_tab = False
            self.update_main_action_buttons_state()
            self.update_status(
                f"Editing details for: {self.current_horse.horse_name or 'Unnamed Horse'}"
            )
        elif self._is_new_mode:
            self.show_info(
                "Information", "Currently adding new. Save or discard first."
            )
        else:
            self.show_info("Edit Horse", "Select a horse to edit.")
        self.logger.debug("edit_selected_horse: FINISHED")

    def refresh_data(self):
        self.logger.debug("refresh_data: START")
        if (
            self._has_changes_in_active_tab or self._is_new_mode
        ) and not self.show_question("Unsaved Changes", "Discard and refresh?"):
            self.logger.debug("refresh_data: Aborted due to unsaved changes.")
            return
        self.logger.info("refresh_data: Proceeding with refresh.")
        self._has_changes_in_active_tab = False
        self._is_new_mode = False
        self.load_horses()
        self.update_status("Data refreshed.")
        self.logger.debug("refresh_data: FINISHED")

    def show_help(self):
        self.logger.debug("show_help: Displaying help message.")
        QMessageBox.information(
            self,
            "EDSI Help",
            "Horse Management Screen:\n\n- Use the list on the left to select a horse.\n- Double-click a horse to edit.\n- Click 'Add Horse' or Ctrl+N to create a new record.\n- Tabs on the right show different aspects of the horse's data.\n- Use radio buttons to filter the list by status.\n- Search box filters by name, account, chip, etc.\n- F5 to refresh. Ctrl+S to save (when editing). Esc to discard (when editing).",
        )

    def keyPressEvent(self, event: QKeyEvent):
        key = event.key()
        modifiers = QApplication.keyboardModifiers()
        self.logger.debug(f"keyPressEvent: Key {key}, Modifiers {modifiers}")
        if key == Qt.Key.Key_F5:
            self.refresh_data()
        elif modifiers == Qt.KeyboardModifier.ControlModifier and key == Qt.Key.Key_N:
            if (
                hasattr(self, "add_horse_btn")
                and self.add_horse_btn
                and self.add_horse_btn.isEnabled()
            ):
                self.add_new_horse()
        elif modifiers == Qt.KeyboardModifier.ControlModifier and key == Qt.Key.Key_S:
            if (
                self.tab_widget
                and self.basic_info_tab
                and self.tab_widget.currentWidget() == self.basic_info_tab
                and hasattr(self.basic_info_tab, "save_btn")
                and self.basic_info_tab.save_btn.isEnabled()
            ):
                self.logger.info("keyPressEvent: Ctrl+S triggering BasicInfoTab save.")
                self.basic_info_tab.save_requested.emit()
            else:
                self.logger.info(
                    "keyPressEvent: Ctrl+S conditions not met for BasicInfoTab save."
                )
        elif key == Qt.Key.Key_F1:
            self.show_help()
        elif key == Qt.Key.Key_Escape:
            active_modal_widget = QApplication.activeModalWidget()
            if active_modal_widget and isinstance(active_modal_widget, QDialog):
                self.logger.debug(
                    "keyPressEvent: Escape rejecting active modal dialog."
                )
                active_modal_widget.reject()
            elif self._has_changes_in_active_tab or self._is_new_mode:
                self.logger.debug("keyPressEvent: Escape triggering discard_changes.")
                self.discard_changes()
            elif (
                self.basic_info_tab
                and hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing
            ):
                self.logger.debug(
                    "keyPressEvent: Escape reverting BasicInfoTab to read-only."
                )
                self.discard_changes()
            else:
                super().keyPressEvent(event)
        else:
            super().keyPressEvent(event)

    def handle_logout_request_from_menu(self):
        self.logger.info(
            f"handle_logout_request_from_menu: User '{self.current_user}' logout."
        )
        self.exit_requested.emit()

    def _on_invoice_created(self):
        self.logger.info("Invoice created signal received, refreshing history tab.")
        if self.invoice_history_tab:
            self.invoice_history_tab.load_invoices()

    def _on_invoice_deleted(self):
        self.logger.info(
            "Invoice deleted signal received, refreshing all relevant tabs."
        )
        if self.invoice_history_tab:
            self.invoice_history_tab.load_invoices()
        if self.billing_tab:
            self.billing_tab.load_transactions()

    def _on_payment_recorded(self):
        self.logger.info(
            "Payment recorded signal received, refreshing all horse details."
        )
        if self.current_horse:
            self.load_horse_details(self.current_horse.horse_id)

    def setup_connections(self):
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_CONNECTIONS START ---")
        if hasattr(self, "add_horse_btn") and self.add_horse_btn:
            self.add_horse_btn.clicked.connect(self.add_new_horse)
        if hasattr(self, "edit_horse_btn") and self.edit_horse_btn:
            self.edit_horse_btn.clicked.connect(self.edit_selected_horse)
        if hasattr(self, "refresh_btn") and self.refresh_btn:
            self.refresh_btn.clicked.connect(self.refresh_data)
        if hasattr(self, "help_btn") and self.help_btn:
            self.help_btn.clicked.connect(self.show_help)
        if hasattr(self, "setup_icon_btn") and self.setup_icon_btn:
            self.setup_icon_btn.clicked.connect(self.setup_requested.emit)
        if hasattr(self, "active_only_radio") and self.active_only_radio:
            self.active_only_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "all_horses_radio") and self.all_horses_radio:
            self.all_horses_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "deactivated_radio") and self.deactivated_radio:
            self.deactivated_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "search_input") and self.search_input:
            self.search_input.textChanged.connect(self.on_search_text_changed)
        if hasattr(self, "horse_list") and self.horse_list:
            self.horse_list.itemSelectionChanged.connect(self.on_selection_changed)
            self.horse_list.itemDoubleClicked.connect(self.edit_selected_horse)

        if self.basic_info_tab:
            self.logger.info("Connecting BasicInfoTab signals.")
            if hasattr(self.basic_info_tab, "data_modified"):
                self.basic_info_tab.data_modified.connect(self._on_tab_data_modified)
            if hasattr(self.basic_info_tab, "save_requested"):
                self.basic_info_tab.save_requested.connect(self.save_changes)
            if hasattr(self.basic_info_tab, "discard_requested"):
                self.basic_info_tab.discard_requested.connect(self.discard_changes)
            if hasattr(self.basic_info_tab, "toggle_active_requested"):
                self.basic_info_tab.toggle_active_requested.connect(
                    self.handle_toggle_active_status_from_tab
                )
        else:
            self.logger.warning(
                "BasicInfoTab is None, its signals cannot be connected."
            )
        if self.owners_tab:
            self.logger.info("Connecting OwnersTab signals.")
            if hasattr(self.owners_tab, "owner_association_changed"):
                self.owners_tab.owner_association_changed.connect(
                    self._on_owner_association_changed
                )
        else:
            self.logger.warning("OwnersTab is None, its signals cannot be connected.")
        if self.location_tab:
            self.logger.info("Connecting LocationTab signals.")
            if hasattr(self.location_tab, "location_assignment_changed"):
                self.location_tab.location_assignment_changed.connect(
                    self._handle_location_assignment_change
                )
        else:
            self.logger.warning("LocationTab is None, its signals cannot be connected.")
        if self.billing_tab:
            self.billing_tab.status_message.connect(self.update_status)
            if hasattr(self.billing_tab, "invoice_created"):
                self.billing_tab.invoice_created.connect(self._on_invoice_created)

        if self.invoice_history_tab:
            self.logger.info("Connecting InvoiceHistoryTab signals.")
            self.invoice_history_tab.status_message.connect(self.update_status)
            if hasattr(self.invoice_history_tab, "invoice_deleted"):
                self.invoice_history_tab.invoice_deleted.connect(
                    self._on_invoice_deleted
                )
            if hasattr(self.invoice_history_tab, "payment_recorded"):
                self.invoice_history_tab.payment_recorded.connect(
                    self._on_payment_recorded
                )
        else:
            self.logger.warning(
                "InvoiceHistoryTab is None, its signals cannot be connected."
            )
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_CONNECTIONS END ---")

=============== FILE: views/horse/dialogs/__init__.py ===============

# views/horse/dialogs/__init__.py

from .add_charge_dialog import AddChargeDialog
from .edit_charge_dialog import EditChargeDialog
from .edit_all_charges_dialog import EditAllChargesDialog
from .create_link_owner_dialog import CreateAndLinkOwnerDialog
from .link_existing_owner_dialog import LinkExistingOwnerDialog
from .select_existing_location_dialog import SelectExistingLocationDialog

__all__ = [
    "AddChargeDialog",
    "EditChargeDialog",
    "EditAllChargesDialog",
    "CreateAndLinkOwnerDialog",
    "LinkExistingOwnerDialog",
    "SelectExistingLocationDialog",
]


=============== FILE: views/horse/dialogs/add_charge_dialog.py ===============

# views/horse/dialogs/add_charge_dialog.py
"""
EDSI Veterinary Management System - Add Charge Dialog
Version: 3.4.0
Purpose: Dialog for entering multiple charge transactions for a horse using a table.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v3.4.0 (2025-06-09):
    - Refactored to use ChargeCodeController instead of FinancialController to
      fetch the list of charge codes, resolving an AttributeError.
    - Imported ChargeCodeController and instantiated it in __init__.
    - Modified _load_initial_data to call get_all_charge_codes(status_filter="active").
- v3.3.2 (2025-06-08):
    - Bug Fix: Re-implemented "add row on Enter" functionality using a subclassed
      QLineEdit to correctly intercept the key press and prevent the dialog
      from closing prematurely.
- v3.3.1 (2025-06-07):
    - Bug Fix: Corrected the behavior of the Enter key. It no longer closes the
      dialog but now correctly adds a new charge row for rapid data entry.
    - Removed the `EnterKeyEventFilter` in favor of connecting the `returnPressed`
      signal directly from the QLineEdit widgets in the table.
    - Disabled the default button behavior on the dialog's button box.
- v3.3.0 (2025-06-07):
    - Added a tax rate input field to allow for percentage-based tax calculation.
- v3.2.0 (2025-06-07):
    - Re-styled all input fields to match the BasicInfoTab style.
- v3.1.0 (2025-06-07):
    - Updated header format to match the main HorseUnifiedManagement screen.
    - Repositioned the Save/Cancel buttons to the bottom-left of the dialog.
- v3.0.3 (2025-06-07):
    - Bug Fix: Corrected signal name from `currentRowChanged` to `currentCellChanged`.
- v3.0.2 (2025-06-07):
    - Bug Fix: Corrected an AttributeError by using QAbstractSpinBox.ButtonSymbols.NoButtons.
- v3.0.1 (2025-06-07):
    - Bug Fix: Imported the `Slot` decorator from PySide6.QtCore.
- v3.0.0 (2025-06-07):
    - Complete refactor to a `QTableWidget`-based interface for charge entry.
"""

import logging
from decimal import Decimal, InvalidOperation
from datetime import date
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QPushButton,
    QLabel,
    QDialogButtonBox,
    QMessageBox,
    QWidget,
    QHBoxLayout,
    QSpacerItem,
    QSizePolicy,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QLineEdit,
    QCompleter,
    QDoubleSpinBox,
    QCheckBox,
    QAbstractItemView,
    QFormLayout,
    QTextEdit,
    QApplication,
    QAbstractSpinBox,
)
from PySide6.QtCore import Qt, Signal, QTimer, QEvent, QObject, Slot
from PySide6.QtGui import QFont, QColor, QPainter, QPen, QKeyEvent

from models import Horse, Transaction, ChargeCode
from controllers import FinancialController, ChargeCodeController
from config.app_config import AppConfig


class BoxedCellDelegate(QStyledItemDelegate):
    """A delegate to draw borders around cells to give them a 'boxed' look."""

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index):
        super().paint(painter, option, index)
        painter.save()
        pen = QPen(QColor(AppConfig.DARK_BORDER))
        pen.setWidth(1)
        painter.setPen(pen)
        painter.drawRect(option.rect)
        painter.restore()


class EnterKeyLineEdit(QLineEdit):
    """A QLineEdit that emits a signal when Enter is pressed and consumes the event."""

    enter_pressed = Signal()

    def keyPressEvent(self, event: QKeyEvent):
        if event.key() in [Qt.Key.Key_Return, Qt.Key.Key_Enter]:
            event.accept()
            self.enter_pressed.emit()
        else:
            super().keyPressEvent(event)


class AddChargeDialog(QDialog):
    """A dialog for adding multiple charge items for a horse in a table."""

    charges_saved = Signal(list)

    def __init__(
        self,
        horse: Horse,
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse = horse
        self.financial_controller = financial_controller
        self.charge_code_controller = ChargeCodeController()
        self.current_user_id = QApplication.instance().current_user_id

        self.setWindowTitle(f"Add Charges for: {self.horse.horse_name}")
        self.setMinimumSize(1200, 700)

        self._charge_codes_list: List[ChargeCode] = []
        self._charge_code_lookup: Dict[str, ChargeCode] = {}
        self._alt_code_lookup: Dict[str, ChargeCode] = {}
        self._row_notes: Dict[int, str] = {}
        self._current_notes_row: Optional[int] = None
        self._taxable_subtotal = Decimal(0)

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()

        self._populate_header()
        QTimer.singleShot(0, self._load_initial_data)

    def _get_input_field_style(self) -> str:
        """Generates the requested style for all input fields."""
        return f"""
            QLineEdit, QDoubleSpinBox, QTextEdit, EnterKeyLineEdit {{
                background-color: #3E3E3E;
                color: white;
                border: 1px solid white;
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus, EnterKeyLineEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QCheckBox::indicator {{
                width: 14px;
                height: 14px;
                border: 1px solid white;
                border-radius: 3px;
                background-color: #3E3E3E;
            }}
            QCheckBox::indicator:checked {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                border-color: {AppConfig.DARK_SUCCESS_ACTION};
            }}
            QCompleter::popup {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
            }}
            QCompleter::popup::item:selected {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
        """

    def _setup_ui(self):
        """Initializes and lays out the UI widgets based on the new design."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        # --- Header ---
        self.horse_title_label = QLabel()
        self.horse_info_line_label = QLabel()
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.addWidget(self.horse_title_label)
        header_layout.addWidget(self.horse_info_line_label)
        main_layout.addWidget(header_widget)

        # --- Main Content: Table and Notes ---
        content_layout = QHBoxLayout()
        table_container = QWidget()
        table_layout = QVBoxLayout(table_container)
        table_layout.setContentsMargins(0, 0, 0, 0)

        self.charges_table = QTableWidget()
        table_layout.addWidget(self.charges_table)

        self.notes_edit = QTextEdit()
        table_layout.addWidget(self.notes_edit)
        table_layout.setStretchFactor(self.charges_table, 3)
        table_layout.setStretchFactor(self.notes_edit, 1)

        content_layout.addWidget(table_container)
        main_layout.addLayout(content_layout, 1)

        # --- Footer ---
        footer_layout = QHBoxLayout()
        footer_layout.setContentsMargins(0, 10, 0, 0)

        self.button_box = QDialogButtonBox()
        self.save_button = self.button_box.addButton(
            "Save Charges", QDialogButtonBox.ButtonRole.AcceptRole
        )
        self.cancel_button = self.button_box.addButton(
            "Cancel", QDialogButtonBox.ButtonRole.RejectRole
        )
        self.save_button.setAutoDefault(False)
        self.cancel_button.setAutoDefault(False)

        totals_container = QWidget()
        totals_form_layout = QFormLayout(totals_container)
        totals_form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        self.subtotal_label = QLabel("$0.00")
        self.taxable_subtotal_label = QLabel("$0.00")
        self.tax_amount_input = QDoubleSpinBox()
        self.tax_rate_input = QDoubleSpinBox()
        self.grand_total_label = QLabel("$0.00")

        tax_layout = QHBoxLayout()
        tax_layout.addWidget(self.tax_rate_input)
        tax_layout.addWidget(self.tax_amount_input)

        totals_form_layout.addRow("Subtotal:", self.subtotal_label)
        totals_form_layout.addRow("Taxable Subtotal:", self.taxable_subtotal_label)
        totals_form_layout.addRow("Tax (% / Amt):", tax_layout)
        totals_form_layout.addRow("<b>Grand Total:</b>", self.grand_total_label)

        footer_layout.addWidget(self.button_box)
        footer_layout.addStretch()
        footer_layout.addWidget(totals_container)

        main_layout.addLayout(footer_layout)

    def _populate_header(self):
        self.horse_title_label.setText(self.horse.horse_name)

        age_str = self._calculate_age(self.horse.date_of_birth)
        owner_name = self._get_display_owner_name(self.horse)
        location_name = self._get_display_location_name(self.horse)

        info_parts = [
            f"Acct: {self.horse.account_number or 'N/A'}",
            f"👥 {owner_name}",
            f"Breed: {self.horse.breed or 'N/A'}",
            f"Color: {self.horse.color or 'N/A'}",
            f"Sex: {self.horse.sex or 'N/A'}",
            f"Age: {age_str}",
            f"📍 {location_name}",
        ]
        self.horse_info_line_label.setText(" | ".join(info_parts))

    def _apply_styles(self):
        """Applies consistent styling to the dialog's widgets."""
        self.horse_title_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 16, QFont.Weight.Bold)
        )
        self.horse_title_label.setStyleSheet(f"color:{AppConfig.DARK_TEXT_PRIMARY};")
        self.horse_info_line_label.setStyleSheet(
            f"color:{AppConfig.DARK_TEXT_SECONDARY}; font-size: 11px;"
        )

        self.charges_table.setColumnCount(7)
        self.charges_table.setHorizontalHeaderLabels(
            ["Code", "Alt. Code", "Description", "Qty", "Unit Price", "Tax", "Total"]
        )
        self.charges_table.verticalHeader().setVisible(False)
        self.charges_table.setItemDelegate(BoxedCellDelegate(self))
        header = self.charges_table.horizontalHeader()
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        self.charges_table.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.charges_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )

        self.notes_edit.setPlaceholderText(
            "Notes for the selected line item will appear here..."
        )

        self.tax_rate_input.setDecimals(4)
        self.tax_rate_input.setRange(0.00, 100.00)
        self.tax_rate_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.tax_rate_input.setSuffix(" %")

        self.tax_amount_input.setDecimals(2)
        self.tax_amount_input.setRange(0.00, 99999.99)
        self.tax_amount_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.tax_amount_input.setPrefix("$ ")

        totals_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 11)
        self.subtotal_label.setFont(totals_font)
        self.taxable_subtotal_label.setFont(totals_font)
        self.grand_total_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        )

        self.save_button.setMinimumSize(120, 40)
        self.cancel_button.setMinimumSize(120, 40)

        save_button_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                color: white;
                border: 1px solid {QColor(AppConfig.DARK_SUCCESS_ACTION).darker(120).name()};
                border-radius: 4px;
            }}
            QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}
        """
        cancel_button_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
            }}
            QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}
        """
        self.save_button.setStyleSheet(save_button_style)
        self.cancel_button.setStyleSheet(cancel_button_style)

        field_style = self._get_input_field_style()
        self.notes_edit.setStyleSheet(field_style)
        self.tax_amount_input.setStyleSheet(field_style)
        self.tax_rate_input.setStyleSheet(field_style)

    def _setup_connections(self):
        self.save_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        self.tax_rate_input.valueChanged.connect(self._calculate_tax_from_rate)
        self.tax_amount_input.valueChanged.connect(self._clear_tax_rate_on_manual_edit)

        self.charges_table.currentCellChanged.connect(self._handle_row_change)
        self.notes_edit.textChanged.connect(self._save_notes_for_current_row)

    def _load_initial_data(self):
        self._charge_codes_list = self.charge_code_controller.get_all_charge_codes(
            status_filter="active"
        )
        self._charge_code_lookup = {
            cc.code.upper(): cc for cc in self._charge_codes_list
        }
        self._alt_code_lookup = {
            cc.alternate_code.upper(): cc
            for cc in self._charge_codes_list
            if cc.alternate_code
        }
        self.logger.debug(f"Loaded {len(self._charge_codes_list)} charge codes.")
        self._add_charge_row()

    @Slot(int)
    def _handle_enter_in_row(self, row: int):
        self._add_charge_row(from_row=row)

    def _add_charge_row(self, from_row: Optional[int] = None):
        """Adds a new, empty row to the charges table."""
        if from_row is None:
            row_to_insert = self.charges_table.rowCount()
        else:
            row_to_insert = from_row + 1

        self.charges_table.insertRow(row_to_insert)
        self._setup_row_widgets(row_to_insert)
        self.charges_table.setCurrentCell(row_to_insert, 0)

    def _setup_row_widgets(self, row: int):
        """Places the appropriate widgets into the cells of a given row."""
        field_style = self._get_input_field_style()

        # Code
        code_edit = EnterKeyLineEdit()
        code_edit.setStyleSheet(field_style)
        code_completer = QCompleter([cc.code for cc in self._charge_codes_list])
        code_completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        code_completer.popup().setStyleSheet(field_style)
        code_edit.setCompleter(code_completer)
        code_edit.editingFinished.connect(lambda r=row: self._on_code_entered(r))
        code_edit.enter_pressed.connect(lambda r=row: self._handle_enter_in_row(r))
        self.charges_table.setCellWidget(row, 0, code_edit)

        # Alt Code
        alt_code_edit = EnterKeyLineEdit()
        alt_code_edit.setStyleSheet(field_style)
        alt_code_completer = QCompleter(
            [cc.alternate_code for cc in self._charge_codes_list if cc.alternate_code]
        )
        alt_code_completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        alt_code_completer.popup().setStyleSheet(field_style)
        alt_code_edit.setCompleter(alt_code_completer)
        alt_code_edit.editingFinished.connect(
            lambda r=row: self._on_alt_code_entered(r)
        )
        alt_code_edit.enter_pressed.connect(lambda r=row: self._handle_enter_in_row(r))
        self.charges_table.setCellWidget(row, 1, alt_code_edit)

        # Description (read-only)
        desc_item = QTableWidgetItem()
        desc_item.setFlags(desc_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
        self.charges_table.setItem(row, 2, desc_item)

        # Qty
        qty_spinbox = QDoubleSpinBox()
        qty_spinbox.setStyleSheet(field_style)
        qty_spinbox.setDecimals(3)
        qty_spinbox.setRange(0.001, 9999.0)
        qty_spinbox.setValue(1.0)
        qty_spinbox.valueChanged.connect(self._update_totals)
        self.charges_table.setCellWidget(row, 3, qty_spinbox)

        # Unit Price
        price_spinbox = QDoubleSpinBox()
        price_spinbox.setStyleSheet(field_style)
        price_spinbox.setDecimals(2)
        price_spinbox.setRange(0.00, 99999.99)
        price_spinbox.setPrefix("$ ")
        price_spinbox.valueChanged.connect(self._update_totals)
        self.charges_table.setCellWidget(row, 4, price_spinbox)

        # Taxable
        tax_checkbox = QCheckBox()
        tax_checkbox.setStyleSheet(field_style)
        tax_checkbox.stateChanged.connect(self._update_totals)
        chk_widget = QWidget()
        chk_layout = QHBoxLayout(chk_widget)
        chk_layout.addWidget(tax_checkbox)
        chk_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        chk_layout.setContentsMargins(0, 0, 0, 0)
        self.charges_table.setCellWidget(row, 5, chk_widget)

        # Total
        total_item = QTableWidgetItem("$0.00")
        total_item.setTextAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        total_item.setFlags(total_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
        self.charges_table.setItem(row, 6, total_item)

    def _on_code_entered(self, row: int):
        code_widget = self.charges_table.cellWidget(row, 0)
        if isinstance(code_widget, QLineEdit):
            code = code_widget.text().upper()
            charge_code = self._charge_code_lookup.get(code)
            self._populate_row_from_charge_code(row, charge_code)

    def _on_alt_code_entered(self, row: int):
        alt_code_widget = self.charges_table.cellWidget(row, 1)
        if isinstance(alt_code_widget, QLineEdit):
            alt_code = alt_code_widget.text().upper()
            charge_code = self._alt_code_lookup.get(alt_code)
            self._populate_row_from_charge_code(row, charge_code)

    def _populate_row_from_charge_code(
        self, row: int, charge_code: Optional[ChargeCode]
    ):
        if charge_code:
            code_widget = self.charges_table.cellWidget(row, 0)
            if isinstance(code_widget, QLineEdit):
                code_widget.setText(charge_code.code)
            alt_code_widget = self.charges_table.cellWidget(row, 1)
            if isinstance(alt_code_widget, QLineEdit):
                alt_code_widget.setText(charge_code.alternate_code or "")
            self.charges_table.item(row, 2).setText(charge_code.description)
            price_widget = self.charges_table.cellWidget(row, 4)
            if isinstance(price_widget, QDoubleSpinBox):
                price_widget.setValue(float(charge_code.standard_charge))
            tax_widget_container = self.charges_table.cellWidget(row, 5)
            if tax_widget_container:
                tax_checkbox = tax_widget_container.findChild(QCheckBox)
                if tax_checkbox:
                    tax_checkbox.setChecked(charge_code.taxable)
        self._update_totals()

    @Slot(int, int, int, int)
    def _handle_row_change(
        self, currentRow, currentColumn, previousRow, previousColumn
    ):
        if previousRow != -1 and previousRow < self.charges_table.rowCount():
            self._save_notes_for_current_row()

        self._current_notes_row = currentRow
        current_notes = self._row_notes.get(currentRow, "")

        self.notes_edit.blockSignals(True)
        self.notes_edit.setPlainText(current_notes)
        self.notes_edit.blockSignals(False)

        if currentRow != -1:
            self.notes_edit.setPlaceholderText(f"Notes for line {currentRow + 1}...")
        else:
            self.notes_edit.setPlaceholderText(
                "Notes for the selected line item will appear here..."
            )

    @Slot()
    def _save_notes_for_current_row(self):
        if (
            self._current_notes_row is not None
            and self._current_notes_row < self.charges_table.rowCount()
        ):
            notes = self.notes_edit.toPlainText().strip()
            if notes:
                self._row_notes[self._current_notes_row] = notes
            elif self._current_notes_row in self._row_notes:
                del self._row_notes[self._current_notes_row]

    def _update_totals(self):
        subtotal = Decimal(0)
        self._taxable_subtotal = Decimal(0)
        for row in range(self.charges_table.rowCount()):
            try:
                qty_widget = self.charges_table.cellWidget(row, 3)
                price_widget = self.charges_table.cellWidget(row, 4)
                tax_container = self.charges_table.cellWidget(row, 5)

                if qty_widget and price_widget:
                    qty = Decimal(qty_widget.value())
                    price = Decimal(price_widget.value())
                    line_total = (qty * price).quantize(Decimal("0.01"))
                    self.charges_table.item(row, 6).setText(f"${line_total:.2f}")

                    subtotal += line_total
                    if tax_container and tax_container.findChild(QCheckBox).isChecked():
                        self._taxable_subtotal += line_total
            except (InvalidOperation, TypeError, AttributeError) as e:
                self.logger.warning(f"Could not calculate total for row {row}: {e}")
                continue

        manual_tax = Decimal(self.tax_amount_input.value())
        grand_total = subtotal + manual_tax

        self.subtotal_label.setText(f"${subtotal:.2f}")
        self.taxable_subtotal_label.setText(f"${self._taxable_subtotal:.2f}")
        self.grand_total_label.setText(f"${grand_total:.2f}")

    @Slot(float)
    def _calculate_tax_from_rate(self, rate: float):
        tax_rate = Decimal(rate) / Decimal(100)
        tax_amount = (self._taxable_subtotal * tax_rate).quantize(Decimal("0.01"))

        self.tax_amount_input.blockSignals(True)
        self.tax_amount_input.setValue(float(tax_amount))
        self.tax_amount_input.blockSignals(False)
        self._update_totals()

    @Slot(float)
    def _clear_tax_rate_on_manual_edit(self, amount: float):
        self.tax_rate_input.blockSignals(True)
        self.tax_rate_input.setValue(0.0)
        self.tax_rate_input.blockSignals(False)
        # We don't call _update_totals here, as this is the primary signal source for totals when edited manually.
        # The valueChanged on this spinbox will trigger a separate totals update.
        # To be safe, we'll call it.
        self._update_totals()

    def get_data_from_table(self) -> List[Dict[str, Any]]:
        """Collects and validates data from all rows in the table."""
        charges_to_save = []
        for row in range(self.charges_table.rowCount()):
            try:
                code_widget = self.charges_table.cellWidget(row, 0)
                desc_item = self.charges_table.item(row, 2)
                qty_widget = self.charges_table.cellWidget(row, 3)
                price_widget = self.charges_table.cellWidget(row, 4)
                tax_container = self.charges_table.cellWidget(row, 5)

                code = code_widget.text().upper()
                charge_code_obj = self._charge_code_lookup.get(code)

                if not charge_code_obj or not desc_item or not desc_item.text():
                    continue

                charges_to_save.append(
                    {
                        "charge_code_id": charge_code_obj.id,
                        "description": desc_item.text(),
                        "quantity": Decimal(qty_widget.value()),
                        "unit_price": Decimal(price_widget.value()),
                        "taxable": tax_container.findChild(QCheckBox).isChecked(),
                        "item_notes": self._row_notes.get(row),
                    }
                )
            except Exception as e:
                self.logger.error(f"Error processing row {row} for saving: {e}")
        return charges_to_save

    def accept(self):
        """Gathers data from the table and sends it to the controller to be saved."""
        self._save_notes_for_current_row()
        charges_to_save = self.get_data_from_table()

        if not charges_to_save:
            QMessageBox.warning(
                self, "No Charges", "Please add at least one valid charge item."
            )
            return

        if not self.horse.owners:
            QMessageBox.critical(
                self,
                "Billing Error",
                "This horse has no owner assigned and cannot be billed.",
            )
            return

        success, message, new_transactions = (
            self.financial_controller.add_charge_batch_to_horse(
                horse_id=self.horse.horse_id,
                owner_id=self.horse.owners[0].owner_id,
                charge_items=charges_to_save,
                batch_transaction_date=date.today(),
                administered_by_user_id=self.current_user_id,
            )
        )

        if success:
            self.charges_saved.emit(new_transactions)
            super().accept()
        else:
            QMessageBox.critical(self, "Error Saving Charges", message)

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"

    def _get_display_owner_name(self, horse: Horse) -> str:
        if not horse.owners:
            return "No Owner Associated"

        first_owner = horse.owners[0]
        name_parts = []
        if first_owner.farm_name:
            name_parts.append(first_owner.farm_name)

        person_name_parts = []
        if first_owner.first_name:
            person_name_parts.append(first_owner.first_name)
        if first_owner.last_name:
            person_name_parts.append(first_owner.last_name)

        person_name_str = " ".join(person_name_parts).strip()
        if person_name_str:
            if name_parts:
                name_parts.append(f"({person_name_str})")
            else:
                name_parts.append(person_name_str)

        return (
            " ".join(name_parts) if name_parts else f"Owner ID: {first_owner.owner_id}"
        )

    def _get_display_location_name(self, horse: Horse) -> str:
        return horse.location.location_name if horse.location else "N/A"


=============== FILE: views/horse/dialogs/add_edit_location_dialog.py ===============

# views/admin/dialogs/add_edit_location_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Location Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing practice locations.
Last Updated: May 19, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-05-19):
    - Initial implementation for adding and editing locations.
    - Fields: Location Name, Description, Is Active.
    - Uses LocationController for backend operations.
    - Styled for dark theme using imported constants.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QTextEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.location_controller import LocationController
from models import Location as LocationModel

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class AddEditLocationDialog(QDialog):
    def __init__(
        self,
        parent_view,
        controller: LocationController,
        current_user_id: str,
        location: Optional[LocationModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.controller = controller
        self.current_user_id = current_user_id
        self.location = location
        self.is_edit_mode = location is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Location")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()
        if self.is_edit_mode and self.location:
            self._populate_fields()

    def _get_dialog_specific_input_field_style(self) -> str:
        """Generates style string for input fields within this dialog."""
        return f"""
            QLineEdit, QTextEdit {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QTextEdit:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        """Generates generic button style string for this dialog."""
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.WrapAllRows)
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)

        input_style = self._get_dialog_specific_input_field_style()
        dialog_styles = (
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top:3px; }}"
            + f"QCheckBox::indicator {{ width: 13px; height: 13px; }}"
        )
        self.setStyleSheet(dialog_styles)

        self.location_name_input = QLineEdit()
        self.location_name_input.setStyleSheet(input_style)
        self.location_name_input.setPlaceholderText("e.g., Main Barn, Paddock A")
        form_layout.addRow("Location Name*:", self.location_name_input)

        self.description_input = QTextEdit()
        self.description_input.setStyleSheet(input_style)
        self.description_input.setPlaceholderText(
            "Optional description or details about the location"
        )
        self.description_input.setFixedHeight(80)
        form_layout.addRow("Description:", self.description_input)

        self.is_active_checkbox = QCheckBox("Location is Active")
        self.is_active_checkbox.setChecked(True)  # Default to active for new locations
        form_layout.addRow("", self.is_active_checkbox)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith("#"):
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        """Populates fields if in edit mode."""
        if self.location:  # Should always be true if self.is_edit_mode is true
            self.location_name_input.setText(self.location.location_name)
            self.description_input.setPlainText(self.location.description or "")
            self.is_active_checkbox.setChecked(self.location.is_active)

    def get_data(self) -> Dict[str, Any]:
        """Collects data from the form fields."""
        return {
            "location_name": self.location_name_input.text().strip(),
            "description": self.description_input.toPlainText().strip(),
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        """Validates form data and accepts dialog if valid."""
        data = self.get_data()

        # Use controller's validation method
        is_valid, errors = self.controller.validate_location_data(
            data,
            is_new=(not self.is_edit_mode),
            location_id_to_check_for_unique=(
                self.location.location_id
                if self.is_edit_mode and self.location
                else None
            ),
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return  # Keep dialog open

        try:
            if self.is_edit_mode and self.location:
                success, message = self.controller.update_location(
                    self.location.location_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_location(
                    data, self.current_user_id
                )

            if success:
                # Show info message from the parent view for consistency if possible
                if hasattr(self.parent(), "show_info"):
                    self.parent().show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()  # Close dialog with Accepted state
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
                # Keep dialog open if controller indicates failure that might be correctable
        except Exception as e:
            self.logger.error(f"Error during location save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )
            # Keep dialog open


=============== FILE: views/horse/dialogs/create_link_owner_dialog.py ===============

# views/horse/dialogs/create_link_owner_dialog.py
"""
EDSI Veterinary Management System - Create New Owner and Link Dialog
Version: 1.0.8
Purpose: Dialog for creating a new owner and linking them to a horse with a percentage.
         - Corrected tuple unpacking error in _setup_ui by ensuring all field
           definitions in `fields_setup` list have a consistent number of elements.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.0.8 (2025-05-26):
    - In `_setup_ui`, standardized the tuples in the `fields_setup` list to consistently
      provide 8 elements (label, name, layout coordinates, widget_type_str, placeholder).
    - Updated the for-loop unpacking these tuples to match the 8 elements,
      resolving the "ValueError: not enough values to unpack".
- v1.0.7 (2025-05-26):
    - Modified `__init__` to accept an optional `total_ownership_validator` callback.
    - Updated `validate_and_accept` to call this external validator.
- v1.0.6 (2025-05-26):
    - Redesigned UI to use a two-column QGridLayout for owner detail fields.
# ... (rest of previous changelog entries assumed present)
"""

import logging
from typing import Optional, Dict, List, Callable

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QComboBox,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QWidget,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class CreateAndLinkOwnerDialog(QDialog):
    def __init__(
        self,
        parent_view,
        horse_name: str,
        current_user_login: str,
        total_ownership_validator: Optional[
            Callable[[Optional[int], float], bool]
        ] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_name = horse_name
        self.current_user_login = current_user_login
        self.owner_controller = OwnerController()
        self.total_ownership_validator = total_ownership_validator

        self.setWindowTitle(f"Create & Link New Owner to {self.horse_name}")
        self.setMinimumWidth(750)

        self._setup_palette()
        self._setup_ui()

        if "state_code" in self.form_fields and isinstance(
            self.form_fields["state_code"], QComboBox
        ):
            self._populate_states_combo(self.form_fields["state_code"])

    def _get_dialog_specific_input_field_style(self):
        # (Same as v1.0.7)
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; subcontrol-position: right center; width: 15px; }}
            QComboBox::down-arrow {{ image: url(none); }} /* Consider a Qt built-in or SVG icon for better dark theme compatibility */
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }} """

    def _get_dialog_generic_button_style(self):
        # (Same as v1.0.7)
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        # (Same as v1.0.7)
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        main_dialog_layout = QVBoxLayout(self)
        main_dialog_layout.setSpacing(15)
        main_dialog_layout.setContentsMargins(15, 15, 15, 15)

        instruction_label = QLabel(
            f"Enter details for the new owner to be linked to <b>{self.horse_name}</b>."
        )
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 5px; background-color: transparent;"
        )
        instruction_label.setWordWrap(True)
        main_dialog_layout.addWidget(instruction_label)

        grid_layout = QGridLayout()
        grid_layout.setHorizontalSpacing(20)
        grid_layout.setVerticalSpacing(10)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)

        self.form_fields = {}
        specific_input_style = self._get_dialog_specific_input_field_style()

        # Each tuple: (Label, field_name, r_lbl, c_lbl, r_fld, c_fld, widget_type_str, placeholder_or_None)
        fields_setup = [
            ("Farm Name:", "farm_name", 0, 0, 0, 1, "QLineEdit", None),
            ("Account #:", "account_number", 0, 2, 0, 3, "QLineEdit", None),
            ("First Name:", "first_name", 1, 0, 1, 1, "QLineEdit", None),
            ("Last Name*:", "last_name", 1, 2, 1, 3, "QLineEdit", None),
            ("Address 1*:", "address_line1", 2, 0, 2, 1, "QLineEdit", None),
            ("Address 2:", "address_line2", 2, 2, 2, 3, "QLineEdit", None),
            ("City*:", "city", 3, 0, 3, 1, "QLineEdit", None),
            ("State*:", "state_code", 3, 2, 3, 3, "QComboBox", None),
            ("Zip/Postal*:", "zip_code", 4, 0, 4, 1, "QLineEdit", None),
            ("Country:", "country_name", 4, 2, 4, 3, "QLineEdit", "e.g. USA"),
            ("Phone:", "phone", 5, 0, 5, 1, "QLineEdit", None),
            ("Email:", "email", 5, 2, 5, 3, "QLineEdit", None),
        ]

        for (
            label_text,
            field_name,
            r_lbl,
            c_lbl,
            r_fld,
            c_fld,
            widget_type_str,
            placeholder_text,
        ) in fields_setup:
            lbl = QLabel(label_text)
            grid_layout.addWidget(lbl, r_lbl, c_lbl, Qt.AlignmentFlag.AlignRight)

            widget: QWidget  # Type hint for clarity
            if widget_type_str == "QComboBox":
                widget = QComboBox()
            else:  # Default to QLineEdit
                widget = QLineEdit()
                if placeholder_text:  # Check if placeholder_text is not None
                    widget.setPlaceholderText(placeholder_text)

            widget.setStyleSheet(specific_input_style)
            self.form_fields[field_name] = widget
            grid_layout.addWidget(widget, r_fld, c_fld)

        # Row 6: Ownership Percentage and Active Checkbox
        self.percentage_input = QDoubleSpinBox()
        self.percentage_input.setRange(0.00, 100.00)
        self.percentage_input.setDecimals(2)
        self.percentage_input.setSuffix(" %")
        self.percentage_input.setValue(100.00)
        self.percentage_input.setStyleSheet(specific_input_style)
        grid_layout.addWidget(
            QLabel("Ownership %*:"), 6, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.percentage_input, 6, 1)

        self.form_fields["is_active"] = QCheckBox("Owner is Active")
        self.form_fields["is_active"].setChecked(True)
        self.form_fields["is_active"].setStyleSheet(
            f"QCheckBox{{color:{DARK_TEXT_SECONDARY};background:transparent;padding-top:3px;}}QCheckBox::indicator{{width:13px;height:13px;}}"
        )
        grid_layout.addWidget(
            self.form_fields["is_active"],
            6,
            3,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )  # Align left in its cell

        main_dialog_layout.addLayout(grid_layout)
        main_dialog_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText("Ok")
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg = DARK_SUCCESS_ACTION
                ok_bg = (
                    f"#{ok_bg[1]*2}{ok_bg[2]*2}{ok_bg[3]*2}"
                    if len(ok_bg) == 4
                    else ok_bg
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton{{background-color:{ok_bg};color:white;}}"
                )
        main_dialog_layout.addWidget(self.button_box)
        self.setStyleSheet(
            f"QDialog{{background-color:{DARK_WIDGET_BACKGROUND};}} QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;padding-top:3px;}} QCheckBox::indicator{{width:13px;height:13px;}} QCheckBox{{color:{DARK_TEXT_SECONDARY};}}"
        )

    def _populate_states_combo(self, combo_box: QComboBox):
        # (Same as v1.0.7)
        try:
            ref_data = self.owner_controller.get_owner_form_reference_data()
            states: List[Dict[str, str]] = ref_data.get("states", [])
            combo_box.blockSignals(True)
            combo_box.clear()
            combo_box.addItem("", None)
            for state_data in states:
                combo_box.addItem(state_data["name"], state_data["id"])
            combo_box.blockSignals(False)
            self.logger.debug(f"Populated states: {len(states)}")
        except Exception as e:
            self.logger.error(f"Error populating states: {e}", exc_info=True)
            QMessageBox.warning(self, "Error", "Could not load states.")

    def validate_and_accept(self):
        # (Same as v1.0.7 - calls self.total_ownership_validator)
        owner_data = {}
        for field_name, widget in self.form_fields.items():
            if isinstance(widget, QLineEdit):
                owner_data[field_name] = widget.text().strip()
            elif isinstance(widget, QComboBox):
                owner_data[field_name] = widget.currentData()
            elif isinstance(widget, QCheckBox):
                owner_data[field_name] = widget.isChecked()
        percentage = self.percentage_input.value()

        is_valid, errors = self.owner_controller.validate_owner_data(
            owner_data, is_new=True
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct owner details:\n- " + "\n- ".join(errors),
            )
            return
        if not (0.00 <= percentage <= 100.00):
            QMessageBox.warning(
                self,
                "Input Error",
                "Ownership percentage must be between 0.00 and 100.00.",
            )
            return
        if self.total_ownership_validator:
            if not self.total_ownership_validator(
                None, percentage
            ):  # Pass None for owner_id_being_changed (new owner)
                self.logger.debug(
                    "External total ownership validation failed for new owner link."
                )
                return
        self.logger.debug("CreateAndLinkOwnerDialog validation successful, accepting.")
        super().accept()

    def get_data(self) -> Optional[Dict]:
        # (Same as v1.0.7)
        owner_details = {}
        for field_name, widget in self.form_fields.items():
            if isinstance(widget, QLineEdit):
                owner_details[field_name] = widget.text().strip()
            elif isinstance(widget, QComboBox):
                owner_details[field_name] = widget.currentData()
            elif isinstance(widget, QCheckBox):
                owner_details[field_name] = widget.isChecked()
        return {
            "owner_details": owner_details,
            "percentage": self.percentage_input.value(),
        }


=============== FILE: views/horse/dialogs/edit_all_charges_dialog.py ===============

# views/horse/dialogs/edit_all_charges_dialog.py
"""
EDSI Veterinary Management System - Edit All Charges Dialog
Version: 1.1.1
Purpose: A dialog for bulk-editing all un-invoiced charges for a horse.
Last Updated: June 8, 2025
Author: Gemini

Changelog:
- v1.1.1 (2025-06-08):
    - Bug Fix: Added defensive checks to the `_update_totals` method to prevent
      warnings caused by a race condition during dialog initialization.
- v1.1.0 (2025-06-08):
    - Updated the header to display the full, detailed information line for the
      horse, matching the main application screens for consistency.
- v1.0.0 (2025-06-08):
    - Initial creation of the dialog.
"""

import logging
from decimal import Decimal, InvalidOperation
from datetime import date
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QPushButton,
    QLabel,
    QDialogButtonBox,
    QMessageBox,
    QWidget,
    QHBoxLayout,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QLineEdit,
    QCompleter,
    QDoubleSpinBox,
    QCheckBox,
    QAbstractItemView,
    QFormLayout,
    QTextEdit,
    QApplication,
    QAbstractSpinBox,
)
from PySide6.QtCore import Qt, Signal, QTimer, Slot
from PySide6.QtGui import QFont, QColor, QPainter, QPen

from models import Horse, Transaction, ChargeCode
from controllers import FinancialController
from config.app_config import AppConfig


class BoxedCellDelegate(QStyledItemDelegate):
    """A delegate to draw borders around cells to give them a 'boxed' look."""

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index):
        super().paint(painter, option, index)
        painter.save()
        pen = QPen(QColor(AppConfig.DARK_BORDER))
        pen.setWidth(1)
        painter.setPen(pen)
        painter.drawRect(option.rect)
        painter.restore()


class EditAllChargesDialog(QDialog):
    """A dialog for editing a batch of existing charge items for a horse."""

    charges_updated = Signal()

    def __init__(
        self,
        horse: Horse,
        transactions: List[Transaction],
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse = horse
        self.transactions = transactions
        self.financial_controller = financial_controller
        self.current_user_id = QApplication.instance().current_user_id

        self.setWindowTitle(
            f"Edit All Un-invoiced Charges for: {self.horse.horse_name}"
        )
        self.setMinimumSize(1200, 700)

        self._charge_codes_list: List[ChargeCode] = []
        self._charge_code_lookup: Dict[str, ChargeCode] = {}
        self._alt_code_lookup: Dict[str, ChargeCode] = {}
        self._row_notes: Dict[int, str] = {}
        self._current_notes_row: Optional[int] = None
        self._taxable_subtotal = Decimal(0)

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()

        self._populate_header()
        QTimer.singleShot(0, self._load_initial_data)

    def _get_input_field_style(self) -> str:
        """Generates the requested style for all input fields."""
        return f"""
            QLineEdit, QDoubleSpinBox, QTextEdit {{
                background-color: #3E3E3E;
                color: white;
                border: 1px solid white;
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
            }}
            QCheckBox::indicator {{
                width: 14px;
                height: 14px;
                border: 1px solid white;
                border-radius: 3px;
                background-color: #3E3E3E;
            }}
            QCheckBox::indicator:checked {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                border-color: {AppConfig.DARK_SUCCESS_ACTION};
            }}
        """

    def _setup_ui(self):
        """Initializes and lays out the UI widgets based on the new design."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        self.horse_title_label = QLabel()
        self.horse_info_line_label = QLabel()
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.addWidget(self.horse_title_label)
        header_layout.addWidget(self.horse_info_line_label)
        main_layout.addWidget(header_widget)

        table_container = QWidget()
        table_layout = QVBoxLayout(table_container)
        table_layout.setContentsMargins(0, 0, 0, 0)
        self.charges_table = QTableWidget()
        table_layout.addWidget(self.charges_table)
        self.notes_edit = QTextEdit()
        table_layout.addWidget(self.notes_edit)
        table_layout.setStretchFactor(self.charges_table, 3)
        table_layout.setStretchFactor(self.notes_edit, 1)
        main_layout.addWidget(table_container, 1)

        footer_layout = QHBoxLayout()
        footer_layout.setContentsMargins(0, 10, 0, 0)
        self.button_box = QDialogButtonBox()
        self.save_button = self.button_box.addButton(
            "Save Changes", QDialogButtonBox.ButtonRole.AcceptRole
        )
        self.cancel_button = self.button_box.addButton(
            "Cancel", QDialogButtonBox.ButtonRole.RejectRole
        )
        footer_layout.addWidget(self.button_box)
        footer_layout.addStretch()

        totals_container = QWidget()
        totals_form_layout = QFormLayout(totals_container)
        totals_form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        self.subtotal_label = QLabel("$0.00")
        self.taxable_subtotal_label = QLabel("$0.00")
        self.tax_amount_input = QDoubleSpinBox()
        self.tax_rate_input = QDoubleSpinBox()
        self.grand_total_label = QLabel("$0.00")
        tax_layout = QHBoxLayout()
        tax_layout.addWidget(self.tax_rate_input)
        tax_layout.addWidget(self.tax_amount_input)
        totals_form_layout.addRow("Subtotal:", self.subtotal_label)
        totals_form_layout.addRow("Taxable Subtotal:", self.taxable_subtotal_label)
        totals_form_layout.addRow("Tax (% / Amt):", tax_layout)
        totals_form_layout.addRow("<b>Grand Total:</b>", self.grand_total_label)
        footer_layout.addWidget(totals_container)
        main_layout.addLayout(footer_layout)

    def _populate_header(self):
        self.horse_title_label.setText(self.horse.horse_name)
        age_str = self._calculate_age(self.horse.date_of_birth)
        owner_name = self._get_display_owner_name(self.horse)
        location_name = self._get_display_location_name(self.horse)
        info_parts = [
            f"Acct: {self.horse.account_number or 'N/A'}",
            f"👥 {owner_name}",
            f"Breed: {self.horse.breed or 'N/A'}",
            f"Color: {self.horse.color or 'N/A'}",
            f"Sex: {self.horse.sex or 'N/A'}",
            f"Age: {age_str}",
            f"📍 {location_name}",
        ]
        self.horse_info_line_label.setText(" | ".join(info_parts))

    def _apply_styles(self):
        """Applies consistent styling to the dialog's widgets."""
        self.horse_title_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 16, QFont.Weight.Bold)
        )
        self.horse_title_label.setStyleSheet(f"color:{AppConfig.DARK_TEXT_PRIMARY};")
        self.horse_info_line_label.setStyleSheet(
            f"color:{AppConfig.DARK_TEXT_SECONDARY}; font-size: 11px;"
        )

        self.charges_table.setColumnCount(7)
        self.charges_table.setHorizontalHeaderLabels(
            ["Code", "Alt. Code", "Description", "Qty", "Unit Price", "Tax", "Total"]
        )
        self.charges_table.verticalHeader().setVisible(False)
        self.charges_table.setItemDelegate(BoxedCellDelegate(self))
        header = self.charges_table.horizontalHeader()
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        self.charges_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )

        self.notes_edit.setPlaceholderText(
            "Notes for the selected line item will appear here..."
        )

        self.tax_rate_input.setDecimals(4)
        self.tax_rate_input.setRange(0.00, 100.00)
        self.tax_rate_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.tax_rate_input.setSuffix(" %")

        self.tax_amount_input.setDecimals(2)
        self.tax_amount_input.setRange(0.00, 99999.99)
        self.tax_amount_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.tax_amount_input.setPrefix("$ ")

        totals_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 11)
        self.subtotal_label.setFont(totals_font)
        self.taxable_subtotal_label.setFont(totals_font)
        self.grand_total_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        )

        self.save_button.setMinimumSize(120, 40)
        self.cancel_button.setMinimumSize(120, 40)

        save_button_style = f"""QPushButton {{ background-color: {AppConfig.DARK_SUCCESS_ACTION}; color: white; border: 1px solid {QColor(AppConfig.DARK_SUCCESS_ACTION).darker(120).name()}; border-radius: 4px; }} QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}"""
        cancel_button_style = f"""QPushButton {{ background-color: {AppConfig.DARK_BUTTON_BG}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_BORDER}; border-radius: 4px; }} QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}"""
        self.save_button.setStyleSheet(save_button_style)
        self.cancel_button.setStyleSheet(cancel_button_style)

        field_style = self._get_input_field_style()
        self.notes_edit.setStyleSheet(field_style)
        self.tax_amount_input.setStyleSheet(field_style)
        self.tax_rate_input.setStyleSheet(field_style)

    def _setup_connections(self):
        self.save_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        self.tax_rate_input.valueChanged.connect(self._calculate_tax_from_rate)
        self.tax_amount_input.valueChanged.connect(self._clear_tax_rate_on_manual_edit)
        self.charges_table.currentCellChanged.connect(self._handle_row_change)
        self.notes_edit.textChanged.connect(self._save_notes_for_current_row)

    def _load_initial_data(self):
        """Populates the table with the transactions passed during init."""
        self.charges_table.setRowCount(len(self.transactions))
        for row, trans in enumerate(self.transactions):
            self._setup_row_widgets(row)
            self._populate_row_from_transaction(row, trans)

        self._update_totals()
        if self.charges_table.rowCount() > 0:
            self.charges_table.setCurrentCell(0, 0)

    def _setup_row_widgets(self, row: int):
        """Places the appropriate widgets into the cells of a given row."""
        field_style = self._get_input_field_style()
        code_item = QTableWidgetItem()
        alt_code_item = QTableWidgetItem()
        desc_item = QTableWidgetItem()

        for item in [code_item, alt_code_item, desc_item]:
            item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEditable)

        self.charges_table.setItem(row, 0, code_item)
        self.charges_table.setItem(row, 1, alt_code_item)
        self.charges_table.setItem(row, 2, desc_item)

        qty_spinbox = QDoubleSpinBox()
        qty_spinbox.setStyleSheet(field_style)
        qty_spinbox.setDecimals(3)
        qty_spinbox.setRange(0.001, 9999.0)
        qty_spinbox.valueChanged.connect(self._update_totals)
        self.charges_table.setCellWidget(row, 3, qty_spinbox)

        price_spinbox = QDoubleSpinBox()
        price_spinbox.setStyleSheet(field_style)
        price_spinbox.setDecimals(2)
        price_spinbox.setRange(0.00, 99999.99)
        price_spinbox.setPrefix("$ ")
        price_spinbox.valueChanged.connect(self._update_totals)
        self.charges_table.setCellWidget(row, 4, price_spinbox)

        tax_checkbox = QCheckBox()
        tax_checkbox.setStyleSheet(field_style)
        tax_checkbox.stateChanged.connect(self._update_totals)
        chk_widget = QWidget()
        chk_layout = QHBoxLayout(chk_widget)
        chk_layout.addWidget(tax_checkbox)
        chk_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        chk_layout.setContentsMargins(0, 0, 0, 0)
        self.charges_table.setCellWidget(row, 5, chk_widget)

        total_item = QTableWidgetItem("$0.00")
        total_item.setTextAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        total_item.setFlags(total_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
        self.charges_table.setItem(row, 6, total_item)

    def _populate_row_from_transaction(self, row: int, trans: Transaction):
        """Fills a pre-made row's widgets with transaction data."""
        self.charges_table.item(row, 0).setData(
            Qt.ItemDataRole.UserRole, trans.transaction_id
        )
        self.charges_table.item(row, 0).setText(
            trans.charge_code.code if trans.charge_code else "N/A"
        )
        self.charges_table.item(row, 1).setText(
            trans.charge_code.alternate_code if trans.charge_code else "N/A"
        )
        self.charges_table.item(row, 2).setText(trans.description)
        self.charges_table.cellWidget(row, 3).setValue(float(trans.quantity))
        self.charges_table.cellWidget(row, 4).setValue(float(trans.unit_price))
        self.charges_table.cellWidget(row, 5).findChild(QCheckBox).setChecked(
            trans.taxable
        )
        self._row_notes[row] = trans.item_notes or ""

    @Slot(int, int, int, int)
    def _handle_row_change(
        self, currentRow, currentColumn, previousRow, previousColumn
    ):
        if previousRow != -1 and previousRow < self.charges_table.rowCount():
            self._save_notes_for_current_row()
        self._current_notes_row = currentRow
        current_notes = self._row_notes.get(currentRow, "")
        self.notes_edit.blockSignals(True)
        self.notes_edit.setPlainText(current_notes)
        self.notes_edit.blockSignals(False)
        self.notes_edit.setPlaceholderText(f"Notes for line {currentRow + 1}...")

    @Slot()
    def _save_notes_for_current_row(self):
        if (
            self._current_notes_row is not None
            and self._current_notes_row < self.charges_table.rowCount()
        ):
            self._row_notes[self._current_notes_row] = (
                self.notes_edit.toPlainText().strip()
            )

    def _update_totals(self):
        subtotal = Decimal(0)
        self._taxable_subtotal = Decimal(0)
        for row in range(self.charges_table.rowCount()):
            try:
                qty_widget = self.charges_table.cellWidget(row, 3)
                price_widget = self.charges_table.cellWidget(row, 4)
                tax_container = self.charges_table.cellWidget(row, 5)

                if qty_widget and price_widget:
                    qty = Decimal(qty_widget.value())
                    price = Decimal(price_widget.value())
                    line_total = (qty * price).quantize(Decimal("0.01"))

                    total_item = self.charges_table.item(row, 6)
                    if not total_item:
                        total_item = QTableWidgetItem()
                        self.charges_table.setItem(row, 6, total_item)
                    total_item.setText(f"${line_total:.2f}")

                    subtotal += line_total
                    if tax_container and tax_container.findChild(QCheckBox).isChecked():
                        self._taxable_subtotal += line_total
            except Exception as e:
                self.logger.warning(f"Could not calculate total for row {row}: {e}")
                continue

        manual_tax = Decimal(self.tax_amount_input.value())
        grand_total = subtotal + manual_tax
        self.subtotal_label.setText(f"${subtotal:.2f}")
        self.taxable_subtotal_label.setText(f"${self._taxable_subtotal:.2f}")
        self.grand_total_label.setText(f"${grand_total:.2f}")

    @Slot(float)
    def _calculate_tax_from_rate(self, rate: float):
        tax_rate = Decimal(rate) / Decimal(100)
        tax_amount = (self._taxable_subtotal * tax_rate).quantize(Decimal("0.01"))
        self.tax_amount_input.blockSignals(True)
        self.tax_amount_input.setValue(float(tax_amount))
        self.tax_amount_input.blockSignals(False)
        self._update_totals()

    @Slot(float)
    def _clear_tax_rate_on_manual_edit(self, amount: float):
        self.tax_rate_input.blockSignals(True)
        self.tax_rate_input.setValue(0.0)
        self.tax_rate_input.blockSignals(False)
        self._update_totals()

    def accept(self):
        """Gathers data and sends updates to the controller."""
        self._save_notes_for_current_row()
        errors = []
        for row in range(self.charges_table.rowCount()):
            trans_id = self.charges_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            if not trans_id:
                continue

            data = {
                "transaction_date": self.transactions[row].transaction_date,
                "description": self.charges_table.item(row, 2).text(),
                "quantity": Decimal(self.charges_table.cellWidget(row, 3).value()),
                "unit_price": Decimal(self.charges_table.cellWidget(row, 4).value()),
                "taxable": self.charges_table.cellWidget(row, 5)
                .findChild(QCheckBox)
                .isChecked(),
                "item_notes": self._row_notes.get(row, "").strip() or None,
            }
            success, message = self.financial_controller.update_charge_transaction(
                transaction_id=trans_id, data=data, current_user_id=self.current_user_id
            )
            if not success:
                errors.append(f"Line {row+1} ({data['description']}): {message}")

        if errors:
            QMessageBox.critical(
                self,
                "Error Saving Charges",
                "Could not save all changes:\n\n" + "\n".join(errors),
            )
        else:
            QMessageBox.information(
                self, "Success", "All charges updated successfully."
            )
            self.charges_updated.emit()
            super().accept()

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"

    def _get_display_owner_name(self, horse: Horse) -> str:
        if not horse.owners:
            return "No Owner Associated"

        first_owner = horse.owners[0]
        name_parts = []
        if first_owner.farm_name:
            name_parts.append(first_owner.farm_name)

        person_name_parts = []
        if first_owner.first_name:
            person_name_parts.append(first_owner.first_name)
        if first_owner.last_name:
            person_name_parts.append(first_owner.last_name)

        person_name_str = " ".join(person_name_parts).strip()
        if person_name_str:
            if name_parts:
                name_parts.append(f"({person_name_str})")
            else:
                name_parts.append(person_name_str)

        return (
            " ".join(name_parts) if name_parts else f"Owner ID: {first_owner.owner_id}"
        )

    def _get_display_location_name(self, horse: Horse) -> str:
        return horse.location.location_name if horse.location else "N/A"


=============== FILE: views/horse/dialogs/edit_charge_dialog.py ===============

# views/horse/dialogs/edit_charge_dialog.py
"""
EDSI Veterinary Management System - Edit Charge Dialog
Version: 1.3.1
Purpose: Dialog for editing the details of a single charge transaction.
         - Corrected styling for read-only fields.
Last Updated: June 8, 2025
Author: Gemini

Changelog:
- v1.3.1 (2025-06-08):
    - Removed a specific style rule for read-only QLineEdits to ensure they
      have the same background color as other input fields for a consistent look.
- v1.3.0 (2025-06-08):
    - Added read-only display fields for "Code" and "Alt. Code" to the top of
      the dialog for better user context.
- v1.2.0 (2025-06-07):
    - Styled the Save (green) and Cancel (gray) buttons with a visible
      border and appropriate colors for better UI consistency and clarity.
- v1.1.0 (2025-06-07):
    - Applied a new, standardized style to all input widgets.
- v1.0.3 (2025-06-07):
    - Bug Fix: Corrected all references to use `item_notes` instead of `notes`.
"""

import logging
from decimal import Decimal, InvalidOperation
from datetime import date
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QDialogButtonBox,
    QMessageBox,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QCheckBox,
    QTextEdit,
    QLabel,
    QHBoxLayout,
)
from PySide6.QtCore import Qt, QDate
from PySide6.QtGui import QPalette, QColor

from models import Transaction
from controllers import FinancialController
from config.app_config import AppConfig


class EditChargeDialog(QDialog):
    """A dialog for editing a single charge item."""

    def __init__(
        self,
        transaction: Transaction,
        financial_controller: FinancialController,
        current_user_id: str,
        parent=None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.transaction = transaction
        self.financial_controller = financial_controller
        self.current_user_id = current_user_id

        self.setWindowTitle(f"Edit Charge: {self.transaction.description[:30]}...")
        self.setMinimumWidth(500)

        self._setup_palette()
        self._setup_ui()
        self._apply_styles()
        self._populate_form()

        self.button_box.accepted.connect(self.save_changes)
        self.button_box.rejected.connect(self.reject)

    def _get_input_field_style(self) -> str:
        """Generates the standard style for all input fields in the dialog."""
        return f"""
            QLineEdit, QDateEdit, QDoubleSpinBox, QTextEdit {{
                background-color: #3E3E3E;
                color: white;
                border: 1px solid white;
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDateEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QCheckBox::indicator {{
                width: 14px;
                height: 14px;
                border: 1px solid white;
                border-radius: 3px;
                background-color: #3E3E3E;
            }}
            QCheckBox::indicator:checked {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                border-color: {AppConfig.DARK_SUCCESS_ACTION};
            }}
        """

    def _setup_palette(self):
        """Sets up the dark theme palette for the dialog."""
        palette = QPalette()
        palette.setColor(
            QPalette.ColorRole.Window, QColor(AppConfig.DARK_WIDGET_BACKGROUND)
        )
        palette.setColor(
            QPalette.ColorRole.WindowText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        self.setPalette(palette)

    def _setup_ui(self):
        """Initializes and lays out the UI widgets."""
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.code_display = QLineEdit()
        self.alt_code_display = QLineEdit()
        self.service_date_edit = QDateEdit()
        self.service_date_edit.setCalendarPopup(True)
        self.service_date_edit.setDisplayFormat("yyyy-MM-dd")

        self.description_edit = QLineEdit()
        self.qty_spinbox = QDoubleSpinBox()
        self.price_spinbox = QDoubleSpinBox()
        self.taxable_checkbox = QCheckBox("This item is taxable")
        self.notes_edit = QTextEdit()

        code_layout = QHBoxLayout()
        code_layout.addWidget(self.code_display)
        code_layout.addWidget(QLabel("Alt. Code:"))
        code_layout.addWidget(self.alt_code_display)

        form_layout.addRow("Charge Code:", code_layout)
        form_layout.addRow("Service Date:", self.service_date_edit)
        form_layout.addRow("Description:", self.description_edit)
        form_layout.addRow("Quantity:", self.qty_spinbox)
        form_layout.addRow("Unit Price:", self.price_spinbox)
        form_layout.addRow("", self.taxable_checkbox)
        form_layout.addRow("Item Notes:", self.notes_edit)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Save
            | QDialogButtonBox.StandardButton.Cancel
        )

        layout.addLayout(form_layout)
        layout.addWidget(self.button_box)

    def _apply_styles(self):
        """Applies consistent styling to the dialog's widgets."""
        field_style = self._get_input_field_style()

        self.code_display.setReadOnly(True)
        self.alt_code_display.setReadOnly(True)

        # Apply the same style to all fields
        for widget in [
            self.code_display,
            self.alt_code_display,
            self.service_date_edit,
            self.description_edit,
            self.qty_spinbox,
            self.price_spinbox,
            self.taxable_checkbox,
            self.notes_edit,
        ]:
            widget.setStyleSheet(field_style)

        self.qty_spinbox.setDecimals(3)
        self.qty_spinbox.setRange(0.001, 9999.999)
        self.price_spinbox.setDecimals(2)
        self.price_spinbox.setRange(0.00, 99999.99)
        self.price_spinbox.setPrefix("$ ")
        self.notes_edit.setMinimumHeight(80)

        # Style Save and Cancel buttons
        save_button = self.button_box.button(QDialogButtonBox.StandardButton.Save)
        cancel_button = self.button_box.button(QDialogButtonBox.StandardButton.Cancel)

        save_button_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                color: white;
                border: 1px solid {QColor(AppConfig.DARK_SUCCESS_ACTION).darker(120).name()};
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }}
            QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}
        """
        cancel_button_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 16px;
            }}
            QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}
        """
        save_button.setStyleSheet(save_button_style)
        cancel_button.setStyleSheet(cancel_button_style)

    def _populate_form(self):
        """Fills the form widgets with data from the transaction object."""
        if self.transaction.charge_code:
            self.code_display.setText(self.transaction.charge_code.code)
            self.alt_code_display.setText(
                self.transaction.charge_code.alternate_code or ""
            )
        else:
            self.code_display.setText("N/A")
            self.alt_code_display.setText("N/A")

        self.service_date_edit.setDate(QDate(self.transaction.transaction_date))
        self.description_edit.setText(self.transaction.description)
        self.qty_spinbox.setValue(float(self.transaction.quantity))
        self.price_spinbox.setValue(float(self.transaction.unit_price))
        self.taxable_checkbox.setChecked(self.transaction.taxable)
        self.notes_edit.setPlainText(self.transaction.item_notes or "")

    def get_data_from_form(self) -> Dict[str, Any]:
        """Collects and returns the current data from the form widgets."""
        return {
            "transaction_date": self.service_date_edit.date().toPython(),
            "description": self.description_edit.text().strip(),
            "quantity": Decimal(str(self.qty_spinbox.value())),
            "unit_price": Decimal(str(self.price_spinbox.value())),
            "taxable": self.taxable_checkbox.isChecked(),
            "item_notes": self.notes_edit.toPlainText().strip() or None,
        }

    def save_changes(self):
        """Validates and saves the changes via the financial controller."""
        updated_data = self.get_data_from_form()

        if not updated_data["description"]:
            QMessageBox.warning(
                self, "Validation Error", "Description cannot be empty."
            )
            return

        success, message = self.financial_controller.update_charge_transaction(
            transaction_id=self.transaction.transaction_id,
            data=updated_data,
            current_user_id=self.current_user_id,
        )

        if success:
            QMessageBox.information(self, "Success", message)
            self.accept()
        else:
            QMessageBox.critical(self, "Error", message)


=============== FILE: views/horse/dialogs/link_existing_owner_dialog.py ===============

# views/horse/dialogs/link_existing_owner_dialog.py
"""
EDSI Veterinary Management System - Link Existing Owner Dialog
Version: 1.0.4
Purpose: Dialog for selecting an existing owner and linking them to a horse.
         Allows 0% ownership and ensures dialog stays open on validation error.
Last Updated: May 19, 2025
Author: Claude Assistant

Changelog:
- v1.0.4 (2025-05-19):
    - Changed percentage_input range and validation to allow 0.00%.
    - Ensured dialog validation logic explicitly keeps dialog open on error.
- v1.0.3 (2025-05-19):
    - Resolved AppConfig constant AttributeError by importing constants directly.
    - Removed import of UserManagementScreen and localized style helper methods.
    - Added missing `from typing import Optional, Dict, List`.
    - Improved UI consistency, label alignment, and QComboBox population logic.
    - Ensured setAutoFillBackground(True) is called after setPalette.
    - Set a base stylesheet for the dialog to ensure `QLabel` color is consistent.
- v1.0.2 (User's May 17th version):
    - Changed percentage_spinbox minimum to 0.00 to allow 0% ownership.
    - Updated percentage validation in `get_data` to allow 0%.
"""
import logging
from typing import Optional, Dict, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QComboBox,
    QDoubleSpinBox,
    QDialogButtonBox,
    QMessageBox,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController
from models import Owner as OwnerModel

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class LinkExistingOwnerDialog(QDialog):
    def __init__(self, parent_view_or_dialog, horse_name: str):
        super().__init__(parent_view_or_dialog)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_name = horse_name
        self.owner_controller = OwnerController()
        self.owners_list: List[OwnerModel] = []
        self.selected_owner_id: Optional[int] = None

        self.setWindowTitle(f"Link Existing Owner to {self.horse_name}")
        self.setMinimumWidth(500)

        self._setup_palette()
        self._setup_ui()
        self._load_owners_and_search()

    def _get_dialog_specific_input_field_style(self) -> str:
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; subcontrol-position: right center; width: 15px; }}
            QComboBox::down-arrow {{ image: url(none); }}
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }} """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _get_dialog_list_widget_style(self) -> str:
        return f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none; border-radius: 4px;
            }}
            QListWidget::item {{ padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND}; }}
            QListWidget::item:selected {{ background-color: {DARK_PRIMARY_ACTION}4D; color: #ffffff; border-left: 3px solid {DARK_PRIMARY_ACTION}; }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }} """

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(12)
        layout.setContentsMargins(15, 15, 15, 15)
        self.setStyleSheet(
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; }}"
        )
        instruction_label = QLabel(
            f"Search for an existing owner to link to <b>{self.horse_name}</b>, select them from the list, then specify their ownership percentage."
        )
        instruction_label.setWordWrap(True)
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 8px; background-color: transparent;"
        )
        layout.addWidget(instruction_label)
        input_style = self._get_dialog_specific_input_field_style()
        list_widget_style = self._get_dialog_list_widget_style()
        search_layout = QHBoxLayout()
        search_label = QLabel("Search Owner:")
        self.owner_search_input = QLineEdit()
        self.owner_search_input.setPlaceholderText("Name or Account #")
        self.owner_search_input.setStyleSheet(input_style)
        self.owner_search_input.textChanged.connect(self._load_owners_and_search)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.owner_search_input, 1)
        layout.addLayout(search_layout)
        self.owner_results_list = QListWidget()
        self.owner_results_list.setStyleSheet(list_widget_style)
        self.owner_results_list.setFixedHeight(150)
        self.owner_results_list.itemClicked.connect(self._on_owner_selected_from_search)
        layout.addWidget(self.owner_results_list)
        self.selected_owner_label = QLabel("Selected Owner:")
        self.selected_owner_display_text = QLabel("<i>No owner selected</i>")
        self.selected_owner_display_text.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-style: italic; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
        )
        self.selected_owner_display_text.setMinimumHeight(20 + 12)
        layout.addWidget(self.selected_owner_label)
        layout.addWidget(self.selected_owner_display_text)
        percentage_layout = QHBoxLayout()
        percentage_label = QLabel("Ownership %:*")
        percentage_label.setAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        self.percentage_spinbox = QDoubleSpinBox()
        self.percentage_spinbox.setStyleSheet(input_style)
        self.percentage_spinbox.setRange(0.00, 100.00)  # MODIFIED: Allow 0.00
        self.percentage_spinbox.setDecimals(2)
        self.percentage_spinbox.setSuffix(" %")
        self.percentage_spinbox.setValue(100.00)
        percentage_layout.addWidget(percentage_label)
        percentage_layout.addWidget(self.percentage_spinbox)
        percentage_layout.addStretch()
        layout.addLayout(percentage_layout)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText("Link Owner")
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)
        self.button_box.accepted.connect(self._validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith("#"):
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _load_owners_and_search(self):
        search_term = (
            self.owner_search_input.text()
            if hasattr(self, "owner_search_input")
            else ""
        )
        try:
            self.owners_list = self.owner_controller.get_all_owners_for_lookup(
                search_term
            )
            self.owner_results_list.blockSignals(True)
            self.owner_results_list.clear()
            if self.owners_list:
                for o_data in self.owners_list:
                    item = QListWidgetItem(o_data["name_account"])
                    item.setData(Qt.ItemDataRole.UserRole, o_data["id"])
                    self.owner_results_list.addItem(item)
            else:
                self.owner_results_list.addItem(
                    "No owners found matching search."
                    if search_term
                    else "No active owners available."
                )
            self.owner_results_list.blockSignals(False)
        except Exception as e:
            self.logger.error(f"Error loading/searching owners: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Load Error", "Could not load existing owners for search."
            )
            self.owner_results_list.blockSignals(True)
            self.owner_results_list.clear()
            self.owner_results_list.addItem("Error loading owners")
            self.owner_results_list.blockSignals(False)
        self._clear_selection_state()

    def _on_owner_selected_from_search(self, item: QListWidgetItem):
        owner_id = item.data(Qt.ItemDataRole.UserRole)
        if owner_id is not None:
            self.selected_owner_id = owner_id
            self.selected_owner_display_text.setText(item.text())
            self.selected_owner_display_text.setStyleSheet(
                f"color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
            )
            self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(True)
            self.logger.info(
                f"Owner selected from search: ID {self.selected_owner_id}, Display: {item.text()}"
            )
        else:
            self._clear_selection_state()

    def _clear_selection_state(self):
        self.selected_owner_id = None
        self.selected_owner_display_text.setText("<i>No owner selected</i>")
        self.selected_owner_display_text.setStyleSheet(
            f"color: {DARK_TEXT_TERTIARY}; font-style: italic; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)

    def _validate_and_accept(self):
        if self.selected_owner_id is None:
            QMessageBox.warning(
                self,
                "Selection Error",
                "Please search for and select an owner from the list.",
            )
            return  # Keep dialog open
        percentage = self.percentage_spinbox.value()
        if not (0.00 <= percentage <= 100.00):  # MODIFIED: Allow 0.00
            QMessageBox.warning(
                self,
                "Input Error",
                "Ownership percentage must be between 0.00 and 100.00.",
            )
            return  # Keep dialog open
        self.logger.debug("LinkExistingOwnerDialog validation successful, accepting.")
        super().accept()  # Close dialog with Accepted result

    def get_data(self) -> Optional[Dict]:
        if self.selected_owner_id is None:
            return None
        return {
            "owner_id": self.selected_owner_id,
            "percentage": self.percentage_spinbox.value(),
        }


=============== FILE: views/horse/dialogs/record_payment_dialog.py ===============

# views/horse/dialogs/record_payment_dialog.py
"""
EDSI Veterinary Management System - Record Payment Dialog
Version: 1.0.1
Purpose: Dialog for recording a payment against a specific invoice.
Last Updated: June 14, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-06-14):
    - Styled the 'Record Payment' and 'Cancel' buttons to conform to the
      application's style guide.
- v1.0.0 (2025-06-10):
    - Initial creation of the dialog.
"""
import logging
from decimal import Decimal
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QDialogButtonBox,
    QMessageBox,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QComboBox,
    QTextEdit,
    QLabel,
)
from PySide6.QtCore import Qt, QDate
from PySide6.QtGui import QPalette, QColor, QFont

from models import Invoice
from controllers import FinancialController
from config.app_config import AppConfig


class RecordPaymentDialog(QDialog):
    """A dialog for recording a payment for an invoice."""

    PAYMENT_METHODS = ["Check", "Credit Card", "Cash", "Wire Transfer", "Other"]

    def __init__(
        self,
        invoice: Invoice,
        financial_controller: FinancialController,
        current_user_id: str,
        parent=None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.invoice = invoice
        self.financial_controller = financial_controller
        self.current_user_id = current_user_id

        self.setWindowTitle("Record Payment")
        self.setMinimumWidth(500)

        self._setup_ui()
        self._apply_styles()
        self._populate_form()

        self.button_box.accepted.connect(self.save_payment)
        self.button_box.rejected.connect(self.reject)

    def _get_input_field_style(self) -> str:
        return f"""
            QLineEdit, QDateEdit, QDoubleSpinBox, QTextEdit, QComboBox {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDateEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus, QComboBox:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
            }}
        """

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        self.form_layout = QFormLayout()
        self.form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.owner_label = QLabel()
        self.invoice_label = QLabel()
        self.balance_due_label = QLabel()

        self.amount_input = QDoubleSpinBox()
        self.date_input = QDateEdit()
        self.method_combo = QComboBox()
        self.reference_input = QLineEdit()
        self.notes_edit = QTextEdit()

        self.form_layout.addRow("Owner:", self.owner_label)
        self.form_layout.addRow("Invoice #:", self.invoice_label)
        self.form_layout.addRow("Balance Due:", self.balance_due_label)
        self.form_layout.addRow("Payment Amount*:", self.amount_input)
        self.form_layout.addRow("Payment Date*:", self.date_input)
        self.form_layout.addRow("Payment Method*:", self.method_combo)
        self.form_layout.addRow("Reference #:", self.reference_input)
        self.form_layout.addRow("Notes:", self.notes_edit)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(
            "Record Payment"
        )

        layout.addLayout(self.form_layout)
        layout.addWidget(self.button_box)

    def _apply_styles(self):
        self.setStyleSheet(
            f"background-color: {AppConfig.DARK_WIDGET_BACKGROUND}; color: {AppConfig.DARK_TEXT_PRIMARY};"
        )
        input_style = self._get_input_field_style()

        for widget in [
            self.amount_input,
            self.date_input,
            self.method_combo,
            self.reference_input,
            self.notes_edit,
        ]:
            widget.setStyleSheet(input_style)

        for label in [self.owner_label, self.invoice_label, self.balance_due_label]:
            label.setStyleSheet("font-weight: bold;")

        self.amount_input.setRange(0.01, 999999.99)
        self.amount_input.setDecimals(2)
        self.amount_input.setPrefix("$ ")

        self.date_input.setCalendarPopup(True)
        self.date_input.setDisplayFormat("yyyy-MM-dd")

        self.method_combo.addItems(self.PAYMENT_METHODS)
        self.notes_edit.setFixedHeight(60)

        # MODIFIED: Add button styling
        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        cancel_button = self.button_box.button(QDialogButtonBox.StandardButton.Cancel)

        base_button_style = """
            QPushButton {
                border: 1px solid white;
                border-radius: 4px;
                padding: 8px 16px;
                min-width: 120px;
                font-weight: bold;
            }
        """
        ok_button.setStyleSheet(
            base_button_style
            + f"""
            QPushButton {{ background-color: {AppConfig.DARK_SUCCESS_ACTION}; color: white; }}
            QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}
            """
        )
        cancel_button.setStyleSheet(
            base_button_style
            + f"""
            QPushButton {{ background-color: {AppConfig.DARK_BUTTON_BG}; color: {AppConfig.DARK_TEXT_PRIMARY}; }}
            QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}
            """
        )

    def _populate_form(self):
        owner_name = "N/A"
        if self.invoice.owner:
            owner_name = (
                self.invoice.owner.farm_name
                or f"{self.invoice.owner.first_name} {self.invoice.owner.last_name}"
            )

        self.owner_label.setText(owner_name)
        self.invoice_label.setText(f"INV-{self.invoice.invoice_id}")
        self.balance_due_label.setText(f"${self.invoice.balance_due:.2f}")
        self.amount_input.setValue(float(self.invoice.balance_due))
        self.date_input.setDate(QDate.currentDate())

    def get_data(self) -> Optional[Dict[str, Any]]:
        """Collects data from the form fields."""
        amount = Decimal(self.amount_input.value())
        if amount <= 0:
            QMessageBox.warning(
                self, "Validation Error", "Payment amount must be greater than zero."
            )
            return None
        if amount > self.invoice.balance_due:
            QMessageBox.warning(
                self,
                "Validation Error",
                "Payment amount cannot be greater than the balance due.",
            )
            return None

        return {
            "invoice_id": self.invoice.invoice_id,
            "owner_id": self.invoice.owner_id,
            "amount": amount,
            "payment_date": self.date_input.date().toPython(),
            "payment_method": self.method_combo.currentText(),
            "reference_number": self.reference_input.text().strip() or None,
            "notes": self.notes_edit.toPlainText().strip() or None,
            "user_id": self.current_user_id,
        }

    def save_payment(self):
        payment_data = self.get_data()
        if not payment_data:
            return

        success, message = self.financial_controller.record_payment(payment_data)

        if success:
            QMessageBox.information(self, "Success", message)
            self.accept()
        else:
            QMessageBox.critical(self, "Error", message)


=============== FILE: views/horse/dialogs/select_existing_location_dialog.py ===============

# views/horse/dialogs/select_existing_location_dialog.py
"""
EDSI Veterinary Management System - Select Existing Location Dialog
Version: 1.0.0
Purpose: Dialog for searching and selecting an existing active location.
Last Updated: May 20, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-05-20):
    - Initial implementation.
    - UI with search input (QLineEdit) and results list (QListWidget).
    - Fetches active locations using LocationController.
    - Search functionality filters locations by name (case-insensitive).
    - "Select Location" (OK) button enabled only when a location is selected.
    - Provides get_selected_location_id() method.
    - Styled for dark theme.
"""

import logging
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QDialogButtonBox,
    QApplication,  # For clipboard
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt, QTimer

from controllers.location_controller import LocationController
from models import Location as LocationModel  # Import the model

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class SelectExistingLocationDialog(QDialog):
    """Dialog to search and select an existing active location."""

    def __init__(self, parent_view, horse_name: str):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_name = horse_name
        self.location_controller = LocationController()
        self.all_active_locations: List[LocationModel] = []
        self.selected_location_id: Optional[int] = None

        self.setWindowTitle(f"Select Location for {self.horse_name}")
        self.setMinimumWidth(450)
        self.setMinimumHeight(350)

        self._setup_palette()
        self._setup_ui()
        self._load_initial_locations()

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self._filter_locations_list)

    def _get_dialog_specific_input_field_style(self) -> str:
        return f"""
            QLineEdit {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _get_dialog_list_widget_style(self) -> str:
        return f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none; border-radius: 4px;
            }}
            QListWidget::item {{ padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND}; }}
            QListWidget::item:selected {{ background-color: {DARK_PRIMARY_ACTION}4D; color: #ffffff; border-left: 3px solid {DARK_PRIMARY_ACTION}; }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }}
        """

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)
        self.setStyleSheet(
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; }}"
        )

        instruction_label = QLabel(
            f"Search for and select a location to assign to <b>{self.horse_name}</b>."
        )
        instruction_label.setWordWrap(True)
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 5px; background-color: transparent;"
        )
        layout.addWidget(instruction_label)

        input_style = self._get_dialog_specific_input_field_style()
        list_widget_style = self._get_dialog_list_widget_style()

        search_layout = QHBoxLayout()
        search_label = QLabel("Search Location:")
        self.location_search_input = QLineEdit()
        self.location_search_input.setPlaceholderText(
            "Enter location name to search..."
        )
        self.location_search_input.setStyleSheet(input_style)
        self.location_search_input.textChanged.connect(self._on_search_text_changed)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.location_search_input, 1)
        layout.addLayout(search_layout)

        self.locations_results_list = QListWidget()
        self.locations_results_list.setStyleSheet(list_widget_style)
        self.locations_results_list.itemClicked.connect(self._on_location_selected)
        layout.addWidget(self.locations_results_list, 1)  # Give stretch factor

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        self.ok_button.setText("Select Location")
        self.ok_button.setEnabled(False)  # Disabled until a location is selected

        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if button == self.ok_button:
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith(
                    "#"
                ):  # Expand 3-digit hex
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _load_initial_locations(self):
        try:
            self.all_active_locations = self.location_controller.get_all_locations(
                status_filter="active"
            )
            self._filter_locations_list()  # Populate initially with all active
            self.logger.info(
                f"Loaded {len(self.all_active_locations)} active locations initially."
            )
        except Exception as e:
            self.logger.error(
                f"Error loading initial active locations: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Load Error", "Could not load active locations.")
            self.locations_results_list.addItem("Error loading locations.")

    def _on_search_text_changed(self):
        self.search_timer.start(300)  # Debounce search

    def _filter_locations_list(self):
        search_term = self.location_search_input.text().strip().lower()
        self.locations_results_list.clear()
        self.selected_location_id = None  # Clear selection on new search
        self.ok_button.setEnabled(False)

        found_any = False
        for loc in self.all_active_locations:
            if search_term in loc.location_name.lower():
                item_text = f"{loc.location_name}"
                if loc.city and loc.state_code:
                    item_text += f" ({loc.city}, {loc.state_code})"
                elif loc.city:
                    item_text += f" ({loc.city})"

                list_item = QListWidgetItem(item_text)
                list_item.setData(Qt.ItemDataRole.UserRole, loc.location_id)
                self.locations_results_list.addItem(list_item)
                found_any = True

        if not found_any:
            self.locations_results_list.addItem(
                "No locations match your search."
                if search_term
                else "No active locations found."
            )

    def _on_location_selected(self, item: QListWidgetItem):
        location_id = item.data(Qt.ItemDataRole.UserRole)
        if location_id is not None:
            self.selected_location_id = location_id
            self.ok_button.setEnabled(True)
            self.logger.info(
                f"Location selected: ID {self.selected_location_id}, Display: {item.text()}"
            )
        else:
            self.selected_location_id = None
            self.ok_button.setEnabled(False)
            self.logger.info("Location selection cleared or invalid item clicked.")

    def get_selected_location_id(self) -> Optional[int]:
        """Returns the ID of the selected location if the dialog was accepted."""
        if self.result() == QDialog.DialogCode.Accepted:
            return self.selected_location_id
        return None


=============== FILE: views/horse/tabs/__init__.py ===============



=============== FILE: views/horse/tabs/basic_info_tab.py ===============

# views/horse/tabs/basic_info_tab.py
"""
EDSI Veterinary Management System - Horse Basic Info Tab
Version: 1.6.0
Purpose: UI for displaying and editing basic information of a horse.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v1.6.0 (2025-06-10):
    - Updated all input field and button styles to conform to EDMS_STYLE_GUIDE.MD.
      This includes the "boxed-in" look with white borders and standard colors
      for save, discard, and deactivate actions.
- v1.5.2 (2025-06-10):
    - Refactored the UI to use a single grid layout for all input fields,
      which enforces correct vertical alignment for all widgets, including
      the previously misaligned date fields.
- v1.5.1 (2025-06-10):
    - Increased vertical spacing in form layouts to make them less dense.
    - Set an explicit minimum height on input fields in the stylesheet to
      prevent text from being clipped, especially in date fields.
- v1.5.0 (2025-06-10):
    - Rearranged fields to improve layout and readability.
- v1.4.2 (2025-06-10):
    - Adjusted padding in the input field stylesheet to prevent text in
      QDateEdit widgets from being vertically cut off.
- v1.4.1 (2025-06-09):
    - Bug Fix: Corrected logic in `update_buttons_state` to enable Save/Discard
      buttons immediately when entering Add or Edit mode.
- v1.4.0 (2025-06-08):
    - Bug Fix: Corrected the logic in `update_buttons_state` to ensure the
      "Deactivate/Activate Horse" button is enabled whenever a horse is
      selected, not only when the form is in edit mode.
"""

import logging
from typing import Optional, Dict, Any, TYPE_CHECKING
from datetime import date

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QDateEdit,
    QLabel,
    QComboBox,
    QFrame,
    QScrollArea,
    QHBoxLayout,
    QPushButton,
    QTextEdit,
    QFormLayout,
)
from PySide6.QtCore import Qt, Signal, QDate, QSize
from PySide6.QtGui import QDoubleValidator, QIcon, QColor, QFont

from controllers.horse_controller import HorseController
from config.app_config import AppConfig


if TYPE_CHECKING:
    from models import Horse, Owner as OwnerModel


class BasicInfoTab(QWidget):
    data_modified = Signal()
    save_requested = Signal()
    discard_requested = Signal()
    toggle_active_requested = Signal(bool)
    edit_mode_toggled = Signal(bool)

    SEX_OPTIONS = ["Unknown", "Stallion", "Mare", "Gelding", "Colt", "Filly"]

    # MODIFIED: Styles updated to conform to EDMS_STYLE_GUIDE.MD
    INPUT_FIELD_STYLE = (
        f"background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND}; "
        "color: white; "
        "border: 1px solid white; "
        "border-radius: 3px; "
        "padding: 6px 5px; "
        "min-height: 22px;"
    )
    TEXT_AREA_STYLE = INPUT_FIELD_STYLE
    COMBO_DATE_STYLE = INPUT_FIELD_STYLE
    DEACTIVATE_BUTTON_STYLE = (
        f"QPushButton {{"
        f"background-color: {AppConfig.DARK_DANGER_ACTION}; color: white; border: 1px solid white; "
        f"border-radius: 3px; padding: 6px 12px; }}"
        f"QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_DANGER_ACTION).lighter(115).name()}; }}"
    )
    DISCARD_BUTTON_STYLE = (
        f"QPushButton {{"
        f"background-color: {AppConfig.DARK_BUTTON_BG}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid white; "
        f"border-radius: 3px; padding: 6px 12px; }}"
        f"QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}"
    )
    SAVE_BUTTON_STYLE = (
        f"QPushButton {{"
        f"background-color: {AppConfig.DARK_SUCCESS_ACTION}; color: white; border: 1px solid white; "
        f"border-radius: 3px; padding: 6px 12px; }}"
        f"QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}"
        f"QPushButton:pressed {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).darker(110).name()}; }}"
    )

    def __init__(
        self,
        horse_controller: Optional[HorseController] = None,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_controller = (
            horse_controller if horse_controller else HorseController()
        )
        self.parent_view: Optional[QWidget] = parent

        self.current_horse_id: Optional[int] = None
        self._is_new_mode: bool = False
        self._is_editing: bool = False
        self._has_unsaved_changes: bool = False
        self._current_horse_is_active: bool = True

        self.horse_name_input: QLineEdit
        self.breed_input: QLineEdit
        self.sex_combo: QComboBox
        self.reg_number_input: QLineEdit
        self.tattoo_number_input: QLineEdit
        self.location_display_label: QLabel
        self.owner_display_label: QLabel
        self.account_number_input: QLineEdit
        self.color_input: QLineEdit
        self.dob_input: QDateEdit
        self.microchip_id_input: QLineEdit
        self.brand_input: QLineEdit
        self.band_tag_input: QLineEdit
        self.coggins_date_input: QDateEdit
        self.height_input: QLineEdit
        self.description_input: QTextEdit
        self.save_btn: QPushButton
        self.discard_btn: QPushButton
        self.toggle_active_btn: QPushButton

        self._suppress_data_changed_signal = False
        self._setup_ui()
        self.set_form_read_only(True)
        self.update_buttons_state(
            is_editing_or_new=False, has_selection=False, has_changes=False
        )

    def _setup_ui(self):
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        scroll_area = QScrollArea(self)
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        content_widget = QWidget()
        outer_layout = QVBoxLayout(content_widget)
        outer_layout.setContentsMargins(15, 15, 15, 15)
        outer_layout.setSpacing(15)

        grid_layout = QGridLayout()
        grid_layout.setVerticalSpacing(12)
        grid_layout.setHorizontalSpacing(20)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)

        # --- Create Widgets ---
        self.horse_name_input = QLineEdit()
        self.account_number_input = QLineEdit()
        self.breed_input = QLineEdit()
        self.color_input = QLineEdit()
        self.sex_combo = QComboBox()
        self.sex_combo.addItems(self.SEX_OPTIONS)
        self.reg_number_input = QLineEdit()
        self.microchip_id_input = QLineEdit()
        self.tattoo_number_input = QLineEdit()
        self.brand_input = QLineEdit()
        self.band_tag_input = QLineEdit()
        self.location_display_label = QLabel("N/A")
        self.owner_display_label = QLabel("N/A")
        self.coggins_date_input = QDateEdit()
        self.coggins_date_input.setCalendarPopup(True)
        self.coggins_date_input.setDisplayFormat("yyyy-MM-dd")
        self.coggins_date_input.setDate(QDate(2000, 1, 1))
        self.coggins_date_input.setSpecialValueText(" ")
        self.dob_input = QDateEdit()
        self.dob_input.setCalendarPopup(True)
        self.dob_input.setDisplayFormat("yyyy-MM-dd")
        self.dob_input.setDate(QDate(2000, 1, 1))
        self.dob_input.setMaximumDate(QDate.currentDate())
        self.dob_input.setSpecialValueText(" ")
        self.height_input = QLineEdit()
        double_validator = QDoubleValidator(0.00, 99.99, 2)
        double_validator.setNotation(QDoubleValidator.Notation.StandardNotation)
        self.height_input.setValidator(double_validator)

        # --- Add Widgets to Grid ---
        grid_layout.addWidget(QLabel("Name*:"), 0, 0, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.horse_name_input, 0, 1)
        grid_layout.addWidget(
            QLabel("Account Number:"), 0, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.account_number_input, 0, 3)

        grid_layout.addWidget(QLabel("Breed:"), 1, 0, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.breed_input, 1, 1)
        grid_layout.addWidget(QLabel("Color:"), 1, 2, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.color_input, 1, 3)

        grid_layout.addWidget(QLabel("Sex:"), 2, 0, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.sex_combo, 2, 1)
        grid_layout.addWidget(QLabel("Reg. Number:"), 2, 2, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.reg_number_input, 2, 3)

        grid_layout.addWidget(
            QLabel("Microchip ID:"), 3, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.microchip_id_input, 3, 1)
        grid_layout.addWidget(QLabel("Tattoo:"), 3, 2, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.tattoo_number_input, 3, 3)

        grid_layout.addWidget(QLabel("Brand:"), 4, 0, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.brand_input, 4, 1)
        grid_layout.addWidget(QLabel("Band/Tag:"), 4, 2, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.band_tag_input, 4, 3)

        grid_layout.addWidget(
            QLabel("Height (Hands):"), 5, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.height_input, 5, 1)

        grid_layout.addWidget(
            QLabel("Coggins Date:"),
            6,
            0,
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignTop,
        )
        grid_layout.addWidget(self.coggins_date_input, 6, 1)
        grid_layout.addWidget(
            QLabel("Date of Birth:"),
            6,
            2,
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignTop,
        )
        grid_layout.addWidget(self.dob_input, 6, 3)

        grid_layout.addWidget(QLabel("Location:"), 7, 0, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.location_display_label, 7, 1)
        grid_layout.addWidget(QLabel("Owner:"), 7, 2, Qt.AlignmentFlag.AlignRight)
        grid_layout.addWidget(self.owner_display_label, 7, 3)

        outer_layout.addLayout(grid_layout)

        outer_layout.addSpacing(20)

        description_form_layout = QFormLayout()
        description_form_layout.setContentsMargins(0, 0, 0, 0)
        description_form_layout.setSpacing(10)
        description_form_layout.setLabelAlignment(
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight
        )
        self.description_input = QTextEdit()
        self.description_input.setFixedHeight(80)
        description_form_layout.addRow(
            QLabel("Description/Markings:"), self.description_input
        )
        outer_layout.addLayout(description_form_layout)

        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setSpacing(10)
        self.toggle_active_btn = QPushButton("Deactivate Horse")
        self.toggle_active_btn.clicked.connect(self._request_toggle_active)
        self.discard_btn = QPushButton("Discard Changes")
        self.discard_btn.clicked.connect(self.discard_requested.emit)
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self.save_requested.emit)
        button_layout.addWidget(self.toggle_active_btn)
        button_layout.addStretch()
        button_layout.addWidget(self.discard_btn)
        button_layout.addWidget(self.save_btn)
        outer_layout.addWidget(button_frame)

        outer_layout.addStretch(1)
        scroll_area.setWidget(content_widget)
        self.main_layout.addWidget(scroll_area)

        # Apply Styles
        for widget in content_widget.findChildren(QLineEdit):
            widget.setStyleSheet(self.INPUT_FIELD_STYLE)
            widget.textChanged.connect(self._on_data_modified)
        for widget in content_widget.findChildren(QDateEdit):
            widget.setStyleSheet(self.COMBO_DATE_STYLE)
            widget.dateChanged.connect(self._on_data_modified)
        for widget in content_widget.findChildren(QComboBox):
            widget.setStyleSheet(self.COMBO_DATE_STYLE)
            widget.currentIndexChanged.connect(self._on_data_modified)
        for widget in content_widget.findChildren(QTextEdit):
            widget.setStyleSheet(self.TEXT_AREA_STYLE)
            widget.textChanged.connect(self._on_data_modified)
        for widget in [self.owner_display_label, self.location_display_label]:
            widget.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.save_btn.setStyleSheet(self.SAVE_BUTTON_STYLE)
        self.discard_btn.setStyleSheet(self.DISCARD_BUTTON_STYLE)
        self.toggle_active_btn.setStyleSheet(self.DEACTIVATE_BUTTON_STYLE)

    def _request_toggle_active(self):
        self.toggle_active_requested.emit(self._current_horse_is_active)

    def update_toggle_active_button_text(self, is_active: bool):
        self.toggle_active_btn.setText(
            "Deactivate Horse" if is_active else "Activate Horse"
        )
        self._current_horse_is_active = is_active

    def populate_form_data(self, horse_data: Optional["Horse"]):
        self.logger.debug(
            f"Populating BasicInfoTab with horse_data: {horse_data.horse_name if horse_data else 'None'}"
        )
        self._suppress_data_changed_signal = True
        if horse_data:
            self.current_horse_id = horse_data.horse_id
            self.horse_name_input.setText(horse_data.horse_name or "")
            self.account_number_input.setText(horse_data.account_number or "")
            self.breed_input.setText(horse_data.breed or "")
            self.color_input.setText(horse_data.color or "")
            sex_idx = self.sex_combo.findText(
                horse_data.sex or "Unknown", Qt.MatchFlag.MatchFixedString
            )
            self.sex_combo.setCurrentIndex(sex_idx if sex_idx >= 0 else 0)
            if horse_data.date_of_birth:
                self.dob_input.setDate(
                    QDate.fromString(str(horse_data.date_of_birth), "yyyy-MM-dd")
                )
            else:
                self.dob_input.setDate(self.dob_input.minimumDate().addDays(-1))
                self.dob_input.setDate(QDate(2000, 1, 1))
            self.reg_number_input.setText(getattr(horse_data, "reg_number", "") or "")
            self.microchip_id_input.setText(horse_data.chip_number or "")
            self.tattoo_number_input.setText(horse_data.tattoo_number or "")
            self.brand_input.setText(getattr(horse_data, "brand", "") or "")
            self.band_tag_input.setText(getattr(horse_data, "band_tag", "") or "")
            self.location_display_label.setText(
                horse_data.location.location_name if horse_data.location else "N/A"
            )
            self.owner_display_label.setText(self._get_display_owner_name(horse_data))
            if horse_data.coggins_date:
                self.coggins_date_input.setDate(
                    QDate.fromString(str(horse_data.coggins_date), "yyyy-MM-dd")
                )
            else:
                self.coggins_date_input.setDate(
                    self.coggins_date_input.minimumDate().addDays(-1)
                )
                self.coggins_date_input.setDate(QDate(2000, 1, 1))
            self.height_input.setText(
                f"{horse_data.height_hands:.2f}"
                if horse_data.height_hands is not None
                else ""
            )
            self.description_input.setPlainText(horse_data.description or "")
            self.update_toggle_active_button_text(horse_data.is_active)
            self.set_form_read_only(True)
            self._is_new_mode = False
            self._is_editing = False
            self.update_buttons_state(
                is_editing_or_new=False, has_selection=True, has_changes=False
            )
        else:
            self.clear_fields(suppress_signal=True)
            self.set_form_read_only(True)
            self._is_new_mode = False
            self._is_editing = False
            self.update_buttons_state(
                is_editing_or_new=False, has_selection=False, has_changes=False
            )
        self._has_unsaved_changes = False
        self._suppress_data_changed_signal = False

    def _on_data_modified(self, *args):
        if self._suppress_data_changed_signal:
            return
        if not self.horse_name_input.isReadOnly():
            if not self._has_unsaved_changes:
                self._has_unsaved_changes = True
                self.logger.debug("Data modified. Flag set.")
                self.data_modified.emit()
            self.update_buttons_state(
                is_editing_or_new=(self._is_new_mode or self._is_editing),
                has_selection=(self.current_horse_id is not None),
                has_changes=True,
            )

    def get_data_from_form(self) -> Dict[str, Any]:
        def get_date_object(date_edit_widget: QDateEdit) -> Optional[date]:
            q_date = date_edit_widget.date()
            if (
                date_edit_widget.text().strip() == ""
                or q_date < date_edit_widget.minimumDate()
                or not q_date.isValid()
                or q_date == date_edit_widget.minimumDate().addDays(-1)
            ):
                return None
            return date(q_date.year(), q_date.month(), q_date.day())

        data = {
            "horse_name": self.horse_name_input.text().strip() or None,
            "account_number": self.account_number_input.text().strip() or None,
            "breed": self.breed_input.text().strip() or None,
            "color": self.color_input.text().strip() or None,
            "sex": (
                self.sex_combo.currentText()
                if self.sex_combo.currentText() != "Unknown"
                else None
            ),
            "date_of_birth": get_date_object(self.dob_input),
            "chip_number": self.microchip_id_input.text().strip() or None,
            "tattoo_number": self.tattoo_number_input.text().strip() or None,
            "is_active": self._current_horse_is_active,
            "reg_number": self.reg_number_input.text().strip() or None,
            "brand": self.brand_input.text().strip() or None,
            "band_tag": self.band_tag_input.text().strip() or None,
            "coggins_date": get_date_object(self.coggins_date_input),
            "height_hands": (
                float(self.height_input.text())
                if self.height_input.text().strip()
                else None
            ),
            "description": self.description_input.toPlainText().strip() or None,
            "date_deceased": None,
        }
        return data

    def set_form_read_only(self, read_only: bool):
        self.logger.debug(f"BasicInfoTab.set_form_read_only: {read_only}")
        self._suppress_data_changed_signal = True
        line_edit_fields = [
            self.horse_name_input,
            self.account_number_input,
            self.breed_input,
            self.color_input,
            self.reg_number_input,
            self.microchip_id_input,
            self.tattoo_number_input,
            self.brand_input,
            self.band_tag_input,
            self.height_input,
        ]
        for field in line_edit_fields:
            field.setReadOnly(read_only)
        interactive_widgets = [self.sex_combo, self.dob_input, self.coggins_date_input]
        for widget in interactive_widgets:
            widget.setEnabled(not read_only)
        self.description_input.setReadOnly(read_only)
        self._is_editing = not read_only
        if read_only:
            self._has_unsaved_changes = False
        self._suppress_data_changed_signal = False

    def clear_fields(self, suppress_signal: bool = False):
        if suppress_signal:
            self._suppress_data_changed_signal = True
        self.current_horse_id = None
        self.horse_name_input.clear()
        self.account_number_input.clear()
        self.breed_input.clear()
        self.color_input.clear()
        self.sex_combo.setCurrentIndex(0)
        self.dob_input.setDate(self.dob_input.minimumDate().addDays(-1))
        self.dob_input.setDate(QDate(2000, 1, 1))
        self.reg_number_input.clear()
        self.microchip_id_input.clear()
        self.tattoo_number_input.clear()
        self.brand_input.clear()
        self.band_tag_input.clear()
        self.location_display_label.setText("N/A")
        self.owner_display_label.setText("N/A")
        self.coggins_date_input.setDate(
            self.coggins_date_input.minimumDate().addDays(-1)
        )
        self.coggins_date_input.setDate(QDate(2000, 1, 1))
        self.height_input.clear()
        self.description_input.clear()
        self.update_toggle_active_button_text(True)
        if suppress_signal:
            self._suppress_data_changed_signal = False
        self._has_unsaved_changes = False
        if not suppress_signal:
            self.data_modified.emit()

    def set_new_mode(self, is_new: bool):
        self.logger.info(f"BasicInfoTab set_new_mode: {is_new}")
        self._is_new_mode = is_new
        self._is_editing = True
        self.current_horse_id = None
        self.clear_fields(suppress_signal=True)
        self.set_form_read_only(False)
        self._has_unsaved_changes = False
        self.update_buttons_state(
            is_editing_or_new=True, has_selection=False, has_changes=False
        )
        self.edit_mode_toggled.emit(True)
        self.horse_name_input.setFocus()

    def set_edit_mode(self, editable: bool):
        self.logger.info(f"BasicInfoTab set_edit_mode: {editable}")
        self._is_new_mode = False
        self._is_editing = editable
        self.set_form_read_only(not editable)
        if editable:
            self._has_unsaved_changes = False
            self.horse_name_input.setFocus()
        self.update_buttons_state(
            is_editing_or_new=editable,
            has_selection=(self.current_horse_id is not None),
            has_changes=self._has_unsaved_changes,
        )
        self.edit_mode_toggled.emit(editable)

    def update_buttons_state(
        self, is_editing_or_new: bool, has_selection: bool, has_changes: bool
    ):
        can_save = (is_editing_or_new or self._is_editing) and has_changes
        can_discard = is_editing_or_new or self._is_editing
        can_toggle_active = has_selection and not self._is_new_mode

        self.save_btn.setEnabled(
            can_save or is_editing_or_new
        )  # Enable Save immediately in new/edit mode
        self.discard_btn.setEnabled(can_discard)
        self.toggle_active_btn.setEnabled(can_toggle_active)

        if not has_selection and not self._is_new_mode:
            self.update_toggle_active_button_text(True)
            self.toggle_active_btn.setEnabled(False)
        elif self._is_new_mode:
            self.update_toggle_active_button_text(True)
            self.toggle_active_btn.setEnabled(False)

    def has_unsaved_changes(self) -> bool:
        return self._has_unsaved_changes

    def mark_as_saved(self):
        self.logger.debug("BasicInfoTab.mark_as_saved.")
        self._has_unsaved_changes = False
        self._is_editing = False
        self.set_form_read_only(True)
        self.update_buttons_state(False, (self.current_horse_id is not None), False)

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yr" if age_val == 1 else f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"

    def _get_display_owner_name(self, horse: "Horse") -> str:
        if not horse.owners:
            return "No Owner Associated"
        first_owner = horse.owners[0]
        name_parts = []
        if first_owner.farm_name:
            name_parts.append(first_owner.farm_name)
        person_name_parts = []
        if first_owner.first_name:
            person_name_parts.append(first_owner.first_name)
        if first_owner.last_name:
            person_name_parts.append(first_owner.last_name)
        person_name_str = " ".join(person_name_parts).strip()
        if person_name_str:
            if name_parts:
                name_parts.append(f"({person_name_str})")
            else:
                name_parts.append(person_name_str)
        return (
            " ".join(name_parts) if name_parts else f"Owner ID: {first_owner.owner_id}"
        )

    def _get_display_location_name(self, horse: "Horse") -> str:
        return horse.location.location_name if horse.location else "N/A"


=============== FILE: views/horse/tabs/billing_tab.py ===============

# views/horse/tabs/billing_tab.py
"""
EDSI Veterinary Management System - Horse Billing Tab
Version: 1.9.0
Purpose: UI for displaying and managing billing charges for a specific horse.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.9.0 (2025-06-09):
    - Added invoice_created signal to notify parent views when an invoice
      has been successfully generated, allowing other UI components to refresh.
- v1.8.0 (2025-06-09):
    - Updated `load_transactions` to use the refactored `get_transactions_for_horse`
      controller method that now filters by status instead of an 'invoiced' flag.
- v1.7.0 (2025-06-09):
    - Refactored `_create_invoice` to call `generate_invoices_from_transactions`.
"""

import logging
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QTableWidget,
    QPushButton,
    QHBoxLayout,
    QHeaderView,
    QAbstractItemView,
    QTableWidgetItem,
    QMessageBox,
    QDialog,
    QApplication,
    QLabel,
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QFont, QColor

from models import Horse, Transaction
from controllers import FinancialController
from ..dialogs.add_charge_dialog import AddChargeDialog
from ..dialogs.edit_charge_dialog import EditChargeDialog
from ..dialogs.edit_all_charges_dialog import EditAllChargesDialog
from config.app_config import AppConfig


class BillingTab(QWidget):
    status_message = Signal(str)
    invoice_created = Signal()

    def __init__(
        self,
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.financial_controller = financial_controller
        self.current_horse: Optional[Horse] = None
        self.transactions: List[Transaction] = []

        self._setup_ui()
        self._setup_connections()
        self.clear_display()

    def _create_action_button(
        self,
        text: str,
        icon_char: str,
        base_color: str,
        border_color: Optional[str] = None,
    ) -> QPushButton:
        button = QPushButton(f" {icon_char}  {text}")
        font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 10)
        font.setBold(True)
        button.setFont(font)
        button.setMinimumHeight(36)

        border_style = (
            f"border: 1px solid {border_color};" if border_color else "border: none;"
        )

        button.setStyleSheet(
            f"""
            QPushButton {{
                background-color: {base_color};
                color: white;
                border-radius: 5px;
                padding: 5px 15px;
                text-align: center;
                {border_style}
            }}
            QPushButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
                border: 1px solid {AppConfig.DARK_TEXT_TERTIARY};
            }}
            QPushButton:hover {{
                background-color: {QColor(base_color).lighter(115).name()};
            }}
        """
        )
        return button

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        action_layout = QHBoxLayout()
        action_layout.setSpacing(10)

        self.add_charge_btn = self._create_action_button(
            "Add New Charges", "➕", AppConfig.DARK_SUCCESS_ACTION
        )
        self.edit_charge_btn = self._create_action_button(
            "Edit Selected",
            "✏️",
            AppConfig.DARK_BUTTON_BG,
            AppConfig.DARK_PRIMARY_ACTION,
        )
        self.edit_all_btn = self._create_action_button(
            "Edit All", "✏️", AppConfig.DARK_BUTTON_BG, AppConfig.DARK_PRIMARY_ACTION
        )
        self.delete_charge_btn = self._create_action_button(
            "Delete Selected",
            "➖",
            AppConfig.DARK_BUTTON_BG,
            AppConfig.DARK_DANGER_ACTION,
        )
        self.create_invoice_btn = self._create_action_button(
            "Create Invoice", "📄", AppConfig.DARK_PRIMARY_ACTION
        )

        action_layout.addWidget(self.add_charge_btn)
        action_layout.addWidget(self.edit_charge_btn)
        action_layout.addWidget(self.edit_all_btn)
        action_layout.addWidget(self.delete_charge_btn)
        action_layout.addStretch()
        action_layout.addWidget(self.create_invoice_btn)
        main_layout.addLayout(action_layout)

        self.title_label = QLabel("Un-invoiced Charges")
        font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        self.title_label.setFont(font)
        self.title_label.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-top: 10px;"
        )
        main_layout.addWidget(self.title_label)

        self.transactions_table = QTableWidget()
        self.transactions_table.setColumnCount(7)
        self.transactions_table.setHorizontalHeaderLabels(
            ["ID", "Code", "Alt. Code", "Description", "Qty", "Unit Price", "Total"]
        )
        self.transactions_table.setEditTriggers(
            QAbstractItemView.EditTrigger.NoEditTriggers
        )
        self.transactions_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )
        self.transactions_table.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.transactions_table.verticalHeader().setVisible(False)
        self.transactions_table.horizontalHeader().setStretchLastSection(True)
        self.transactions_table.horizontalHeader().setSectionResizeMode(
            3, QHeaderView.ResizeMode.Stretch
        )
        self.transactions_table.setColumnHidden(0, True)
        self.transactions_table.setStyleSheet(
            f"""
            QTableWidget {{
                gridline-color: {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                border-radius: 4px;
            }}
            QHeaderView::section {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                padding: 5px;
                border: none;
                border-bottom: 1px solid {AppConfig.DARK_BORDER};
            }}
            QTableWidget::item {{ padding: 5px; }}
            QTableWidget::item:selected {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """
        )
        main_layout.addWidget(self.transactions_table)

        total_layout = QHBoxLayout()
        total_layout.addStretch()
        total_due_title_label = QLabel("Total Due:")
        font.setPointSize(14)
        total_due_title_label.setFont(font)
        self.total_due_label = QLabel("$0.00")
        self.total_due_label.setFont(font)
        self.total_due_label.setStyleSheet("color: white;")

        total_layout.addWidget(total_due_title_label)
        total_layout.addWidget(self.total_due_label)
        main_layout.addLayout(total_layout)

    def _setup_connections(self):
        self.add_charge_btn.clicked.connect(self._launch_add_charge_dialog)
        self.edit_charge_btn.clicked.connect(self._edit_selected_charge)
        self.edit_all_btn.clicked.connect(self._launch_edit_all_charges_dialog)
        self.delete_charge_btn.clicked.connect(self._delete_selected_charge)
        self.create_invoice_btn.clicked.connect(self._create_invoice)
        self.transactions_table.itemSelectionChanged.connect(self.update_buttons_state)
        self.transactions_table.cellDoubleClicked.connect(self._edit_selected_charge)

    def set_current_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.load_transactions()
        self.update_buttons_state()

    def load_transactions(self):
        if not self.current_horse:
            self.clear_display()
            return
        self.transactions = self.financial_controller.get_transactions_for_horse(
            self.current_horse.horse_id
        )
        self.populate_transactions_table()

    def populate_transactions_table(self):
        self.transactions_table.setRowCount(0)
        if self.transactions:
            self.transactions_table.setRowCount(len(self.transactions))
            for row, trans in enumerate(self.transactions):
                trans_id = trans.transaction_id
                id_item = QTableWidgetItem(str(trans_id))
                id_item.setData(Qt.ItemDataRole.UserRole, trans_id)
                self.transactions_table.setItem(row, 0, id_item)

                code = trans.charge_code.code if trans.charge_code else "N/A"
                alt_code = (
                    trans.charge_code.alternate_code if trans.charge_code else "N/A"
                )

                self.transactions_table.setItem(row, 1, QTableWidgetItem(code))
                self.transactions_table.setItem(row, 2, QTableWidgetItem(alt_code))
                self.transactions_table.setItem(
                    row, 3, QTableWidgetItem(trans.description)
                )
                self.transactions_table.setItem(
                    row, 4, QTableWidgetItem(str(trans.quantity))
                )
                self.transactions_table.setItem(
                    row, 5, QTableWidgetItem(f"{trans.unit_price:.2f}")
                )
                self.transactions_table.setItem(
                    row, 6, QTableWidgetItem(f"{trans.total_price:.2f}")
                )
        self._update_total_due_display()
        self.update_buttons_state()

    def clear_display(self):
        self.transactions_table.setRowCount(0)
        self.transactions = []
        self.current_horse = None
        self.update_buttons_state()
        self._update_total_due_display()

    def update_buttons_state(self):
        has_horse = self.current_horse is not None
        has_transactions = len(self.transactions) > 0
        has_selection = (
            has_transactions and len(self.transactions_table.selectedItems()) > 0
        )

        self.add_charge_btn.setEnabled(has_horse)
        self.edit_charge_btn.setEnabled(has_selection)
        self.edit_all_btn.setEnabled(has_transactions)
        self.delete_charge_btn.setEnabled(has_selection)
        self.create_invoice_btn.setEnabled(has_transactions)

    def _update_total_due_display(self):
        total_due = sum(
            trans.total_price
            for trans in self.transactions
            if trans and hasattr(trans, "total_price")
        )
        self.total_due_label.setText(f"${total_due:.2f}")

    def _create_invoice(self):
        """Handler for the 'Create Invoice' button."""
        if not self.current_horse or not self.transactions:
            self.status_message.emit("No charges available to create an invoice.")
            return

        transaction_ids = [t.transaction_id for t in self.transactions]
        total_due = sum(t.total_price for t in self.transactions)

        current_user_id = (
            self.parent_view.current_user
            if hasattr(self.parent_view, "current_user")
            else "Unknown"
        )
        owner_count = len(self.current_horse.owner_associations)

        confirmation_message = (
            f"This will generate {owner_count} separate invoice(s) for all owners of {self.current_horse.horse_name}, "
            f"splitting a total of ${total_due:.2f} based on their ownership percentage.\n\nProceed?"
        )

        if self.parent_view.show_question(
            "Confirm Invoice Generation", confirmation_message
        ):
            success, message, new_invoices = (
                self.financial_controller.generate_invoices_from_transactions(
                    source_transaction_ids=transaction_ids,
                    current_user_id=current_user_id,
                )
            )
            if success:
                self.status_message.emit(message)
                self.load_transactions()
                self.invoice_created.emit()
            else:
                self.parent_view.show_error("Invoice Creation Failed", message)

    def _launch_add_charge_dialog(self):
        if not self.current_horse:
            return
        dialog = AddChargeDialog(self.current_horse, self.financial_controller, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit(
                f"New charges added for {self.current_horse.horse_name}."
            )
            self.load_transactions()

    def _launch_edit_all_charges_dialog(self):
        if not self.current_horse or not self.transactions:
            return
        dialog = EditAllChargesDialog(
            self.current_horse, self.transactions, self.financial_controller, self
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit(
                f"Charges updated for {self.current_horse.horse_name}."
            )
            self.load_transactions()

    @Slot(int, int)
    def _edit_selected_charge(self, row=None, column=None):
        selected_items = self.transactions_table.selectedItems()
        if not selected_items:
            return

        selected_row = selected_items[0].row()
        transaction_id = self.transactions_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )

        transaction_to_edit = self.financial_controller.get_transaction_by_id(
            transaction_id
        )
        if not transaction_to_edit:
            QMessageBox.critical(
                self, "Error", "Could not find the selected transaction to edit."
            )
            return

        dialog = EditChargeDialog(
            transaction=transaction_to_edit,
            financial_controller=self.financial_controller,
            current_user_id=QApplication.instance().current_user_id,
            parent=self,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit("Charge updated successfully.")
            self.load_transactions()

    def _delete_selected_charge(self):
        selected_items = self.transactions_table.selectedItems()
        if not selected_items:
            return

        row = selected_items[0].row()
        transaction_id = self.transactions_table.item(row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        description = self.transactions_table.item(row, 3).text()

        if self.parent_view and hasattr(self.parent_view, "show_question"):
            reply_is_yes = self.parent_view.show_question(
                "Confirm Delete",
                f"Are you sure you want to delete this charge?\n\n- {description}",
            )
        else:
            reply = QMessageBox.question(
                self,
                "Confirm Delete",
                f"Are you sure you want to delete this charge?\n\n- {description}",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
            reply_is_yes = reply == QMessageBox.StandardButton.Yes

        if reply_is_yes:
            success, message = self.financial_controller.delete_charge_transaction(
                transaction_id
            )
            if success:
                self.status_message.emit(message)
                self.load_transactions()
            else:
                QMessageBox.critical(self, "Error", message)


=============== FILE: views/horse/tabs/invoice_history_tab.py ===============

# views/horse/tabs/invoice_history_tab.py
"""
EDSI Veterinary Management System - Invoice History Tab
Version: 2.5.2
Purpose: UI for displaying and managing historical invoices for a horse's owners.
Last Updated: June 13, 2025
Author: Gemini

Changelog:
- v2.5.2 (2025-06-13):
    - Refactored the email invoice confirmation to use `self.parent_view.show_info`
      to ensure a consistently styled dialog is displayed, matching the
      application's theme.
- v2.5.1 (2025-06-13):
    - Fixed application closing unexpectedly after saving a PDF by re-parenting
      the QFileDialog to the main window, ensuring stability.
- v2.5.0 (2025-06-10):
    - Added "Record Payment" button and workflow.
    - Button is enabled for single, unpaid invoices.
    - Launches the new RecordPaymentDialog.
    - Added `payment_recorded` signal to notify parent view to refresh data.
- v2.4.0 (2025-06-10):
    - Fixed bug in _on_invoice_selected where details would not show.
    - Enabled batch emailing and deleting for multiple selected invoices.
- v2.3.0 (2025-06-10):
    - Enabled multi-selection (ExtendedSelection) on the main invoices table.
    - Refactored _print_selected_invoice to handle batch saving to a directory.
- v2.2.0 (2025-06-09):
    - Updated PDF save locations to use the new `AppConfig.INVOICES_DIR`.
- v2.1.0 (2025-06-09):
    - Added "Email Invoice" button and functionality.
"""
import logging
import os
import webbrowser
import urllib.parse
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QTableWidget,
    QPushButton,
    QHBoxLayout,
    QHeaderView,
    QAbstractItemView,
    QTableWidgetItem,
    QLabel,
    QFileDialog,
    QMessageBox,
    QDialog,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QFont, QColor

from models import Horse, Invoice, Transaction
from controllers import FinancialController, CompanyProfileController
from reports import InvoiceGenerator
from config.app_config import AppConfig
from ..dialogs.record_payment_dialog import RecordPaymentDialog


class InvoiceHistoryTab(QWidget):
    """Tab widget for displaying and managing invoice history."""

    status_message = Signal(str)
    invoice_deleted = Signal()
    payment_recorded = Signal()

    def __init__(
        self,
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.financial_controller = financial_controller
        self.company_profile_controller = CompanyProfileController()
        self.current_horse: Optional[Horse] = None
        self.invoices: List[Invoice] = []

        self._setup_ui()
        self._setup_connections()

    def _create_action_button(
        self,
        text: str,
        icon_char: str,
        base_color: str,
        border_color: Optional[str] = None,
    ) -> QPushButton:
        button = QPushButton(f" {icon_char}  {text}")
        font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 10)
        font.setBold(True)
        button.setFont(font)
        button.setMinimumHeight(36)

        border_style = (
            f"border: 1px solid {border_color};" if border_color else "border: none;"
        )

        button.setStyleSheet(
            f"""
            QPushButton {{
                background-color: {base_color};
                color: white;
                border-radius: 5px;
                padding: 5px 15px;
                text-align: center;
                {border_style}
            }}
            QPushButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
                border: 1px solid {AppConfig.DARK_TEXT_TERTIARY};
            }}
            QPushButton:hover {{
                background-color: {QColor(base_color).lighter(115).name()};
            }}
        """
        )
        return button

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        action_layout = QHBoxLayout()
        self.record_payment_btn = self._create_action_button(
            "Record Payment", "💵", AppConfig.DARK_SUCCESS_ACTION
        )
        self.email_invoice_btn = self._create_action_button(
            "Email Selected Invoice(s)",
            "✉️",
            AppConfig.DARK_BUTTON_BG,
            AppConfig.DARK_PRIMARY_ACTION,
        )
        self.print_invoice_btn = self._create_action_button(
            "Print Selected Invoice(s)",
            "🖨️",
            AppConfig.DARK_BUTTON_BG,
            AppConfig.DARK_PRIMARY_ACTION,
        )
        self.delete_invoice_btn = self._create_action_button(
            "Delete Selected Invoice(s)", "🗑️", AppConfig.DARK_DANGER_ACTION
        )

        action_layout.addWidget(self.record_payment_btn)
        action_layout.addStretch()
        action_layout.addWidget(self.email_invoice_btn)
        action_layout.addWidget(self.print_invoice_btn)
        action_layout.addWidget(self.delete_invoice_btn)
        main_layout.addLayout(action_layout)

        main_layout.addWidget(QLabel("All Invoices for This Horse's Owners"))
        self.invoices_table = self._create_table(
            ["Invoice #", "Date", "Billed To", "Total", "Balance Due", "Status"],
            multi_select=True,
        )
        self.invoices_table.horizontalHeader().setSectionResizeMode(
            0, QHeaderView.ResizeMode.ResizeToContents
        )
        self.invoices_table.horizontalHeader().setSectionResizeMode(
            2, QHeaderView.ResizeMode.Stretch
        )
        self.invoices_table.horizontalHeader().setSectionResizeMode(
            5, QHeaderView.ResizeMode.Stretch
        )
        main_layout.addWidget(self.invoices_table)

        main_layout.addWidget(QLabel("Details for Selected Invoice"))
        self.invoice_details_table = self._create_table(
            ["Date", "Code", "Description", "Qty", "Unit Price", "Line Total"]
        )
        self.invoice_details_table.horizontalHeader().setSectionResizeMode(
            2, QHeaderView.ResizeMode.Stretch
        )
        main_layout.addWidget(self.invoice_details_table)

        main_layout.setStretchFactor(self.invoices_table, 2)
        main_layout.setStretchFactor(self.invoice_details_table, 1)

        self.update_buttons_state()

    def _create_table(
        self, headers: List[str], multi_select: bool = False
    ) -> QTableWidget:
        table = QTableWidget()
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)

        if multi_select:
            table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        else:
            table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)

        table.verticalHeader().setVisible(False)
        table.setStyleSheet(
            f"""
            QTableWidget {{
                gridline-color: {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                border-radius: 4px;
            }}
            QHeaderView::section {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                padding: 5px; border: none;
                border-bottom: 1px solid {AppConfig.DARK_BORDER};
            }}
            QTableWidget::item {{ padding: 5px; }}
            QTableWidget::item:selected {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """
        )
        return table

    def _setup_connections(self):
        self.invoices_table.itemSelectionChanged.connect(self._on_invoice_selected)
        self.print_invoice_btn.clicked.connect(self._print_selected_invoice)
        self.email_invoice_btn.clicked.connect(self._email_selected_invoice)
        self.delete_invoice_btn.clicked.connect(self._delete_selected_invoice)
        self.record_payment_btn.clicked.connect(self._launch_record_payment_dialog)

    def set_current_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.load_invoices()

    def load_invoices(self):
        self.invoices_table.setRowCount(0)
        self.invoice_details_table.setRowCount(0)

        if not self.current_horse or not self.current_horse.owners:
            self.invoices = []
            self.update_buttons_state()
            return

        owner_ids = {owner.owner_id for owner in self.current_horse.owners}
        all_invoices = []
        for owner_id in owner_ids:
            owner_invoices = self.financial_controller.get_invoices_for_owner(owner_id)
            all_invoices.extend(owner_invoices)

        self.invoices = sorted(
            all_invoices, key=lambda inv: inv.invoice_date, reverse=True
        )

        for inv in self.invoices:
            row = self.invoices_table.rowCount()
            self.invoices_table.insertRow(row)

            owner_name = "N/A"
            if inv.owner:
                owner_name = (
                    inv.owner.farm_name
                    or f"{inv.owner.first_name} {inv.owner.last_name}"
                )

            self.invoices_table.setItem(
                row, 0, QTableWidgetItem(f"INV-{inv.invoice_id}")
            )
            self.invoices_table.setItem(
                row, 1, QTableWidgetItem(inv.invoice_date.strftime("%Y-%m-%d"))
            )
            self.invoices_table.setItem(row, 2, QTableWidgetItem(owner_name))
            self.invoices_table.setItem(
                row, 3, QTableWidgetItem(f"${inv.grand_total:.2f}")
            )
            self.invoices_table.setItem(
                row, 4, QTableWidgetItem(f"${inv.balance_due:.2f}")
            )
            self.invoices_table.setItem(row, 5, QTableWidgetItem(inv.status))
            self.invoices_table.item(row, 0).setData(
                Qt.ItemDataRole.UserRole, inv.invoice_id
            )

        self.update_buttons_state()

    def _on_invoice_selected(self):
        self.invoice_details_table.setRowCount(0)
        selected_rows = self.invoices_table.selectionModel().selectedRows()

        if len(selected_rows) == 1:
            selected_row_index = selected_rows[0].row()
            invoice_id = self.invoices_table.item(selected_row_index, 0).data(
                Qt.ItemDataRole.UserRole
            )
            transactions = self.financial_controller.get_transactions_for_invoice(
                invoice_id
            )
            for trans in transactions:
                row = self.invoice_details_table.rowCount()
                self.invoice_details_table.insertRow(row)
                self.invoice_details_table.setItem(
                    row,
                    0,
                    QTableWidgetItem(trans.transaction_date.strftime("%Y-%m-%d")),
                )
                self.invoice_details_table.setItem(
                    row,
                    1,
                    QTableWidgetItem(
                        trans.charge_code.code if trans.charge_code else ""
                    ),
                )
                self.invoice_details_table.setItem(
                    row, 2, QTableWidgetItem(trans.description)
                )
                self.invoice_details_table.setItem(
                    row, 3, QTableWidgetItem(str(trans.quantity))
                )
                self.invoice_details_table.setItem(
                    row, 4, QTableWidgetItem(f"${trans.unit_price:.2f}")
                )
                self.invoice_details_table.setItem(
                    row, 5, QTableWidgetItem(f"${trans.total_price:.2f}")
                )

        self.update_buttons_state()

    def _get_selected_invoices(self) -> List[Invoice]:
        """Helper to get the full Invoice objects for all selected rows."""
        selected_invoices = []
        selected_rows = self.invoices_table.selectionModel().selectedRows()
        if not selected_rows:
            return []

        selected_ids = {
            self.invoices_table.item(row.row(), 0).data(Qt.ItemDataRole.UserRole)
            for row in selected_rows
        }

        for inv in self.invoices:
            if inv.invoice_id in selected_ids:
                selected_invoices.append(inv)
        return selected_invoices

    def _launch_record_payment_dialog(self):
        selected_invoices = self._get_selected_invoices()
        if len(selected_invoices) != 1:
            self.status_message.emit(
                "Please select a single invoice to record a payment."
            )
            return

        invoice_to_pay = selected_invoices[0]
        if invoice_to_pay.balance_due <= 0:
            self.status_message.emit("This invoice has been fully paid.")
            return

        current_user_id = (
            self.parent_view.current_user
            if hasattr(self.parent_view, "current_user")
            else "Unknown"
        )
        dialog = RecordPaymentDialog(
            invoice=invoice_to_pay,
            financial_controller=self.financial_controller,
            current_user_id=current_user_id,
            parent=self,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit(
                f"Payment recorded for Invoice #{invoice_to_pay.invoice_id}."
            )
            self.payment_recorded.emit()

    def _email_selected_invoice(self):
        """Generates a PDF of the invoice and opens the user's mail client."""
        selected_invoices = self._get_selected_invoices()
        if not selected_invoices:
            self.status_message.emit("Please select one or more invoices to email.")
            return

        if len(selected_invoices) > 1:
            reply = self.parent_view.show_question(
                "Confirm Batch Email",
                f"This will attempt to open {len(selected_invoices)} separate draft emails. Do you want to continue?",
            )
            if not reply:
                return

        company_profile = self.company_profile_controller.get_company_profile()
        company_name = (
            company_profile.company_name if company_profile else "Your Company"
        )
        invoices_dir = AppConfig.INVOICES_DIR
        generator = InvoiceGenerator()

        for inv in selected_invoices:
            owner = inv.owner
            if not owner or not owner.email:
                self.parent_view.show_warning(
                    "Missing Information",
                    f"Invoice INV-{inv.invoice_id} cannot be emailed because the owner has no email address.",
                )
                continue

            pdf_filename = f"Invoice-{inv.invoice_id} for {owner.last_name}.pdf"
            file_path = os.path.join(invoices_dir, pdf_filename)

            try:
                success, message = generator.generate_invoice_pdf(
                    inv.invoice_id, file_path
                )
                if not success:
                    self.parent_view.show_error(
                        "PDF Error",
                        f"Failed to generate PDF for INV-{inv.invoice_id}:\n{message}",
                    )
                    continue
            except Exception as e:
                self.logger.error(
                    f"An unexpected error occurred during PDF generation for INV-{inv.invoice_id}: {e}",
                    exc_info=True,
                )
                self.parent_view.show_error(
                    "Critical Error",
                    f"An unexpected error occurred during PDF generation for INV-{inv.invoice_id}:\n{e}",
                )
                continue

            subject = f"Invoice from {company_name}"
            body = f"Dear {owner.first_name or owner.last_name},\n\nPlease find your invoice attached.\n\nThank you,\n{company_name}"
            mailto_url = f"mailto:{owner.email}?subject={urllib.parse.quote(subject)}&body={urllib.parse.quote(body)}"
            webbrowser.open(mailto_url)

        # MODIFIED: Use parent_view's show_info method for consistency
        self.parent_view.show_info(
            "Email Process Complete",
            f"Your email client should have opened with drafts for the selected invoices.\n\n"
            f"The invoice PDFs have been saved to the 'invoices' folder.\n\n"
            "Please attach the correct file to each email before sending.",
        )

    def _print_selected_invoice(self):
        selected_invoices = self._get_selected_invoices()
        if not selected_invoices:
            self.status_message.emit("Please select one or more invoices to print.")
            return

        if len(selected_invoices) > 1:
            folder_path = QFileDialog.getExistingDirectory(
                self, "Select Folder to Save Invoices", AppConfig.INVOICES_DIR
            )
            if not folder_path:
                self.logger.info("Batch PDF save was cancelled by the user.")
                return

            generator = InvoiceGenerator()
            for inv in selected_invoices:
                file_path = os.path.join(folder_path, f"Invoice-{inv.invoice_id}.pdf")
                generator.generate_invoice_pdf(inv.invoice_id, file_path)

            QMessageBox.information(
                self,
                "Success",
                f"{len(selected_invoices)} invoices successfully saved to:\n{folder_path}",
            )
        else:
            selected_invoice = selected_invoices[0]
            default_filename = f"Invoice-{selected_invoice.invoice_id}.pdf"
            default_path = os.path.join(AppConfig.INVOICES_DIR, default_filename)
            file_path, _ = QFileDialog.getSaveFileName(
                self.parent_view, "Save Invoice PDF", default_path, "PDF Files (*.pdf)"
            )
            if not file_path:
                return

            try:
                generator = InvoiceGenerator()
                success, message = generator.generate_invoice_pdf(
                    selected_invoice.invoice_id, file_path
                )
                if success:
                    self.parent_view.show_info(
                        "Success", f"Invoice successfully saved to:\n{file_path}"
                    )
                else:
                    self.parent_view.show_error(
                        "Error", f"Failed to generate PDF:\n{message}"
                    )
            except Exception as e:
                self.logger.error(
                    f"An unexpected error occurred during PDF generation: {e}",
                    exc_info=True,
                )
                self.parent_view.show_error(
                    "Critical Error", f"An unexpected error occurred:\n{e}"
                )

    def _delete_selected_invoice(self):
        selected_invoices = self._get_selected_invoices()
        if not selected_invoices:
            self.status_message.emit("Please select one or more invoices to delete.")
            return

        invoice_list_str = "\n - ".join(
            [f"INV-{inv.invoice_id}" for inv in selected_invoices]
        )
        warning_message = (
            f"Are you sure you want to permanently delete the following {len(selected_invoices)} invoice(s)?\n\n- {invoice_list_str}\n\n"
            "This will adjust each owner's balance accordingly.\n\n"
            "<b>IMPORTANT:</b> This action will NOT make the original charges billable again. "
            "This action cannot be undone."
        )

        if self.parent_view.show_question("Confirm Delete Invoice(s)", warning_message):
            current_user_id = (
                self.parent_view.current_user
                if hasattr(self.parent_view, "current_user")
                else "Unknown"
            )
            success_count = 0
            for inv in selected_invoices:
                success, message = self.financial_controller.delete_invoice(
                    inv.invoice_id, current_user_id
                )
                if success:
                    success_count += 1
                else:
                    self.parent_view.show_error(
                        f"Deletion Failed for INV-{inv.invoice_id}", message
                    )

            if success_count > 0:
                self.status_message.emit(
                    f"Successfully deleted {success_count} invoice(s)."
                )
                self.invoice_deleted.emit()

    def update_buttons_state(self):
        selection_count = len(self.invoices_table.selectionModel().selectedRows())

        self.print_invoice_btn.setEnabled(selection_count > 0)
        self.email_invoice_btn.setEnabled(selection_count > 0)
        self.delete_invoice_btn.setEnabled(selection_count > 0)

        has_single_unpaid_selection = False
        if selection_count == 1:
            selected_invoice = self._get_selected_invoices()[0]
            if selected_invoice.balance_due > 0:
                has_single_unpaid_selection = True

        self.record_payment_btn.setEnabled(has_single_unpaid_selection)


=============== FILE: views/horse/tabs/location_tab.py ===============

# views/horse/tabs/location_tab.py
"""
EDSI Veterinary Management System - Horse Location Tab
Version: 1.0.1
Purpose: Manages the assignment of a single location to a horse.
         - Modified assign/remove location logic to call HorseController for
           database persistence BEFORE emitting location_assignment_changed signal,
           ensuring data integrity and proper UI updates in parent views.
Last Updated: May 25, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-05-25):
    - Refactored `_assign_location_to_horse`: Now calls
      `horse_controller.assign_horse_to_location` to save the assignment
      to the database. Emits `location_assignment_changed` only on successful save.
      Updates local UI based on controller success.
    - Refactored `_handle_remove_location_link`: Now calls
      `horse_controller.remove_horse_from_location` to update the database.
      Emits `location_assignment_changed` (with None for location) only on
      successful removal. Updates local UI based on controller success.
    - Ensured user feedback (info/error messages) is provided based on the
      outcome of controller operations.
- v1.0.0 (2025-05-20):
    - Initial implementation.
    - UI with current location display (QLabel).
    - Buttons: "Create New & Link Location", "Link Existing Location", "Remove Location Link".
    - Integrates AddEditLocationDialog and SelectExistingLocationDialog.
    - Emits location_assignment_changed(location_id: Optional[int], location_name: Optional[str]) signal.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFrame,
    QDialog,
    QMessageBox,  # Explicitly imported for clarity, though parent_view might handle
)
from PySide6.QtCore import Qt, Signal

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_SUCCESS_ACTION,
    DARK_PRIMARY_ACTION,
    DARK_DANGER_ACTION,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
)
from models import (
    Horse,
)  # LocationModel not directly used here, controller returns names/ids
from controllers.horse_controller import HorseController
from controllers.location_controller import LocationController
from views.admin.dialogs.add_edit_location_dialog import AddEditLocationDialog
from views.horse.dialogs.select_existing_location_dialog import (
    SelectExistingLocationDialog,
)


class LocationTab(QWidget):
    """Tab widget for managing a horse's single assigned location."""

    location_assignment_changed = Signal(
        object
    )  # Emits a dict: {'id': Optional[int], 'name': Optional[str]}

    def __init__(
        self,
        parent_view,
        horse_controller: HorseController,
        location_controller: LocationController,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_controller = horse_controller
        self.location_controller = location_controller

        self.current_horse: Optional[Horse] = None
        self._current_location_id: Optional[int] = None
        self._current_location_name: str = "N/A"

        self.current_user_login = "UnknownUser"
        if hasattr(self.parent_view, "current_user") and self.parent_view.current_user:
            self.current_user_login = self.parent_view.current_user
        else:
            self.logger.warning(
                "Could not determine current_user for LocationTab auditing."
            )

        self.setStyleSheet(f"background-color: {DARK_WIDGET_BACKGROUND};")
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(15)

        self._setup_ui(main_layout)
        self._setup_connections()
        self.update_buttons_state()

    def _get_generic_button_style(self) -> str:
        if hasattr(self.parent_view, "get_generic_button_style"):
            return self.parent_view.get_generic_button_style()
        return (
            f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_ui(self, main_layout: QVBoxLayout):
        location_display_frame = QFrame()
        location_display_frame.setStyleSheet("background-color: transparent;")
        location_display_layout = QHBoxLayout(location_display_frame)
        location_display_layout.setContentsMargins(0, 0, 0, 10)

        current_location_title_label = QLabel("Currently Assigned Location:")
        current_location_title_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-weight: bold; background: transparent;"
        )
        self.current_location_display_label = QLabel(self._current_location_name)
        self.current_location_display_label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 14px; background-color: {DARK_INPUT_FIELD_BACKGROUND}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; min-height: 22px;"
        )
        self.current_location_display_label.setWordWrap(True)

        location_display_layout.addWidget(current_location_title_label)
        location_display_layout.addWidget(self.current_location_display_label, 1)
        main_layout.addWidget(location_display_frame)

        action_buttons_layout = QHBoxLayout()
        self.create_link_location_btn = QPushButton("➕ Create New & Assign Location")
        self.link_existing_location_btn = QPushButton("🔗 Assign Existing Location")
        self.remove_location_link_btn = QPushButton("➖ Clear Assigned Location")

        button_style = self._get_generic_button_style()
        self.create_link_location_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_SUCCESS_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        self.link_existing_location_btn.setStyleSheet(
            button_style.replace(
                DARK_BUTTON_BG, DARK_PRIMARY_ACTION
            )  # Assuming default text color is fine
        )
        self.remove_location_link_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_DANGER_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )

        action_buttons_layout.addWidget(self.create_link_location_btn)
        action_buttons_layout.addWidget(self.link_existing_location_btn)
        action_buttons_layout.addWidget(self.remove_location_link_btn)
        action_buttons_layout.addStretch()
        main_layout.addLayout(action_buttons_layout)
        main_layout.addStretch(1)

    def _setup_connections(self):
        self.create_link_location_btn.clicked.connect(
            self._handle_create_and_link_location
        )
        self.link_existing_location_btn.clicked.connect(
            self._handle_link_existing_location
        )
        self.remove_location_link_btn.clicked.connect(self._handle_remove_location_link)

    def load_location_for_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.logger.debug(
            f"LocationTab: Loading location for horse: {horse.horse_name if horse else 'None'}"
        )
        if self.current_horse and self.current_horse.horse_id is not None:
            # The horse object passed might already be eager-loaded by HorseUnifiedManagement
            # If not, self.horse_controller.get_horse_by_id() would re-fetch.
            # For consistency, let's use the passed horse object directly if its location is loaded.
            # If horse.location is not loaded, then a fresh fetch might be needed,
            # but this should ideally be handled by the caller providing a fully loaded horse.

            # Let's assume the passed 'horse' object has its .location eager-loaded
            # by HorseUnifiedManagement calling HorseController.get_horse_by_id().
            self._current_location_id = self.current_horse.current_location_id
            if self.current_horse.location and hasattr(
                self.current_horse.location, "location_name"
            ):
                self._current_location_name = (
                    self.current_horse.location.location_name or "N/A"
                )
            else:
                self._current_location_name = (
                    "N/A"  # If location object is None or no name
                )

            self.logger.debug(
                f"LocationTab: Horse ID {self.current_horse.horse_id}, "
                f"current_location_id: {self._current_location_id}, "
                f"current_location_name: '{self._current_location_name}'"
            )
        else:
            self._current_location_id = None
            self._current_location_name = "N/A (No horse selected)"
            self.logger.debug("LocationTab: No current horse, location set to N/A.")

        self.current_location_display_label.setText(self._current_location_name)
        self.update_buttons_state()

    def _handle_create_and_link_location(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Assign Location", "Please select a horse first."
            )
            return
        self.logger.info(
            f"Initiating Create & Assign New Location for horse: {self.current_horse.horse_name}"
        )

        dialog = AddEditLocationDialog(
            self.parent_view,
            self.location_controller,
            self.current_user_login,
            location=None,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # IMPORTANT: AddEditLocationDialog must be modified to return the created location's ID and name
            # For example, by adding methods like dialog.get_created_location_id() and dialog.get_created_location_name()
            created_location_id = getattr(
                dialog, "created_location_id", None
            )  # Hypothetical
            created_location_name = getattr(
                dialog, "created_location_name", None
            )  # Hypothetical

            if created_location_id is not None and created_location_name is not None:
                self.logger.info(
                    f"New location created: ID {created_location_id}, Name '{created_location_name}'. Assigning to horse."
                )
                self._assign_location_to_horse(
                    created_location_id, created_location_name
                )
            else:
                self.logger.warning(
                    "AddEditLocationDialog did not return created location details. User may need to assign manually."
                )
                self.parent_view.show_info(
                    "Location Created",
                    "New location created. If not automatically assigned, please use 'Assign Existing Location' to link it.",
                )
        else:
            self.logger.info("Create & Assign New Location dialog cancelled.")

    def _handle_link_existing_location(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Assign Location", "Please select a horse first."
            )
            return
        self.logger.info(
            f"Initiating Assign Existing Location for horse: {self.current_horse.horse_name}"
        )

        dialog = SelectExistingLocationDialog(
            self.parent_view, self.current_horse.horse_name or "Selected Horse"
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_id = dialog.get_selected_location_id()
            if selected_id is not None:
                # Fetch location details to get the name for UI update and signal
                loc_obj = self.location_controller.get_location_by_id(selected_id)
                if loc_obj and hasattr(loc_obj, "location_name"):
                    self._assign_location_to_horse(
                        loc_obj.location_id, loc_obj.location_name
                    )
                else:
                    self.parent_view.show_error(
                        "Error",
                        f"Could not retrieve details for Location ID {selected_id}.",
                    )
            else:
                self.parent_view.show_warning(
                    "Assign Location", "No location was selected."
                )
        else:
            self.logger.info("Assign Existing Location dialog cancelled.")

    def _assign_location_to_horse(self, location_id: int, location_name: str):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.logger.error("No current horse to assign location to.")
            self.parent_view.show_error(
                "Error", "No horse selected to assign location."
            )
            return

        self.logger.info(
            f"Attempting to assign Location ID {location_id} ('{location_name}') to Horse ID {self.current_horse.horse_id}"
        )

        # Call controller to persist the change
        success, message = self.horse_controller.assign_horse_to_location(
            horse_id=self.current_horse.horse_id,
            location_id=location_id,
            notes=None,  # Or add a notes field to this tab/dialog if needed
            modified_by_user=self.current_user_login,
        )

        if success:
            self._current_location_id = location_id
            self._current_location_name = location_name
            self.current_location_display_label.setText(self._current_location_name)

            self.logger.info(
                f"Successfully assigned Location ID {location_id} to Horse ID {self.current_horse.horse_id}. Emitting signal."
            )
            self.location_assignment_changed.emit(
                {"id": location_id, "name": location_name}
            )
            self.parent_view.show_info(
                "Location Assigned", message
            )  # Use message from controller
        else:
            self.logger.error(f"Failed to assign location: {message}")
            self.parent_view.show_error("Assignment Failed", message)

        self.update_buttons_state()

    def _handle_remove_location_link(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Clear Location", "Please select a horse first."
            )
            return
        if self._current_location_id is None:  # Check local state first
            self.parent_view.show_info(
                "Clear Location", "No location is currently assigned to this horse."
            )
            return

        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        if self.parent_view.show_question(
            "Confirm Clear Location",
            f"Are you sure you want to clear the location assignment for horse '{horse_name_display}'?",
        ):
            self.logger.info(
                f"Attempting to clear location for horse ID {self.current_horse.horse_id}, current loc ID: {self._current_location_id}"
            )

            success, message = self.horse_controller.remove_horse_from_location(
                horse_id=self.current_horse.horse_id,
                location_id=self._current_location_id,  # Pass current location ID to ensure correct history update
                modified_by_user=self.current_user_login,
            )

            if success:
                self._current_location_id = None
                self._current_location_name = "N/A"
                self.current_location_display_label.setText(self._current_location_name)

                self.logger.info(
                    f"Successfully cleared location for Horse ID {self.current_horse.horse_id}. Emitting signal."
                )
                self.location_assignment_changed.emit({"id": None, "name": "N/A"})
                self.parent_view.show_info(
                    "Location Cleared", message
                )  # Use message from controller
            else:
                self.logger.error(f"Failed to clear location: {message}")
                self.parent_view.show_error("Clear Location Failed", message)

            self.update_buttons_state()
        else:
            self.logger.info("Clear location assignment cancelled by user.")

    def update_buttons_state(self):
        is_horse_selected = (
            self.current_horse is not None and self.current_horse.horse_id is not None
        )
        is_location_assigned = self._current_location_id is not None

        self.create_link_location_btn.setEnabled(is_horse_selected)
        self.link_existing_location_btn.setEnabled(is_horse_selected)
        self.remove_location_link_btn.setEnabled(
            is_horse_selected and is_location_assigned
        )


=============== FILE: views/horse/tabs/owners_tab.py ===============

# views/horse/tabs/owners_tab.py
"""
EDSI Veterinary Management System - Horse Owners Tab
Version: 1.3.0
Purpose: Manages the association of owners with a specific horse.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-09):
    - Added double-click functionality to the owners list. Users can now
      double-click a linked owner to open the AddEditOwnerDialog and edit
      their details directly.
    - Implemented the _handle_edit_owner method to manage this workflow.
- v1.2.5 (2025-05-26):
    - Modified `_handle_create_and_link_owner` and `_handle_link_existing_owner`
      to pass a new method `_validate_total_ownership_for_dialog` as a callback
      to `CreateAndLinkOwnerDialog` and `LinkExistingOwnerDialog` respectively.
    - The dialogs will now call this callback to perform total ownership
      validation before closing. If validation fails, the dialog remains open.
- v1.2.4 (2025-05-26):
    - Added `_validate_total_ownership` helper method for client-side validation.
    - Integrated this validation into relevant handler methods.
"""

import logging
from typing import Optional, List, Dict
from decimal import Decimal

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFrame,
    QDoubleSpinBox,
    QMessageBox,
    QDialog,
    QListWidgetItem,
)
from PySide6.QtCore import Qt, Signal

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_BORDER,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_SUCCESS_ACTION,
    DARK_PRIMARY_ACTION,
    DARK_DANGER_ACTION,
    DARK_TEXT_SECONDARY,
    DARK_ITEM_HOVER,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
)
from models import Horse, Owner as OwnerModel
from controllers.horse_controller import HorseController
from controllers.owner_controller import OwnerController

from ..dialogs.create_link_owner_dialog import CreateAndLinkOwnerDialog
from ..dialogs.link_existing_owner_dialog import LinkExistingOwnerDialog
from ...admin.dialogs.add_edit_owner_dialog import AddEditOwnerDialog
from ..widgets.horse_owner_list_widget import HorseOwnerListWidget


class OwnersTab(QWidget):
    owner_association_changed = Signal(str)

    def __init__(
        self,
        parent_view,
        horse_controller: HorseController,
        owner_controller: OwnerController,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_controller = horse_controller
        self.owner_controller = owner_controller
        self.current_horse: Optional[Horse] = None
        self.current_horse_owners_assoc: List[Dict] = []
        self.selected_horse_owner_assoc_id: Optional[int] = None
        self.current_user_login = "UnknownUser"
        if hasattr(self.parent_view, "current_user") and self.parent_view.current_user:
            self.current_user_login = self.parent_view.current_user
        else:
            self.logger.warning(
                "Could not determine current_user for OwnersTab auditing."
            )
        self.setStyleSheet(f"background-color: {DARK_WIDGET_BACKGROUND};")
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)
        self._setup_ui(main_layout)
        self._setup_connections()
        self.update_buttons_state()

    def _get_generic_button_style(self) -> str:
        if hasattr(self.parent_view, "get_generic_button_style"):
            return self.parent_view.get_generic_button_style()
        return f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;}} QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"

    def _get_input_style(self) -> str:
        return f"QDoubleSpinBox {{ background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; padding: 5px; border-radius: 4px; }}"

    def _setup_ui(self, main_layout: QVBoxLayout):
        owners_action_layout = QHBoxLayout()
        self.create_link_owner_btn = QPushButton("➕ Create New & Link Owner")
        self.link_existing_owner_btn = QPushButton("🔗 Link Existing Owner")
        self.remove_horse_owner_btn = QPushButton("➖ Remove Selected Owner Link")
        button_style = self._get_generic_button_style()
        self.create_link_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_SUCCESS_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        self.link_existing_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_PRIMARY_ACTION)
        )
        self.remove_horse_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_DANGER_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        owners_action_layout.addWidget(self.create_link_owner_btn)
        owners_action_layout.addWidget(self.link_existing_owner_btn)
        owners_action_layout.addWidget(self.remove_horse_owner_btn)
        owners_action_layout.addStretch()
        main_layout.addLayout(owners_action_layout)
        self.current_owners_list_widget = HorseOwnerListWidget()
        owners_list_label = QLabel(
            "Current Owners & Percentages (Double-click to Edit):"
        )
        owners_list_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; background: transparent; margin-bottom: 5px; font-weight: bold;"
        )
        main_layout.addWidget(owners_list_label)
        main_layout.addWidget(self.current_owners_list_widget, 1)
        self.percentage_edit_frame = QFrame()
        self.percentage_edit_frame.setStyleSheet("background-color: transparent;")
        percentage_edit_layout = QHBoxLayout(self.percentage_edit_frame)
        percentage_edit_layout.setContentsMargins(0, 5, 0, 0)
        self.selected_owner_for_pct_label = QLabel("Edit % for:")
        self.selected_owner_for_pct_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-right: 5px;"
        )
        self.edit_owner_percentage_spinbox = QDoubleSpinBox()
        self.edit_owner_percentage_spinbox.setRange(0.00, 100.00)
        self.edit_owner_percentage_spinbox.setDecimals(2)
        self.edit_owner_percentage_spinbox.setSuffix(" %")
        self.edit_owner_percentage_spinbox.setStyleSheet(self._get_input_style())
        self.edit_owner_percentage_spinbox.setFixedWidth(100)
        self.save_owner_percentage_btn = QPushButton("💾 Save %")
        self.save_owner_percentage_btn.setStyleSheet(
            self._get_generic_button_style().replace(
                DARK_BUTTON_BG, DARK_SUCCESS_ACTION
            )
        )
        percentage_edit_layout.addWidget(self.selected_owner_for_pct_label)
        percentage_edit_layout.addWidget(self.edit_owner_percentage_spinbox)
        percentage_edit_layout.addWidget(self.save_owner_percentage_btn)
        percentage_edit_layout.addStretch()
        main_layout.addWidget(self.percentage_edit_frame)
        self.percentage_edit_frame.hide()

    def _setup_connections(self):
        self.current_owners_list_widget.itemSelectionChanged.connect(
            self._on_horse_owner_selection_changed
        )
        self.current_owners_list_widget.itemDoubleClicked.connect(
            self._handle_edit_owner
        )
        self.create_link_owner_btn.clicked.connect(self._handle_create_and_link_owner)
        self.link_existing_owner_btn.clicked.connect(self._handle_link_existing_owner)
        self.remove_horse_owner_btn.clicked.connect(
            self._handle_remove_owner_from_horse
        )
        self.save_owner_percentage_btn.clicked.connect(
            self._handle_save_owner_percentage
        )

    def load_owners_for_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.current_owners_list_widget.clear()
        self.selected_horse_owner_assoc_id = None
        self.current_horse_owners_assoc = []
        if self.current_horse and self.current_horse.horse_id is not None:
            self.logger.debug(
                f"Populating owners for horse ID {self.current_horse.horse_id}"
            )
            self.current_horse_owners_assoc = self.horse_controller.get_horse_owners(
                self.current_horse.horse_id
            )
            for owner_assoc_data in self.current_horse_owners_assoc:
                item_text = f"{owner_assoc_data.get('owner_name', 'N/A')} - {owner_assoc_data.get('percentage_ownership', 0.0):.2f}%"
                list_item = QListWidgetItem(item_text)
                list_item.setData(
                    Qt.ItemDataRole.UserRole, owner_assoc_data.get("owner_id")
                )
                self.current_owners_list_widget.addItem(list_item)
        else:
            self.logger.debug("No current horse or horse ID to load owners for.")
        self.percentage_edit_frame.hide()
        self.update_buttons_state()

    def _on_horse_owner_selection_changed(self):
        selected_items = self.current_owners_list_widget.selectedItems()
        if selected_items:
            list_item = selected_items[0]
            self.selected_horse_owner_assoc_id = list_item.data(
                Qt.ItemDataRole.UserRole
            )
            self.logger.info(f"Owner ID {self.selected_horse_owner_assoc_id} selected.")
            assoc_data = next(
                (
                    ho
                    for ho in self.current_horse_owners_assoc
                    if ho["owner_id"] == self.selected_horse_owner_assoc_id
                ),
                None,
            )
            if assoc_data:
                self.edit_owner_percentage_spinbox.setValue(
                    assoc_data.get("percentage_ownership", 0.0)
                )
                self.selected_owner_for_pct_label.setText(
                    f"Edit % for: {assoc_data.get('owner_name','N/A')}"
                )
                self.percentage_edit_frame.show()
            else:
                self.logger.warning(
                    f"No data for selected owner ID {self.selected_horse_owner_assoc_id}"
                )
                self.percentage_edit_frame.hide()
        else:
            self.selected_horse_owner_assoc_id = None
            self.percentage_edit_frame.hide()
            self.logger.info("Owner selection cleared.")
        self.update_buttons_state()

    def _handle_edit_owner(self, item: QListWidgetItem):
        """Opens the AddEditOwnerDialog for the double-clicked owner."""
        owner_id = item.data(Qt.ItemDataRole.UserRole)
        if owner_id is None:
            return

        self.logger.info(f"Edit requested for owner ID: {owner_id}")
        owner_to_edit = self.owner_controller.get_owner_by_id(owner_id)

        if owner_to_edit:
            dialog = AddEditOwnerDialog(
                parent_view=self.parent_view,
                owner_controller=self.owner_controller,
                owner_object=owner_to_edit,
                current_user_id=self.current_user_login,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.logger.info(f"Owner ID {owner_id} was updated. Refreshing list.")
                # After saving, reload the owners for the current horse
                self.load_owners_for_horse(self.current_horse)
                # Notify the main screen that data has changed
                self.owner_association_changed.emit(
                    f"Details updated for owner '{owner_to_edit.last_name}'."
                )
        else:
            self.parent_view.show_error(
                "Error", f"Could not retrieve details for owner ID {owner_id}."
            )

    def _validate_total_ownership_for_dialog(
        self,
        owner_id_being_changed: Optional[int],
        new_percentage_for_this_owner: float,
    ) -> bool:
        """Called by dialogs to validate total ownership before they accept."""
        if not self.current_horse:
            return False
        current_total_other_owners = Decimal("0.00")
        for assoc in self.current_horse_owners_assoc:
            if (
                owner_id_being_changed is not None
                and assoc.get("owner_id") == owner_id_being_changed
            ):
                continue
            current_total_other_owners += Decimal(
                str(assoc.get("percentage_ownership", 0.0))
            )

        prospective_total = current_total_other_owners + Decimal(
            str(new_percentage_for_this_owner)
        )
        self.logger.debug(
            f"Dialog validation: Others total={current_total_other_owners}, New%={new_percentage_for_this_owner}, Prospective={prospective_total}"
        )
        if prospective_total > Decimal("100.00"):
            msg = (
                f"Total ownership cannot exceed 100%.\n"
                f"Other owners: {current_total_other_owners:.2f}%\n"
                f"This owner: {new_percentage_for_this_owner:.2f}%\n"
                f"Resulting total: {prospective_total:.2f}%"
            )
            QMessageBox.warning(
                self.parent_view, "Ownership Error", msg
            )  # Show error via parent_view
            return False
        return True

    def _handle_create_and_link_owner(self):
        if not self.current_horse:
            self.parent_view.show_warning("Add Owner", "Select horse first.")
            return
        self.logger.info(
            f"Initiating Create & Link Owner for: {self.current_horse.horse_name}"
        )

        # Pass the validation method to the dialog
        dialog = CreateAndLinkOwnerDialog(
            self,
            self.current_horse.horse_name or "Selected Horse",
            self.current_user_login,
            total_ownership_validator=self._validate_total_ownership_for_dialog,  # Pass callback
        )
        if (
            dialog.exec() == QDialog.DialogCode.Accepted
        ):  # Dialog only accepts if ALL validation (incl. total %) passed
            data = dialog.get_data()
            if (
                data
                and data.get("owner_details")
                and data.get("percentage") is not None
            ):
                owner_details, percentage = data["owner_details"], data["percentage"]
                self.logger.info(
                    f"Dialog OK. Owner: {owner_details}, Percentage: {percentage}"
                )
                # Total ownership validation already done by the dialog via callback
                success_create, msg_create, new_owner_obj = (
                    self.owner_controller.create_master_owner(
                        owner_details, self.current_user_login
                    )
                )
                if (
                    success_create
                    and new_owner_obj
                    and self.current_horse
                    and self.current_horse.horse_id is not None
                ):
                    success_link, msg_link = self.horse_controller.add_owner_to_horse(
                        self.current_horse.horse_id,
                        new_owner_obj.owner_id,
                        percentage,
                        self.current_user_login,
                    )
                    if success_link:
                        self.parent_view.show_info("Owner Linked", msg_link)
                        self.load_owners_for_horse(self.current_horse)
                        self.owner_association_changed.emit(msg_link)
                    else:
                        self.parent_view.show_error("Link Error", msg_link)
                else:
                    self.parent_view.show_error(
                        "Create Error", msg_create or "Could not create owner."
                    )
            else:
                self.logger.warning("Create dialog accepted, but no valid data.")
                self.parent_view.show_warning("Data Error", "No data from form.")
        else:
            self.logger.info("Create & link owner dialog cancelled.")

    def _handle_link_existing_owner(self):
        if not self.current_horse:
            self.parent_view.show_warning("Link Owner", "Select horse first.")
            return
        self.logger.info(
            f"Initiating Link Existing Owner for: {self.current_horse.horse_name}"
        )

        # LinkExistingOwnerDialog needs similar modification to accept validator
        # For now, we'll keep its internal validation and add OwnersTab validation after it closes.
        # This means if total % validation fails, user has to re-open LinkExistingOwnerDialog.
        # Ideal solution: Modify LinkExistingOwnerDialog to also take the callback.

        dialog = LinkExistingOwnerDialog(
            self, self.current_horse.horse_name or "Selected Horse"
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_data()
            if (
                data
                and data.get("owner_id") is not None
                and data.get("percentage") is not None
                and self.current_horse
                and self.current_horse.horse_id is not None
            ):
                owner_id, percentage = data["owner_id"], data["percentage"]
                self.logger.info(
                    f"Linking owner ID {owner_id} with {percentage}% to horse ID {self.current_horse.horse_id}"
                )

                # Perform total ownership validation AFTER dialog closes for this dialog type (can be improved)
                if not self._validate_total_ownership_for_dialog(None, percentage):
                    # User has to click "Link Existing Owner" again if this fails.
                    return

                success_link, msg_link = self.horse_controller.add_owner_to_horse(
                    self.current_horse.horse_id,
                    owner_id,
                    percentage,
                    self.current_user_login,
                )
                if success_link:
                    self.parent_view.show_info("Owner Linked", msg_link)
                    self.load_owners_for_horse(self.current_horse)
                    self.owner_association_changed.emit(msg_link)
                else:
                    self.parent_view.show_error("Link Error", msg_link)
            else:
                self.logger.warning("No data from link dialog.")
                self.parent_view.show_warning("Data Error", "No selection from form.")
        else:
            self.logger.info("Link existing owner dialog cancelled.")

    def _handle_save_owner_percentage(self):
        if (
            not self.current_horse
            or self.current_horse.horse_id is None
            or self.selected_horse_owner_assoc_id is None
        ):
            self.parent_view.show_warning(
                "Save %", "Select horse and owner to update %."
            )
            return
        new_percentage = self.edit_owner_percentage_spinbox.value()

        # VALIDATION using the dialog-focused validator
        if not self._validate_total_ownership_for_dialog(
            self.selected_horse_owner_assoc_id, new_percentage
        ):
            return  # Error message already shown by validator

        self.logger.info(
            f"Updating % for owner ID {self.selected_horse_owner_assoc_id} on horse ID {self.current_horse.horse_id} to {new_percentage}%"
        )
        success, message = self.horse_controller.update_horse_owner_percentage(
            self.current_horse.horse_id,
            self.selected_horse_owner_assoc_id,
            new_percentage,
            self.current_user_login,
        )
        if success:
            self.parent_view.show_info("Percentage Updated", message)
            self.load_owners_for_horse(self.current_horse)
            self.owner_association_changed.emit(message)
        else:
            self.parent_view.show_error("Update % Error", message)

    def _handle_remove_owner_from_horse(self):
        if (
            not self.current_horse
            or self.current_horse.horse_id is None
            or self.selected_horse_owner_assoc_id is None
        ):
            warn_msg = "Select horse and owner from list."
            if hasattr(self.parent_view, "show_warning"):
                self.parent_view.show_warning("Remove Owner", warn_msg)
            else:
                QMessageBox.warning(self, "Remove Owner", warn_msg)
                return
        owner_id_to_remove = self.selected_horse_owner_assoc_id
        owner_display_name = f"Owner ID {owner_id_to_remove}"
        for oa in self.current_horse_owners_assoc:
            if oa.get("owner_id") == owner_id_to_remove:
                owner_display_name = oa.get("owner_name", owner_display_name)
                break
        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        confirm_msg = (
            f"Remove owner '{owner_display_name}' from horse '{horse_name_display}'?"
        )
        proceed = False
        if hasattr(self.parent_view, "show_question"):
            proceed = self.parent_view.show_question("Confirm Removal", confirm_msg)
        else:
            proceed = (
                QMessageBox.question(
                    self,
                    "Confirm Removal",
                    confirm_msg,
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No,
                )
                == QMessageBox.StandardButton.Yes
            )
        if proceed:
            self.logger.info(
                f"Confirmed removal of owner ID {owner_id_to_remove} from horse ID {self.current_horse.horse_id}"
            )
            success, message = self.horse_controller.remove_owner_from_horse(
                self.current_horse.horse_id, owner_id_to_remove, self.current_user_login
            )
            if success:
                if hasattr(self.parent_view, "show_info"):
                    self.parent_view.show_info("Owner Removed", message)
                else:
                    QMessageBox.information(self, "Owner Removed", message)
                self.load_owners_for_horse(self.current_horse)
                self.owner_association_changed.emit(message)
            else:
                if hasattr(self.parent_view, "show_error"):
                    self.parent_view.show_error("Remove Error", message)
                else:
                    QMessageBox.critical(self, "Remove Error", message)
        else:
            self.logger.info("Owner removal cancelled.")

    def update_buttons_state(self):
        is_horse_selected = (
            self.current_horse is not None and self.current_horse.horse_id is not None
        )
        is_owner_in_list_selected = self.selected_horse_owner_assoc_id is not None
        self.create_link_owner_btn.setEnabled(is_horse_selected)
        self.link_existing_owner_btn.setEnabled(is_horse_selected)
        self.remove_horse_owner_btn.setEnabled(
            is_horse_selected and is_owner_in_list_selected
        )
        self.save_owner_percentage_btn.setEnabled(
            is_horse_selected and is_owner_in_list_selected
        )
        self.percentage_edit_frame.setVisible(
            is_horse_selected and is_owner_in_list_selected
        )


=============== FILE: views/horse/tabs/reports_tab.py ===============

"""
EDSI Veterinary Management System - Reports Tab
Version: 1.8.0
Purpose: A UI tab to serve as a hub for selecting and running reports.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v1.8.0 (2025-06-12):
    - Fully integrated the advanced "Charge Code Usage" report.
    - Added ChargeCodeUsageOptionsWidget and ChargeCodeUsageGenerator.
    - Implemented _run_charge_code_usage_report method to connect the UI to
      the upgraded controller method and the new advanced PDF generator.
- v1.7.0 (2025-06-12):
    - Added and integrated the HorseTransactionHistoryOptionsWidget.
- v1.6.0 (2025-06-11):
    - Implemented the `_run_payment_history_report` method.
"""

import logging
import os
import webbrowser
import urllib.parse
from typing import Optional, Dict
from datetime import date

from PySide6.QtWidgets import (
    QWidget,
    QHBoxLayout,
    QVBoxLayout,
    QListWidget,
    QStackedWidget,
    QLabel,
    QPushButton,
    QFrame,
    QListWidgetItem,
    QFileDialog,
    QMessageBox,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QFont

from config.app_config import AppConfig
from controllers import ReportsController, HorseController
from reports import (
    OwnerStatementGenerator,
    ARAgingGenerator,
    InvoiceRegisterGenerator,
    PaymentHistoryGenerator,
    HorseTransactionHistoryGenerator,
    ChargeCodeUsageGenerator,
)
from views.reports.options import (
    OwnerStatementOptionsWidget,
    ARAgingOptionsWidget,
    InvoiceRegisterOptionsWidget,
    PaymentHistoryOptionsWidget,
    HorseTransactionHistoryOptionsWidget,
    ChargeCodeUsageOptionsWidget,
)
from models import Owner


class ReportsTab(QWidget):
    """A tab for selecting and running all system reports."""

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.reports_controller = ReportsController()
        self.horse_controller = HorseController()
        self.setup_ui()
        self.setup_connections()

    def setup_ui(self):
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(20)

        left_panel = QFrame()
        left_panel.setFixedWidth(300)
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.setSpacing(10)

        report_list_label = QLabel("Available Reports")
        report_list_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        )
        report_list_label.setStyleSheet(f"color: {AppConfig.DARK_TEXT_SECONDARY};")

        self.report_list_widget = QListWidget()
        self.report_list_widget.setStyleSheet(
            f"""
            QListWidget {{ border: 1px solid {AppConfig.DARK_BORDER}; background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND}; }}
            QListWidget::item {{ padding: 12px; }}
            QListWidget::item:selected {{ background-color: {AppConfig.DARK_PRIMARY_ACTION}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: none; }}
            """
        )
        self.populate_report_list()
        left_layout.addWidget(report_list_label)
        left_layout.addWidget(self.report_list_widget, 1)

        right_panel = QFrame()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(15)

        self.options_stack = QStackedWidget()
        right_layout.addWidget(self.options_stack, 1)

        self.placeholder_widget = QLabel(
            "Select a report from the list to configure its options."
        )
        self.placeholder_widget.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.placeholder_widget.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY};"
        )

        self.owner_statement_options = OwnerStatementOptionsWidget()
        self.ar_aging_options = ARAgingOptionsWidget()
        self.invoice_register_options = InvoiceRegisterOptionsWidget()
        self.payment_history_options = PaymentHistoryOptionsWidget()
        self.charge_code_usage_options = ChargeCodeUsageOptionsWidget()
        self.horse_transaction_history_options = HorseTransactionHistoryOptionsWidget(
            self.horse_controller
        )

        self.options_stack.addWidget(self.placeholder_widget)
        self.options_stack.addWidget(self.owner_statement_options)
        self.options_stack.addWidget(self.ar_aging_options)
        self.options_stack.addWidget(self.invoice_register_options)
        self.options_stack.addWidget(self.payment_history_options)
        self.options_stack.addWidget(self.charge_code_usage_options)
        self.options_stack.addWidget(self.horse_transaction_history_options)

        action_layout = QHBoxLayout()
        action_layout.addStretch()
        self.email_report_button = QPushButton("Generate & Email")
        self.email_report_button.setEnabled(False)
        self.email_report_button.setMinimumHeight(36)
        self.run_report_button = QPushButton("Generate Report")
        self.run_report_button.setEnabled(False)
        self.run_report_button.setMinimumHeight(36)
        action_layout.addWidget(self.email_report_button)
        action_layout.addWidget(self.run_report_button)
        right_layout.addLayout(action_layout)

        main_layout.addWidget(left_panel)
        main_layout.addWidget(right_panel, 1)
        self._apply_button_styles()

    def _apply_button_styles(self):
        self.run_report_button.setStyleSheet(
            f"""
            QPushButton {{ background-color: {AppConfig.DARK_SUCCESS_ACTION}; color: white; border: none; border-radius: 4px; padding: 8px 24px; font-weight: bold; }}
            QPushButton:disabled {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; color: {AppConfig.DARK_TEXT_TERTIARY}; }}
            """
        )
        self.email_report_button.setStyleSheet(
            f"""
            QPushButton {{ background-color: {AppConfig.DARK_BUTTON_BG}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_PRIMARY_ACTION}; border-radius: 4px; padding: 8px 24px; font-weight: bold; }}
            QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}
            QPushButton:disabled {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; color: {AppConfig.DARK_TEXT_TERTIARY}; border: 1px solid {AppConfig.DARK_HEADER_FOOTER};}}
            """
        )

    def setup_connections(self):
        self.report_list_widget.currentItemChanged.connect(
            self._on_report_selection_changed
        )
        self.run_report_button.clicked.connect(self._on_run_report_clicked)
        self.email_report_button.clicked.connect(self._on_email_report_clicked)

    def populate_report_list(self):
        reports = [
            "Owner Statement",
            "A/R Aging",
            "Invoice Register",
            "Payment History",
            "Charge Code Usage",
            "Horse Transaction History",
        ]
        for report_name in reports:
            self.report_list_widget.addItem(QListWidgetItem(report_name))

    def _on_report_selection_changed(
        self, current: QListWidgetItem, previous: QListWidgetItem
    ):
        self.run_report_button.setEnabled(bool(current))
        self.email_report_button.setEnabled(False)
        if not current:
            self.options_stack.setCurrentWidget(self.placeholder_widget)
            return

        report_name = current.text()
        if report_name == "Owner Statement":
            self.options_stack.setCurrentWidget(self.owner_statement_options)
            self.email_report_button.setEnabled(True)
        elif report_name == "A/R Aging":
            self.options_stack.setCurrentWidget(self.ar_aging_options)
        elif report_name == "Invoice Register":
            self.options_stack.setCurrentWidget(self.invoice_register_options)
        elif report_name == "Payment History":
            self.options_stack.setCurrentWidget(self.payment_history_options)
        elif report_name == "Charge Code Usage":
            self.options_stack.setCurrentWidget(self.charge_code_usage_options)
        elif report_name == "Horse Transaction History":
            self.options_stack.setCurrentWidget(self.horse_transaction_history_options)
        else:
            self.options_stack.setCurrentWidget(self.placeholder_widget)
            self.run_report_button.setEnabled(False)

    def _on_run_report_clicked(self):
        current_item = self.report_list_widget.currentItem()
        if not current_item:
            return

        report_name = current_item.text()
        if report_name == "Owner Statement":
            self._run_owner_statement_report(False)
        elif report_name == "A/R Aging":
            self._run_ar_aging_report()
        elif report_name == "Invoice Register":
            self._run_invoice_register_report()
        elif report_name == "Payment History":
            self._run_payment_history_report()
        elif report_name == "Charge Code Usage":
            self._run_charge_code_usage_report()
        elif report_name == "Horse Transaction History":
            self._run_horse_transaction_history_report()
        else:
            QMessageBox.information(
                self,
                "Not Implemented",
                f"The '{report_name}' report has not been implemented yet.",
            )

    def _run_charge_code_usage_report(self):
        """Orchestrates the generation of the Charge Code Usage report."""
        options = self.charge_code_usage_options.get_options()
        self.logger.info(f"Generating Charge Code Usage report with options: {options}")

        report_data = self.reports_controller.get_charge_code_usage_data(options)

        if report_data.get("error"):
            QMessageBox.critical(
                self,
                "Data Error",
                f"Could not retrieve data: {report_data.get('error')}",
            )
            return

        if not report_data.get("details"):
            QMessageBox.information(
                self, "No Data", "No charge code usage found for the selected criteria."
            )
            return

        default_filename = f"Charge_Code_Usage_{date.today()}.pdf"
        default_path = os.path.join(AppConfig.PROJECT_ROOT, default_filename)
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Charge Code Usage Report", default_path, "PDF Files (*.pdf)"
        )

        if not file_path:
            return

        try:
            generator = ChargeCodeUsageGenerator()
            success, message = generator.generate_pdf(report_data, file_path)
            if success:
                QMessageBox.information(
                    self, "Success", f"Report saved successfully to:\n{file_path}"
                )
            else:
                QMessageBox.critical(self, "PDF Generation Failed", message)
        except Exception as e:
            self.logger.error(
                f"Failed to run Charge Code Usage generator: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")

    def _on_email_report_clicked(self):
        # ... existing implementation ...
        current_item = self.report_list_widget.currentItem()
        if not current_item:
            return
        if current_item.text() == "Owner Statement":
            self._run_owner_statement_report(True)
        else:
            QMessageBox.information(
                self,
                "Not Implemented",
                "Emailing is not available for this report type.",
            )

    def _run_horse_transaction_history_report(self):
        # ... existing implementation ...
        options = self.horse_transaction_history_options.get_options()
        if not options.get("horse_id"):
            QMessageBox.warning(self, "Selection Required", "Please select a horse.")
            return
        self.logger.info(
            f"Generating Horse Transaction History for horse_id: {options['horse_id']} from {options['start_date']} to {options['end_date']}"
        )
        report_data = self.reports_controller.get_horse_transaction_history_data(
            **options
        )
        if report_data.get("error") or not report_data.get("horse"):
            QMessageBox.information(
                self,
                "No Data",
                f"Could not retrieve data: {report_data.get('error', 'Unknown error')}",
            )
            return
        if not report_data.get("transactions"):
            QMessageBox.information(
                self,
                "No Data",
                "No transactions found for the selected horse and date range.",
            )
            return
        horse_name = report_data["horse"].horse_name.replace(" ", "_")
        default_filename = f"Transaction_History_{horse_name}_{date.today()}.pdf"
        default_path = os.path.join(AppConfig.PROJECT_ROOT, default_filename)
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Horse Transaction History", default_path, "PDF Files (*.pdf)"
        )
        if not file_path:
            return
        try:
            generator = HorseTransactionHistoryGenerator()
            success, message = generator.generate_pdf(report_data, file_path)
            if success:
                QMessageBox.information(
                    self, "Success", f"Report saved successfully to:\n{file_path}"
                )
            else:
                QMessageBox.critical(self, "PDF Generation Failed", message)
        except Exception as e:
            self.logger.error(
                f"Failed to run Horse Transaction History generator: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")

    def _run_payment_history_report(self):
        # ... existing implementation ...
        options = self.payment_history_options.get_options()
        self.logger.info(
            f"Generating Payment History from {options['start_date']} to {options['end_date']} for owner: {options['owner_id']}"
        )
        report_data = self.reports_controller.get_payment_history_data(**options)
        if not report_data or not report_data.get("payments"):
            QMessageBox.information(
                self, "No Data", "No payments found for the selected criteria."
            )
            return
        default_filename = f"Payment_History_{date.today()}.pdf"
        default_path = os.path.join(AppConfig.PROJECT_ROOT, default_filename)
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Payment History Report", default_path, "PDF Files (*.pdf)"
        )
        if not file_path:
            return
        try:
            generator = PaymentHistoryGenerator()
            success, message = generator.generate_pdf(report_data, file_path)
            if success:
                QMessageBox.information(
                    self, "Success", f"Report saved successfully to:\n{file_path}"
                )
            else:
                QMessageBox.critical(self, "PDF Generation Failed", message)
        except Exception as e:
            self.logger.error(
                f"Failed to run Payment History generator: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")

    def _run_invoice_register_report(self):
        # ... existing implementation ...
        options = self.invoice_register_options.get_options()
        self.logger.info(
            f"Generating Invoice Register from {options['start_date']} to {options['end_date']}"
        )
        report_data = self.reports_controller.get_invoice_register_data(
            options["start_date"], options["end_date"]
        )
        if not report_data or not report_data.get("invoices"):
            QMessageBox.information(
                self, "No Data", "No invoices found in the selected date range."
            )
            return
        default_filename = f"Invoice_Register_{date.today()}.pdf"
        default_path = os.path.join(AppConfig.PROJECT_ROOT, default_filename)
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Invoice Register", default_path, "PDF Files (*.pdf)"
        )
        if not file_path:
            return
        try:
            generator = InvoiceRegisterGenerator()
            success, message = generator.generate_pdf(report_data, file_path)
            if success:
                QMessageBox.information(
                    self, "Success", f"Report saved successfully to:\n{file_path}"
                )
            else:
                QMessageBox.critical(self, "PDF Generation Failed", message)
        except Exception as e:
            self.logger.error(
                f"Failed to run Invoice Register generator: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")

    def _run_ar_aging_report(self):
        # ... existing implementation ...
        options = self.ar_aging_options.get_options()
        as_of_date = options["as_of_date"]
        self.logger.info(f"Generating A/R Aging report for date: {as_of_date}")
        report_data = self.reports_controller.get_ar_aging_data(as_of_date)
        if not report_data or not report_data.get("lines"):
            QMessageBox.information(
                self, "No Data", "No outstanding balances found for the selected date."
            )
            return
        default_filename = f"AR_Aging_Report_{date.today()}.pdf"
        default_path = os.path.join(AppConfig.PROJECT_ROOT, default_filename)
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save A/R Aging Report", default_path, "PDF Files (*.pdf)"
        )
        if not file_path:
            return
        try:
            generator = ARAgingGenerator()
            success, message = generator.generate_pdf(report_data, file_path)
            if success:
                QMessageBox.information(
                    self, "Success", f"Report saved successfully to:\n{file_path}"
                )
            else:
                QMessageBox.critical(self, "PDF Generation Failed", message)
        except Exception as e:
            self.logger.error(f"Failed to run A/R Aging generator: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")

    def _run_owner_statement_report(self, email_after: bool):
        # ... existing implementation ...
        options = self.owner_statement_options.get_options()
        owner_id = options.get("owner_id")
        if email_after and owner_id == "all":
            QMessageBox.warning(
                self,
                "Batch Email Not Supported",
                "Emailing is only available when a single owner is selected.",
            )
            return
        if owner_id == "all":
            self._generate_batch_statements(options["start_date"], options["end_date"])
        elif owner_id is not None:
            self._generate_single_statement(owner_id, options, email_after)
        else:
            QMessageBox.warning(self, "Selection Required", "Please select an owner.")

    def _generate_batch_statements(self, start_date: date, end_date: date):
        # ... existing implementation ...
        self.logger.info(
            f"Generating batch owner statements from {start_date} to {end_date}"
        )
        all_data = self.reports_controller.get_data_for_all_owner_statements(
            start_date, end_date
        )
        if not all_data:
            QMessageBox.information(
                self,
                "No Statements",
                "No owners found with a balance or activity in the selected period.",
            )
            return
        save_dir = QFileDialog.getExistingDirectory(
            self, "Select Directory to Save Statements", AppConfig.PROJECT_ROOT
        )
        if not save_dir:
            return
        generator = OwnerStatementGenerator()
        success_count, fail_count = 0, 0
        for data in all_data:
            owner_name = data["owner"].last_name or f"Owner{data['owner'].owner_id}"
            file_path = os.path.join(
                save_dir, f"Statement for {owner_name} {date.today()}.pdf"
            )
            success, _ = generator.generate_statement_pdf(data, file_path)
            if success:
                success_count += 1
            else:
                fail_count += 1
        summary_message = f"Successfully generated {success_count} statements."
        if fail_count > 0:
            summary_message += (
                f"\nFailed to generate {fail_count} statements. Please check the logs."
            )
        QMessageBox.information(self, "Batch Generation Complete", summary_message)

    def _generate_single_statement(
        self, owner_id: int, options: Dict, email_after: bool
    ):
        # ... existing implementation ...
        self.logger.info(f"Generating owner statement for owner_id: {owner_id}")
        report_data = self.reports_controller.get_owner_statement_data(
            owner_id=owner_id,
            start_date=options["start_date"],
            end_date=options["end_date"],
        )
        if not report_data:
            QMessageBox.critical(self, "Error", "Could not fetch data for the report.")
            return
        owner_name = report_data["owner"].last_name or f"Owner{owner_id}"
        default_filename = f"Statement for {owner_name} {date.today()}.pdf"
        save_dir = AppConfig.INVOICES_DIR if email_after else AppConfig.PROJECT_ROOT
        default_path = os.path.join(save_dir, default_filename)
        file_path = (
            default_path
            if email_after
            else QFileDialog.getSaveFileName(
                self, "Save Owner Statement", default_path, "PDF Files (*.pdf)"
            )[0]
        )
        if not file_path:
            return
        try:
            generator = OwnerStatementGenerator()
            success, message = generator.generate_statement_pdf(report_data, file_path)
            if success:
                if email_after:
                    self._dispatch_email(report_data["owner"], file_path)
                else:
                    QMessageBox.information(
                        self, "Success", f"Report saved successfully to:\n{file_path}"
                    )
            else:
                QMessageBox.critical(self, "PDF Generation Failed", message)
        except Exception as e:
            self.logger.error(
                f"Failed to instantiate or run PDF generator: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")

    def _dispatch_email(self, owner: Owner, attachment_path: str):
        # ... existing implementation ...
        if not owner.email:
            QMessageBox.warning(
                self,
                "Cannot Email",
                f"Owner '{owner.last_name}' does not have an email address on file.",
            )
            return
        company_name = (
            self.reports_controller.company_profile.company_name
            if self.reports_controller.company_profile
            else "Your Clinic"
        )
        subject = f"Your Statement from {company_name}"
        body = f"Dear {owner.first_name or owner.last_name},\n\nPlease find your statement attached.\n\nThank you,\n{company_name}"
        mailto_url = f"mailto:{owner.email}?subject={urllib.parse.quote(subject)}&body={urllib.parse.quote(body)}"
        try:
            webbrowser.open(mailto_url)
            QMessageBox.information(
                self,
                "Email Draft Created",
                f"Your email client should now be open.\n\nPlease manually attach the following file before sending:\n{attachment_path}",
            )
        except Exception as e:
            self.logger.error(f"Could not open mail client: {e}", exc_info=True)
            QMessageBox.critical(
                self,
                "Email Error",
                "Could not open your default email client. The PDF has been saved for you to attach manually.",
            )


=============== FILE: views/horse/widgets/__init__.py ===============

# views/widgets/__init__.py
"""
EDMS reusable custom widgets package.
"""


=============== FILE: views/horse/widgets/charge_line_item_widget.py ===============

# views/horse/widgets/charge_line_item_widget.py
"""
EDSI Veterinary Management System - Charge Line Item Widget
Version: 1.1.0
Purpose: A self-contained widget for a single charge line item, including notes.
         - Added styling for input fields.
Last Updated: June 6, 2025
Author: Gemini
"""
import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDoubleSpinBox,
    QCheckBox,
    QTextEdit,
    QCompleter,
    QToolButton,
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QFont, QIcon

from models import ChargeCode
from config.app_config import AppConfig


class ChargeLineItemWidget(QWidget):
    """A widget representing a single, editable charge line."""

    remove_requested = Signal(QWidget)
    amount_changed = Signal()

    def __init__(self, charge_codes: List[ChargeCode], parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self._charge_codes = charge_codes if charge_codes else []
        self._charge_code_lookup = {cc.code: cc for cc in self._charge_codes}
        self._alt_code_lookup = {
            cc.alternate_code: cc for cc in self._charge_codes if cc.alternate_code
        }

        self.charge_data: Optional[ChargeCode] = None

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 10)
        main_layout.setSpacing(5)
        self.setStyleSheet(
            f"background-color: {AppConfig.DARK_WIDGET_BACKGROUND}; border-radius: 5px; padding: 5px;"
        )

        top_layout = QHBoxLayout()
        top_layout.setSpacing(5)

        self.charge_code_input = QLineEdit()
        self.alt_code_input = QLineEdit()
        self.description_label = QLineEdit()
        self.qty_spinbox = QDoubleSpinBox()
        self.price_spinbox = QDoubleSpinBox()
        self.taxable_checkbox = QCheckBox()
        self.total_label = QLabel("$0.00")
        self.remove_button = QToolButton()

        top_layout.addWidget(self.charge_code_input, 2)
        top_layout.addWidget(self.alt_code_input, 2)
        top_layout.addWidget(self.description_label, 6)
        top_layout.addWidget(self.qty_spinbox, 1)
        top_layout.addWidget(self.price_spinbox, 2)
        top_layout.addWidget(self.taxable_checkbox)
        top_layout.addWidget(self.total_label, 2)
        top_layout.addWidget(self.remove_button)

        self.notes_edit = QTextEdit()

        main_layout.addLayout(top_layout)
        main_layout.addWidget(self.notes_edit)

    def _apply_styles(self):
        # Apply the "boxed" style to all input fields
        input_style = f"""
            QLineEdit, QDoubleSpinBox, QTextEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
            }}
        """
        self.setStyleSheet(self.styleSheet() + input_style)

        self.charge_code_input.setPlaceholderText("Code")
        self.alt_code_input.setPlaceholderText("Alt Code")
        self.description_label.setPlaceholderText("Description")
        self.description_label.setReadOnly(True)

        self.qty_spinbox.setRange(0.001, 9999.0)
        self.qty_spinbox.setDecimals(3)
        self.qty_spinbox.setValue(1.0)

        self.price_spinbox.setRange(0.00, 99999.99)
        self.price_spinbox.setDecimals(2)
        self.price_spinbox.setPrefix("$ ")

        self.total_label.setAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        self.total_label.setMinimumWidth(80)

        self.notes_edit.setPlaceholderText("Enter notes for this line item...")
        self.notes_edit.setFixedHeight(40)

        self.remove_button.setIcon(QIcon(":/icons/delete"))  # Placeholder
        self.remove_button.setToolTip("Remove this charge")

    def _setup_connections(self):
        self.charge_code_input.editingFinished.connect(self._on_code_entered)
        self.alt_code_input.editingFinished.connect(self._on_alt_code_entered)
        self.qty_spinbox.valueChanged.connect(self._update_total)
        self.price_spinbox.valueChanged.connect(self._update_total)
        self.taxable_checkbox.stateChanged.connect(self.amount_changed.emit)
        self.remove_button.clicked.connect(lambda: self.remove_requested.emit(self))

    @Slot()
    def _on_code_entered(self):
        code_text = self.charge_code_input.text().upper()
        self.charge_data = self._charge_code_lookup.get(code_text)
        self._populate_from_charge_code()

    @Slot()
    def _on_alt_code_entered(self):
        alt_code_text = self.alt_code_input.text().upper()
        self.charge_data = self._alt_code_lookup.get(alt_code_text)
        self._populate_from_charge_code()

    def _populate_from_charge_code(self):
        if self.charge_data:
            self.charge_code_input.setText(self.charge_data.code)
            self.alt_code_input.setText(self.charge_data.alternate_code or "")
            self.description_label.setText(self.charge_data.description)
            self.price_spinbox.setValue(float(self.charge_data.standard_charge))
            self.taxable_checkbox.setChecked(self.charge_data.taxable)
        self._update_total()

    @Slot()
    def _update_total(self):
        try:
            qty = Decimal(self.qty_spinbox.value())
            price = Decimal(self.price_spinbox.value())
            total = qty * price
            self.total_label.setText(f"${total:.2f}")
        except (InvalidOperation, TypeError):
            self.total_label.setText("$0.00")
        self.amount_changed.emit()

    def get_data(self) -> Optional[Dict[str, Any]]:
        if not self.charge_data:
            return None

        return {
            "charge_code_id": self.charge_data.id,
            "description": self.description_label.text(),
            "quantity": Decimal(str(self.qty_spinbox.value())),
            "unit_price": Decimal(str(self.price_spinbox.value())),
            "total_price": (
                Decimal(str(self.qty_spinbox.value()))
                * Decimal(str(self.price_spinbox.value()))
            ),
            "taxable": self.taxable_checkbox.isChecked(),
            "item_notes": self.notes_edit.toPlainText().strip() or None,
        }


=============== FILE: views/horse/widgets/horse_list_widget.py ===============

# views/horse/widgets/horse_list_widget.py
"""
EDSI Veterinary Management System - Horse List Widget
Version: 1.1.2
Purpose: Custom QListWidget for displaying a list of horses with specific styling
         and item representation. Corrected vertical text cutoff.
Last Updated: June 13, 2025
Author: Gemini

Changelog:
- v1.1.2 (2025-06-13):
    - Increased the minimum height of list items to 70px to provide more vertical padding and improve visual balance.
- v1.1.1 (2025-06-13):
    - Correctly fixed vertical text cutoff by setting the minimum height on the
      custom item widget directly, as the stylesheet height is ignored when
      using setItemWidget.
    - Removed ineffective min-height style from QListWidget::item stylesheet.
- v1.1.0 (2025-06-13):
    - Increased list item min-height to 80px to fix vertical text cutoff after content simplification.
- v1.0.9 (2025-06-13):
    - Fixed vertical text cutoff by increasing the min-height of list items in the stylesheet to 70px.
- v1.0.8 (2025-06-13):
    - Simplified the list item to display only the horse's name and account number.
    - Removed breed, color, sex, age, and location from the list item display.
    - Set word wrap on the horse name to prevent it from being cut off.
    - Reduced the minimum height of list items to 55px to better fit the reduced content.
- v1.0.7 (2025-06-10):
    - Increased `min-height` of list items in the stylesheet to 70px to
      definitively prevent text from being cut off.
- v1.0.6 (2025-06-10):
    - Increased the minimum height of list items to 75px to
      provide more vertical space and prevent text clipping.
- v1.0.5 (2025-06-10):
    - Adjusted vertical margins and spacing in the custom item widget to
      prevent text from being cut off at the bottom.
- v1.0.4 (2025-06-10):
    - Adjusted vertical margins and spacing in the custom item widget to
      prevent text from being cut off at the bottom.
- v1.0.3 (2025-06-08):
    - Re-implemented `mouseDoubleClickEvent` to more reliably emit the
      `itemDoubleClicked` signal, fixing the double-click-to-edit feature.
- v1.0.2 (2025-06-08):
    - Bug Fix: Overrode `mouseDoubleClickEvent` to ensure the `itemDoubleClicked`
      signal is emitted correctly, even when using custom item widgets.
- v1.0.1 (2025-05-18):
    - Corrected AppConfig constant usage.
- v1.0.0 (2025-05-17):
    - Initial extraction from horse_unified_management.py.
"""

import logging
from typing import Optional
from datetime import date

from PySide6.QtWidgets import QListWidget, QVBoxLayout, QLabel, QWidget
from PySide6.QtGui import QFont, QMouseEvent
from PySide6.QtCore import Qt

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_BORDER,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
    DEFAULT_FONT_FAMILY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
)


class HorseListWidget(QListWidget):
    """Custom list widget styled for the dark theme and responsible for horse item rendering."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setStyleSheet(
            f"""
            QListWidget {{
                border: none; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none;
            }}
            QListWidget::item {{
                padding: 10px 15px; border-bottom: 1px solid {DARK_BORDER};
                background-color: {DARK_WIDGET_BACKGROUND};
            }}
            QListWidget::item:selected {{
                background-color: {DARK_PRIMARY_ACTION}40; /* RGBA */
                border-left: 3px solid {DARK_PRIMARY_ACTION};
                color: #ffffff;
            }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }}
            """
        )

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        """
        Overrides the default double-click handler to ensure the itemDoubleClicked
        signal is emitted reliably, even when using custom widgets.
        """
        item = self.itemAt(event.pos())
        if item:
            self.logger.debug(
                f"Double click detected on item for horse ID: {item.data(Qt.ItemDataRole.UserRole)}"
            )
            self.itemDoubleClicked.emit(item)
        # We do not call the super() implementation, as we are handling the event completely.
        # This prevents any potential conflicts.

    def create_horse_list_item_widget(self, horse) -> QWidget:
        """
        Creates a custom widget for displaying a single horse item in the list.
        Args:
            horse: The horse data object.
        Returns:
            QWidget: The custom widget for the list item.
        """
        widget = QWidget()
        widget.setMinimumHeight(70)  # Set height on the widget itself
        widget.setStyleSheet(
            f"background-color: transparent; border: none; color: {DARK_TEXT_PRIMARY};"
        )
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(0, 5, 0, 5)
        layout.setSpacing(2)

        name_label = QLabel(horse.horse_name or "Unnamed Horse")
        name_label.setFont(QFont(DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold))
        name_label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background: transparent;"
        )
        name_label.setWordWrap(True)

        info_text = f"Acct: {horse.account_number or 'N/A'}"
        info_label = QLabel(info_text)
        info_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-size: 10px; background: transparent;"
        )

        layout.addWidget(name_label)
        layout.addWidget(info_label)
        layout.addStretch()
        return widget

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        """
        Calculates the age of the horse based on the birth date.
        Args:
            birth_date_obj: The date of birth of the horse.
        Returns:
            str: A string representation of the horse's age.
        """
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yr" if age_val == 1 else f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"


=============== FILE: views/horse/widgets/horse_owner_list_widget.py ===============

# views/horse/widgets/horse_owner_list_widget.py

"""
EDSI Veterinary Management System - Horse Owner List Widget
Version: 1.0.1
Purpose: Custom QListWidget for displaying horse-owner associations with specific styling.
         Corrected AppConfig constant usage.
Last Updated: May 18, 2025
Author: Claude Assistant

Changelog:
- v1.0.1 (2025-05-18):
    - Corrected AppConfig constant usage. Imported constants directly instead of
      accessing them via the AppConfig class.
- v1.0.0 (2025-05-17):
    - Initial extraction from horse_unified_management.py.
"""

import logging
from PySide6.QtWidgets import QListWidget

# QColor might not be directly used if config provides strings, but good to keep if needed by palette
from PySide6.QtGui import QColor

# Corrected import: Import constants directly
from config.app_config import (
    DARK_BORDER,
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
)


class HorseOwnerListWidget(QListWidget):
    """Custom list widget for displaying horse owners in the Owners tab."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setStyleSheet(
            f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER};
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                outline: none; border-radius: 4px;
            }}
            QListWidget::item {{
                padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER};
            }}
            QListWidget::item:selected {{
                background-color: {DARK_PRIMARY_ACTION}50; /* Using alpha for selection */
                color: #ffffff; /* Ensure text is readable on selection */
            }}
            QListWidget::item:hover:!selected {{
                background-color: {DARK_ITEM_HOVER};
            }}
            """
        )


=============== FILE: views/reports/options/__init__.py ===============

"""
Report-specific option panel widgets.
"""

from .owner_statement_options import OwnerStatementOptionsWidget
from .ar_aging_options import ARAgingOptionsWidget
from .invoice_register_options import InvoiceRegisterOptionsWidget
from .payment_history_options import PaymentHistoryOptionsWidget
from .charge_code_usage_options import ChargeCodeUsageOptionsWidget
from .horse_transaction_history_options import HorseTransactionHistoryOptionsWidget


__all__ = [
    "OwnerStatementOptionsWidget",
    "ARAgingOptionsWidget",
    "InvoiceRegisterOptionsWidget",
    "PaymentHistoryOptionsWidget",
    "ChargeCodeUsageOptionsWidget",
    "HorseTransactionHistoryOptionsWidget",
]


=============== FILE: views/reports/options/ar_aging_options.py ===============

# views/reports/options/ar_aging_options.py
"""
EDSI Veterinary Management System - A/R Aging Options Widget
Version: 1.0.0
Purpose: A widget defining the user-selectable options for generating an
         Accounts Receivable (A/R) Aging report.
Last Updated: June 11, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict
from datetime import date

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QFormLayout,
    QDateEdit,
    QLabel,
)
from PySide6.QtCore import Qt, QDate

from config.app_config import AppConfig


class ARAgingOptionsWidget(QWidget):
    """UI for the A/R Aging report options."""

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setup_ui()

    def setup_ui(self):
        """Initializes and lays out the UI widgets."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        description = QLabel(
            "This report shows all outstanding owner balances, "
            "categorized by how long they are overdue."
        )
        description.setWordWrap(True)
        description.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-bottom: 15px;"
        )
        layout.addWidget(description)

        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setSpacing(10)

        # Date Field
        self.age_as_of_date_edit = QDateEdit(QDate.currentDate())
        self.age_as_of_date_edit.setCalendarPopup(True)
        self.age_as_of_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("Age Balances as of:", self.age_as_of_date_edit)

        layout.addLayout(form_layout)
        self.apply_styles()

    def apply_styles(self):
        """Applies consistent styling to the widgets."""
        style_sheet = f"""
            QDateEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 22px;
            }}
            QDateEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
        """
        self.setStyleSheet(style_sheet)

    def get_options(self) -> Dict:
        """Returns the currently selected report options."""
        return {
            "as_of_date": self.age_as_of_date_edit.date().toPython(),
        }


=============== FILE: views/reports/options/charge_code_usage_options.py ===============

"""
EDSI Veterinary Management System - Charge Code Usage Options Widget
Version: 2.0.0
Purpose: An advanced UI panel for selecting options for the Charge Code Usage report.
Last Updated: June 12, 2025
Author: Gemini

Changelog:
- v2.0.0 (2025-06-12):
    - Upgraded widget to include options for grouping and sorting the report data.
    - Added QGroupBoxes for better UI organization.
    - get_options() now returns group_by and sort_by keys.
"""

import logging
from datetime import date, timedelta
from typing import Dict, Any

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGridLayout,
    QLabel,
    QDateEdit,
    QGroupBox,
    QRadioButton,
    QComboBox,
)
from PySide6.QtCore import Qt, QDate

from config.app_config import AppConfig


class ChargeCodeUsageOptionsWidget(QWidget):
    """Widget for setting options for the Charge Code Usage report."""

    def __init__(self, parent: QWidget = None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self._setup_ui()

    def _setup_ui(self):
        """Initializes the user interface components."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(20)
        main_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # === Date Range Group ===
        date_group = QGroupBox("Date Range")
        date_layout = QGridLayout(date_group)

        self.start_date_edit = QDateEdit(calendarPopup=True)
        self.start_date_edit.setDate(date.today() - timedelta(days=30))

        self.end_date_edit = QDateEdit(calendarPopup=True)
        self.end_date_edit.setDate(date.today())

        date_layout.addWidget(QLabel("Start Date:"), 0, 0)
        date_layout.addWidget(self.start_date_edit, 0, 1)
        date_layout.addWidget(QLabel("End Date:"), 1, 0)
        date_layout.addWidget(self.end_date_edit, 1, 1)

        # === Grouping Group ===
        grouping_group = QGroupBox("Group By")
        grouping_layout = QVBoxLayout(grouping_group)
        self.group_by_code_radio = QRadioButton("Charge Code")
        self.group_by_category_radio = QRadioButton("Charge Code Category")
        self.group_by_code_radio.setChecked(True)
        grouping_layout.addWidget(self.group_by_code_radio)
        grouping_layout.addWidget(self.group_by_category_radio)

        # === Sorting Group ===
        sorting_group = QGroupBox("Sort By")
        sorting_layout = QVBoxLayout(sorting_group)
        self.sort_combo = QComboBox()
        self.sort_combo.addItems(
            [
                "Usage Count (High to Low)",
                "Total Revenue (High to Low)",
                "Charge Code (A-Z)",
                "Category (A-Z)",
            ]
        )
        sorting_layout.addWidget(self.sort_combo)

        main_layout.addWidget(date_group)
        main_layout.addWidget(grouping_group)
        main_layout.addWidget(sorting_group)

        self.setStyleSheet(self._get_style())

    def _get_style(self) -> str:
        """Returns the stylesheet for the widget."""
        return f"""
            QGroupBox {{
                font-weight: bold;
                color: {AppConfig.DARK_TEXT_SECONDARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 5px;
                margin-top: 1ex;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                subcontrol-position: top left;
                padding: 0 3px;
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
            }}
            QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
                font-size: 10pt;
            }}
            QDateEdit, QComboBox {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: white;
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
            }}
            QDateEdit:focus, QComboBox:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QRadioButton {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
        """

    def get_options(self) -> Dict[str, Any]:
        """
        Retrieves the selected report options from the UI controls.

        Returns:
            A dictionary containing the selected options.
        """
        grouping_option = (
            "category" if self.group_by_category_radio.isChecked() else "code"
        )

        options = {
            "start_date": self.start_date_edit.date().toPython(),
            "end_date": self.end_date_edit.date().toPython(),
            "group_by": grouping_option,
            "sort_by": self.sort_combo.currentText(),
        }
        self.logger.info(f"Report options selected: {options}")
        return options


=============== FILE: views/reports/options/horse_transaction_history_options.py ===============

# views/reports/options/horse_transaction_history_options.py
"""
EDSI Veterinary Management System - Horse Transaction History Options Widget
Version: 1.0.0
Purpose: A widget defining the user-selectable options for generating a
         Horse Transaction History report.
Last Updated: June 12, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict, List

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QFormLayout,
    QDateEdit,
    QLabel,
    QComboBox,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
)
from PySide6.QtCore import Qt, QDate, QTimer

from config.app_config import AppConfig
from controllers import HorseController
from models import Horse


class HorseTransactionHistoryOptionsWidget(QWidget):
    """UI for the Horse Transaction History report options."""

    def __init__(
        self, horse_controller: HorseController, parent: Optional[QWidget] = None
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_controller = horse_controller
        self.all_horses: List[Horse] = []
        self.selected_horse_id: Optional[int] = None

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self._filter_horse_list)

        self.setup_ui()
        self.load_horses()

    def setup_ui(self):
        """Initializes and lays out the UI widgets."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        description = QLabel(
            "This report provides a detailed list of all financial transactions "
            "for a single horse within a selected date range."
        )
        description.setWordWrap(True)
        description.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-bottom: 15px;"
        )
        layout.addWidget(description)

        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setSpacing(10)

        # Horse Selection
        self.horse_search_input = QLineEdit()
        self.horse_search_input.setPlaceholderText("Search for horse by name...")
        self.horse_search_input.textChanged.connect(self.search_timer.start)
        form_layout.addRow("Search Horse:", self.horse_search_input)

        self.horse_list_widget = QListWidget()
        self.horse_list_widget.setFixedHeight(150)
        self.horse_list_widget.itemClicked.connect(self._on_horse_selected)
        form_layout.addRow(self.horse_list_widget)

        # Date Range
        self.start_date_edit = QDateEdit(QDate.currentDate().addDays(-30))
        self.start_date_edit.setCalendarPopup(True)
        self.start_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("Start Date:", self.start_date_edit)

        self.end_date_edit = QDateEdit(QDate.currentDate())
        self.end_date_edit.setCalendarPopup(True)
        self.end_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("End Date:", self.end_date_edit)

        layout.addLayout(form_layout)
        self.apply_styles()

    def apply_styles(self):
        """Applies consistent styling to the widgets."""
        style_sheet = f"""
            QDateEdit, QLineEdit, QListWidget {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 22px;
            }}
            QDateEdit:focus, QLineEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QListWidget::item:selected {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
        """
        self.setStyleSheet(style_sheet)

    def load_horses(self):
        """Loads all active horses for the selection list."""
        try:
            self.all_horses = self.horse_controller.search_horses(status="all")
            self._filter_horse_list()
        except Exception as e:
            self.logger.error(f"Failed to load horses: {e}", exc_info=True)

    def _filter_horse_list(self):
        """Filters the horse list based on the search input."""
        search_text = self.horse_search_input.text().lower()
        self.horse_list_widget.clear()
        for horse in self.all_horses:
            if search_text in horse.horse_name.lower():
                item = QListWidgetItem(
                    f"{horse.horse_name} (Acct: {horse.account_number or 'N/A'})"
                )
                item.setData(Qt.ItemDataRole.UserRole, horse.horse_id)
                self.horse_list_widget.addItem(item)

    def _on_horse_selected(self, item: QListWidgetItem):
        """Handles the selection of a horse from the list."""
        self.selected_horse_id = item.data(Qt.ItemDataRole.UserRole)
        self.logger.info(f"Horse selected for report: ID {self.selected_horse_id}")

    def get_options(self) -> Dict:
        """Returns the currently selected report options."""
        return {
            "horse_id": self.selected_horse_id,
            "start_date": self.start_date_edit.date().toPython(),
            "end_date": self.end_date_edit.date().toPython(),
        }


=============== FILE: views/reports/options/invoice_register_options.py ===============

# views/reports/options/invoice_register_options.py
"""
EDSI Veterinary Management System - Invoice Register Options Widget
Version: 1.0.0
Purpose: A widget defining the user-selectable options for generating an
         Invoice Register report.
Last Updated: June 11, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict
from datetime import date

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QFormLayout,
    QDateEdit,
    QLabel,
)
from PySide6.QtCore import Qt, QDate

from config.app_config import AppConfig


class InvoiceRegisterOptionsWidget(QWidget):
    """UI for the Invoice Register report options."""

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setup_ui()

    def setup_ui(self):
        """Initializes and lays out the UI widgets."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        description = QLabel(
            "This report provides a detailed list of all invoices "
            "generated within the selected date range."
        )
        description.setWordWrap(True)
        description.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-bottom: 15px;"
        )
        layout.addWidget(description)

        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setSpacing(10)

        # Date Range
        self.start_date_edit = QDateEdit(QDate.currentDate().addDays(-30))
        self.start_date_edit.setCalendarPopup(True)
        self.start_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("Start Date:", self.start_date_edit)

        self.end_date_edit = QDateEdit(QDate.currentDate())
        self.end_date_edit.setCalendarPopup(True)
        self.end_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("End Date:", self.end_date_edit)

        layout.addLayout(form_layout)
        self.apply_styles()

    def apply_styles(self):
        """Applies consistent styling to the widgets."""
        style_sheet = f"""
            QDateEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 22px;
            }}
            QDateEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
        """
        self.setStyleSheet(style_sheet)

    def get_options(self) -> Dict:
        """Returns the currently selected report options."""
        return {
            "start_date": self.start_date_edit.date().toPython(),
            "end_date": self.end_date_edit.date().toPython(),
        }


=============== FILE: views/reports/options/owner_statement_options.py ===============

# views/reports/options/owner_statement_options.py
"""
EDSI Veterinary Management System - Owner Statement Options Widget
Version: 1.0.0
Purpose: A widget defining the user-selectable options for generating an
         Owner Statement report.
Last Updated: June 11, 2025
Author: Gemini
"""

import logging
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QFormLayout,
    QComboBox,
    QDateEdit,
    QCheckBox,
    QLabel,
)
from PySide6.QtCore import Qt, QDate

from controllers import OwnerController
from config.app_config import AppConfig


class OwnerStatementOptionsWidget(QWidget):
    """UI for the Owner Statement report options."""

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.owner_controller = OwnerController()

        self.setup_ui()
        self.load_owners()

    def setup_ui(self):
        """Initializes and lays out the UI widgets."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setSpacing(10)

        # Owner Selection
        self.owner_combo = QComboBox()
        form_layout.addRow("Select Owner*:", self.owner_combo)

        # Date Range
        self.start_date_edit = QDateEdit(QDate.currentDate().addMonths(-1))
        self.start_date_edit.setCalendarPopup(True)
        self.start_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("Start Date:", self.start_date_edit)

        self.end_date_edit = QDateEdit(QDate.currentDate())
        self.end_date_edit.setCalendarPopup(True)
        self.end_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("End Date:", self.end_date_edit)

        # Additional Options
        self.include_balance_checkbox = QCheckBox("Include previous balance")
        self.include_balance_checkbox.setChecked(True)
        form_layout.addRow("", self.include_balance_checkbox)

        layout.addLayout(form_layout)
        self.apply_styles()

    def apply_styles(self):
        """Applies consistent styling to the widgets."""
        style_sheet = f"""
            QComboBox, QDateEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 22px;
            }}
            QComboBox:focus, QDateEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QCheckBox, QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
        """
        self.setStyleSheet(style_sheet)

    def load_owners(self):
        """Fetches active owners and populates the combo box."""
        self.owner_combo.clear()
        self.owner_combo.addItem("All Owners", "all")
        try:
            owners_data = self.owner_controller.get_all_owners_for_lookup()
            for owner in owners_data:
                self.owner_combo.addItem(owner["name_account"], owner["id"])
        except Exception as e:
            self.logger.error(
                f"Failed to load owners for report options: {e}", exc_info=True
            )

    def get_options(self) -> Dict:
        """Returns the currently selected report options."""
        return {
            "owner_id": self.owner_combo.currentData(),
            "start_date": self.start_date_edit.date().toPython(),
            "end_date": self.end_date_edit.date().toPython(),
            "include_previous_balance": self.include_balance_checkbox.isChecked(),
        }


=============== FILE: views/reports/options/payment_history_options.py ===============

# views/reports/options/payment_history_options.py
"""
EDSI Veterinary Management System - Payment History Options Widget
Version: 1.0.0
Purpose: A widget defining the user-selectable options for generating a
         Payment History report.
Last Updated: June 11, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict
from datetime import date

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QFormLayout,
    QDateEdit,
    QLabel,
    QComboBox,
)
from PySide6.QtCore import Qt, QDate

from config.app_config import AppConfig
from controllers import OwnerController


class PaymentHistoryOptionsWidget(QWidget):
    """UI for the Payment History report options."""

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.owner_controller = OwnerController()

        self.setup_ui()
        self.load_owners()

    def setup_ui(self):
        """Initializes and lays out the UI widgets."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        description = QLabel(
            "This report provides a list of all payments received within a "
            "selected date range. You can filter for a specific owner or "
            "view payments from all owners."
        )
        description.setWordWrap(True)
        description.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-bottom: 15px;"
        )
        layout.addWidget(description)

        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setSpacing(10)

        # Owner Selection
        self.owner_combo = QComboBox()
        form_layout.addRow("Filter by Owner:", self.owner_combo)

        # Date Range
        self.start_date_edit = QDateEdit(QDate.currentDate().addDays(-30))
        self.start_date_edit.setCalendarPopup(True)
        self.start_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("Start Date:", self.start_date_edit)

        self.end_date_edit = QDateEdit(QDate.currentDate())
        self.end_date_edit.setCalendarPopup(True)
        self.end_date_edit.setDisplayFormat("yyyy-MM-dd")
        form_layout.addRow("End Date:", self.end_date_edit)

        layout.addLayout(form_layout)
        self.apply_styles()

    def apply_styles(self):
        """Applies consistent styling to the widgets."""
        style_sheet = f"""
            QComboBox, QDateEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 22px;
            }}
            QComboBox:focus, QDateEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
        """
        self.setStyleSheet(style_sheet)

    def load_owners(self):
        """Fetches active owners and populates the combo box."""
        self.owner_combo.clear()
        self.owner_combo.addItem("All Owners", "all")
        try:
            owners_data = self.owner_controller.get_all_owners_for_lookup()
            for owner in owners_data:
                self.owner_combo.addItem(owner["name_account"], owner["id"])
        except Exception as e:
            self.logger.error(
                f"Failed to load owners for report options: {e}", exc_info=True
            )

    def get_options(self) -> Dict:
        """Returns the currently selected report options."""
        return {
            "owner_id": self.owner_combo.currentData(),
            "start_date": self.start_date_edit.date().toPython(),
            "end_date": self.end_date_edit.date().toPython(),
        }


=============== FILE: scripts/add_initial_data.py ===============

# scripts/add_initial_data.py
"""
EDSI Veterinary Management System - Add Initial Data Script
Version: 1.3.4
Purpose: Populates the database with essential initial data, including a full
         charge code list extracted from the legacy system's report.
         Now directly initializes DatabaseManager, making it standalone.
Last Updated: June 23, 2025
Author: Gemini

Changelog:
- v1.3.4 (2025-06-23):
    - Modified `add_initial_data_main` to directly instantiate `DatabaseManager`
      using `AppConfig` and the global `config_manager`.
    - All database calls (`initialize_database`, `get_session`, `close`) now use
      this locally instantiated `_db_manager` object, eliminating reliance on
      the singleton setup from `main.py` and resolving `RuntimeError: DatabaseManager instance not set`.
- v1.3.3 (2025-06-23):
    - Corrected database access calls from `db_manager.get_session()` to `db_manager().get_session()`
      and `db_manager.close()` to `db_manager().close()` to align with the updated `DatabaseManager` singleton access pattern.
- v1.3.2 (2025-06-09):
    - Fix: Restored the full implementations for all helper functions.
    - Feature: Populated with the complete list of all 167 charge codes from the PDF.
- v1.3.1 (2025-06-09):
    - Added placeholder functions to be filled.
"""
import logging
import os
import sys
from datetime import date
from decimal import Decimal
from sqlalchemy.exc import SQLAlchemyError
from typing import List, Dict, Optional, Any

# Setup project path
script_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(script_dir)
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Import required modules
try:
    from config.database_config import DatabaseManager  # Import the class directly
    from config.app_config import AppConfig  # Import AppConfig
    from config.config_manager import (
        config_manager,
    )  # Import the global config_manager instance
    from models import (
        User,
        Role,
        UserRole,
        StateProvince,
        ChargeCodeCategory,
        ChargeCode,
        Veterinarian,
        Location,
        Owner,
    )
except ImportError as e:
    print(f"Error importing modules in add_initial_data.py: {e}")
    sys.exit(1)

# --- Logging Setup ---
# Assuming logs directory is set up by AppConfig in main.py, but for standalone script, ensure it exists.
log_file_path = os.path.join(project_root, "logs", "add_initial_data.log")
os.makedirs(os.path.dirname(log_file_path), exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s",
    handlers=[
        logging.FileHandler(log_file_path, mode="w"),
        logging.StreamHandler(sys.stdout),
    ],
)
logger = logging.getLogger(os.path.basename(__file__))


def add_roles(session) -> bool:
    roles_to_add = [
        {"name": "ADMIN", "description": "Administrator with full system access."},
        {"name": "MANAGER", "description": "Manager with operational oversight."},
        {
            "name": "VETERINARIAN",
            "description": "Veterinarian providing medical services.",
        },
        {
            "name": "TECHNICIAN",
            "description": "Veterinary technician assisting with procedures.",
        },
        {
            "name": "RECEPTIONIST",
            "description": "Receptionist handling front-desk operations.",
        },
        {
            "name": "CLIENT",
            "description": "Client/Owner accessing their animal's information (future).",
        },
    ]
    for role_data in roles_to_add:
        role_data.update({"created_by": "system_init", "modified_by": "system_init"})
    existing_roles = {role_tuple[0] for role_tuple in session.query(Role.name).all()}
    new_roles_instances = []
    for role_data in roles_to_add:
        if role_data["name"] not in existing_roles:
            new_roles_instances.append(Role(**role_data))
            logger.info(f"Prepared role: {role_data['name']}")
        else:
            logger.info(f"Role '{role_data['name']}' already exists, skipping.")
    if new_roles_instances:
        session.add_all(new_roles_instances)
        logger.info(f"Successfully prepared {len(new_roles_instances)} new roles.")
        return True
    logger.info("No new roles to add.")
    return False


def add_admin_user(session) -> bool:
    admin_login_id = "ADMIN"
    admin_exists = session.query(User).filter_by(user_id=admin_login_id).first()
    changes_made = False
    if not admin_exists:
        admin_role = session.query(Role).filter_by(name="ADMIN").first()
        if not admin_role:
            logger.error("ADMIN role not found. Cannot create admin user.")
            return False
        admin_user = User(
            user_id=admin_login_id,
            user_name="System Administrator",
            email="admin@edsystem.com",
            is_active=True,
            created_by="system_init",
            modified_by="system_init",
        )
        admin_user.set_password("admin1234")
        admin_user.roles.append(admin_role)
        session.add(admin_user)
        changes_made = True
        logger.info(
            f"Admin user '{admin_login_id}' prepared with default password and ADMIN role."
        )
    else:
        logger.info(f"Admin user '{admin_login_id}' already exists.")
        if not admin_exists.check_password("admin1234"):
            admin_exists.set_password("admin1234")
            logger.info(
                f"Password for existing ADMIN user '{admin_login_id}' reset to default (bcrypt)."
            )
            changes_made = True
        admin_role = session.query(Role).filter_by(name="ADMIN").first()
        if admin_role and admin_role not in admin_exists.roles:
            admin_exists.roles.append(admin_role)
            admin_exists.modified_by = "system_init_role_add"
            changes_made = True
            logger.info(f"ADMIN role assigned to existing user '{admin_login_id}'.")
    return changes_made


def add_charge_code_categories(session) -> bool:
    logger.info("Preparing charge code categories...")
    categories_structure = [
        {
            "name": "ANTHELMINTICS",
            "level": 1,
            "children": [
                {"name": "ADMINISTERED", "level": 2},
                {"name": "DISPENSED", "level": 2},
            ],
        },
        {"name": "CALL FEES", "level": 1, "children": []},
        {
            "name": "DIAGNOSTIC PROCEDURES",
            "level": 1,
            "children": [
                {"name": "NERVE BLOCKS", "level": 2},
                {"name": "JOINT BLOCKS", "level": 2},
                {"name": "RADIOLOGY - FRONT LEG", "level": 2},
                {"name": "RADIOLOGY - HIND LEG", "level": 2},
                {"name": "RADIOLOGY - OTHER", "level": 2},
                {"name": "ULTRASOUND EXAM OF EXTREMITIES", "level": 2},
                {"name": "OTHER", "level": 2},
            ],
        },
        {
            "name": "EXAMINATIONS",
            "level": 1,
            "children": [
                {"name": "SICK HORSE EXAMS", "level": 2},
                {"name": "OTHER EXAMS", "level": 2},
            ],
        },
        {
            "name": "IMMUNIZATIONS",
            "level": 1,
            "children": [{"name": "HORSE", "level": 2}],
        },
        {
            "name": "LABORATORY PROCEDURES",
            "level": 1,
            "children": [
                {"name": "BLOOD WORK", "level": 2},
                {"name": "OTHER", "level": 2},
            ],
        },
        {
            "name": "MEDICATION ADMINISTERED",
            "level": 1,
            "children": [
                {"name": "ANABOLIC STEROIDS", "level": 2},
                {"name": "ANTIBIOTICS", "level": 2},
                {"name": "DIURETICS", "level": 2},
                {"name": "FLUIDS ADMINISTERED", "level": 2},
                {"name": "GASTROINTESTINAL TREATMENTS", "level": 2},
                {"name": "INTRA-ARTICULAR INJECTIONS", "level": 2},
                {"name": "OTHER HORMONES", "level": 2},
                {"name": "NON-ARTICULAR INJECTIONS", "level": 2},
                {"name": "NSAID'S ANALGESICS", "level": 2},
                {"name": "TRANQUILIZERS & ANESTHETICS", "level": 2},
                {"name": "VITAMINS", "level": 2},
                {"name": "OTHER", "level": 2},
            ],
        },
        {
            "name": "MEDICATIONS DISPENSED",
            "level": 1,
            "children": [
                {"name": "OTHER HORMONES", "level": 2},
                {"name": "ANTIBIOTICS - PENICILLINS", "level": 2},
                {"name": "ANTIBIOTICS - OTHER", "level": 2},
                {"name": "BANDAGES & MATERIALS", "level": 2},
                {"name": "DERMATITIS/TOPICAL ANTISEPTICS", "level": 2},
                {"name": "DIURETICS", "level": 2},
                {"name": "FLUIDS", "level": 2},
                {"name": "G.I. MEDICATIONS", "level": 2},
                {"name": "INJECTABLE NSAID'S", "level": 2},
                {"name": "OTHER INJECTABLE ANTI-INFLAM.", "level": 2},
                {"name": "INTRA-ARTICULAR PRODUCTS", "level": 2},
                {"name": "LEG PREPARATIONS", "level": 2},
                {"name": "NEEDLES & SYRINGES", "level": 2},
                {"name": "ORAL NSAID'S", "level": 2},
                {"name": "OTHER ORAL ANTI-INFLAM.", "level": 2},
                {"name": "OPHTHALMIC DRUGS", "level": 2},
                {"name": "RESPIRATORY DRUGS", "level": 2},
                {"name": "TOPICAL MEDICATIONS", "level": 2},
                {"name": "TRANQUILIZERS & MUSCLE RELAX.", "level": 2},
                {"name": "VITAMINS", "level": 2},
                {"name": "NON-VITAMIN FEED SUPPLEMENTS", "level": 2},
                {"name": "OTHER", "level": 2},
            ],
        },
        {
            "name": "REPRODUCTIVE PROCEDURES",
            "level": 1,
            "children": [{"name": "GENERAL BROODMARE WORK", "level": 2}],
        },
        {"name": "SURGICAL PROCEDURES", "level": 1, "children": []},
        {
            "name": "VET. PROCEDURES & SERVICES",
            "level": 1,
            "children": [
                {"name": "BANDAGING", "level": 2},
                {"name": "OTHER", "level": 2},
            ],
        },
        {"name": "OTHER", "level": 1, "children": []},
    ]
    changes_made = False

    def _process_categories(
        categories_list: List[Dict[str, Any]], current_parent_id: Optional[int] = None
    ):
        nonlocal session  # Declare session as nonlocal to modify the outer scope's session variable
        nonlocal changes_made
        for cat_data in categories_list:
            existing_cat = (
                session.query(ChargeCodeCategory)
                .filter_by(
                    name=cat_data["name"],
                    level=cat_data["level"],
                    parent_id=current_parent_id,
                )
                .first()
            )
            if not existing_cat:
                new_cat = ChargeCodeCategory(
                    name=cat_data["name"],
                    level=cat_data["level"],
                    parent_id=current_parent_id,
                    is_active=True,
                    created_by="system_init",
                    modified_by="system_init",
                )
                session.add(new_cat)
                session.flush()
                logger.info(
                    f"Prepared category: {new_cat.name} (Level {new_cat.level}, Parent ID: {new_cat.parent_id}) with ID {new_cat.category_id}"
                )
                changes_made = True
                created_cat_id = new_cat.category_id
            else:
                logger.info(
                    f"Category '{cat_data['name']}' (Level {cat_data['level']}, Parent ID: {current_parent_id}) already exists, skipping creation."
                )
                created_cat_id = existing_cat.category_id
            if "children" in cat_data and cat_data["children"]:
                _process_categories(cat_data["children"], created_cat_id)

    _process_categories(categories_structure)
    if changes_made:
        logger.info("Successfully prepared new charge code categories.")
    else:
        logger.info("No new charge code categories to add or all existed.")
    return changes_made


def _get_category_id_by_path(session, path_list: List[str]) -> Optional[int]:
    if not path_list:
        return None
    parent_id, current_category_id, level = None, None, 1
    for category_name in path_list:
        category = (
            session.query(ChargeCodeCategory)
            .filter_by(name=category_name, level=level, parent_id=parent_id)
            .first()
        )
        if not category:
            logger.warning(
                f"Category not found in path: Name='{category_name}', Level={level}, ParentID={parent_id}. Full path: {path_list}"
            )
            return None
        current_category_id = category.category_id
        parent_id = current_category_id
        level += 1
    return current_category_id


def add_state_provinces(session) -> bool:
    full_states_list = [
        {
            "state_code": "AL",
            "state_name": "Alabama",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "AK",
            "state_name": "Alaska",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "AZ",
            "state_name": "Arizona",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "AR",
            "state_name": "Arkansas",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "CA",
            "state_name": "California",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "CO",
            "state_name": "Colorado",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "CT",
            "state_name": "Connecticut",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "DE",
            "state_name": "Delaware",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "FL",
            "state_name": "Florida",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "GA",
            "state_name": "Georgia",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "HI",
            "state_name": "Hawaii",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "ID",
            "state_name": "Idaho",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "IL",
            "state_name": "Illinois",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "IN",
            "state_name": "Indiana",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "IA",
            "state_name": "Iowa",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "KS",
            "state_name": "Kansas",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "KY",
            "state_name": "Kentucky",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "LA",
            "state_name": "Louisiana",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "ME",
            "state_name": "Maine",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "MD",
            "state_name": "Maryland",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "MA",
            "state_name": "Massachusetts",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "MI",
            "state_name": "Michigan",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "MN",
            "state_name": "Minnesota",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "MS",
            "state_name": "Mississippi",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "MO",
            "state_name": "Missouri",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "MT",
            "state_name": "Montana",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "NE",
            "state_name": "Nebraska",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "NV",
            "state_name": "Nevada",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "NH",
            "state_name": "New Hampshire",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "NJ",
            "state_name": "New Jersey",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "NM",
            "state_name": "New Mexico",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "NY",
            "state_name": "New York",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "NC",
            "state_name": "North Carolina",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "ND",
            "state_name": "North Dakota",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "OH",
            "state_name": "Ohio",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "OK",
            "state_name": "Oklahoma",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "OR",
            "state_name": "Oregon",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "PA",
            "state_name": "Pennsylvania",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "RI",
            "state_name": "Rhode Island",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "SC",
            "state_name": "South Carolina",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "SD",
            "state_name": "South Dakota",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "TN",
            "state_name": "Tennessee",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "TX",
            "state_name": "Texas",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "UT",
            "state_name": "Utah",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "VT",
            "state_name": "Vermont",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "VA",
            "state_name": "Virginia",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "WA",
            "state_name": "Washington",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "WV",
            "state_name": "West Virginia",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "WI",
            "state_name": "Wisconsin",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "WY",
            "state_name": "Wyoming",
            "country_code": "USA",
            "is_active": True,
        },
        {
            "state_code": "AB",
            "state_name": "Alberta",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "BC",
            "state_name": "British Columbia",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "MB",
            "state_name": "Manitoba",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "NB",
            "state_name": "New Brunswick",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "NL",
            "state_name": "Newfoundland and Labrador",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "NS",
            "state_name": "Nova Scotia",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "ON",
            "state_name": "Ontario",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "PE",
            "state_name": "Prince Edward Island",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "QC",
            "state_name": "Quebec",
            "country_code": "CAN",
            "is_active": True,
        },
        {
            "state_code": "SK",
            "state_name": "Saskatchewan",
            "country_code": "CAN",
            "is_active": True,
        },
    ]
    for sp_data in full_states_list:
        sp_data.update({"created_by": "system_init", "modified_by": "system_init"})
    existing_codes = {
        sp_tuple[0] for sp_tuple in session.query(StateProvince.state_code).all()
    }
    new_entries = [
        StateProvince(**sp_data)
        for sp_data in full_states_list
        if sp_data["state_code"] not in existing_codes
    ]
    for entry in new_entries:
        logger.info(f"Prepared state/province: {entry.state_name}")
    if new_entries:
        session.add_all(new_entries)
        logger.info(f"Added {len(new_entries)} new states/provinces.")
    else:
        logger.info("No new states/provinces to add or all existed.")
    return len(new_entries) > 0


def add_initial_locations(session) -> bool:
    locations_to_add = [
        {
            "location_name": "Main Stable",
            "address_line1": "123 Paddock Lane",
            "city": "Equineville",
            "state_code": "PA",
            "zip_code": "19355",
            "country_code": "USA",
            "is_active": True,
            "created_by": "system_init",
            "modified_by": "system_init",
        },
        {
            "location_name": "Quarantine Barn",
            "address_line1": "456 Quarantine Rd",
            "city": "Equineville",
            "state_code": "PA",
            "zip_code": "19355",
            "country_code": "USA",
            "is_active": True,
            "created_by": "system_init",
            "modified_by": "system_init",
        },
        {
            "location_name": "West Wing Stalls",
            "address_line1": "789 Derby Drive",
            "city": "Raceburg",
            "state_code": "KY",
            "zip_code": "40511",
            "country_code": "USA",
            "is_active": True,
            "created_by": "system_init",
            "modified_by": "system_init",
        },
    ]
    existing_locations = {
        loc_tuple[0] for loc_tuple in session.query(Location.location_name).all()
    }
    new_locations_instances = []
    for loc_data in locations_to_add:
        if (
            loc_data.get("state_code")
            and not session.query(StateProvince)
            .filter_by(state_code=loc_data["state_code"])
            .first()
        ):
            logger.warning(
                f"State code '{loc_data['state_code']}' for location '{loc_data['location_name']}' not found. Ensure states are added first."
            )
        if loc_data["location_name"] not in existing_locations:
            new_locations_instances.append(Location(**loc_data))
            logger.info(f"Prepared location: {loc_data['location_name']}")
        else:
            logger.info(
                f"Location '{loc_data['location_name']}' already exists, skipping."
            )
    if new_locations_instances:
        session.add_all(new_locations_instances)
    return len(new_locations_instances) > 0


def add_sample_owners(session) -> bool:
    owners_to_add = [
        {
            "farm_name": "Willow Creek Stables",
            "first_name": "John",
            "last_name": "Smith",
            "address_line1": "100 Willow Creek Rd",
            "city": "Lexington",
            "state_code": "KY",
            "zip_code": "40502",
            "phone": "555-0101",
            "email": "john.smith@willowcreek.com",
            "is_active": True,
            "account_number": "WC001",
            "created_by": "system_init",
            "modified_by": "system_init",
        },
        {
            "farm_name": "Quail Pond Farms",
            "first_name": "Sarah",
            "last_name": "Davis",
            "address_line1": "25 Horseman's Way",
            "city": "Ocala",
            "state_code": "FL",
            "zip_code": "34470",
            "phone": "555-0202",
            "email": "sarah.davis@email.com",
            "is_active": True,
            "account_number": "SD001",
            "created_by": "system_init",
            "modified_by": "system_init",
        },
    ]
    existing_account_numbers = {
        owner_tuple[0]
        for owner_tuple in session.query(Owner.account_number)
        .filter(Owner.account_number.isnot(None))
        .all()
    }
    new_owners_instances = []
    for owner_data in owners_to_add:
        if (
            owner_data.get("state_code")
            and not session.query(StateProvince)
            .filter_by(state_code=owner_data["state_code"])
            .first()
        ):
            logger.warning(
                f"State code '{owner_data['state_code']}' for owner '{owner_data.get('farm_name', owner_data.get('last_name'))}' not found."
            )
        if owner_data.get("account_number") not in existing_account_numbers:
            new_owners_instances.append(Owner(**owner_data))
            logger.info(
                f"Prepared owner: {owner_data.get('farm_name', owner_data.get('last_name'))}"
            )
        elif owner_data.get("account_number") is None:
            new_owners_instances.append(Owner(**owner_data))
            logger.info(
                f"Prepared owner (no account number): {owner_data.get('farm_name', owner_data.get('last_name'))}"
            )
        else:
            logger.info(
                f"Owner with account number '{owner_data['account_number']}' already exists, skipping."
            )
    if new_owners_instances:
        session.add_all(new_owners_instances)
    return len(new_owners_instances) > 0


def add_all_charge_codes(session) -> bool:
    """Populates the database with a comprehensive list of charge codes from the legacy report."""
    logger.info("Preparing complete charge code list...")
    charge_codes_data = [
        {
            "code": "9991",
            "alt": "IVO",
            "desc": "IVERMECTIN AND PRAZIQUANTEL",
            "price": "25.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "413",
            "alt": "PWBEN",
            "desc": "PASTE WORM WITH BENZELMIN",
            "price": "14.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "412",
            "alt": "PWPAN",
            "desc": "PASTE WORM WITH FENBENDAZOLE",
            "price": "24.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "414",
            "alt": "PWPP",
            "desc": "PASTE WORM WITH PYRANTAL PAMOATE",
            "price": "12.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "107",
            "alt": "PPP",
            "desc": "TREATMENT WITH PANACUR POWER PAC",
            "price": "90.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "576",
            "alt": "Q",
            "desc": "TREATMENT WITH QUEST",
            "price": "25.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "405",
            "alt": "TW2X",
            "desc": "TUBE WORM WITH DOUBLE DOSE OF PANACUR OR STRONGID T",
            "price": "60.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "400",
            "alt": "TWBQ",
            "desc": "TUBE WORM WITH EQUIZOLE A",
            "price": "18.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "403",
            "alt": "TWPAN",
            "desc": "TUBE WORM WITH FENBENDAZOLE",
            "price": "20.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "402",
            "alt": "TWPP",
            "desc": "TUBE WORM WITH PYRANTAL PAMOATE",
            "price": "20.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "406",
            "alt": "TW10X",
            "desc": "TUBE WORM WITH TEN TIMES DOSE OF PANACUR",
            "price": "70.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "420",
            "alt": "WORM",
            "desc": "WORM",
            "price": "20.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "109",
            "alt": "W2X",
            "desc": "WORM WITH DOUBLE DOSE STRONGID OR PANACUR",
            "price": "24.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "411",
            "alt": "PWIV",
            "desc": "WORM WITH IVERMECTIN",
            "price": "20.00",
            "path": ["ANTHELMINTICS", "ADMINISTERED"],
        },
        {
            "code": "9634",
            "alt": "STRC",
            "desc": "25 LB PAIL OF STRONGID C 2X PELLETS",
            "price": "100.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "424",
            "alt": "DBEN",
            "desc": "BENZELMIN PASTE",
            "price": "15.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "39",
            "alt": "STRC2X",
            "desc": "BUCKET OF STRONGID C 2X PELLETS",
            "price": "100.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "426",
            "alt": "DPANL",
            "desc": "DISPENSE PANACUR LIQUID 1000 ML",
            "price": "240.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "581",
            "alt": "DQUEST",
            "desc": "DISPENSE QUEST",
            "price": "200.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "429",
            "alt": "DWORM",
            "desc": "DISPENSE WORMER",
            "price": "11.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "425",
            "alt": "DEQV",
            "desc": "EQVALAN PASTE",
            "price": "15.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "423",
            "alt": "DPAN",
            "desc": "PANACUR PASTE",
            "price": "20.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "422",
            "alt": "PPPT",
            "desc": "PYRANTAL PAMOATE 1 PINT",
            "price": "40.00",
            "path": ["ANTHELMINTICS", "DISPENSED"],
        },
        {
            "code": "650",
            "alt": "AF",
            "desc": "ATTEND FOALING",
            "price": "100.00",
            "path": ["CALL FEES"],
        },
        {
            "code": "101",
            "alt": "EFC",
            "desc": "EMERGENCY FARM CALL",
            "price": "100.00",
            "path": ["CALL FEES"],
        },
        {
            "code": "100",
            "alt": "FC",
            "desc": "FARM CALL",
            "price": "60.00",
            "path": ["CALL FEES"],
        },
        {
            "code": "103",
            "alt": "NFC",
            "desc": "NO FARM CALL CHARGE",
            "price": "0.00",
            "path": ["CALL FEES"],
        },
        {
            "code": "102",
            "alt": "PFC",
            "desc": "PARTIAL FARM CALL",
            "price": "10.00",
            "path": ["CALL FEES"],
        },
        {
            "code": "32",
            "alt": "BLBS",
            "desc": "DIAGNOSTIC BASISESMOID NERVE BLOCK",
            "price": "50.00",
            "path": ["DIAGNOSTIC PROCEDURES", "NERVE BLOCKS"],
        },
        {
            "code": "33",
            "alt": "BLHV",
            "desc": "DIAGNOSTIC HIGH VOLAR NERVE BLOCK",
            "price": "50.00",
            "path": ["DIAGNOSTIC PROCEDURES", "NERVE BLOCKS"],
        },
        {
            "code": "35",
            "alt": "BLLV",
            "desc": "DIAGNOSTIC LOW VOLAR NERVE BLOCK",
            "price": "50.00",
            "path": ["DIAGNOSTIC PROCEDURES", "NERVE BLOCKS"],
        },
        {
            "code": "31",
            "alt": "BLN",
            "desc": "DIAGNOSTIC NERVE BLOCK",
            "price": "20.00",
            "path": ["DIAGNOSTIC PROCEDURES", "NERVE BLOCKS"],
        },
        {
            "code": "34",
            "alt": "BLIA",
            "desc": "DIAGNOSTIC INTRA-ARTICULAR BLOCK",
            "price": "50.00",
            "path": ["DIAGNOSTIC PROCEDURES", "JOINT BLOCKS"],
        },
        {
            "code": "3",
            "alt": "XLA",
            "desc": "RADIOGRAPH LEFT FRONT FETLOCK",
            "price": "75.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - FRONT LEG"],
        },
        {
            "code": "5",
            "alt": "XLC",
            "desc": "RADIOGRAPH LEFT FRONT CANNON BONE AND SPLINTS",
            "price": "60.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - FRONT LEG"],
        },
        {
            "code": "1",
            "alt": "XLF",
            "desc": "RADIOGRAPH OF LEFT FRONT FOOT",
            "price": "80.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - FRONT LEG"],
        },
        {
            "code": "7",
            "alt": "XLK",
            "desc": "RADIOGRAPH OF LEFT KNEE",
            "price": "90.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - FRONT LEG"],
        },
        {
            "code": "8",
            "alt": "XRK",
            "desc": "RADIOGRAPH OF RIGHT KNEE",
            "price": "90.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - FRONT LEG"],
        },
        {
            "code": "6",
            "alt": "XRC",
            "desc": "RADIOGRAPH RIGHT FRONT CANNON BONE AND SPLINTS",
            "price": "60.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - FRONT LEG"],
        },
        {
            "code": "4",
            "alt": "XRA",
            "desc": "RADIOGRAPH RIGHT FRONT FETLOCK",
            "price": "75.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - FRONT LEG"],
        },
        {
            "code": "2",
            "alt": "XRF",
            "desc": "RADIOGRAPH RIGHT FRONT FOOT",
            "price": "80.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - FRONT LEG"],
        },
        {
            "code": "9",
            "alt": "XLHC",
            "desc": "RADIOGRAPH LEFT HIND CANNON AND SPLINTS",
            "price": "60.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "13",
            "alt": "XLHA",
            "desc": "RADIOGRAPH LEFT HIND FETLOCK",
            "price": "75.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "15",
            "alt": "XLHF",
            "desc": "RADIOGRAPH LEFT HIND FOOT",
            "price": "80.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "11",
            "alt": "XLH",
            "desc": "RADIOGRAPH LEFT HOCK",
            "price": "75.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "17",
            "alt": "XLS",
            "desc": "RADIOGRAPH LEFT STIFLE",
            "price": "75.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "10",
            "alt": "XRHC",
            "desc": "RADIOGRAPH RIGHT HIND CANNON AND SPLINTS",
            "price": "60.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "14",
            "alt": "XRHA",
            "desc": "RADIOGRAPH RIGHT HIND FETLOCK",
            "price": "75.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "16",
            "alt": "XRHF",
            "desc": "RADIOGRAPH RIGHT HIND FOOT",
            "price": "80.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "12",
            "alt": "XRH",
            "desc": "RADIOGRAPH RIGHT HOCK",
            "price": "75.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "18",
            "alt": "XRS",
            "desc": "RADIOGRAPH RIGHT STIFLE",
            "price": "75.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - HIND LEG"],
        },
        {
            "code": "20",
            "alt": "X",
            "desc": "RADIOGRAPHS MULTIPLE VIEWS",
            "price": "15.00",
            "path": ["DIAGNOSTIC PROCEDURES", "RADIOLOGY - OTHER"],
        },
        {
            "code": "40",
            "alt": "UOTHER",
            "desc": "ULTRASOUND EXAM ON LEG",
            "price": "175.00",
            "path": ["DIAGNOSTIC PROCEDURES", "ULTRASOUND EXAM OF EXTREMITIES"],
        },
        {
            "code": "1017",
            "alt": "EPMT",
            "desc": "BLOOD FOR EPM TEST",
            "price": "150.00",
            "path": ["DIAGNOSTIC PROCEDURES", "OTHER"],
        },
        {
            "code": "41",
            "alt": "SCOPE",
            "desc": "ENDOSCOPIC EXAMINATION OF UPPER AIRWAY",
            "price": "50.00",
            "path": ["DIAGNOSTIC PROCEDURES", "OTHER"],
        },
        {
            "code": "7732",
            "alt": "FEC",
            "desc": "FECAL SCREEN FOR PARASITE OVA",
            "price": "20.00",
            "path": ["DIAGNOSTIC PROCEDURES", "OTHER"],
        },
        {
            "code": "7342",
            "alt": "GASTRO",
            "desc": "GASTROSCOPY WITH SEDATION",
            "price": "200.00",
            "path": ["DIAGNOSTIC PROCEDURES", "OTHER"],
        },
        {
            "code": "8801",
            "alt": "SA",
            "desc": "SERUM AMYLOID TEST",
            "price": "60.00",
            "path": ["DIAGNOSTIC PROCEDURES", "OTHER"],
        },
        {
            "code": "200",
            "alt": "DERMX",
            "desc": "DERMATOLOGICAL EXAMINATION",
            "price": "50.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "201",
            "alt": "GIX",
            "desc": "GASTRO-INTESTINAL EXAMINATION",
            "price": "50.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "204",
            "alt": "NEURX",
            "desc": "NEUROLOGIC EXAMINATION",
            "price": "35.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "205",
            "alt": "OPX",
            "desc": "OPTHALMIC EXAMINATION",
            "price": "40.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "209",
            "alt": "EXAM",
            "desc": "OTHER TYPES OF EXAMINATIONS",
            "price": "35.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "206",
            "alt": "PHX",
            "desc": "PHYSICAL EXAMINATION",
            "price": "50.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "215",
            "alt": "REEX",
            "desc": "RE-EXAMINATION",
            "price": "35.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "207",
            "alt": "RBCX",
            "desc": "RECTAL EXAMINATION",
            "price": "30.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "208",
            "alt": "RBSPX",
            "desc": "RESPIRATORY EXAMINATION",
            "price": "35.00",
            "path": ["EXAMINATIONS", "SICK HORSE EXAMS"],
        },
        {
            "code": "772",
            "alt": "BCJ",
            "desc": "BICARBONATE JUG 500 CC",
            "price": "30.00",
            "path": ["EXAMINATIONS", "OTHER EXAMS"],
        },
        {
            "code": "213",
            "alt": "CHCH",
            "desc": "CANADIAN HEALTH CERTIFICATE",
            "price": "175.00",
            "path": ["EXAMINATIONS", "OTHER EXAMS"],
        },
        {
            "code": "212",
            "alt": "HCH",
            "desc": "HEALTH CERTIFICATE",
            "price": "20.00",
            "path": ["EXAMINATIONS", "OTHER EXAMS"],
        },
        {
            "code": "211",
            "alt": "INSX",
            "desc": "INSURANCE EXAM AND PAPERWORK",
            "price": "25.00",
            "path": ["EXAMINATIONS", "OTHER EXAMS"],
        },
        {
            "code": "202",
            "alt": "LAMX",
            "desc": "LAMENESS EXAMINATION",
            "price": "50.00",
            "path": ["EXAMINATIONS", "OTHER EXAMS"],
        },
        {
            "code": "210",
            "alt": "PPE",
            "desc": "PREPURCHASE EVALUATION",
            "price": "300.00",
            "path": ["EXAMINATIONS", "OTHER EXAMS"],
        },
        {
            "code": "4567",
            "alt": None,
            "desc": "ADMINISTER EQUINE RHINITIS A VACCINE",
            "price": "30.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "5588",
            "alt": "RHI",
            "desc": "ADMINISTER EQUINE RHINITIS A VACCINE",
            "price": "30.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "3120",
            "alt": "BOT",
            "desc": "BOTULISM TOXOID",
            "price": "30.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "300",
            "alt": "EWTFR",
            "desc": "E&W ENCEPHALITIS, TETANUS, INFLUENZA, RHINOPNEUMONITIS",
            "price": "60.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "302",
            "alt": "EW",
            "desc": "EASTERN AND WESTERN ENCEPHALITIS",
            "price": "20.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "305",
            "alt": "EWT",
            "desc": "EASTERN AND WESTERN ENCEPHALITIS AND TETANUS",
            "price": "30.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "303",
            "alt": "FR",
            "desc": "INFLUENZA AND RHINOPNEUMONITIS",
            "price": "30.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "7908",
            "alt": "F",
            "desc": "INFLUENZA VACCINE",
            "price": "10.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "311",
            "alt": "FRIN",
            "desc": "INTRANASAL INFLUENZA AND RHINOPNEUMONITIS VACCINATION",
            "price": "25.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "309",
            "alt": "PHF",
            "desc": "POTOMAC HORSE FEVER VACCINE",
            "price": "30.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "307",
            "alt": "RA",
            "desc": "RABIES VACCINATION",
            "price": "30.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "304",
            "alt": "R",
            "desc": "RHINOPNEUMONITIS",
            "price": "25.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "312",
            "alt": "EPMV",
            "desc": "SARCOSYSTIS NEURONA VACCINE",
            "price": "25.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "308",
            "alt": "STR",
            "desc": "STRANGLES",
            "price": "40.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "3125",
            "alt": "TAT",
            "desc": "TETANUS ANTITOXIN",
            "price": "20.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "301",
            "alt": "TVAC",
            "desc": "TETANUS INJECTION IM",
            "price": "10.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "5410",
            "alt": "WNVB",
            "desc": "WEST NILE VACCINATION BOOSTER",
            "price": "26.50",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "140",
            "alt": "WNV",
            "desc": "WEST NILES VACCINATION",
            "price": "35.00",
            "path": ["IMMUNIZATIONS", "HORSE"],
        },
        {
            "code": "69",
            "alt": "BLOOD",
            "desc": "BLOOD ANALYSIS",
            "price": "0.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "53",
            "alt": "COG",
            "desc": "COGGINS TEST FOR EIA",
            "price": "65.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "52",
            "alt": "CHEM",
            "desc": "COMPLETE BLOOD CHEMISTRY",
            "price": "65.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "50",
            "alt": "CBC",
            "desc": "COMPLETE BLOOD COUNT",
            "price": "35.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "51",
            "alt": "BTS",
            "desc": "COMPLETE BLOOD COUNT AND CHEMISTRY",
            "price": "100.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "9995",
            "alt": "DRUG",
            "desc": "DRUG SCREEN",
            "price": "300.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "9754",
            "alt": "PIRO",
            "desc": "PIROPLASMOSIS TESTING FOR EXPORT/TRAVEL PURPOSE",
            "price": "130.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "60",
            "alt": "FIB",
            "desc": "SERUM FIBRINOGEN",
            "price": "75.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "116",
            "alt": "SI",
            "desc": "SERUM IRON LEVEL",
            "price": "30.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "62",
            "alt": "SGOT",
            "desc": "SERUM SGOT AND CPK",
            "price": "35.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "55",
            "alt": "LYME",
            "desc": "SERUM TITER FOR LYMES DISEASE",
            "price": "60.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "9996",
            "alt": "T3T4",
            "desc": "THYROID ANALYSIS",
            "price": "100.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "61",
            "alt": "T3",
            "desc": "THYROID ASSAY T3 AND T4",
            "price": "100.00",
            "path": ["LABORATORY PROCEDURES", "BLOOD WORK"],
        },
        {
            "code": "70",
            "alt": "C/S",
            "desc": "BACTERIAL CULTURE AND SENSITIVITY",
            "price": "60.00",
            "path": ["LABORATORY PROCEDURES", "OTHER"],
        },
        {
            "code": "75",
            "alt": "CYT",
            "desc": "CYTOLOGY",
            "price": "65.00",
            "path": ["LABORATORY PROCEDURES", "OTHER"],
        },
        {
            "code": "71",
            "alt": "TTW",
            "desc": "TRANS TRACHAEL WASH",
            "price": "150.00",
            "path": ["LABORATORY PROCEDURES", "OTHER"],
        },
        {
            "code": "271",
            "alt": "COMBO",
            "desc": "BCP AND EQUIPOSE 3 ML",
            "price": "45.00",
            "path": ["MEDICATION ADMINISTERED", "ANABOLIC STEROIDS"],
        },
        {
            "code": "670",
            "alt": "B",
            "desc": "EQUIPOSE INJECTION",
            "price": "35.00",
            "path": ["MEDICATION ADMINISTERED", "ANABOLIC STEROIDS"],
        },
        {
            "code": "674",
            "alt": "TEST",
            "desc": "TESTOSTERONE INJECTION IM",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "ANABOLIC STEROIDS"],
        },
        {
            "code": "676",
            "alt": "W",
            "desc": "WINSTROL INJECTION",
            "price": "42.00",
            "path": ["MEDICATION ADMINISTERED", "ANABOLIC STEROIDS"],
        },
        {
            "code": "8920",
            "alt": "EXC",
            "desc": "ADMINISTER 4 DAY TREATMENT WITH EXCEED",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "ANTIBIOTICS"],
        },
        {
            "code": "25",
            "alt": "BAYI",
            "desc": "BAYTRIL INJECTION IV",
            "price": "38.00",
            "path": ["MEDICATION ADMINISTERED", "ANTIBIOTICS"],
        },
        {
            "code": "814",
            "alt": "DVGEN",
            "desc": "EXAM, DISPENSE BOTTLE OF GENTAMICIN SULFATE",
            "price": "50.00",
            "path": ["MEDICATION ADMINISTERED", "ANTIBIOTICS"],
        },
        {
            "code": "998",
            "alt": "AMP",
            "desc": "INJECTION OF AMPICILLIN IV",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "ANTIBIOTICS"],
        },
        {
            "code": "607",
            "alt": "GEN",
            "desc": "INJECTION OF GENTAMYCIN SULFATE",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "ANTIBIOTICS"],
        },
        {
            "code": "600",
            "alt": "PPG",
            "desc": "INJECTION OF PROCAINE PENICILLIN G",
            "price": "10.00",
            "path": ["MEDICATION ADMINISTERED", "ANTIBIOTICS"],
        },
        {
            "code": "608",
            "alt": "TET",
            "desc": "INJECTION OF TETRACYCLINE IV",
            "price": "30.00",
            "path": ["MEDICATION ADMINISTERED", "ANTIBIOTICS"],
        },
        {
            "code": "610",
            "alt": "NAX",
            "desc": "NAXCEL INJECTION",
            "price": "30.00",
            "path": ["MEDICATION ADMINISTERED", "ANTIBIOTICS"],
        },
        {
            "code": "22",
            "alt": "NAQI",
            "desc": "INJECTION OF NAQUASONE IV",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "DIURETICS"],
        },
        {
            "code": "760",
            "alt": "LAS",
            "desc": "LASIX INJECTION",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "DIURETICS"],
        },
        {
            "code": "892",
            "alt": "JUG6",
            "desc": "6 LITRES OF SALINE ADMINISTERED WITH VITAMINS",
            "price": "140.00",
            "path": ["MEDICATION ADMINISTERED", "FLUIDS ADMINISTERED"],
        },
        {
            "code": "770",
            "alt": "JUG",
            "desc": "ONE LITER OF LACTATED RINGERS",
            "price": "24.00",
            "path": ["MEDICATION ADMINISTERED", "FLUIDS ADMINISTERED"],
        },
        {
            "code": "778",
            "alt": "NAI",
            "desc": "SODIUM IODIDE JUG",
            "price": "35.00",
            "path": ["MEDICATION ADMINISTERED", "FLUIDS ADMINISTERED"],
        },
        {
            "code": "703",
            "alt": "OIL",
            "desc": "TUBE WITH ONE GALLON MINERAL OIL",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "GASTROINTESTINAL TREATMENTS"],
        },
        {
            "code": "992",
            "alt": "KZ",
            "desc": "INTRA-ARTICULAR INJ. OF CARPAL JOINT WITH ZEEL & TRAUMBEL",
            "price": "100.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "991",
            "alt": "AZ",
            "desc": "INTRA-ARTICULAR INJ. OF FETLOCK JOINT WITH ZEEL & TRAUMEEL",
            "price": "100.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "993",
            "alt": "HZ",
            "desc": "INTRA-ARTICULAR INJ. OF HOCK JOINT WITH ZEEL & TRAUMBEL",
            "price": "100.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "994",
            "alt": "SZ",
            "desc": "INTRA-ARTICULAR INJ. OF STIFLE JOINT WITH ZEEL & TRAUMBEL",
            "price": "100.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "720",
            "alt": "KC",
            "desc": "INTRA-ARTICULAR INJECTION OF CARPAL JOINT",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "721",
            "alt": "KH",
            "desc": "INTRA-ARTICULAR INJECTION OF CARPAL JOINT WITH ACID",
            "price": "130.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "738",
            "alt": "CC",
            "desc": "INTRA-ARTICULAR INJECTION OF COFFIN JOINT",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "433",
            "alt": "CH",
            "desc": "INTRA-ARTICULAR INJECTION OF COFFIN JOINT WITH ACID",
            "price": "130.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "990",
            "alt": "CZ",
            "desc": "INTRA-ARTICULAR INJECTION OF COFFIN JOINT WITH ZEEL & TRAUMBEL",
            "price": "100.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "723",
            "alt": "AC",
            "desc": "INTRA-ARTICULAR INJECTION OF FETLOCK JOINT",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "724",
            "alt": "AH",
            "desc": "INTRA-ARTICULAR INJECTION OF FETLOCK JOINT WITH ACID",
            "price": "130.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "124",
            "alt": "SC",
            "desc": "INTRA-ARTICULAR INJECTION OF STIFLE",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "726",
            "alt": "HC",
            "desc": "INTRA-ARTICULAR INJECTION OF TARSAL JOINT",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "727",
            "alt": "HH",
            "desc": "INTRA-ARTICULAR INJECTION OF TARSAL JOINT WITH ACID",
            "price": "130.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "125",
            "alt": "SH",
            "desc": "INTRA-ARTICULAR INJECTION OF THE STIFLE JOINT WITH ACID",
            "price": "125.00",
            "path": ["MEDICATION ADMINISTERED", "INTRA-ARTICULAR INJECTIONS"],
        },
        {
            "code": "680",
            "alt": "ACTH",
            "desc": "ACTH INJECTION",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER HORMONES"],
        },
        {
            "code": "681",
            "alt": "EST",
            "desc": "ESTRONE INJECTION",
            "price": "30.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER HORMONES"],
        },
        {
            "code": "682",
            "alt": "HCG",
            "desc": "HCG INJECTION",
            "price": "35.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER HORMONES"],
        },
        {
            "code": "1251",
            "alt": "DEPO",
            "desc": "INJECTION OF DEPO-PROVERA",
            "price": "50.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER HORMONES"],
        },
        {
            "code": "683",
            "alt": "LEVO",
            "desc": "LEVOTHYROXINE INJECTION",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER HORMONES"],
        },
        {
            "code": "404",
            "alt": "BCP",
            "desc": "TREATMENT WITH BCP",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER HORMONES"],
        },
        {
            "code": "733",
            "alt": "ADIM",
            "desc": "INJECTION OF ADEQUAN IM",
            "price": "70.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "700",
            "alt": "XP",
            "desc": "INJECTION OF DISTAL RADIAL PHYSES",
            "price": "100.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "742",
            "alt": "MGS",
            "desc": "INJECTION OF GLUTEAL MUSCLES, EPAXIAL MUSCLES AND STIFLES",
            "price": "90.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "1018",
            "alt": "HAIV",
            "desc": "INJECTION OF HYALURONIC ACID IV",
            "price": "50.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "740",
            "alt": "ZT",
            "desc": "INJECTION OF ZEEL AND TRAUMEEL",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "743",
            "alt": "S",
            "desc": "INTERNAL BLISTER OF STIFLE",
            "price": "80.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "792",
            "alt": "MG",
            "desc": "INTERNAL BLISTER OF THE BACK, STIFLE AND WHORL BONES",
            "price": "120.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "751",
            "alt": "LF",
            "desc": "NON-ARTICULAR INJECTION OF LEFT FRONT LEG",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "748",
            "alt": "LH",
            "desc": "NON-ARTICULAR INJECTION OF LEFT HIND LEG",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "750",
            "alt": "RF",
            "desc": "NON-ARTICULAR INJECTION OF RIGHT FRONT LEG",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "749",
            "alt": "RH",
            "desc": "NON-ARTICULAR INJECTION OF THE RIGHT HIND LEG",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "4876",
            "alt": "POLY",
            "desc": "POLYGLYCAN IV 5CC",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "741",
            "alt": "FBB",
            "desc": "PROFESSIONAL SERVICES FEET",
            "price": "100.00",
            "path": ["MEDICATION ADMINISTERED", "NON-ARTICULAR INJECTIONS"],
        },
        {
            "code": "640",
            "alt": "BAN",
            "desc": "BANAMINE INJECTION",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "641",
            "alt": "BUT",
            "desc": "BUTAZOLIDIN INJECTION",
            "price": "12.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "643",
            "alt": "DMSOJ",
            "desc": "DMSO INJECTION IN 1 LITER FLUIDS",
            "price": "30.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "138",
            "alt": "ADN",
            "desc": "INJECTION OF ADENOSINE IM",
            "price": "10.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "649",
            "alt": "ASA",
            "desc": "INJECTION OF ASPIRIN IV",
            "price": "10.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "660",
            "alt": "DEX",
            "desc": "INJECTION OF DEXAMETHASONE",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "642",
            "alt": "NOV",
            "desc": "INJECTION OF DIPYRONE",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "995",
            "alt": "DMSO",
            "desc": "INJECTION OF DMSO IV",
            "price": "10.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "663",
            "alt": "FLUC",
            "desc": "INJECTION OF FLUCORT",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "666",
            "alt": "VETA",
            "desc": "INJECTION OF VETALOG",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "621",
            "alt": "KET",
            "desc": "KETOFEN INJECTION",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "648",
            "alt": "ROB",
            "desc": "ROBAXIN INJECTION",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "553",
            "alt": "RVI",
            "desc": "RVI INJECTION",
            "price": "30.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "84",
            "alt": "VOR",
            "desc": "TREATMENT WITH VOREN",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "NSAID'S ANALGESICS"],
        },
        {
            "code": "688",
            "alt": "DET",
            "desc": "INJECTION OF DETOMIDINE HCL",
            "price": "30.00",
            "path": ["MEDICATION ADMINISTERED", "TRANQUILIZERS & ANESTHETICS"],
        },
        {
            "code": "1020",
            "alt": "PRO",
            "desc": "INJECTION OF PROLIXIN IM",
            "price": "45.00",
            "path": ["MEDICATION ADMINISTERED", "TRANQUILIZERS & ANESTHETICS"],
        },
        {
            "code": "693",
            "alt": "XYL",
            "desc": "INJECTION OF ROMPUN",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "TRANQUILIZERS & ANESTHETICS"],
        },
        {
            "code": "549",
            "alt": "XY",
            "desc": "INJECTION OF XYLAZINE",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "TRANQUILIZERS & ANESTHETICS"],
        },
        {
            "code": "699",
            "alt": "TO",
            "desc": "TRANQUILIZE",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "TRANQUILIZERS & ANESTHETICS"],
        },
        {
            "code": "690",
            "alt": "ACB",
            "desc": "TRANQUILIZE WITH ACEPROMAZINE",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "TRANQUILIZERS & ANESTHETICS"],
        },
        {
            "code": "692",
            "alt": "RES",
            "desc": "TRANQUILIZE WITH RESERPINE",
            "price": "35.00",
            "path": ["MEDICATION ADMINISTERED", "TRANQUILIZERS & ANESTHETICS"],
        },
        {
            "code": "1260",
            "alt": "RK",
            "desc": "TRANQUILIZE WITH ROMPUM AND KETAMINE",
            "price": "50.00",
            "path": ["MEDICATION ADMINISTERED", "TRANQUILIZERS & ANESTHETICS"],
        },
        {
            "code": "5961",
            "alt": "BC2A",
            "desc": "BC2A PASTE 88 GRAM TUBE",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "9233",
            "alt": "FOL",
            "desc": "FOLIC ACID INJECTION",
            "price": "0.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "623",
            "alt": "BCOM",
            "desc": "INJECTION OF B-COMPLEX",
            "price": "10.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "222",
            "alt": "CIC",
            "desc": "INJECTION OF CACO IRON COPPER",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "671",
            "alt": "CAL",
            "desc": "INJECTION OF CALCIUM",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "220",
            "alt": "CA",
            "desc": "INJECTION OF CALCIUM",
            "price": "10.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "620",
            "alt": "CMPK",
            "desc": "INJECTION OF CALCIUM, MAGNESIUM AND PHOSPHORUS",
            "price": "10.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "555",
            "alt": "HIP",
            "desc": "INJECTION OF HIPIRON",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "536",
            "alt": "IAS",
            "desc": "INJECTION OF IRON ARSENIC AND STRYCHNINE",
            "price": "10.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "629",
            "alt": "VITC",
            "desc": "INJECTION OF VITAMIN C",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "626",
            "alt": "VITES",
            "desc": "INJECTION OF VITAMIN E AND SELENIUM",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "1261",
            "alt": "VR",
            "desc": "INJECTION OF VITAMIN RED",
            "price": "40.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "796",
            "alt": "PRDI",
            "desc": "POST RACE DRENCH WITH IRON AND VITAMINS",
            "price": "50.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "791",
            "alt": "PTD",
            "desc": "POST TRAINING DRENCH",
            "price": "50.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "794",
            "alt": "PTDI",
            "desc": "POST TRAINING DRENCH WITH ELECTROLYTES AND BLOODSHOT",
            "price": "70.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "630",
            "alt": "FA",
            "desc": "TREATMENT WITH FOLIC ACID SUPPLEMENT",
            "price": "30.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "628",
            "alt": "VBB",
            "desc": "VITAMIN BLOOD BUILDER",
            "price": "28.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "625",
            "alt": "BSB",
            "desc": "VITAMIN BSE INJECTION",
            "price": "120.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "632",
            "alt": "VIT",
            "desc": "VITAMIN INJECTION",
            "price": "0.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "619",
            "alt": "CMPKJ",
            "desc": "VITAMIN JUG WITH CALCIUM, MAGNISIUM AND PHOSPHORUS",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "VITAMINS"],
        },
        {
            "code": "9228",
            "alt": "AMI",
            "desc": "AMICAR INJECTION",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "6066",
            "alt": "BAYC",
            "desc": "BAYCOX (TOLAZATRIL PASTE-2 DOSES)",
            "price": "162.50",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "4019",
            "alt": "DBPENT",
            "desc": "EXAM, DISPENSE BOTTLE OF PENTOSAN",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "9876",
            "alt": "IMOD",
            "desc": "IMMUNOMODULATOR",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "996",
            "alt": "ACTL",
            "desc": "INJECTION OF ACETYLCYSTEINE",
            "price": "22.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "30",
            "alt": "CAM",
            "desc": "INJECTION OF CAMPHOR (GOMENOL)",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "790",
            "alt": "BS",
            "desc": "INJECTION OF EQUISTIM IV",
            "price": "30.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "2000",
            "alt": "GLU",
            "desc": "INJECTION OF GLUCOSAMINE",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "645",
            "alt": "LAC",
            "desc": "INJECTION OF LACTANASE IV",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "421",
            "alt": "LIPO",
            "desc": "INJECTION OF LIPOTROPES IV",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "85",
            "alt": "PB",
            "desc": "INJECTION OF P-BLOCK",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "7789",
            "alt": "INT",
            "desc": "INTERFERON F2A 250 ML BOTTLE 100 UNITS PER DOSE",
            "price": "150.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "8111",
            "alt": "LARG",
            "desc": "L ARGININE",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "571",
            "alt": "MMA",
            "desc": "MISCELLANEOUS MEDICATION ADMINISTERED",
            "price": "0.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "3091",
            "alt": "PENT",
            "desc": "PENTOSAN INJECTION",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "797",
            "alt": "B",
            "desc": "POST EXERCISE MEDICATION FOR BLEEDING",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "985",
            "alt": "BP",
            "desc": "POST EXERCISE MEDICATION FOR BLEEDING AND PAIN",
            "price": "45.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "801",
            "alt": "BR",
            "desc": "POST EXERCISE MEDICATION FOR BLEEDING AND RESPIRATORY",
            "price": "35.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "802",
            "alt": "BT",
            "desc": "POST EXERCISE MEDICATION FOR BLEEDING AND TYING-UP",
            "price": "35.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "691",
            "alt": "BRT",
            "desc": "POST EXERCISE MEDICATION FOR BLEEDING, BREATHING AND TYING UP",
            "price": "50.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "916",
            "alt": "BPR",
            "desc": "POST EXERCISE MEDICATION FOR BLEEDING, PAIN AND RESPIRATORY",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "917",
            "alt": "BPT",
            "desc": "POST EXERCISE MEDICATION FOR BLEEDING, PAIN AND TYING-UP",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "798",
            "alt": "P",
            "desc": "POST EXERCISE MEDICATION FOR PAIN",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "806",
            "alt": "PR",
            "desc": "POST EXERCISE MEDICATION FOR PAIN AND RESPIRATORY",
            "price": "40.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "807",
            "alt": "PT",
            "desc": "POST EXERCISE MEDICATION FOR PAIN AND TYING-UP",
            "price": "40.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "918",
            "alt": "PRT",
            "desc": "POST EXERCISE MEDICATION FOR PAIN, RESPIRATORY AND TYINGUP-",
            "price": "65.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "805",
            "alt": "TU",
            "desc": "POST EXERCISE MEDICATION FOR TYING-UP",
            "price": "60.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "960",
            "alt": "BPRT",
            "desc": "POST EXERCISE MEDS. FOR BREATHING, PAIN, RESP. AND TYING-UP",
            "price": "75.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "539",
            "alt": "RESP",
            "desc": "RESPIRATORY TREATMENT",
            "price": "20.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "262",
            "alt": "ROBIN",
            "desc": "ROBINUL INJECTION IV",
            "price": "15.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "154",
            "alt": "ATP",
            "desc": "TREATMENT WITH ATP",
            "price": "25.00",
            "path": ["MEDICATION ADMINISTERED", "OTHER"],
        },
        {
            "code": "979",
            "alt": "R1000",
            "desc": "EXAM DISPENSE BOTTLE OF REGUMATE 1000 CC",
            "price": "350.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "146",
            "alt": "DBEST",
            "desc": "EXAM DISPENSE ONE BOTTLE OF ESTRONE",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "687",
            "alt": "DBACTH",
            "desc": "EXAM, DISPENSE BOTTLE OF ACTH",
            "price": "55.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "1009",
            "alt": "DBADC",
            "desc": "EXAM, DISPENSE BOTTLE OF ADRENAL CORTEX 50 CC",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "1254",
            "alt": "DBDEPO",
            "desc": "EXAM, DISPENSE BOTTLE OF DEPO-PROVERA 30 ML",
            "price": "225.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "981",
            "alt": "DBBCP",
            "desc": "EXAM, DISPENSE BOTTLE OF ECP",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "970",
            "alt": "DBES",
            "desc": "EXAM, DISPENSE BOTTLE OF EQUI-STEM",
            "price": "240.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "982",
            "alt": "DBHCG",
            "desc": "EXAM, DISPENSE BOTTLE OF HCG",
            "price": "70.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "684",
            "alt": "DBLEVO",
            "desc": "EXAM, DISPENSE BOTTLE OF LEVOTHYROXINE",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "980",
            "alt": "TL",
            "desc": "EXAM, DISPENSE THYROL -POWDER",
            "price": "55.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "6098",
            "alt": "PURG",
            "desc": "PURGOLIDE MESTILATE 1MG/ML 120 ML BOTTLE",
            "price": "150.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "8854",
            "alt": "TLL",
            "desc": "THROID POWDER LARGE BUCKET",
            "price": "250.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER HORMONES"],
        },
        {
            "code": "800",
            "alt": "DVAMP",
            "desc": "EXAM, DISPENSE BOTTLE OF AMPICILLIN",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - PENICILLINS"],
        },
        {
            "code": "8500",
            "alt": "DBPPG2",
            "desc": "EXAM, DISPENSE BOTTLE OF PROCAINE PENNICILLIN 250ML",
            "price": "45.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - PENICILLINS"],
        },
        {
            "code": "804",
            "alt": "DBPPG",
            "desc": "EXAM, DISPENSE BOTTLE OF PROCAINE PENNICILLIN G 100 CC'S",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - PENICILLINS"],
        },
        {
            "code": "857",
            "alt": "DBGEN",
            "desc": "EXAM, DISPENSE BOTTLE OF GENTOCIN 100 ML",
            "price": "70.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "858",
            "alt": "DBGBN2",
            "desc": "EXAM, DISPENSE BOTTLE OF GENTOCIN 250 ML",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "37",
            "alt": "DBBAYI",
            "desc": "EXAM, DISPENSE BOTTLE OF INJECTABLE BAYTRIL",
            "price": "300.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "826",
            "alt": "DBNAX",
            "desc": "EXAM, DISPENSE BOTTLE OF NAXCEL",
            "price": "105.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "817",
            "alt": "DBTET",
            "desc": "EXAM, DISPENSE BOTTLE OF TETRACYCLINE 250CC'S",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "819",
            "alt": "DBDOX",
            "desc": "EXAM, DISPENSE CONTAINER OF DOXYCYCLINE HYCLATE POWDER",
            "price": "250.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "1015",
            "alt": "SMZS",
            "desc": "EXAM, DISPENSE SMZ SYRUP",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "544",
            "alt": "DBEPM",
            "desc": "EXAM, DISPENSE TREATMENT WITH EPM MEDICATION",
            "price": "155.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "820",
            "alt": "DBTMS5",
            "desc": "EXAM, DISPENSE TRIMETHOPRIM SULFA PILLS #500",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "63",
            "alt": "TUCO",
            "desc": "EXAM, DISPENSE TUCOPRIM POWDER",
            "price": "45.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "3906",
            "alt": "DBBAYL",
            "desc": "LARGE BOTTLE OF BAYTRIL 100 MG PER ML. 250 CC BOTTLE",
            "price": "0.00",
            "path": ["MEDICATIONS DISPENSED", "ANTIBIOTICS - OTHER"],
        },
        {
            "code": "927",
            "alt": "VC",
            "desc": "EXAM, DISPENSE ONE CASE OF VETWRAP",
            "price": "72.00",
            "path": ["MEDICATIONS DISPENSED", "BANDAGES & MATERIALS"],
        },
        {
            "code": "923",
            "alt": "COT",
            "desc": "EXAM, DISPENSE ONE ROLL OF COTTON",
            "price": "10.00",
            "path": ["MEDICATIONS DISPENSED", "BANDAGES & MATERIALS"],
        },
        {
            "code": "926",
            "alt": "V",
            "desc": "EXAM, DISPENSE ONE ROLL OF VETWRAP",
            "price": "3.00",
            "path": ["MEDICATIONS DISPENSED", "BANDAGES & MATERIALS"],
        },
        {
            "code": "988",
            "alt": "FUL",
            "desc": "EXAM, DISPENSE FULVICIN LARGE-",
            "price": "50.00",
            "path": ["MEDICATIONS DISPENSED", "DERMATITIS/TOPICAL ANTISEPTICS"],
        },
        {
            "code": "900",
            "alt": "NOLV",
            "desc": "EXAM, DISPENSE NOLVASAN OINTMENT",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "DERMATITIS/TOPICAL ANTISEPTICS"],
        },
        {
            "code": "899",
            "alt": "NOLVL",
            "desc": "EXAM, DISPENSE NOLVESAN LARGE",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "DERMATITIS/TOPICAL ANTISEPTICS"],
        },
        {
            "code": "1016",
            "alt": "SSD",
            "desc": "EXAM, DISPENSE SILVER SULFADIAZINE CREAM",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "DERMATITIS/TOPICAL ANTISEPTICS"],
        },
        {
            "code": "28",
            "alt": "DBNAQI",
            "desc": "EXAM, DISPENSE BOTTLE INJECTABLE NAQUASONE",
            "price": "35.00",
            "path": ["MEDICATIONS DISPENSED", "DIURETICS"],
        },
        {
            "code": "592",
            "alt": "DBLAS",
            "desc": "EXAM, DISPENSE BOTTLE OF LASIX",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "DIURETICS"],
        },
        {
            "code": "1257",
            "alt": "LR",
            "desc": "EXAM, DISPENSE 1 LITER LACTATED RINGERS",
            "price": "8.00",
            "path": ["MEDICATIONS DISPENSED", "FLUIDS"],
        },
        {
            "code": "1250",
            "alt": "DBCAR",
            "desc": "CARAFATE TABLETS",
            "price": "120.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "863",
            "alt": "FUR",
            "desc": "EXAM, DISPENSE 1 LB FURACIN OINTMENT",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "1252",
            "alt": "DBLACL",
            "desc": "EXAM, DISPENSE LARGE BOTTLE OF LACTANASE 100CC",
            "price": "130.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "358",
            "alt": "DGPB",
            "desc": "EXAM, DISPENSE ONE GALLON OF PEPTO BISMOL",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "1010",
            "alt": "LACP",
            "desc": "EXAM, DISPENSE ONE TUBE OF LACTANASE PASTE",
            "price": "15.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "655",
            "alt": "PROBP",
            "desc": "EXAM, DISPENSE PROBIAS PASTE",
            "price": "15.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "656",
            "alt": "PROB",
            "desc": "EXAM, DISPENSE PROBIAS POWDER",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "1002",
            "alt": "FULP",
            "desc": "EXAM, DISPENSE TUBE OF FULVICIN PASTE 12.5g",
            "price": "28.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "1003",
            "alt": "LEVP",
            "desc": "EXAM, DISPENSE TUBE OF LEVAMISOLE PASTE",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "144",
            "alt": "OMBP",
            "desc": "EXAM, DISPENSE TUBE OF OMEPRAZOLE",
            "price": "18.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "43",
            "alt": "GG",
            "desc": "TREATMENT WITH GASTROGUARD ONE DOSE",
            "price": "50.00",
            "path": ["MEDICATIONS DISPENSED", "G.I. MEDICATIONS"],
        },
        {
            "code": "894",
            "alt": "DBNOV",
            "desc": "EXAM, DISPENSE 1 BOTTLE DIPYRONE 100 ML",
            "price": "50.00",
            "path": ["MEDICATIONS DISPENSED", "INJECTABLE NSAID'S"],
        },
        {
            "code": "893",
            "alt": "DBANB",
            "desc": "EXAM, DISPENSE BOTTLE OF BANAMINE 100 CC",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "INJECTABLE NSAID'S"],
        },
        {
            "code": "6210",
            "alt": "DBKET",
            "desc": "EXAM, DISPENSE BOTTLE OF KETOFEN",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "INJECTABLE NSAID'S"],
        },
        {
            "code": "229",
            "alt": "DBLAC",
            "desc": "EXAM, DISPENSE BOTTLE OF LACTANASE",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "INJECTABLE NSAID'S"],
        },
        {
            "code": "891",
            "alt": "DBUTB",
            "desc": "EXAM, DISPENSE BOTTLE OF PHENYLBUTAZONE 100 CC",
            "price": "28.00",
            "path": ["MEDICATIONS DISPENSED", "INJECTABLE NSAID'S"],
        },
        {
            "code": "837",
            "alt": "DBBUT",
            "desc": "EXAM, DISPENSE BOTTLE OF PHENYLBUTAZONE TABLETS 1g",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "INJECTABLE NSAID'S"],
        },
        {
            "code": "47",
            "alt": "DBRVI",
            "desc": "EXAM, DISPENSE BOTTLE OF RVI",
            "price": "125.00",
            "path": ["MEDICATIONS DISPENSED", "INJECTABLE NSAID'S"],
        },
        {
            "code": "8904",
            "alt": "DBANBL",
            "desc": "EXAM, DISPENSE ONE BOTTLE FLUNIXIN 250CC",
            "price": "140.00",
            "path": ["MEDICATIONS DISPENSED", "INJECTABLE NSAID'S"],
        },
        {
            "code": "4798",
            "alt": "POLY",
            "desc": "BOTTLE OF POLYGLYCAN",
            "price": "120.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER INJECTABLE ANTI-INFLAM."],
        },
        {
            "code": "901",
            "alt": "DBDBX",
            "desc": "EXAM, DISPENSE BOTTLE OF DEXAMETHASONE 100ML",
            "price": "44.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER INJECTABLE ANTI-INFLAM."],
        },
        {
            "code": "903",
            "alt": "DBFLU",
            "desc": "EXAM, DISPENSE BOTTLE OF FLUCORT",
            "price": "70.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER INJECTABLE ANTI-INFLAM."],
        },
        {
            "code": "1019",
            "alt": "DBHAIV",
            "desc": "EXAM, DISPENSE BOTTLE OF HYALURONIC ACID IV",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER INJECTABLE ANTI-INFLAM."],
        },
        {
            "code": "46",
            "alt": "DBP",
            "desc": "EXAM, DISPENSE BOTTLE OF P-BLOC",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER INJECTABLE ANTI-INFLAM."],
        },
        {
            "code": "1014",
            "alt": "DBVOR",
            "desc": "EXAM, DISPENSE BOTTLE OF VOREN",
            "price": "80.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER INJECTABLE ANTI-INFLAM."],
        },
        {
            "code": "147",
            "alt": "DBGLU",
            "desc": "TREATMENT WITH ONE BOTTLE GLUCOSAMINE",
            "price": "60.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER INJECTABLE ANTI-INFLAM."],
        },
        {
            "code": "1012",
            "alt": "CHOND",
            "desc": "EXAM, DISPENSE CHONDROCARB JOINT SUPPLEMENT",
            "price": "80.00",
            "path": ["MEDICATIONS DISPENSED", "INTRA-ARTICULAR PRODUCTS"],
        },
        {
            "code": "368",
            "alt": "T",
            "desc": "EXAM, DISPENSE ONE VIAL OF TRAUMBEL",
            "price": "8.00",
            "path": ["MEDICATIONS DISPENSED", "INTRA-ARTICULAR PRODUCTS"],
        },
        {
            "code": "367",
            "alt": "Z",
            "desc": "EXAM, DISPENSE ONE VIAL OF ZEEL",
            "price": "8.00",
            "path": ["MEDICATIONS DISPENSED", "INTRA-ARTICULAR PRODUCTS"],
        },
        {
            "code": "879",
            "alt": "DMSOP",
            "desc": "EXAM, DISPENSE DMSO 1 PINT",
            "price": "35.00",
            "path": ["MEDICATIONS DISPENSED", "LEG PREPARATIONS"],
        },
        {
            "code": "882",
            "alt": "DMSOG",
            "desc": "EXAM, DISPENSE DMSO GEL",
            "price": "15.00",
            "path": ["MEDICATIONS DISPENSED", "LEG PREPARATIONS"],
        },
        {
            "code": "881",
            "alt": "FURSW",
            "desc": "EXAM, DISPENSE ONE PT FURACIN SWEAT",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "LEG PREPARATIONS"],
        },
        {
            "code": "36",
            "alt": "RIT",
            "desc": "EXAM, TREATMENT WITH RITE'S PAINT",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "LEG PREPARATIONS"],
        },
        {
            "code": "953",
            "alt": "N19B",
            "desc": 'BOX OF 19 X 1 1/2" NEEDLES',
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "933",
            "alt": "N16B",
            "desc": "EXAM, DISPENSE 16G NEEDLES 100 CT.",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "937",
            "alt": "N20B",
            "desc": "EXAM, DISPENSE 20g NEEDLES 100 CT.",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "935",
            "alt": "N18B",
            "desc": "EXAM, DISPENSE BOX 18 G NEEDLES",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "944",
            "alt": "S12B",
            "desc": "EXAM, DISPENSE BOX OF 12 CC SYRINGES",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "946",
            "alt": "S20B",
            "desc": "EXAM, DISPENSE BOX OF 20 CC SYRINGES",
            "price": "35.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "940",
            "alt": "S3B",
            "desc": "EXAM, DISPENSE BOX OF 3 CC SYRINGES",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "947",
            "alt": "S35B",
            "desc": "EXAM, DISPENSE BOX OF 35 CC SYRINGES",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "948",
            "alt": "S6B",
            "desc": "EXAM, DISPENSE BOX OF 6 CC SYRINGES",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "950",
            "alt": "S60B",
            "desc": "EXAM, DISPENSE BOX OF 60 CC SYRINGES",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "951",
            "alt": "DS",
            "desc": "EXAM, DISPENSE DOSING SYRINGE",
            "price": "4.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "949",
            "alt": "S60",
            "desc": "EXAM, DISPENSE ONE 60 CC SYRINGE",
            "price": "2.00",
            "path": ["MEDICATIONS DISPENSED", "NEEDLES & SYRINGES"],
        },
        {
            "code": "7023",
            "alt": None,
            "desc": "100 SCOOP APPLE FLAVORED PHENYLBUTAZONE POWDER",
            "price": "45.00",
            "path": ["MEDICATIONS DISPENSED", "ORAL NSAID'S"],
        },
        {
            "code": "4960",
            "alt": "BQUI",
            "desc": "BQUIOX PASTE",
            "price": "0.00",
            "path": ["MEDICATIONS DISPENSED", "ORAL NSAID'S"],
        },
        {
            "code": "82",
            "alt": "DBARQ",
            "desc": "EXAM, DISPENSE BOTTLE OF ARQUEL",
            "price": "50.00",
            "path": ["MEDICATIONS DISPENSED", "ORAL NSAID'S"],
        },
        {
            "code": "897",
            "alt": "DBASA",
            "desc": "EXAM, DISPENSE ONE BOTTLE OF ASPIRIN 100 ML",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "ORAL NSAID'S"],
        },
        {
            "code": "24",
            "alt": "DBANP",
            "desc": "EXAM, DISPENSE TREATMENT WITH BANAMINE PASTE",
            "price": "45.00",
            "path": ["MEDICATIONS DISPENSED", "ORAL NSAID'S"],
        },
        {
            "code": "836",
            "alt": "DPB12",
            "desc": "EXAM, DISPENSE TUBE OF PHENYLBUTAZONE PASTE 12g",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "ORAL NSAID'S"],
        },
        {
            "code": "6051",
            "alt": "BUTP",
            "desc": "ORAL PHENYLBUTAZONE POWDER 100 SCOOP CONTAINER",
            "price": "45.00",
            "path": ["MEDICATIONS DISPENSED", "ORAL NSAID'S"],
        },
        {
            "code": "905",
            "alt": "DBPRED",
            "desc": "EXAM, DISPENSE 1000CT BOTTLE PREDNISOLONE 20MG TABS.",
            "price": "120.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER ORAL ANTI-INFLAM."],
        },
        {
            "code": "851",
            "alt": "IS",
            "desc": "EXAM, DISPENSE ISOXSUPRINE TABLETS",
            "price": "42.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER ORAL ANTI-INFLAM."],
        },
        {
            "code": "852",
            "alt": "NAQ",
            "desc": "EXAM, DISPENSE NAQUASONE BOLUS",
            "price": "5.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER ORAL ANTI-INFLAM."],
        },
        {
            "code": "21",
            "alt": "NAQP",
            "desc": "EXAM, DISPENSE NAQUASONE PASTE",
            "price": "28.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER ORAL ANTI-INFLAM."],
        },
        {
            "code": "6033",
            "alt": "UCII",
            "desc": "FLEXADIN UCII POWDER ORAL",
            "price": "167.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER ORAL ANTI-INFLAM."],
        },
        {
            "code": "527",
            "alt": "O",
            "desc": "EXAM AND DISPENSE OPTHALMIC MEDICATION",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "OPHTHALMIC DRUGS"],
        },
        {
            "code": "29",
            "alt": "DBCAM",
            "desc": "EXAM DISPENSE BOTTLE OF CAMPHOR",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "554",
            "alt": "ALB",
            "desc": "EXAM, DISPENSE ALBUTEROL SYRUP",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "533",
            "alt": "BH",
            "desc": "EXAM, DISPENSE ANTIHISTAMINE GRANULES",
            "price": "35.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "997",
            "alt": "DBACTL",
            "desc": "EXAM, DISPENSE BOTTLE OF ACETYLCYSTEINE 100 CC",
            "price": "60.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "130",
            "alt": "DI",
            "desc": "EXAM, DISPENSE BOTTLE OF DIAMINE IODIDE POWDER",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "1255",
            "alt": "DBINT",
            "desc": "EXAM, DISPENSE BOTTLE OF INTAL 20 MG/2 ML",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "127",
            "alt": "DBKR",
            "desc": "EXAM, DISPENSE BOTTLE OF KENTUCKY RED",
            "price": "60.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "5503",
            "alt": None,
            "desc": "EXAM, DISPENSE BOTTLE OF L ARGININE",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "1500",
            "alt": "DBMET",
            "desc": "EXAM, DISPENSE BOTTLE OF METICORT",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "890",
            "alt": "VENT",
            "desc": "EXAM, DISPENSE BOTTLE OF VENTIPULMIN SYRUP 100 ML",
            "price": "140.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "1011",
            "alt": "VENTL",
            "desc": "EXAM, DISPENSE BOTTLE OF VENTIPULMIN SYRUP 330 ML",
            "price": "300.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "1008",
            "alt": "CKP",
            "desc": "EXAM, DISPENSE C.K. POWDER",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "131",
            "alt": "CE",
            "desc": "EXAM, DISPENSE COUGH BASE SYRUP",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "64",
            "alt": "TUCOL",
            "desc": "EXAM, DISPENSE LARGE CONTAINER OF TUCOPRIM",
            "price": "180.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "6877",
            "alt": "NEB",
            "desc": "NEBULISER SOLUTION 500ML",
            "price": "50.00",
            "path": ["MEDICATIONS DISPENSED", "RESPIRATORY DRUGS"],
        },
        {
            "code": "865",
            "alt": "ICH",
            "desc": "EXAM, DISPENSE 1LB. ICTHAMMOL",
            "price": "15.00",
            "path": ["MEDICATIONS DISPENSED", "TOPICAL MEDICATIONS"],
        },
        {
            "code": "26",
            "alt": "FURSP",
            "desc": "EXAM, DISPENSE FURACIN SPRAY",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "TOPICAL MEDICATIONS"],
        },
        {
            "code": "866",
            "alt": "P8",
            "desc": "EXAM, DISPENSE PANALOG 8 oz.",
            "price": "90.00",
            "path": ["MEDICATIONS DISPENSED", "TOPICAL MEDICATIONS"],
        },
        {
            "code": "867",
            "alt": "P30",
            "desc": "EXAM, DISPENSE PANALOG TUBE 30 ML",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "TOPICAL MEDICATIONS"],
        },
        {
            "code": "9631",
            "alt": "SUR",
            "desc": "SURPASS TOPICAL ANTI INFLAMMATORY CREAM",
            "price": "70.00",
            "path": ["MEDICATIONS DISPENSED", "TOPICAL MEDICATIONS"],
        },
        {
            "code": "542",
            "alt": "DBACK",
            "desc": "EXAM, DISPENSE BOTTLE OF ACEPROMAZINE MALEATE",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "TRANQUILIZERS & MUSCLE RELAX."],
        },
        {
            "code": "1013",
            "alt": "DBDET",
            "desc": "EXAM, DISPENSE BOTTLE OF DETOMIDINE HCL 30ML",
            "price": "400.00",
            "path": ["MEDICATIONS DISPENSED", "TRANQUILIZERS & MUSCLE RELAX."],
        },
        {
            "code": "909",
            "alt": "DROBB",
            "desc": "EXAM, DISPENSE BOTTLE OF METHOCARBONAL 100 CC",
            "price": "44.00",
            "path": ["MEDICATIONS DISPENSED", "TRANQUILIZERS & MUSCLE RELAX."],
        },
        {
            "code": "547",
            "alt": "DTR",
            "desc": "EXAM, DISPENSE BOTTLE OF METHOCARBONAL TABLETS 500 CT.",
            "price": "110.00",
            "path": ["MEDICATIONS DISPENSED", "TRANQUILIZERS & MUSCLE RELAX."],
        },
        {
            "code": "394",
            "alt": "DBRES",
            "desc": "EXAM, DISPENSE BOTTLE OF RESERPINE",
            "price": "50.00",
            "path": ["MEDICATIONS DISPENSED", "TRANQUILIZERS & MUSCLE RELAX."],
        },
        {
            "code": "550",
            "alt": "DBX",
            "desc": "EXAM, DISPENSE BOTTLE OF XYLAZINE",
            "price": "80.00",
            "path": ["MEDICATIONS DISPENSED", "TRANQUILIZERS & MUSCLE RELAX."],
        },
        {
            "code": "27",
            "alt": "DILP",
            "desc": "EXAM, DISPENSE TREATMENT WITH DILANTIN PASTE",
            "price": "28.00",
            "path": ["MEDICATIONS DISPENSED", "TRANQUILIZERS & MUSCLE RELAX."],
        },
        {
            "code": "1589",
            "alt": "ERY",
            "desc": "ERYTHO EQ BLOOD BUILDER ORAL POWDER",
            "price": "85.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "587",
            "alt": "DBHEMO",
            "desc": "EXAM DISPENSE BOTTLE OF HEMO/150 100ML",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "567",
            "alt": "DBB12",
            "desc": "EXAM, DISPENSE BOTTLE OF B-12 3000 MCG 100 CC",
            "price": "15.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "563",
            "alt": "DBBC",
            "desc": "EXAM, DISPENSE BOTTLE OF B-COMPLEX VITAMINS",
            "price": "15.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "561",
            "alt": "DBCIC",
            "desc": "EXAM, DISPENSE BOTTLE OF CACO-COPPER",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "559",
            "alt": "DBLIV",
            "desc": "EXAM, DISPENSE BOTTLE OF DELVOREX",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "556",
            "alt": "DBHIP",
            "desc": "EXAM, DISPENSE BOTTLE OF HIP IRON",
            "price": "60.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "150",
            "alt": "DBLIPO",
            "desc": "EXAM, DISPENSE BOTTLE OF LIPOTROPES",
            "price": "30.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "565",
            "alt": "DBC",
            "desc": "EXAM, DISPENSE BOTTLE OF VITAMIN C 100 ML",
            "price": "15.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "1253",
            "alt": "DBCL",
            "desc": "EXAM, DISPENSE BOTTLE OF VITAMIN C 250 ML",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "45",
            "alt": "DBIAS",
            "desc": "EXAM, DISPENSE BOTTLE OF WESTERN FORMULA",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "449",
            "alt": "ELEC",
            "desc": "EXAM, DISPENSE BUCKET OF ELECTROLYTES 25#",
            "price": "75.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "346",
            "alt": "HIPP",
            "desc": "EXAM, DISPENSE HIPPARION POWDER",
            "price": "100.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "570",
            "alt": "MMD",
            "desc": "EXAM, DISPENSE MISCELLANEOUS MEDICATION",
            "price": "0.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "448",
            "alt": "FOLIC",
            "desc": "EXAM, DISPENSE TREATMENT OF FOLIC ACID",
            "price": "40.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "66",
            "alt": "DBB15",
            "desc": "EXAM, DISPENSE TREATMENT WITH ONE BOTTLE OF B-15",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "6677",
            "alt": "DBFOL",
            "desc": "FOLIC ACID INJECTABLE BOTTLE 100 CC",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "VITAMINS"],
        },
        {
            "code": "399",
            "alt": "RL",
            "desc": "EXAM, DISPENSE RED LUNG PLUS POWDER",
            "price": "90.00",
            "path": ["MEDICATIONS DISPENSED", "NON-VITAMIN FEED SUPPLEMENTS"],
        },
        {
            "code": "9990",
            "alt": "NAV",
            "desc": "EXAM AND DISPENSE 28 DAY SUPPLY OF NAVIGATOR PASTE-EPM TXT",
            "price": "1200.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "9994",
            "alt": "CYP",
            "desc": "EXAM, DISPENSE 100 ML CYPROHEPTADINE 100MG/MG",
            "price": "150.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "376",
            "alt": "DBADN",
            "desc": "EXAM, DISPENSE BOTTLE OF ADENOSINE",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "1258",
            "alt": "DBCYPR",
            "desc": "EXAM, DISPENSE BOTTLE OF CYPROHEPTADINE 120 ML",
            "price": "125.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "141",
            "alt": "DBWNV",
            "desc": "EXAM, DISPENSE BOTTLE OF WEST NILE VACCINE",
            "price": "150.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "65",
            "alt": "CK",
            "desc": "EXAM, DISPENSE C.K. POWDER",
            "price": "25.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "500",
            "alt": "ETHER",
            "desc": "EXAM, DISPENSE ETHER",
            "price": "20.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "374",
            "alt": "NL",
            "desc": "EXAM, DISPENSE NEIGH-LOX",
            "price": "200.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "250",
            "alt": "MARQ",
            "desc": "EXAM, DISPENSE TUBE OF MARQUIS",
            "price": "280.00",
            "path": ["MEDICATIONS DISPENSED", "OTHER"],
        },
        {
            "code": "5908",
            "alt": "CASL",
            "desc": "CASLICKS PROCEEDURE",
            "price": "115.00",
            "path": ["REPRODUCTIVE PROCEDURES", "GENERAL BROODMARE WORK"],
        },
        {
            "code": "1275",
            "alt": "BREED",
            "desc": "INSEMINATE MARE",
            "price": "50.00",
            "path": ["REPRODUCTIVE PROCEDURES", "GENERAL BROODMARE WORK"],
        },
        {
            "code": "450",
            "alt": "REC",
            "desc": "RECTAL PALPATION",
            "price": "40.00",
            "path": ["REPRODUCTIVE PROCEDURES", "GENERAL BROODMARE WORK"],
        },
        {
            "code": "98",
            "alt": "US",
            "desc": "ULTRASOUND FOR PREGNANCY",
            "price": "60.00",
            "path": ["REPRODUCTIVE PROCEDURES", "GENERAL BROODMARE WORK"],
        },
        {
            "code": "501",
            "alt": "CAST",
            "desc": "CASTRATION",
            "price": "500.00",
            "path": ["SURGICAL PROCEDURES"],
        },
        {
            "code": "1256",
            "alt": "CRYO",
            "desc": "CRYOSURGICAL PROCEDURE",
            "price": "150.00",
            "path": ["SURGICAL PROCEDURES"],
        },
        {
            "code": "503",
            "alt": "CUT1",
            "desc": "SUTURE LACERATION",
            "price": "70.00",
            "path": ["SURGICAL PROCEDURES"],
        },
        {
            "code": "5030",
            "alt": "SR",
            "desc": "SUTURE REMOVAL",
            "price": "20.00",
            "path": ["SURGICAL PROCEDURES"],
        },
        {
            "code": "95",
            "alt": "BAND",
            "desc": "BANDAGE LEG",
            "price": "60.00",
            "path": ["VET. PROCEDURES & SERVICES", "BANDAGING"],
        },
        {
            "code": "1001",
            "alt": "GEL",
            "desc": "EXAM, DISPENSE GEL CAST",
            "price": "15.00",
            "path": ["VET. PROCEDURES & SERVICES", "BANDAGING"],
        },
        {
            "code": "99",
            "alt": "ACU",
            "desc": "ACUPUNCTURE",
            "price": "100.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "1000",
            "alt": "CS",
            "desc": "CLEAN SHEATH",
            "price": "60.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "999",
            "alt": "DP",
            "desc": "DRENCH PROCEDURE",
            "price": "50.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "23",
            "alt": "SW",
            "desc": "EXTRACORPOREAL SHOCK WAVE THERAPY",
            "price": "100.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "38",
            "alt": "SWR",
            "desc": "EXTRACORPOREAL SHOCK WAVE THERAPY",
            "price": "150.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "92",
            "alt": "FGP",
            "desc": "FLUSH GUTTERAL POUCHES WITH ANTIBIOTICS AND FLUIDS",
            "price": "30.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "93",
            "alt": "FNLD",
            "desc": "FLUSH NASOLACRIMAL DUCT",
            "price": "15.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "106",
            "alt": "BURSA",
            "desc": "INJECT NAVICULAR BURSAS",
            "price": "100.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "310",
            "alt": "IP",
            "desc": "INJECT PALATE",
            "price": "40.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "1007",
            "alt": "INLFSP",
            "desc": "INJECTION OF LEFT FRONT SPLINT",
            "price": "50.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "1006",
            "alt": "INLHSP",
            "desc": "INJECTION OF LEFT HIND SPLINT",
            "price": "50.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "1005",
            "alt": "INRFSP",
            "desc": "INJECTION OF RIGHT FRONT SPLINT",
            "price": "50.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "1004",
            "alt": "INRHSP",
            "desc": "INJECTION OF RIGHT HIND SPLINT",
            "price": "50.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "707",
            "alt": "PRD",
            "desc": "POST TRAINING/RACE DRENCH WITH VITAMINS AND ELECTROLYTES",
            "price": "25.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "739",
            "alt": "PS",
            "desc": "PROFESSIONAL SERVICE",
            "price": "0.00",
            "path": ["VET. PROCEDURES & SERVICES", "OTHER"],
        },
        {
            "code": "5000",
            "alt": "BD",
            "desc": "BOARD",
            "price": "500.00",
            "path": ["OTHER"],
        },
        {
            "code": "5002",
            "alt": "DBD",
            "desc": "DAILY BOARD",
            "price": "18.00",
            "path": ["OTHER"],
        },
        {
            "code": "5003",
            "alt": "PRBD",
            "desc": "DAILY LAY-UP BOARD",
            "price": "20.00",
            "path": ["OTHER"],
        },
        {
            "code": "3126",
            "alt": "EN",
            "desc": "FLEET ENEMA",
            "price": "10.00",
            "path": ["OTHER"],
        },
        {
            "code": "9452",
            "alt": "HOSP",
            "desc": "HOSPITALIZATION",
            "price": "30.00",
            "path": ["OTHER"],
        },
        {
            "code": "5001",
            "alt": "LBD",
            "desc": "LAY-UP BOARD",
            "price": "550.00",
            "path": ["OTHER"],
        },
        {
            "code": "5005",
            "alt": "MFB",
            "desc": "MARE AND FOAL BOARD",
            "price": "600.00",
            "path": ["OTHER"],
        },
        {
            "code": "808",
            "alt": "RT",
            "desc": "POST EXERCISE MEDICATION FOR RESPIRATORY AND TYING-UP",
            "price": "40.00",
            "path": ["OTHER"],
        },
        {
            "code": "19",
            "alt": "TRYP",
            "desc": "TRYPZYME SPRAY",
            "price": "35.00",
            "path": ["OTHER"],
        },
    ]

    existing_codes = {cc_tuple[0] for cc_tuple in session.query(ChargeCode.code).all()}
    new_charge_codes_instances = []
    changes_made = False

    for data in charge_codes_data:
        if data["code"] not in existing_codes:
            category_id = (
                _get_category_id_by_path(session, data["path"])
                if data.get("path")
                else None
            )
            if category_id is None and data.get("path"):
                logger.warning(
                    f"Could not find category for charge code '{data['code']}' using path {data['path']}. Assigning to root or skipping."
                )

            charge_code_model_data = {
                "code": data["code"],
                "alternate_code": data.get("alt"),
                "description": data["desc"],
                "standard_charge": Decimal(data["price"]),
                "category_id": category_id,
                "is_active": True,
                "taxable": False,
                "created_by": "system_init",
                "modified_by": "system_init",
            }

            new_charge_codes_instances.append(ChargeCode(**charge_code_model_data))
            logger.info(
                f"Prepared charge code: {data['code']} with category_id: {category_id}"
            )
            changes_made = True
        else:
            logger.info(f"Charge code '{data['code']}' already exists, skipping.")

    if new_charge_codes_instances:
        session.add_all(new_charge_codes_instances)
        logger.info(
            f"Successfully prepared {len(new_charge_codes_instances)} new charge codes."
        )
    else:
        logger.info("No new charge codes to add.")

    return changes_made


def add_initial_data_main():
    logger.info("Running script to add initial data to the database...")

    # Initialize DatabaseManager locally for this standalone script
    _db_manager = DatabaseManager(AppConfig, config_manager)

    try:
        _db_manager.initialize_database()  # Corrected call
        logger.info("Database initialized.")
    except Exception as e:
        logger.critical(f"Failed to initialize database: {e}", exc_info=True)
        return

    session = _db_manager.get_session()  # Corrected call
    try:
        logger.info("Starting to add initial reference data...")
        changes_made_this_block = False
        if add_roles(session):
            changes_made_this_block = True
        if add_admin_user(session):
            changes_made_this_block = True
        if changes_made_this_block:
            session.commit()
            logger.info("Committed roles and admin user.")
            changes_made_this_block = False

        if add_charge_code_categories(session):
            session.commit()
            logger.info("Committed charge code categories.")

        if add_state_provinces(session):
            session.commit()
            logger.info("Committed states/provinces.")

        if add_initial_locations(session):
            changes_made_this_block = True
        if add_sample_owners(session):
            changes_made_this_block = True
        if add_all_charge_codes(session):
            changes_made_this_block = True
        if changes_made_this_block:
            session.commit()
            logger.info("Committed locations, owners, and all charge codes.")

        logger.info("Initial data setup process completed successfully.")

    except SQLAlchemyError as e_sql:
        logger.error(f"SQLAlchemyError during data population: {e_sql}", exc_info=True)
        session.rollback()
    except Exception as e_gen:
        logger.error(
            f"An unexpected error occurred during data population: {e_gen}",
            exc_info=True,
        )
        session.rollback()
    finally:
        if session and session.is_active:  # Check session.is_active before closing
            _db_manager.close()  # Corrected call, close on the local manager
        logger.info("Database session closed.")


if __name__ == "__main__":
    add_initial_data_main()
    print("Script execution finished. Check logs for details.")


=============== FILE: scripts/backup_data.py ===============

# scripts/backup_data.py
"""
EDSI Veterinary Management System - Database Backup Utility
Version: 1.0.0
Purpose: Creates a backup of the entire SQLite database into an SQL text file.
Last Updated: June 10, 2025
Author: Gemini
"""
import sqlite3
import os
import sys

# This allows the script to find the 'config' module
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.append(PROJECT_ROOT)

try:
    from config.app_config import AppConfig
except ImportError:
    print(
        "Error: Could not import AppConfig. Make sure the script is run from the project root directory."
    )
    sys.exit(1)


def backup_database():
    """Connects to the database and dumps its content to a backup.sql file."""
    db_path = AppConfig.DATABASE_URL.split("///")[-1]
    backup_path = os.path.join(AppConfig.PROJECT_ROOT, "backup.sql")

    if not os.path.exists(db_path):
        print(f"Error: Database file not found at '{db_path}'. Cannot create backup.")
        return

    try:
        print(f"Backing up database from '{db_path}' to '{backup_path}'...")
        con = sqlite3.connect(db_path)
        with open(backup_path, "w", encoding="utf-8") as f:
            # iterdump() generates an SQL script from the database content
            for line in con.iterdump():
                f.write("%s\n" % line)
        con.close()
        print("\nDatabase backup completed successfully.")
        print(f"Data saved to: {backup_path}")

    except Exception as e:
        print(f"\nAn error occurred during backup: {e}")


if __name__ == "__main__":
    backup_database()


=============== FILE: scripts/restore_data.py ===============

# scripts/restore_data.py
"""
EDSI Veterinary Management System - Database Restore Utility
Version: 1.1.0
Purpose: Restores data from a backup.sql file into the SQLite database.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-10):
    - Made the script more robust by wrapping the restore commands in a
      transaction and disabling foreign key checks during the import. This
      prevents errors related to table creation order and data dependencies.
- v1.0.0 (2025-06-10):
    - Initial implementation.
"""
import sqlite3
import os
import sys

# This allows the script to find the 'config' module
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.append(PROJECT_ROOT)

try:
    from config.app_config import AppConfig
except ImportError:
    print(
        "Error: Could not import AppConfig. Make sure the script is run from the project root directory."
    )
    sys.exit(1)


def restore_database():
    """Connects to the database and restores data from the backup.sql file."""
    db_path = AppConfig.DATABASE_URL.split("///")[-1]
    backup_path = os.path.join(AppConfig.PROJECT_ROOT, "backup.sql")

    if not os.path.exists(backup_path):
        print(f"Error: Backup file not found at '{backup_path}'. Cannot restore.")
        return

    if not os.path.exists(db_path):
        print(f"Warning: Database file not found at '{db_path}'.")
        print("A new empty database will be created for the restore process.")
        # This is expected behavior, as the user should delete the old DB first.

    try:
        print(f"Restoring database from '{backup_path}' to '{db_path}'...")
        con = sqlite3.connect(db_path)
        cursor = con.cursor()
        with open(backup_path, "r", encoding="utf-8") as f:
            sql_script = f.read()

        # Wrap the script execution to disable foreign keys, which prevents errors
        # with out-of-order data insertion. This makes the restore much safer.
        wrapper_script = f"""
        PRAGMA foreign_keys = OFF;
        BEGIN TRANSACTION;
        {sql_script}
        COMMIT;
        PRAGMA foreign_keys = ON;
        """

        # executescript can run a string containing multiple SQL statements
        cursor.executescript(wrapper_script)

        con.commit()
        con.close()
        print("\nDatabase restore completed successfully.")
        print("Your test data should now be available.")

    except Exception as e:
        print(f"\nAn error occurred during restore: {e}")


if __name__ == "__main__":
    restore_database()


