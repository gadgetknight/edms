=============== FILE: config\__init__.py ===============

# config/__init__.py

"""Configuration package"""


=============== FILE: config\app_config.py ===============

# config/app_config.py

"""
EDSI Veterinary Management System - Application Configuration
Version: 2.1.0
Purpose: Simplified centralized configuration for application settings, paths, and constants.
Last Updated: June 9, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.1.0 (2025-06-09):
    - Added INVOICES_DIR path constant for storing generated invoice PDFs.
    - Updated ensure_directories() to create the 'invoices' folder on startup.
- v2.0.1 (2025-05-26):
    - Added LOG_MAX_BYTES and LOG_BACKUP_COUNT constants for log file rotation.
    - Included log_max_bytes and log_backup_count in the get_logging_config() dictionary.
    - Updated module-level APP_VERSION constant to "2.0.3" to align with main application.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Consolidated all configuration into single AppConfig class
"""

import os
import logging
from typing import Dict, Any

# --- Project Paths ---
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
LOG_DIR = os.path.join(PROJECT_ROOT, "logs")
ASSETS_DIR = os.path.join(PROJECT_ROOT, "assets")
INVOICES_DIR = os.path.join(PROJECT_ROOT, "invoices")  # ADDED

# --- Application Information ---
APP_NAME = "EDSI Veterinary Management System"
APP_VERSION = "2.0.3"
APP_AUTHOR = "EDSI"

# --- Database Configuration ---
DATABASE_URL = f"sqlite:///{os.path.join(PROJECT_ROOT, 'edsi_database.db')}"

# --- Logging Configuration ---
APP_LOG_FILE = os.path.join(LOG_DIR, "edsi_app.log")
DB_LOG_FILE = os.path.join(LOG_DIR, "edsi_db.log")
LOGGING_LEVEL = logging.INFO
LOG_MAX_BYTES = 1024 * 1024 * 5
LOG_BACKUP_COUNT = 5

# --- UI Configuration ---
DEFAULT_FONT_FAMILY = "Inter"
DEFAULT_FONT_SIZE = 10
SMALL_FONT_SIZE = 9
MIN_WINDOW_WIDTH = 900
MIN_WINDOW_HEIGHT = 700

# --- Dark Theme Colors (Essential Only) ---
DARK_BACKGROUND = "#2D3748"
DARK_WIDGET_BACKGROUND = "#1A202C"
DARK_HEADER_FOOTER = "#222B38"
DARK_BORDER = "#4A5568"
DARK_TEXT_PRIMARY = "#E2E8F0"
DARK_TEXT_SECONDARY = "#A0AEC0"
DARK_TEXT_TERTIARY = "#718096"
DARK_PRIMARY_ACTION = "#3182CE"
DARK_SUCCESS_ACTION = "#38A169"
DARK_WARNING_ACTION = "#DD6B20"
DARK_DANGER_ACTION = "#E53E3E"
DARK_BUTTON_BG = "#4A5568"
DARK_BUTTON_HOVER = "#718096"
DARK_ITEM_HOVER = "#2C3543"
DARK_HIGHLIGHT_BG = "#3182CE"
DARK_HIGHLIGHT_TEXT = "#FFFFFF"
DARK_INPUT_FIELD_BACKGROUND = "#222B38"


class AppConfig:
    """
    Centralized application configuration class.
    Provides clean access to all application settings.
    """

    # Application Info
    APP_NAME = APP_NAME
    APP_VERSION = APP_VERSION
    APP_AUTHOR = APP_AUTHOR

    # Paths
    PROJECT_ROOT = PROJECT_ROOT
    LOG_DIR = LOG_DIR
    ASSETS_DIR = ASSETS_DIR
    INVOICES_DIR = INVOICES_DIR  # ADDED

    # Database
    DATABASE_URL = DATABASE_URL

    # Logging
    APP_LOG_FILE = APP_LOG_FILE
    DB_LOG_FILE = DB_LOG_FILE
    LOGGING_LEVEL = LOGGING_LEVEL
    LOG_MAX_BYTES = LOG_MAX_BYTES
    LOG_BACKUP_COUNT = LOG_BACKUP_COUNT

    # UI Settings
    DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY
    DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE
    SMALL_FONT_SIZE = SMALL_FONT_SIZE
    MIN_WINDOW_WIDTH = MIN_WINDOW_WIDTH
    MIN_WINDOW_HEIGHT = MIN_WINDOW_HEIGHT

    # Theme Colors
    DARK_BACKGROUND = DARK_BACKGROUND
    DARK_WIDGET_BACKGROUND = DARK_WIDGET_BACKGROUND
    DARK_HEADER_FOOTER = DARK_HEADER_FOOTER
    DARK_BORDER = DARK_BORDER
    DARK_TEXT_PRIMARY = DARK_TEXT_PRIMARY
    DARK_TEXT_SECONDARY = DARK_TEXT_SECONDARY
    DARK_TEXT_TERTIARY = DARK_TEXT_TERTIARY
    DARK_PRIMARY_ACTION = DARK_PRIMARY_ACTION
    DARK_SUCCESS_ACTION = DARK_SUCCESS_ACTION
    DARK_WARNING_ACTION = DARK_WARNING_ACTION
    DARK_DANGER_ACTION = DARK_DANGER_ACTION
    DARK_BUTTON_BG = DARK_BUTTON_BG
    DARK_BUTTON_HOVER = DARK_BUTTON_HOVER
    DARK_ITEM_HOVER = DARK_ITEM_HOVER
    DARK_HIGHLIGHT_BG = DARK_HIGHLIGHT_BG
    DARK_HIGHLIGHT_TEXT = DARK_HIGHLIGHT_TEXT
    DARK_INPUT_FIELD_BACKGROUND = DARK_INPUT_FIELD_BACKGROUND

    @classmethod
    def get_database_url(cls) -> str:
        return cls.DATABASE_URL

    @classmethod
    def get_app_dir(cls) -> str:
        return cls.PROJECT_ROOT

    @classmethod
    def get_assets_dir(cls) -> str:
        return cls.ASSETS_DIR

    @classmethod
    def get_invoices_dir(cls) -> str:
        return cls.INVOICES_DIR

    @classmethod
    def get_app_info(cls) -> Dict[str, str]:
        return {
            "name": cls.APP_NAME,
            "version": cls.APP_VERSION,
            "author": cls.APP_AUTHOR,
        }

    @classmethod
    def get_logging_config(cls) -> Dict[str, Any]:
        """Get logging configuration"""
        return {
            "level": cls.LOGGING_LEVEL,
            "app_log_file": cls.APP_LOG_FILE,
            "db_log_file": cls.DB_LOG_FILE,
            "log_dir": cls.LOG_DIR,
            "log_max_bytes": cls.LOG_MAX_BYTES,
            "log_backup_count": cls.LOG_BACKUP_COUNT,
        }

    @classmethod
    def get_ui_config(cls) -> Dict[str, Any]:
        return {
            "font_family": cls.DEFAULT_FONT_FAMILY,
            "font_size": cls.DEFAULT_FONT_SIZE,
            "small_font_size": cls.SMALL_FONT_SIZE,
            "min_window_width": cls.MIN_WINDOW_WIDTH,
            "min_window_height": cls.MIN_WINDOW_HEIGHT,
        }

    @classmethod
    def get_theme_colors(cls) -> Dict[str, str]:
        return {
            "background": cls.DARK_BACKGROUND,
            "widget_background": cls.DARK_WIDGET_BACKGROUND,
            "header_footer": cls.DARK_HEADER_FOOTER,
            "border": cls.DARK_BORDER,
            "text_primary": cls.DARK_TEXT_PRIMARY,
            "text_secondary": cls.DARK_TEXT_SECONDARY,
            "text_tertiary": cls.DARK_TEXT_TERTIARY,
            "primary_action": cls.DARK_PRIMARY_ACTION,
            "success_action": cls.DARK_SUCCESS_ACTION,
            "warning_action": cls.DARK_WARNING_ACTION,
            "danger_action": cls.DARK_DANGER_ACTION,
            "button_bg": cls.DARK_BUTTON_BG,
            "button_hover": cls.DARK_BUTTON_HOVER,
            "item_hover": cls.DARK_ITEM_HOVER,
            "highlight_bg": cls.DARK_HIGHLIGHT_BG,
            "highlight_text": cls.DARK_HIGHLIGHT_TEXT,
            "input_field_background": cls.DARK_INPUT_FIELD_BACKGROUND,
        }

    @classmethod
    def ensure_directories(cls) -> None:
        """Ensure required directories exist"""
        directories = [cls.LOG_DIR, cls.ASSETS_DIR, cls.INVOICES_DIR]  # MODIFIED

        for directory in directories:
            if not os.path.exists(directory):
                try:
                    os.makedirs(directory, exist_ok=True)
                    # Optionally log creation:
                    # logging.info(f"Created directory: {directory}")
                except OSError as e:
                    # Using print as logger might not be fully setup when this is called early
                    print(f"Warning: Could not create directory {directory}: {e}")


=============== FILE: config\database_config.py ===============

# config/database_config.py

"""
EDSI Veterinary Management System - Database Configuration
Version: 2.0.3 (Example version, update as needed)
Purpose: Simplified database connection and session management using SQLAlchemy.
         Ensures ADMIN user password is set using bcrypt via User.set_password(),
         with robust handling for pre-existing non-bcrypt hashes.
         Added new financial models to _import_models.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.3 (2025-06-04):
    - Added Transaction and Invoice from financial_models to _import_models method
      to ensure their tables are created by Base.metadata.create_all.
- v2.0.2 (2025-05-29):
    - Made _ensure_default_admin_user method more robust:
        - It now tries to check the ADMIN password using bcrypt.
        - If check_password fails (returns False or raises ValueError due to
          invalid hash format like old SHA256), it then calls
          user.set_password() to ensure the password becomes "admin1234"
          hashed with bcrypt.
        - This resolves the "ValueError: Invalid salt" during startup.
- v2.0.1 (2025-05-29):
    - Modified _ensure_default_admin_user method to use user.set_password()
      (which uses bcrypt) for the ADMIN user's password ("admin1234")
      instead of directly setting a SHA-256 hash.
    - Removed hashlib import as it's no longer used.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification.
"""

import logging
import os
from typing import Optional
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, scoped_session, Session as SQLAlchemySession
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.exc import SQLAlchemyError

from config.app_config import AppConfig

# Create Base for all models
Base = declarative_base()

# Setup logger
db_logger = logging.getLogger("database_operations")


class DatabaseManager:
    """
    Simplified database manager for EDSI application.
    Handles database initialization, session creation, and table management.
    """

    def __init__(self):
        self.engine = None
        self.SessionLocal: Optional[scoped_session[SQLAlchemySession]] = None
        self.db_url: Optional[str] = None
        self.logger = logging.getLogger(self.__class__.__name__)

    def initialize_database(self, db_url: Optional[str] = None) -> None:
        """
        Initialize database connection and create tables.
        """
        if self.engine:
            self.logger.info("Database already initialized")
            return

        self.db_url = db_url or AppConfig.get_database_url()
        if not self.db_url:
            raise ValueError("DATABASE_URL is not configured")

        self.logger.info(f"Initializing database: {self.db_url}")

        try:
            self.engine = create_engine(
                self.db_url,
                echo=False,  # Set to True for SQL logging, False for production
                pool_pre_ping=True,
            )

            self.SessionLocal = scoped_session(
                sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
            )

            self.logger.info("Database engine and session factory created")
            self.create_tables()
            self._test_connection()
            self._ensure_default_admin_user()
            self.logger.info("Database initialization completed successfully")

        except SQLAlchemyError as e:
            self.logger.error(f"SQLAlchemy error during database initialization: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error during database initialization: {e}")
            raise

    def get_session(self) -> SQLAlchemySession:
        """
        Get a database session.
        """
        if not self.SessionLocal:
            raise RuntimeError(
                "Database not initialized. Call initialize_database() first."
            )
        return self.SessionLocal()

    def create_tables(self) -> None:
        """
        Create all database tables.
        """
        if not self.engine:
            raise RuntimeError("Database engine not initialized")

        try:
            self.logger.info("Creating database tables...")
            self._import_models()  # This ensures all models are known to Base
            Base.metadata.create_all(bind=self.engine)
            table_names = list(Base.metadata.tables.keys())
            self.logger.info(f"Database tables created/verified: {table_names}")

        except Exception as e:
            self.logger.error(f"Error creating database tables: {e}")
            raise

    def _import_models(self) -> None:
        """
        Import all model classes to ensure they are registered with Base.
        This is crucial for Base.metadata.create_all() to work correctly.
        """
        try:
            from models.base_model import BaseModel  # Already imported by other models
            from models.user_models import User, Role, UserRole
            from models.horse_models import Horse, HorseOwner, HorseLocation
            from models.owner_models import Owner, OwnerBillingHistory, OwnerPayment

            # The placeholder Invoice from owner_models is implicitly imported if not removed from its __init__ or owner_models.py
            from models.reference_models import (
                StateProvince,
                ChargeCodeCategory,
                ChargeCode,
                Veterinarian,
                Location,
                Procedure,  # Placeholder
                Drug,  # Placeholder
                TreatmentLog,  # Placeholder
                CommunicationLog,  # Placeholder
                Document,  # Placeholder
                Reminder,  # Placeholder
                Appointment,  # Placeholder
                # The placeholder Transaction & TransactionDetail from reference_models might also be imported
                # if not removed from its __init__ or reference_models.py
            )

            # Import new financial models
            from models.financial_models import Transaction, Invoice

            self.logger.debug(
                "Models imported for table creation, including new financial models."
            )
        except ImportError as e:
            self.logger.error(
                f"Critical error: Could not import core models for table creation: {e}",
                exc_info=True,
            )
            # Depending on severity, you might want to raise this error
            # raise ImportError(f"Failed to import essential models: {e}") from e
        except Exception as e:
            self.logger.error(
                f"Unexpected error during model imports for table creation: {e}",
                exc_info=True,
            )

    def _test_connection(self) -> None:
        """
        Test database connection.
        """
        try:
            with self.get_session() as session:
                session.execute(text("SELECT 1"))
            self.logger.info("Database connection test successful")
        except Exception as e:
            self.logger.error(f"Database connection test failed: {e}")
            raise

    def _ensure_default_admin_user(self) -> None:
        """
        Ensure default admin user always exists with correct credentials
        (password hashed using bcrypt via User.set_password).
        Handles pre-existing non-bcrypt hashes for ADMIN by resetting the password.
        """
        try:
            with self.get_session() as session:
                from models.user_models import (
                    User,
                    Role,
                )

                self.logger.info(
                    "Ensuring default ADMIN user exists with bcrypt password."
                )

                admin_role_name = "ADMIN"
                admin_role = (
                    session.query(Role).filter(Role.name == admin_role_name).first()
                )
                if not admin_role:
                    self.logger.warning(
                        f"Role '{admin_role_name}' not found. Creating it now. "
                        "It's recommended to run add_initial_data.py for full role setup."
                    )
                    admin_role = Role(
                        name=admin_role_name,
                        description="System Administrator (auto-created by db_config)",
                        created_by="SYSTEM_DB_CONFIG",
                        modified_by="SYSTEM_DB_CONFIG",
                    )
                    session.add(admin_role)
                    session.flush()
                    self.logger.info(f"Created '{admin_role_name}' role.")

                admin_user = session.query(User).filter(User.user_id == "ADMIN").first()
                default_password = "admin1234"
                admin_default_name = "System Administrator"
                admin_default_email = "admin@edsi.local"

                if admin_user:
                    password_reset_done = False
                    attributes_updated = False

                    try:
                        if not admin_user.check_password(default_password):
                            self.logger.info(
                                "ADMIN user password check failed. Resetting."
                            )
                            admin_user.set_password(default_password)
                            password_reset_done = True
                    except ValueError as e:
                        self.logger.warning(
                            f"ADMIN password hash not bcrypt/valid ({e}). Resetting password."
                        )
                        admin_user.set_password(default_password)
                        password_reset_done = True

                    if password_reset_done:
                        admin_user.modified_by = "SYSTEM_DB_CONFIG_PWD"
                        self.logger.info(
                            "ADMIN user password has been set/reset to a bcrypt hash."
                        )

                    if not admin_user.is_active:
                        admin_user.is_active = True
                        self.logger.info("Activated ADMIN user.")
                        attributes_updated = True

                    if admin_user.user_name != admin_default_name:
                        admin_user.user_name = admin_default_name
                        self.logger.info(
                            f"Set ADMIN user_name to '{admin_default_name}'."
                        )
                        attributes_updated = True

                    if admin_user.email != admin_default_email:
                        admin_user.email = admin_default_email
                        self.logger.info(f"Set ADMIN email to '{admin_default_email}'.")
                        attributes_updated = True

                    if attributes_updated and not password_reset_done:
                        admin_user.modified_by = "SYSTEM_DB_CONFIG_ATTR"

                    if password_reset_done or attributes_updated:
                        self.logger.info("ADMIN user record updated/verified.")
                    else:
                        self.logger.info(
                            "ADMIN user credentials, status, and name are correct."
                        )

                else:
                    self.logger.info("ADMIN user not found. Creating new ADMIN user...")
                    admin_user = User(
                        user_id="ADMIN",
                        user_name=admin_default_name,
                        email=admin_default_email,
                        is_active=True,
                        created_by="SYSTEM_DB_CONFIG",
                        modified_by="SYSTEM_DB_CONFIG",
                    )
                    admin_user.set_password(default_password)
                    session.add(admin_user)
                    session.flush()
                    self.logger.info("Created new ADMIN user with bcrypt password.")

                if admin_role and admin_role not in admin_user.roles:
                    admin_user.roles.append(admin_role)
                    self.logger.info("Linked ADMIN user to ADMIN role.")
                elif not admin_role:
                    self.logger.error(
                        f"Cannot link ADMIN user to '{admin_role_name}' role as role object is missing."
                    )

                session.commit()
                self.logger.info(
                    f"Default ADMIN user ready (Username: ADMIN, Password: {default_password})"
                )

        except Exception as e:
            self.logger.error(f"Error ensuring default admin user: {e}", exc_info=True)
            if "session" in locals() and session.is_active:
                session.rollback()

    def close(self) -> None:
        if self.SessionLocal:
            self.SessionLocal.remove()
            self.logger.info("Database sessions closed")
        if self.engine:
            self.engine.dispose()
            self.logger.info("Database engine disposed")

    def get_engine(self):
        return self.engine


db_manager = DatabaseManager()


def get_db_session() -> SQLAlchemySession:
    return db_manager.get_session()


def init_database(db_url: Optional[str] = None) -> None:
    db_manager.initialize_database(db_url)


=============== FILE: controllers\__init__.py ===============

# controllers/__init__.py
"""
EDSI Veterinary Management System - Controllers Package
"""
from .user_controller import UserController
from .location_controller import LocationController
from .charge_code_controller import ChargeCodeController
from .owner_controller import OwnerController
from .financial_controller import FinancialController
from .horse_controller import HorseController
from .company_profile_controller import CompanyProfileController
from .veterinarian_controller import VeterinarianController

__all__ = [
    "UserController",
    "LocationController",
    "ChargeCodeController",
    "OwnerController",
    "FinancialController",
    "HorseController",
    "CompanyProfileController",
    "VeterinarianController",
]


=============== FILE: controllers\charge_code_controller.py ===============

# controllers/charge_code_controller.py
"""
EDSI Veterinary Management System - Charge Code Controller
Version: 1.2.0
Purpose: Business logic for charge code and charge code category operations.
         - Added delete_charge_code method.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.2.0 (2025-06-05):
    - Added `delete_charge_code` method to permanently delete a charge code.
    - The method checks for linked records in the `Transaction` model to prevent deletion if the charge code is in use.
    - Added `Transaction` to the model imports.
- v1.1.3 (2025-06-04):
    - Added `get_category_by_id` method to fetch a single category by its ID,
      as required by UserManagementScreen.
    - Modified `get_charge_code_by_id` to filter by `ChargeCode.id` (assuming 'id'
      is the current primary key attribute on the ChargeCode model) instead of
      `ChargeCode.charge_code_id` to resolve an AttributeError.
- v1.1.2 (2025-06-03):
    - Modified `get_all_charge_code_categories_hierarchical` to remove the
      `active_filter` parameter. It now always fetches all Level 1 categories
      (active and inactive) and their children. Filtering logic is handled by the view.
- v1.1.1 (2025-06-03):
    - Added `toggle_charge_code_category_status` method to specifically handle
      activating/deactivating ChargeCodeCategory items.
- v1.1.0 (2025-06-03):
    - Added full CRUD operations and validation for ChargeCodeCategory.
# ... (previous changelog entries)
"""

import logging
import re
from datetime import datetime
from typing import List, Optional, Tuple, Dict, Any
from decimal import Decimal, InvalidOperation

from sqlalchemy.orm import Session, joinedload, aliased, selectinload
from sqlalchemy import or_, func, exc as sqlalchemy_exc, and_

from config.database_config import db_manager
from models import ChargeCode, ChargeCodeCategory, Transaction


class ChargeCodeController:
    """Controller for charge code and charge code category operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    # --- ChargeCode Methods ---
    def validate_charge_code_data(
        self,
        charge_data: dict,
        is_new: bool = True,
        charge_code_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        code = charge_data.get("code", "").strip()
        description = charge_data.get("description", "").strip()
        standard_charge_str = str(charge_data.get("standard_charge", "")).strip()

        if not code:
            errors.append("Charge Code (Code) is required.")
        elif len(code) > 20:
            errors.append("Charge Code (Code) cannot exceed 20 characters.")

        # Validate code uniqueness
        if code:  # Only check if code is provided
            session = db_manager.get_session()
            try:
                query = session.query(ChargeCode).filter(
                    ChargeCode.code.collate("NOCASE") == code.upper()
                )
                if not is_new and charge_code_id_to_ignore is not None:
                    query = query.filter(ChargeCode.id != charge_code_id_to_ignore)
                if query.first():
                    errors.append(f"Charge Code '{code.upper()}' already exists.")
            finally:
                if session:
                    session.close()

        if not description:
            errors.append("Description is required.")
        elif len(description) > 255:
            errors.append("Description cannot exceed 255 characters.")

        if not standard_charge_str:
            errors.append("Standard Charge is required.")
        else:
            try:
                charge_value = Decimal(standard_charge_str)
                if charge_value < Decimal("0.00"):
                    errors.append("Standard Charge cannot be negative.")
            except InvalidOperation:
                errors.append("Standard Charge must be a valid number (e.g., 25.00).")

        alternate_code = charge_data.get("alternate_code")
        if alternate_code is not None and len(str(alternate_code).strip()) > 50:
            errors.append("Alternate Code cannot exceed 50 characters.")

        if "taxable" in charge_data and not isinstance(
            charge_data.get("taxable"), bool
        ):
            errors.append("Taxable field must be a true/false value.")

        category_id = charge_data.get("category_id")
        if category_id is not None:
            session = db_manager.get_session()
            try:
                category_exists = (
                    session.query(ChargeCodeCategory)
                    .filter(ChargeCodeCategory.category_id == category_id)
                    .first()
                )
                if not category_exists:
                    errors.append(
                        f"Selected category ID '{category_id}' does not exist."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"Error validating category_id '{category_id}': {e}", exc_info=True
                )
                errors.append("Database error validating category.")
            finally:
                if session:
                    session.close()
        elif "category_id" not in charge_data:
            errors.append("Category selection is required.")

        return not errors, errors

    def create_charge_code(
        self, charge_data: dict, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[ChargeCode]]:
        is_valid, errors = self.validate_charge_code_data(
            charge_data, is_new=True, charge_code_id_to_ignore=None
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_charge_code = ChargeCode(
                code=charge_data["code"].strip().upper(),
                alternate_code=(
                    (charge_data.get("alternate_code", "").strip().upper() or None)
                    if charge_data.get("alternate_code") is not None
                    else None
                ),
                description=charge_data["description"].strip(),
                category_id=charge_data.get("category_id"),
                standard_charge=Decimal(str(charge_data["standard_charge"]).strip()),
                is_active=charge_data.get("is_active", True),
                taxable=charge_data.get("taxable", False),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_charge_code)
            session.commit()
            session.refresh(new_charge_code)
            self.logger.info(
                f"Charge Code '{new_charge_code.code}' created (ID: {new_charge_code.id}) by {current_user_id}."
            )
            return True, "Charge code created successfully.", new_charge_code
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating charge code: {str(ie.orig)}", exc_info=True
            )
            if "UNIQUE constraint failed: charge_codes.code" in str(ie.orig).lower():
                return (
                    False,
                    f"Charge Code '{charge_data['code'].strip().upper()}' already exists.",
                    None,
                )
            return False, f"Database integrity error: {str(ie.orig)}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating charge code: {e}", exc_info=True)
            return False, f"Failed to create charge code: {str(e)}", None
        finally:
            if session:
                session.close()

    def get_charge_code_by_id(self, charge_code_pk_value: int) -> Optional[ChargeCode]:
        session = db_manager.get_session()
        try:
            return (
                session.query(ChargeCode)
                .options(joinedload(ChargeCode.category))
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code by ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return None
        finally:
            if session:
                session.close()

    def get_charge_code_by_code(self, code: str) -> Optional[ChargeCode]:
        session = db_manager.get_session()
        try:
            return (
                session.query(ChargeCode)
                .options(joinedload(ChargeCode.category))
                .filter(ChargeCode.code.collate("NOCASE") == code.upper())
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code by code '{code}': {e}", exc_info=True
            )
            return None
        finally:
            if session:
                session.close()

    def get_all_charge_codes(
        self, search_term: str = "", status_filter: str = "all"
    ) -> List[ChargeCode]:
        session = db_manager.get_session()
        try:
            category_alias = aliased(ChargeCodeCategory)
            query = session.query(ChargeCode).options(joinedload(ChargeCode.category))

            if status_filter == "active":
                query = query.filter(ChargeCode.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(ChargeCode.is_active == False)

            query = query.outerjoin(category_alias, ChargeCode.category)

            if search_term:
                like_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        ChargeCode.code.ilike(like_pattern),
                        ChargeCode.alternate_code.ilike(like_pattern),
                        ChargeCode.description.ilike(like_pattern),
                        category_alias.name.ilike(like_pattern),
                    )
                )
            query = query.order_by(
                category_alias.name.asc().nullsfirst(), ChargeCode.code.asc()
            )
            return query.all()
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all charge codes: {e}", exc_info=True)
            return []
        finally:
            if session:
                session.close()

    def update_charge_code(
        self,
        charge_code_pk_value: int,
        charge_data: dict,
        current_user_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            charge_code_to_update = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
            if not charge_code_to_update:
                return False, "Charge code not found."

            validation_data = charge_data.copy()
            if "code" not in validation_data:
                validation_data["code"] = charge_code_to_update.code

            is_valid, errors = self.validate_charge_code_data(
                validation_data,
                is_new=False,
                charge_code_id_to_ignore=charge_code_pk_value,
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            if "code" in charge_data:
                charge_code_to_update.code = charge_data["code"].strip().upper()
            if "description" in charge_data:
                charge_code_to_update.description = charge_data["description"].strip()
            if (
                "standard_charge" in charge_data
                and charge_data["standard_charge"] is not None
            ):
                try:
                    charge_code_to_update.standard_charge = Decimal(
                        str(charge_data["standard_charge"])
                    )
                except InvalidOperation:
                    return False, "Invalid Standard Charge value provided for update."
            if "alternate_code" in charge_data:
                alt_code = charge_data.get("alternate_code")
                charge_code_to_update.alternate_code = (
                    (alt_code.strip().upper() or None)
                    if isinstance(alt_code, str)
                    else None
                )

            if "category_id" in charge_data:
                charge_code_to_update.category_id = charge_data.get("category_id")

            if "is_active" in charge_data:
                charge_code_to_update.is_active = charge_data["is_active"]
            if "taxable" in charge_data:
                charge_code_to_update.taxable = charge_data["taxable"]

            charge_code_to_update.modified_by = current_user_id

            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code_to_update.code}' (ID: {charge_code_pk_value}) updated by {current_user_id}."
            )
            return True, "Charge code updated successfully."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            if "UNIQUE constraint failed: charge_codes.code" in str(ie.orig).lower():
                return (
                    False,
                    f"Charge Code '{charge_data.get('code', '').strip().upper()}' already exists.",
                )
            return False, f"Database integrity error: {str(ie.orig)}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating charge code ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return False, f"Failed to update charge code: {str(e)}"
        finally:
            if session:
                session.close()

    def toggle_charge_code_status(
        self,
        charge_code_pk_value: int,
        current_user_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            charge_code = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_pk_value)
                .first()
            )
            if not charge_code:
                return False, "Charge code not found."

            charge_code.is_active = not charge_code.is_active
            charge_code.modified_by = current_user_id
            new_status = "active" if charge_code.is_active else "inactive"
            session.commit()
            self.logger.info(
                f"Charge Code '{charge_code.code}' (ID: {charge_code_pk_value}) status changed to {new_status} by {current_user_id}."
            )
            return True, f"Charge code '{charge_code.code}' status set to {new_status}."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error toggling status for charge code ID {charge_code_pk_value}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle charge code status: {str(e)}"
        finally:
            if session:
                session.close()

    def delete_charge_code(
        self, charge_code_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        """Permanently deletes a charge code after checking for dependencies."""
        session = db_manager.get_session()
        try:
            # Check for linked transactions before deleting
            linked_transactions_count = (
                session.query(Transaction)
                .filter(Transaction.charge_code_id == charge_code_id)
                .count()
            )

            if linked_transactions_count > 0:
                message = f"Cannot delete charge code. It is used in {linked_transactions_count} financial transaction(s)."
                self.logger.warning(
                    f"Attempt to delete charge code ID {charge_code_id} failed: {message}"
                )
                return False, message

            # Proceed with deletion if no links are found
            charge_code_to_delete = (
                session.query(ChargeCode)
                .filter(ChargeCode.id == charge_code_id)
                .first()
            )

            if not charge_code_to_delete:
                return False, "Charge code not found."

            code = charge_code_to_delete.code
            session.delete(charge_code_to_delete)
            session.commit()
            self.logger.info(
                f"Charge Code '{code}' (ID: {charge_code_id}) deleted by {current_user_id}."
            )
            return True, f"Charge Code '{code}' was successfully deleted."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting charge code ID {charge_code_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred: {e}"
        finally:
            session.close()

    # --- ChargeCodeCategory Management Methods ---

    def get_category_by_id(self, category_id: int) -> Optional[ChargeCodeCategory]:
        session = db_manager.get_session()
        try:
            category = (
                session.query(ChargeCodeCategory)
                .options(joinedload(ChargeCodeCategory.parent))
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            return category
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching category by ID {category_id}: {e}", exc_info=True
            )
            return None
        finally:
            if session:
                session.close()

    def validate_charge_code_category_data(
        self,
        category_data: dict,
        is_new: bool = True,
        category_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        name = category_data.get("name", "").strip()
        level = category_data.get("level")
        parent_id = category_data.get("parent_id")

        if not name:
            errors.append("Category/Process name is required.")
        elif len(name) > 100:
            errors.append("Category/Process name cannot exceed 100 characters.")

        if level not in [1, 2]:
            errors.append("Level must be 1 (for Category) or 2 (for Process).")

        if level == 1 and parent_id is not None:
            errors.append("A Level 1 Category cannot have a parent.")
        if level == 2 and parent_id is None:
            errors.append("A Level 2 Process must have a parent Category.")

        if name and level is not None:
            session = db_manager.get_session()
            try:
                query = session.query(ChargeCodeCategory.category_id).filter(
                    ChargeCodeCategory.name.collate("NOCASE") == name,
                    ChargeCodeCategory.level == level,
                )
                if parent_id:
                    query = query.filter(ChargeCodeCategory.parent_id == parent_id)
                else:
                    query = query.filter(ChargeCodeCategory.parent_id.is_(None))

                if not is_new and category_id_to_ignore is not None:
                    query = query.filter(
                        ChargeCodeCategory.category_id != category_id_to_ignore
                    )

                if query.first():
                    type_name = "Process" if level == 2 else "Category"
                    parent_info = f" under the selected parent" if parent_id else ""
                    errors.append(
                        f"{type_name} name '{name}' already exists{parent_info}."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"DB error validating category name uniqueness: {e}", exc_info=True
                )
                errors.append("Database error during name validation.")
            finally:
                if session:
                    session.close()
        return not errors, errors

    def create_charge_code_category(
        self, category_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str, Optional[ChargeCodeCategory]]:
        is_valid, errors = self.validate_charge_code_category_data(
            category_data, is_new=True
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_category = ChargeCodeCategory(
                name=category_data["name"].strip(),
                level=category_data["level"],
                parent_id=category_data.get("parent_id"),
                is_active=category_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_category)
            session.commit()
            session.refresh(new_category)
            cat_type = "Process" if new_category.level == 2 else "Category"
            self.logger.info(
                f"Charge Code {cat_type} '{new_category.name}' (ID: {new_category.category_id}, Level: {new_category.level}, ParentID: {new_category.parent_id}) created by {current_user_id}."
            )
            return True, f"{cat_type} created successfully.", new_category
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating charge code category: {str(ie.orig)}",
                exc_info=True,
            )
            return False, f"Database integrity error: {str(ie.orig)}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error creating charge code category: {e}", exc_info=True
            )
            return False, f"Failed to create category/process: {str(e)}", None
        finally:
            if session:
                session.close()

    def update_charge_code_category(
        self, category_id: int, category_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            category_to_update = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category_to_update:
                return False, "Category/Process not found."

            validation_data = {
                "name": category_data.get("name", category_to_update.name).strip(),
                "level": category_to_update.level,
                "parent_id": category_to_update.parent_id,
            }

            is_valid, errors = self.validate_charge_code_category_data(
                validation_data, is_new=False, category_id_to_ignore=category_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            changed = False
            if (
                "name" in category_data
                and category_to_update.name != category_data["name"].strip()
            ):
                category_to_update.name = category_data["name"].strip()
                changed = True

            if (
                "is_active" in category_data
                and category_to_update.is_active != category_data["is_active"]
            ):
                category_to_update.is_active = category_data["is_active"]
                changed = True

            if changed:
                category_to_update.modified_by = current_user_id
                session.commit()
                cat_type = "Process" if category_to_update.level == 2 else "Category"
                self.logger.info(
                    f"Charge Code {cat_type} '{category_to_update.name}' (ID: {category_id}) updated by {current_user_id}."
                )
                return True, f"{cat_type} updated successfully."
            else:
                return True, "No changes detected to update."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            return False, f"Database integrity error: {str(ie.orig)}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating category ID {category_id}: {e}", exc_info=True
            )
            return False, f"Failed to update category/process: {str(e)}"
        finally:
            if session:
                session.close()

    def toggle_charge_code_category_status(
        self, category_id: int, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        category = None
        try:
            category = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category:
                return False, "Category/Process not found."
            item_type = "Process" if category.level == 2 else "Category"
            original_name = category.name
            category.is_active = not category.is_active
            category.modified_by = current_user_id
            session.commit()
            new_status_str = "active" if category.is_active else "inactive"
            self.logger.info(
                f"{item_type} '{original_name}' (ID: {category.category_id}) status changed to {new_status_str} by {current_user_id}."
            )
            return (
                True,
                f"{item_type} '{original_name}' status set to {new_status_str}.",
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            if session:
                session.rollback()
            err_item_type = "Category/Process"
            err_name = f"ID {category_id}"
            if category:
                err_item_type = "Process" if category.level == 2 else "Category"
                err_name = category.name
            self.logger.error(
                f"Error toggling status for {err_item_type} {err_name}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle {err_item_type} status: {str(e)}"
        finally:
            if session:
                session.close()

    def delete_charge_code_category(
        self, category_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        category_to_delete = None
        try:
            category_to_delete = (
                session.query(ChargeCodeCategory)
                .filter(ChargeCodeCategory.category_id == category_id)
                .first()
            )
            if not category_to_delete:
                return False, "Category/Process not found."

            linked_charge_codes_count = (
                session.query(ChargeCode)
                .filter(ChargeCode.category_id == category_id)
                .count()
            )
            if linked_charge_codes_count > 0:
                msg = f"Cannot delete '{category_to_delete.name}'. It is assigned to {linked_charge_codes_count} charge code(s)."
                self.logger.warning(msg)
                return False, msg

            if category_to_delete.level == 1:
                children_count = (
                    session.query(ChargeCodeCategory)
                    .filter(ChargeCodeCategory.parent_id == category_id)
                    .count()
                )
                if children_count > 0:
                    msg = f"Cannot delete Category '{category_to_delete.name}'. It has {children_count} child Process(es). Delete children first."
                    self.logger.warning(msg)
                    return False, msg

            cat_type_name = "Process" if category_to_delete.level == 2 else "Category"
            deleted_name = category_to_delete.name
            session.delete(category_to_delete)
            session.commit()
            self.logger.info(
                f"Charge Code {cat_type_name} '{deleted_name}' (ID: {category_id}) deleted by {current_user_id}."
            )
            return True, f"{cat_type_name} '{deleted_name}' deleted successfully."
        except sqlalchemy_exc.SQLAlchemyError as e:
            if session:
                session.rollback()
            self.logger.error(
                f"Error deleting category ID {category_id}: {e}", exc_info=True
            )
            name_for_error = (
                category_to_delete.name if category_to_delete else f"ID {category_id}"
            )
            if isinstance(e, sqlalchemy_exc.IntegrityError):
                return (
                    False,
                    f"Cannot delete '{name_for_error}'. It might still be referenced by other records. Details: {e.orig}",
                )
            return (
                False,
                f"Failed to delete category/process due to a database error: {str(e)}",
            )
        finally:
            if session:
                session.close()

    def get_all_charge_code_categories_hierarchical(
        self,
    ) -> List[ChargeCodeCategory]:
        """Fetches all Level 1 categories, with their Level 2 children (processes) eager-loaded."""
        session = db_manager.get_session()
        try:
            level1_categories = (
                session.query(ChargeCodeCategory)
                .filter(
                    ChargeCodeCategory.parent_id.is_(None),
                    ChargeCodeCategory.level == 1,
                )
                .options(selectinload(ChargeCodeCategory.children))
                .order_by(ChargeCodeCategory.name)
                .all()
            )
            return level1_categories
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching hierarchical charge code categories: {e}",
                exc_info=True,
            )
            return []
        finally:
            if session:
                session.close()

    def get_charge_code_categories(
        self,
        parent_id: Optional[int] = None,
        level: Optional[int] = None,
        active_only: bool = True,
    ) -> List[ChargeCodeCategory]:
        session = db_manager.get_session()
        try:
            query = session.query(ChargeCodeCategory)
            if active_only:
                query = query.filter(ChargeCodeCategory.is_active == True)

            if parent_id is None and level == 1:
                query = query.filter(
                    ChargeCodeCategory.parent_id.is_(None),
                    ChargeCodeCategory.level == 1,
                )
            else:
                if parent_id is not None:
                    query = query.filter(ChargeCodeCategory.parent_id == parent_id)
                if level is not None:
                    query = query.filter(ChargeCodeCategory.level == level)

            categories = query.order_by(ChargeCodeCategory.name).all()
            return categories
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching charge code categories: {e}", exc_info=True
            )
            return []
        finally:
            if session:
                session.close()

    def get_category_path(self, category_id: Optional[int]) -> List[Dict[str, Any]]:
        """
        Retrieves the hierarchical path for a given category ID.
        Returns a list of dictionaries, each with 'id' and 'name'.
        """
        path_for_display = []
        if category_id is None:
            return path_for_display

        current_cat_id = category_id
        session = db_manager.get_session()
        try:
            while current_cat_id is not None:
                category = (
                    session.query(
                        ChargeCodeCategory.category_id,
                        ChargeCodeCategory.name,
                        ChargeCodeCategory.parent_id,
                    )
                    .filter(ChargeCodeCategory.category_id == current_cat_id)
                    .first()
                )
                if category:
                    path_for_display.insert(
                        0, {"id": category.category_id, "name": category.name}
                    )
                    current_cat_id = category.parent_id
                else:
                    break
            return path_for_display
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching category path for ID {category_id}: {e}", exc_info=True
            )
            return []
        finally:
            if session:
                session.close()


=============== FILE: controllers\company_profile_controller.py ===============

# controllers/company_profile_controller.py
"""
EDSI Veterinary Management System - Company Profile Controller
Version: 1.0.0
Purpose: Business logic for managing the company's profile information.
Last Updated: June 8, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict, Any, Tuple

from sqlalchemy.exc import SQLAlchemyError

from config.database_config import db_manager
from models import CompanyProfile


class CompanyProfileController:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_company_profile(self) -> Optional[CompanyProfile]:
        """
        Retrieves the company profile. Assumes a single profile with id=1.
        """
        session = db_manager.get_session()
        try:
            profile = (
                session.query(CompanyProfile).filter(CompanyProfile.id == 1).first()
            )
            return profile
        except SQLAlchemyError as e:
            self.logger.error(f"Error retrieving company profile: {e}", exc_info=True)
            return None
        finally:
            session.close()

    def update_company_profile(
        self, data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        """
        Creates or updates the company profile. Assumes a single profile with id=1.
        """
        session = db_manager.get_session()
        try:
            profile = (
                session.query(CompanyProfile).filter(CompanyProfile.id == 1).first()
            )

            if not profile:
                self.logger.info("No existing company profile found. Creating new one.")
                profile = CompanyProfile(id=1, created_by=current_user_id)
                session.add(profile)

            for key, value in data.items():
                if hasattr(profile, key):
                    setattr(profile, key, value)

            profile.modified_by = current_user_id
            session.commit()
            self.logger.info(f"Company profile updated by {current_user_id}.")
            return True, "Company profile updated successfully."

        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error updating company profile: {e}", exc_info=True
            )
            return False, f"A database error occurred: {e}"
        finally:
            session.close()


=============== FILE: controllers\financial_controller.py ===============

# controllers/financial_controller.py
"""
EDSI Veterinary Management System - Financial Controller
Version: 2.3.0
Purpose: Handles business logic for financial operations like creating invoices and recording payments.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v2.3.0 (2025-06-10):
    - Added record_payment method to handle saving a payment transaction. This
      method updates the Owner and Invoice balances, creates an OwnerPayment
      record, and logs the event in OwnerBillingHistory.
- v2.2.0 (2025-06-10):
    - Refactored generate_invoices_from_transactions to be more robust. It now
      explicitly groups charges by horse before processing, ensuring that all
      charges for a single horse are correctly grouped onto one invoice per owner.
"""
# ... (imports remain the same) ...
import logging
from typing import List, Optional, Dict, Any, Tuple
from decimal import Decimal, InvalidOperation
from datetime import date
from collections import defaultdict

from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm import joinedload, selectinload

from config.database_config import db_manager
from models import (
    Transaction,
    Invoice,
    Horse,
    Owner,
    ChargeCode,
    User,
    ChargeCodeCategory,
    OwnerBillingHistory,
    HorseOwner,
    OwnerPayment,
)


class FinancialController:
    # ... (all existing methods like __init__, get_invoice_by_id, etc. remain unchanged) ...
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_invoice_by_id(self, invoice_id: int) -> Optional[Invoice]:
        session = db_manager.get_session()
        try:
            invoice = (
                session.query(Invoice).filter(Invoice.invoice_id == invoice_id).first()
            )
            return invoice
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving invoice {invoice_id}: {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def get_invoices_for_owner(self, owner_id: int) -> List[Invoice]:
        session = db_manager.get_session()
        try:
            invoices = (
                session.query(Invoice)
                .options(joinedload(Invoice.owner))
                .filter(
                    Invoice.owner_id == owner_id, Invoice.status != "INTERNAL_PROCESSED"
                )
                .order_by(Invoice.invoice_date.desc())
                .all()
            )
            return invoices
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving invoices for owner {owner_id}: {e}", exc_info=True
            )
            return []
        finally:
            session.close()

    def get_transactions_for_invoice(self, invoice_id: int) -> List[Transaction]:
        session = db_manager.get_session()
        try:
            transactions = (
                session.query(Transaction)
                .filter(Transaction.invoice_id == invoice_id)
                .options(joinedload(Transaction.charge_code))
                .order_by(Transaction.transaction_date.asc())
                .all()
            )
            return transactions
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving transactions for invoice {invoice_id}: {e}",
                exc_info=True,
            )
            return []
        finally:
            session.close()

    def generate_invoices_from_transactions(
        self, source_transaction_ids: List[int], current_user_id: str
    ) -> Tuple[bool, str, List[Invoice]]:
        self.logger.info(
            f"--- Starting Invoice Generation for transaction IDs: {source_transaction_ids} ---"
        )
        session = db_manager.get_session()
        try:
            if not source_transaction_ids:
                return False, "No charges were selected to be invoiced.", []

            source_transactions = (
                session.query(Transaction)
                .filter(Transaction.transaction_id.in_(source_transaction_ids))
                .options(
                    joinedload(Transaction.horse)
                    .selectinload(Horse.owner_associations)
                    .joinedload(HorseOwner.owner)
                )
                .all()
            )

            for t in source_transactions:
                if t.status != "ACTIVE":
                    return (
                        False,
                        f"Charge '{t.description}' (ID: {t.transaction_id}) has already been processed.",
                        [],
                    )

            generated_invoices = []

            transactions_by_horse = defaultdict(list)
            for t in source_transactions:
                transactions_by_horse[t.horse_id].append(t)

            self.logger.info(
                f"Generating invoices for {len(transactions_by_horse)} horse(s)."
            )

            for horse_id, transactions_for_horse in transactions_by_horse.items():
                horse = transactions_for_horse[0].horse
                owner_associations = horse.owner_associations
                if not owner_associations:
                    self.logger.warning(
                        f"Horse '{horse.horse_name}' has no owners assigned, skipping."
                    )
                    continue

                for association in owner_associations:
                    owner = association.owner
                    ownership_percentage = association.percentage_ownership / Decimal(
                        100
                    )

                    owner_invoice = Invoice(
                        owner_id=owner.owner_id,
                        invoice_date=date.today(),
                        created_by=current_user_id,
                        modified_by=current_user_id,
                        status="Unpaid",
                    )
                    session.add(owner_invoice)
                    session.flush()

                    invoice_total = Decimal("0.00")
                    for src_trans in transactions_for_horse:
                        prorated_price = (
                            src_trans.total_price * ownership_percentage
                        ).quantize(Decimal("0.01"))
                        invoice_total += prorated_price

                        line_item_desc = src_trans.description
                        if len(owner_associations) > 1:
                            line_item_desc += (
                                f" ({association.percentage_ownership:.2f}% Share)"
                            )

                        new_line_item = Transaction(
                            horse_id=src_trans.horse_id,
                            owner_id=owner.owner_id,
                            invoice_id=owner_invoice.invoice_id,
                            charge_code_id=src_trans.charge_code_id,
                            administered_by_user_id=src_trans.administered_by_user_id,
                            transaction_date=src_trans.transaction_date,
                            description=line_item_desc,
                            quantity=src_trans.quantity,
                            unit_price=(src_trans.unit_price * ownership_percentage),
                            total_price=prorated_price,
                            taxable=src_trans.taxable,
                            item_notes=src_trans.item_notes,
                            created_by=current_user_id,
                            modified_by=current_user_id,
                            status="BILLED",
                        )
                        session.add(new_line_item)

                    owner_invoice.subtotal = invoice_total
                    owner_invoice.grand_total = invoice_total
                    owner_invoice.balance_due = invoice_total
                    owner.balance = (owner.balance or Decimal("0.00")) + invoice_total

                    history_entry = OwnerBillingHistory(
                        owner_id=owner.owner_id,
                        description=f"Invoice #{owner_invoice.invoice_id} generated for {horse.horse_name}.",
                        amount_change=invoice_total,
                        new_balance=owner.balance,
                        created_by=current_user_id,
                    )
                    session.add(history_entry)
                    generated_invoices.append(owner_invoice)

            for src_trans in source_transactions:
                src_trans.status = "PROCESSED"
                self.logger.debug(
                    f"Marking source TXN ID {src_trans.transaction_id} as PROCESSED."
                )

            session.commit()
            self.logger.info(
                f"--- Invoice Generation Complete. {len(generated_invoices)} invoices created. ---"
            )
            return (
                True,
                f"{len(generated_invoices)} invoice(s) created successfully.",
                generated_invoices,
            )

        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error during invoice generation: {e}", exc_info=True
            )
            return False, f"A database error occurred: {e}", []
        finally:
            session.close()

    def record_payment(self, payment_data: Dict[str, Any]) -> Tuple[bool, str]:
        """Records a payment against an invoice and updates balances."""
        session = db_manager.get_session()
        try:
            invoice_id = payment_data.get("invoice_id")
            amount = payment_data.get("amount")
            current_user_id = payment_data.get("user_id")

            if not all([invoice_id, amount, current_user_id]):
                return False, "Missing required payment data."

            invoice = (
                session.query(Invoice)
                .options(joinedload(Invoice.owner))
                .filter(Invoice.invoice_id == invoice_id)
                .first()
            )
            if not invoice:
                return False, "Invoice not found."

            owner = invoice.owner
            if not owner:
                return False, "Owner for the invoice could not be found."

            # Create the payment record
            new_payment = OwnerPayment(
                owner_id=invoice.owner_id,
                amount=amount,
                payment_date=payment_data.get("payment_date", date.today()),
                payment_method=payment_data.get("payment_method", "Unknown"),
                reference_number=payment_data.get("reference_number"),
                notes=payment_data.get("notes"),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_payment)

            # Update invoice balances
            invoice.amount_paid = (invoice.amount_paid or Decimal("0.00")) + amount
            invoice.balance_due = (invoice.balance_due or Decimal("0.00")) - amount
            if invoice.balance_due <= Decimal("0.00"):
                invoice.status = "Paid"
                self.logger.info(f"Invoice #{invoice_id} marked as Paid.")

            # Update owner's total balance
            owner.balance = (owner.balance or Decimal("0.00")) - amount

            # Create billing history log for the payment
            history_entry = OwnerBillingHistory(
                owner_id=owner.owner_id,
                description=f"Payment received for Invoice #{invoice.invoice_id}. Ref: {new_payment.reference_number or new_payment.payment_method}",
                amount_change=-amount,
                new_balance=owner.balance,
                created_by=current_user_id,
            )
            session.add(history_entry)

            session.commit()
            self.logger.info(
                f"Payment of ${amount} successfully recorded for Invoice #{invoice_id}."
            )
            return True, "Payment recorded successfully."

        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error recording payment for invoice {invoice_id}: {e}",
                exc_info=True,
            )
            return False, "A database error occurred while recording the payment."
        finally:
            if session:
                session.close()

    def get_transactions_for_horse(self, horse_id: int) -> List[Transaction]:
        session = db_manager.get_session()
        try:
            transactions = (
                session.query(Transaction)
                .filter(
                    Transaction.horse_id == horse_id, Transaction.status == "ACTIVE"
                )
                .options(
                    joinedload(Transaction.charge_code),
                    joinedload(Transaction.administered_by),
                )
                .order_by(Transaction.transaction_date.desc())
                .all()
            )
            self.logger.info(
                f"Retrieved {len(transactions)} ACTIVE transactions for horse ID {horse_id}."
            )
            return transactions
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving transactions for horse ID {horse_id}: {e}",
                exc_info=True,
            )
            return []
        finally:
            if session:
                session.close()

    def add_charge_batch_to_horse(
        self,
        horse_id: int,
        owner_id: int,
        charge_items: List[Dict[str, Any]],
        batch_transaction_date: date,
        administered_by_user_id: str,
    ) -> Tuple[bool, str, Optional[List[Transaction]]]:
        session = db_manager.get_session()
        new_transactions = []
        try:
            for item in charge_items:
                total_price = item.get("quantity", Decimal(0)) * item.get(
                    "unit_price", Decimal(0)
                )
                new_transaction = Transaction(
                    horse_id=horse_id,
                    owner_id=owner_id,
                    charge_code_id=item.get("charge_code_id"),
                    administered_by_user_id=administered_by_user_id,
                    transaction_date=batch_transaction_date,
                    description=item.get("description"),
                    quantity=item.get("quantity"),
                    unit_price=item.get("unit_price"),
                    total_price=total_price,
                    taxable=item.get("taxable", False),
                    item_notes=item.get("item_notes"),
                    created_by=administered_by_user_id,
                    modified_by=administered_by_user_id,
                )
                session.add(new_transaction)
                new_transactions.append(new_transaction)
            session.commit()
            for trans in new_transactions:
                session.refresh(trans)
            self.logger.info(
                f"Successfully added {len(new_transactions)} charges for horse ID {horse_id}."
            )
            return (
                True,
                f"{len(new_transactions)} charges added successfully.",
                new_transactions,
            )
        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error adding charge batch for horse ID {horse_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred: {e}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Unexpected error adding charge batch for horse ID {horse_id}: {e}",
                exc_info=True,
            )
            return False, f"An unexpected error occurred: {e}", None
        finally:
            if session:
                session.close()

    def update_charge_transaction(
        self, transaction_id: int, data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            transaction = (
                session.query(Transaction)
                .filter(Transaction.transaction_id == transaction_id)
                .first()
            )
            if not transaction:
                return False, "Transaction not found."
            if transaction.invoice_id:
                return False, "Cannot edit a charge that has already been invoiced."
            transaction.transaction_date = data.get(
                "transaction_date", transaction.transaction_date
            )
            transaction.description = data.get("description", transaction.description)
            transaction.quantity = data.get("quantity", transaction.quantity)
            transaction.unit_price = data.get("unit_price", transaction.unit_price)
            transaction.taxable = data.get("taxable", transaction.taxable)
            transaction.item_notes = data.get("item_notes", transaction.item_notes)
            transaction.total_price = transaction.quantity * transaction.unit_price
            transaction.modified_by = current_user_id
            session.commit()
            self.logger.info(f"Transaction ID {transaction_id} updated successfully.")
            return True, "Charge updated successfully."
        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error updating transaction {transaction_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred: {e}"
        finally:
            if session:
                session.close()

    def delete_charge_transaction(self, transaction_id: int) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            transaction_to_delete = (
                session.query(Transaction)
                .filter(Transaction.transaction_id == transaction_id)
                .first()
            )
            if not transaction_to_delete:
                self.logger.warning(
                    f"Delete failed: Transaction ID {transaction_id} not found."
                )
                return False, "Transaction not found."
            if transaction_to_delete.invoice_id is not None:
                self.logger.warning(
                    f"Attempted to delete invoiced transaction ID {transaction_id}."
                )
                return False, "Cannot delete a charge that has already been invoiced."
            session.delete(transaction_to_delete)
            session.commit()
            self.logger.info(f"Transaction ID {transaction_id} deleted successfully.")
            return True, "Charge deleted successfully."
        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting transaction ID {transaction_id}: {e}",
                exc_info=True,
            )
            return False, f"A database error occurred while deleting the charge: {e}"
        finally:
            if session:
                session.close()

    def get_transaction_by_id(self, transaction_id: int) -> Optional[Transaction]:
        session = db_manager.get_session()
        try:
            transaction = (
                session.query(Transaction)
                .options(joinedload(Transaction.charge_code))
                .filter(Transaction.transaction_id == transaction_id)
                .first()
            )
            if transaction:
                self.logger.info(
                    f"Retrieved transaction ID {transaction_id} with its charge code."
                )
            else:
                self.logger.warning(f"Transaction ID {transaction_id} not found.")
            return transaction
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving transaction ID {transaction_id}: {e}", exc_info=True
            )
            return None
        finally:
            if session:
                session.close()

    def delete_invoice(self, invoice_id: int, current_user_id: str) -> Tuple[bool, str]:
        """
        Deletes an invoice and reverses the owner's balance.
        NOTE: This does NOT make the original charges billable again.
        """
        session = db_manager.get_session()
        try:
            invoice_to_delete = (
                session.query(Invoice)
                .options(joinedload(Invoice.owner))
                .filter(Invoice.invoice_id == invoice_id)
                .first()
            )

            if not invoice_to_delete:
                return False, "Invoice not found."

            if not invoice_to_delete.owner:
                return (
                    False,
                    "Cannot delete invoice: Owner record is missing or detached.",
                )

            owner = invoice_to_delete.owner
            reversal_amount = invoice_to_delete.grand_total

            self.logger.info(
                f"Deleting Invoice #{invoice_id} for owner '{owner.owner_id}'. "
                f"Reversing balance by ${reversal_amount}."
            )

            owner.balance = (owner.balance or Decimal("0.00")) - reversal_amount

            history_entry = OwnerBillingHistory(
                owner_id=owner.owner_id,
                description=f"Invoice #{invoice_id} deleted by user. Reversal of charges.",
                amount_change=-reversal_amount,
                new_balance=owner.balance,
                created_by=current_user_id,
            )
            session.add(history_entry)

            session.delete(invoice_to_delete)
            session.commit()

            self.logger.info(
                f"Successfully deleted Invoice #{invoice_id} and adjusted owner balance."
            )
            return True, f"Invoice #{invoice_id} has been deleted."

        except SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting invoice {invoice_id}: {e}", exc_info=True
            )
            return False, f"A database error occurred during deletion: {e}"
        finally:
            if session:
                session.close()


=============== FILE: controllers\horse_controller.py ===============

# controllers/horse_controller.py
"""
EDSI Veterinary Management System - Horse Controller
Version: 1.5.0
Purpose: Handles business logic related to horses.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v1.5.0 (2025-06-10):
    - Fixed a critical bug in `create_horse` that caused a crash when saving a
      new horse without a location. The creation of a HorseLocation history
      record is now conditional on a location_id being provided.
- v1.4.0 (2025-06-09):
    - Refactored to improve separation of concerns by removing the redundant
      `get_all_locations` method. This functionality correctly belongs to the
      LocationController.
- v1.3.0 (2025-06-09):
    - Bug Fix: In `get_horse_by_id`, added `selectinload(Horse.owner_associations)`
      to the query to prevent DetachedInstanceError during invoice generation.
"""
import logging
from typing import List, Optional, Dict, Any
from datetime import datetime, date

from sqlalchemy import (
    select,
    update,
    delete,
    and_,
    or_,
    func as sql_func,
)
from sqlalchemy.orm import joinedload, selectinload, aliased
from sqlalchemy.exc import SQLAlchemyError

from config.database_config import db_manager
from models import Horse, Owner, HorseOwner, Location, HorseLocation


class HorseController:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def validate_horse_data(
        self,
        data: dict,
        is_new: bool = True,
        horse_id_to_check_for_unique: Optional[int] = None,
    ) -> tuple[bool, list]:
        errors = []
        required_fields = ["horse_name"]

        for field in required_fields:
            if not data.get(field) or not str(data[field]).strip():
                errors.append(f"{field.replace('_', ' ').capitalize()} is required.")

        if data.get("date_of_birth"):
            try:
                dob = data["date_of_birth"]
                if not isinstance(dob, date):
                    errors.append("Date of Birth was not a valid date object.")
                elif dob > date.today():
                    errors.append("Date of Birth cannot be in the future.")
            except Exception:
                errors.append("Invalid Date of Birth provided.")

        if data.get("coggins_date"):
            try:
                coggins_dt = data["coggins_date"]
                if not isinstance(coggins_dt, date):
                    errors.append("Coggins Date was not a valid date object.")
                elif coggins_dt > date.today():
                    errors.append("Coggins Date cannot be in the future.")
            except Exception:
                errors.append("Invalid Coggins Date provided.")

        chip_number = data.get("chip_number")
        if chip_number and str(chip_number).strip():
            session = db_manager.get_session()
            try:
                query = session.query(Horse).filter(Horse.chip_number == chip_number)
                if not is_new and horse_id_to_check_for_unique:
                    query = query.filter(Horse.horse_id != horse_id_to_check_for_unique)
                if query.first():
                    errors.append(f"Chip number '{chip_number}' already exists.")
            finally:
                session.close()

        tattoo_number = data.get("tattoo_number")
        if tattoo_number and str(tattoo_number).strip():
            session = db_manager.get_session()
            try:
                query = session.query(Horse).filter(
                    Horse.tattoo_number == tattoo_number
                )
                if not is_new and horse_id_to_check_for_unique:
                    query = query.filter(Horse.horse_id != horse_id_to_check_for_unique)
                if query.first():
                    errors.append(f"Tattoo number '{tattoo_number}' already exists.")
            finally:
                session.close()
        return not errors, errors

    def create_horse(
        self, data: dict, created_by_user: str
    ) -> tuple[bool, str, Optional[Horse]]:
        session = db_manager.get_session()
        try:
            data["created_by"] = created_by_user
            data["modified_by"] = created_by_user

            horse_columns = {col.name for col in Horse.__table__.columns}
            filtered_data = {k: v for k, v in data.items() if k in horse_columns}

            for key in data:
                if key not in horse_columns and key not in ["current_location_id"]:
                    self.logger.warning(
                        f"HorseController.create_horse - Attribute '{key}' present in data but not in Horse model columns. It will be ignored."
                    )

            new_horse = Horse(**filtered_data)
            session.add(new_horse)

            # MODIFIED: Only create a location assignment if a location is provided.
            location_id = data.get("current_location_id")
            if location_id is not None:
                new_horse.current_location_id = location_id

                new_assignment = HorseLocation(
                    horse=new_horse,
                    location_id=location_id,
                    date_arrived=date.today(),
                    is_current_location=True,
                    created_by=created_by_user,
                    modified_by=created_by_user,
                )
                session.add(new_assignment)

            session.commit()
            session.refresh(new_horse)

            self.logger.info(
                f"Horse '{new_horse.horse_name}' (ID: {new_horse.horse_id}) created successfully by {created_by_user}."
            )
            return (
                True,
                f"Horse '{new_horse.horse_name}' created successfully.",
                new_horse,
            )
        except TypeError as te:
            self.logger.error(
                f"TypeError during Horse creation: {te} - Data was: {data}",
                exc_info=True,
            )
            session.rollback()
            return (
                False,
                f"Failed to create horse due to invalid data field: {te}",
                None,
            )
        except SQLAlchemyError as e:
            self.logger.error(
                f"SQLAlchemyError creating horse: {e} - Data was: {data}", exc_info=True
            )
            session.rollback()
            return (
                False,
                f"A database error occurred while creating the horse: {e}",
                None,
            )
        except Exception as e:
            self.logger.error(
                f"Unexpected error creating horse: {e} - Data was: {data}",
                exc_info=True,
            )
            session.rollback()
            return (
                False,
                f"An unexpected error occurred while creating the horse: {e}",
                None,
            )
        finally:
            session.close()

    def update_horse(
        self, horse_id: int, data: dict, modified_by_user: str
    ) -> tuple[bool, str]:
        session = db_manager.get_session()
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return False, "Horse not found."

            data["modified_by"] = modified_by_user
            horse_columns = {col.name for col in Horse.__table__.columns}

            for key, value in data.items():
                if key == "current_location_id":
                    if horse.current_location_id != value:
                        horse.current_location_id = value
                elif key in horse_columns:
                    setattr(horse, key, value)
                elif hasattr(horse, key):
                    self.logger.info(
                        f"Setting attribute '{key}' which is not a direct column but exists on Horse model."
                    )
                    setattr(horse, key, value)
                else:
                    self.logger.warning(
                        f"HorseController.update_horse - Attempted to set unknown attribute '{key}' on Horse model."
                    )
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} updated successfully by {modified_by_user}."
            )
            return True, "Horse details updated successfully."
        except SQLAlchemyError as e:
            self.logger.error(
                f"SQLAlchemyError updating horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"A database error occurred while updating the horse: {e}"
        except Exception as e:
            self.logger.error(
                f"Unexpected error updating horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"An unexpected error occurred while updating the horse: {e}"
        finally:
            session.close()

    def get_horse_by_id(self, horse_id: int) -> Optional[Horse]:
        session = db_manager.get_session()
        try:
            horse = (
                session.query(Horse)
                .options(
                    selectinload(Horse.owner_associations).joinedload(HorseOwner.owner),
                    selectinload(Horse.owners),
                    joinedload(Horse.location),
                )
                .filter(Horse.horse_id == horse_id)
                .first()
            )
            if horse:
                self.logger.info(f"Retrieved horse ID {horse_id}: {horse.horse_name}")
            else:
                self.logger.warning(f"Horse ID {horse_id} not found.")
            return horse
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error retrieving horse ID {horse_id}: {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def search_horses(
        self,
        search_term: str = "",
        status: str = "active",
        owner_name_search: Optional[str] = None,
    ) -> List[Horse]:
        session = db_manager.get_session()
        try:
            query = session.query(Horse).options(
                selectinload(Horse.owners),
                joinedload(Horse.location),
            )

            if search_term:
                search_term_like = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Horse.horse_name.ilike(search_term_like),
                        Horse.account_number.ilike(search_term_like),
                        Horse.chip_number.ilike(search_term_like),
                        Horse.tattoo_number.ilike(search_term_like),
                    )
                )

            if owner_name_search:
                OwnerAlias = aliased(Owner)
                owner_search_like = f"%{owner_name_search}%"
                query = query.join(Horse.owners.of_type(OwnerAlias)).filter(
                    or_(
                        OwnerAlias.farm_name.ilike(owner_search_like),
                        OwnerAlias.first_name.ilike(owner_search_like),
                        OwnerAlias.last_name.ilike(owner_search_like),
                    )
                )
                query = query.distinct()

            if status == "active":
                query = query.filter(Horse.is_active == True)
            elif status == "inactive":
                query = query.filter(Horse.is_active == False)

            horses = query.order_by(Horse.horse_name).all()
            self.logger.info(
                f"Search for horses (term: '{search_term}', owner: '{owner_name_search}', status: {status}) found {len(horses)} results."
            )
            return horses
        except SQLAlchemyError as e:
            self.logger.error(f"Error searching horses: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()

    def deactivate_horse(
        self, horse_id: int, modified_by_user: str
    ) -> tuple[bool, str]:
        return self._toggle_horse_status(horse_id, False, modified_by_user)

    def activate_horse(self, horse_id: int, modified_by_user: str) -> tuple[bool, str]:
        return self._toggle_horse_status(horse_id, True, modified_by_user)

    def _toggle_horse_status(
        self, horse_id: int, is_active: bool, modified_by_user: str
    ) -> tuple[bool, str]:
        session = db_manager.get_session()
        try:
            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if not horse:
                return False, "Horse not found."
            horse.is_active = is_active
            horse.modified_by = modified_by_user

            session.commit()
            status_text = "activated" if is_active else "deactivated"
            self.logger.info(
                f"Horse ID {horse_id} {status_text} by {modified_by_user}."
            )
            return True, f"Horse {status_text} successfully."
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error toggling horse status for ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return False, f"Database error: Could not change horse status."
        finally:
            session.close()

    def get_horse_owners(self, horse_id: int) -> List[Dict[str, Any]]:
        session = db_manager.get_session()
        try:
            associations = (
                session.query(HorseOwner)
                .filter(HorseOwner.horse_id == horse_id)
                .options(joinedload(HorseOwner.owner))
                .all()
            )
            owner_details = []
            for assoc in associations:
                if assoc.owner:
                    owner_name_parts = []
                    if assoc.owner.farm_name:
                        owner_name_parts.append(assoc.owner.farm_name)

                    person_name_parts = []
                    if assoc.owner.first_name:
                        person_name_parts.append(assoc.owner.first_name)
                    if assoc.owner.last_name:
                        person_name_parts.append(assoc.owner.last_name)
                    person_name_str = " ".join(person_name_parts).strip()

                    if person_name_str:
                        owner_name_parts.append(f"({person_name_str})")

                    display_name = " ".join(owner_name_parts).strip()
                    if not display_name:
                        display_name = f"Owner ID: {assoc.owner.owner_id}"

                    owner_details.append(
                        {
                            "owner_id": assoc.owner.owner_id,
                            "owner_name": display_name,
                            "percentage_ownership": assoc.percentage_ownership,
                            "phone_number": assoc.owner.phone,
                        }
                    )
            return owner_details
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owners for horse ID {horse_id}: {e}", exc_info=True
            )
            session.rollback()
            return []
        finally:
            session.close()

    def add_owner_to_horse(
        self,
        horse_id: int,
        owner_id: int,
        percentage: Optional[float],
        modified_by_user: str,
    ) -> tuple[bool, str]:
        session = db_manager.get_session()
        try:
            existing_assoc = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if existing_assoc:
                return False, "Owner is already associated with this horse."
            new_association = HorseOwner(
                horse_id=horse_id, owner_id=owner_id, percentage_ownership=percentage
            )
            session.add(new_association)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Owner ID {owner_id} added to horse ID {horse_id} by {modified_by_user}."
            )
            return True, "Owner successfully added to horse."
        except SQLAlchemyError as e:
            self.logger.error(f"Error adding owner to horse: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not add owner."
        finally:
            session.close()

    def update_horse_owner_percentage(
        self, horse_id: int, owner_id: int, percentage: float, modified_by_user: str
    ) -> tuple[bool, str]:
        session = db_manager.get_session()
        try:
            association = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if not association:
                return False, "Owner association not found."
            association.percentage_ownership = percentage

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Ownership percentage updated for horse ID {horse_id}, owner ID {owner_id} by {modified_by_user}."
            )
            return True, "Ownership percentage updated."
        except SQLAlchemyError as e:
            self.logger.error(
                f"Error updating ownership percentage: {e}", exc_info=True
            )
            session.rollback()
            return False, "Database error: Could not update ownership."
        finally:
            session.close()

    def remove_owner_from_horse(
        self, horse_id: int, owner_id: int, modified_by_user: str
    ) -> tuple[bool, str]:
        session = db_manager.get_session()
        try:
            association = (
                session.query(HorseOwner)
                .filter_by(horse_id=horse_id, owner_id=owner_id)
                .first()
            )
            if not association:
                return False, "Owner association not found."
            session.delete(association)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Owner ID {owner_id} removed from horse ID {horse_id} by {modified_by_user}."
            )
            return True, "Owner removed from horse successfully."
        except SQLAlchemyError as e:
            self.logger.error(f"Error removing owner from horse: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not remove owner."
        finally:
            session.close()

    def assign_horse_to_location(
        self,
        horse_id: int,
        location_id: int,
        notes: Optional[str],
        modified_by_user: str,
    ) -> tuple[bool, str]:
        session = db_manager.get_session()
        try:
            today = date.today()
            previous_assignments = (
                session.query(HorseLocation)
                .filter(
                    HorseLocation.horse_id == horse_id,
                    HorseLocation.is_current_location == True,
                )
                .all()
            )
            for prev_assign in previous_assignments:
                if prev_assign.location_id != location_id:
                    prev_assign.date_departed = today
                    prev_assign.is_current_location = False
                    prev_assign.modified_by = modified_by_user

            new_assignment = HorseLocation(
                horse_id=horse_id,
                location_id=location_id,
                date_arrived=today,
                notes=notes,
                is_current_location=True,
                created_by=modified_by_user,
                modified_by=modified_by_user,
            )
            session.add(new_assignment)

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse:
                horse.current_location_id = location_id
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} assigned to location ID {location_id} by {modified_by_user}."
            )
            return True, "Horse location assigned successfully."
        except SQLAlchemyError as e:
            self.logger.error(f"Error assigning horse to location: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not assign location."
        finally:
            session.close()

    def remove_horse_from_location(
        self,
        horse_id: int,
        location_id: Optional[int] = None,
        modified_by_user: str = "system",
    ) -> tuple[bool, str]:
        session = db_manager.get_session()
        try:
            query = session.query(HorseLocation).filter(
                HorseLocation.horse_id == horse_id,
                HorseLocation.is_current_location == True,
            )
            if location_id is not None:
                query = query.filter(HorseLocation.location_id == location_id)

            current_assignment = query.first()
            if not current_assignment:
                return (
                    False,
                    "No current location assignment found for this horse (or not at the specified location if one was provided).",
                )

            current_assignment.date_departed = date.today()
            current_assignment.is_current_location = False
            current_assignment.modified_by = modified_by_user

            horse = session.query(Horse).filter(Horse.horse_id == horse_id).first()
            if horse and horse.current_location_id == current_assignment.location_id:
                horse.current_location_id = None
                horse.modified_by = modified_by_user
            session.commit()
            self.logger.info(
                f"Horse ID {horse_id} removed from location (assignment ID: {current_assignment.id}) by {modified_by_user}."
            )
            return True, "Horse removed from location (assignment ended)."
        except SQLAlchemyError as e:
            self.logger.error(f"Error removing horse from location: {e}", exc_info=True)
            session.rollback()
            return False, "Database error: Could not remove horse from location."
        finally:
            session.close()


=============== FILE: controllers\location_controller.py ===============

# controllers/location_controller.py
"""
EDSI Veterinary Management System - Location Controller
Version: 1.2.0
Purpose: Handles business logic for locations.
         - Added delete_location method with referential integrity check.
         - Modified get_all_locations to accept a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.2.0 (2025-06-05):
    - Added `delete_location` method, which checks for linked horses in
      HorseLocation before allowing deletion.
    - Modified `get_all_locations` to accept a string `status_filter` ('active',
      'inactive', or 'all') instead of a boolean for consistency.
- v1.1.7 (2025-06-05):
    - Reverted `update_location` to return a tuple of two values (bool, str).
"""
import logging
from typing import List, Optional, Tuple, Dict, Any

from sqlalchemy.orm import Session, joinedload
from sqlalchemy import exc as sqlalchemy_exc

from config.database_config import db_manager
from models import Location, StateProvince, HorseLocation


class LocationController:
    """Controller for location management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_locations(self, status_filter: str = "all") -> List[Location]:
        session = db_manager.get_session()
        try:
            query = session.query(Location).options(joinedload(Location.state))
            if status_filter == "active":
                query = query.filter(Location.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Location.is_active == False)
            locations = query.order_by(Location.location_name).all()
            return locations
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all locations: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_location_by_id(self, location_id: int) -> Optional[Location]:
        session = db_manager.get_session()
        try:
            return (
                session.query(Location)
                .options(joinedload(Location.state))
                .filter(Location.location_id == location_id)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching location by ID {location_id}: {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_location_data(
        self,
        location_data: dict,
        is_new: bool = True,
        location_id_to_check_for_unique: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        errors = []
        name = location_data.get("location_name", "").strip()

        if not name:
            errors.append("Location Name is required.")
        elif len(name) > 100:
            errors.append("Location Name cannot exceed 100 characters.")
        else:
            session = db_manager.get_session()
            try:
                query = session.query(Location.location_id).filter(
                    Location.location_name.collate("NOCASE") == name
                )
                if not is_new and location_id_to_check_for_unique is not None:
                    query = query.filter(
                        Location.location_id != location_id_to_check_for_unique
                    )
                if query.first():
                    errors.append(f"Location Name '{name}' already exists.")
            finally:
                session.close()
        return not errors, errors

    def create_location(
        self, location_data: dict, current_user_id: str
    ) -> Tuple[bool, str, Optional[Location]]:
        is_valid, errors = self.validate_location_data(location_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:

            def process_string(value: Any) -> Optional[str]:
                return value.strip() if isinstance(value, str) else None

            new_location = Location(
                location_name=location_data.get("location_name", "").strip(),
                address_line1=process_string(location_data.get("address_line1")),
                address_line2=process_string(location_data.get("address_line2")),
                city=process_string(location_data.get("city")),
                state_code=process_string(location_data.get("state_code")),
                zip_code=process_string(location_data.get("zip_code")),
                phone=process_string(location_data.get("phone")),
                contact_person=process_string(location_data.get("contact_person")),
                email=process_string(location_data.get("email")),
                is_active=location_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_location)
            session.commit()
            session.refresh(new_location)
            self.logger.info(
                f"Location '{new_location.location_name}' created by {current_user_id}."
            )
            return True, "Location created successfully.", new_location
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(f"Error creating location: {e.orig}", exc_info=True)
            return False, f"Database integrity error: {e.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating location: {e}", exc_info=True)
            return False, f"Failed to create location: {e}", None
        finally:
            session.close()

    def update_location(
        self, location_id: int, location_data: dict, current_user_id: str
    ) -> Tuple[bool, str]:
        is_valid, errors = self.validate_location_data(
            location_data, is_new=False, location_id_to_check_for_unique=location_id
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors)

        session = db_manager.get_session()
        try:
            location = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )
            if not location:
                return False, "Location not found."

            for key, value in location_data.items():
                if hasattr(location, key):
                    processed_value = value.strip() if isinstance(value, str) else value
                    setattr(location, key, processed_value)

            location.modified_by = current_user_id
            session.commit()
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location_id}) updated by {current_user_id}."
            )
            return True, "Location updated successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating location ID {location_id}: {e}", exc_info=True
            )
            return False, f"Failed to update location: {e}"
        finally:
            session.close()

    def toggle_location_active_status(
        self, location_id: int, current_user_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            location = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )
            if not location:
                return False, f"Location with ID {location_id} not found."

            location.is_active = not location.is_active
            location.modified_by = current_user_id

            session.commit()

            new_status = "activated" if location.is_active else "deactivated"
            self.logger.info(
                f"Location '{location.location_name}' (ID: {location_id}) status changed to {new_status} by {current_user_id}."
            )
            return (
                True,
                f"Location '{location.location_name}' has been successfully {new_status}.",
            )

        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error toggling status for location ID {location_id}: {e}",
                exc_info=True,
            )
            return False, "A database error occurred while toggling location status."
        finally:
            if session:
                session.close()

    def delete_location(
        self, location_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        session = db_manager.get_session()
        try:
            linked_horses_count = (
                session.query(HorseLocation)
                .filter(HorseLocation.location_id == location_id)
                .count()
            )

            if linked_horses_count > 0:
                message = f"Cannot delete location. It is currently or was previously assigned to {linked_horses_count} horse(s)."
                self.logger.warning(message)
                return False, message

            location_to_delete = (
                session.query(Location)
                .filter(Location.location_id == location_id)
                .first()
            )

            if not location_to_delete:
                return False, "Location not found."

            location_name = location_to_delete.location_name
            session.delete(location_to_delete)
            session.commit()
            self.logger.info(
                f"Location '{location_name}' (ID: {location_id}) deleted by {current_user_id}."
            )
            return True, f"Location '{location_name}' was deleted."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error deleting location ID {location_id}: {e}", exc_info=True
            )
            return False, f"A database error occurred: {e}"
        finally:
            session.close()


=============== FILE: controllers\owner_controller.py ===============

# controllers/owner_controller.py
"""
EDSI Veterinary Management System - Owner Controller
Version: 1.4.0
Purpose: Business logic for owner master file operations.
         - Standardized get_all_master_owners filter to use a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.4.0 (2025-06-05):
    - Modified `get_all_master_owners` to accept a string `status_filter` ('active',
      'inactive', 'all') for consistency.
- v1.3.5 (2025-06-04):
    - In `get_all_master_owners`, added `options(joinedload(Owner.state))`
      to eagerly load the related StateProvince object, preventing
      DetachedInstanceError when accessing owner.state in views.
- v1.3.4 (2025-06-02):
    - Added `import re` to resolve NameError during email validation
      in `validate_owner_data`.
- v1.3.3 (2025-06-02):
    - Modified `validate_owner_data` to correctly handle optional fields that
      might be `None` before calling `len()` on them, preventing TypeError.
- v1.3.2 (2025-05-17):
    - Removed `country_name` from Owner instantiation/update and validation.
- v1.3.1 (2025-05-17):
    - Removed phone number requirement from `validate_owner_data`.
    - Added `mobile_phone` handling.
- v1.2.1 (2025-05-15): Removed credit_rating.
- v1.2.0 (2025-05-15): Added delete_master_owner method.
"""

import logging
import re
from typing import List, Optional, Tuple, Dict, Any
from decimal import Decimal, InvalidOperation
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import or_, func, exc as sqlalchemy_exc

from config.database_config import db_manager
from models import (
    Owner,
    StateProvince,
    HorseOwner,
)
from datetime import datetime


class OwnerController:
    """Controller for owner master file operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_master_owners(self, status_filter: str = "all") -> List[Owner]:
        session = db_manager.get_session()
        try:
            query = session.query(Owner).options(joinedload(Owner.state))

            if status_filter == "active":
                query = query.filter(Owner.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Owner.is_active == False)

            owners = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()
            self.logger.info(
                f"Retrieved {len(owners)} master owners (status_filter={status_filter})."
            )
            return owners
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all master owners: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_all_owners_for_lookup(self, search_term: str = "") -> List[Dict[str, Any]]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            query = session.query(
                Owner.owner_id,
                Owner.first_name,
                Owner.last_name,
                Owner.farm_name,
                Owner.account_number,
            ).filter(Owner.is_active == True)

            if search_term:
                search_pattern = f"%{search_term}%"
                query = query.filter(
                    or_(
                        Owner.first_name.ilike(search_pattern),
                        Owner.last_name.ilike(search_pattern),
                        Owner.farm_name.ilike(search_pattern),
                        Owner.account_number.ilike(search_pattern),
                    )
                )

            owners_data = query.order_by(
                Owner.farm_name, Owner.last_name, Owner.first_name
            ).all()

            lookup_list = []
            for (
                owner_id,
                first_name,
                last_name,
                farm_name,
                account_number,
            ) in owners_data:
                name_parts = [name for name in [first_name, last_name] if name]
                individual_name = " ".join(name_parts)
                display_text = farm_name if farm_name else ""
                if individual_name:
                    display_text = (
                        f"{display_text} ({individual_name})"
                        if farm_name
                        else individual_name
                    )
                if not display_text:
                    display_text = f"Owner ID {owner_id}"  # Fallback if no names
                if account_number:
                    display_text += f" [{account_number}]"
                lookup_list.append({"id": owner_id, "name_account": display_text})
            return lookup_list
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching owners for lookup: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_owner_by_id(self, owner_id: int) -> Optional[Owner]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            owner = (
                session.query(Owner)
                .options(joinedload(Owner.state))  # Eager load state here too
                .filter(Owner.owner_id == owner_id)
                .first()
            )
            return owner
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owner by ID '{owner_id}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_owner_data(
        self,
        owner_data: dict,
        is_new: bool = True,
        owner_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        # ... (implementation unchanged) ...
        errors = []
        first_name = owner_data.get("first_name")
        last_name = owner_data.get("last_name")
        farm_name = owner_data.get("farm_name")
        account_number_val = owner_data.get("account_number")

        if not owner_data.get("address_line1", "").strip():
            errors.append("Address Line 1 is required.")
        if not owner_data.get("city", "").strip():
            errors.append("City is required.")
        if not owner_data.get("state_code", "").strip():
            errors.append("State is required.")
        if not owner_data.get("zip_code", "").strip():
            errors.append("Zip Code is required.")

        field_max_lengths = {
            "first_name": 50,
            "last_name": 50,
            "farm_name": 100,
            "address_line1": 100,
            "address_line2": 100,
            "city": 50,
            "zip_code": 20,
            "phone": 20,
            "mobile_phone": 20,
            "email": 100,
            "account_number": 20,
            "billing_terms": 50,
        }

        for field, max_len in field_max_lengths.items():
            value = owner_data.get(field)
            if value is not None and isinstance(value, str) and len(value) > max_len:
                errors.append(
                    f"{field.replace('_', ' ').title()} cannot exceed {max_len} characters."
                )

        email_val = owner_data.get("email")
        if email_val and email_val.strip():
            if not re.match(
                r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email_val
            ):
                errors.append("Invalid email format.")

        if account_number_val and account_number_val.strip():
            session = db_manager.get_session()
            try:
                query = session.query(Owner).filter(
                    Owner.account_number.collate("NOCASE") == account_number_val.strip()
                )
                if not is_new and owner_id_to_ignore is not None:
                    query = query.filter(Owner.owner_id != owner_id_to_ignore)

                existing_owner_with_account = query.first()
                if existing_owner_with_account:
                    errors.append(
                        f"Account Number '{account_number_val}' already exists."
                    )
            except sqlalchemy_exc.SQLAlchemyError as e:
                self.logger.error(
                    f"DB error validating account_number: {e}", exc_info=True
                )
                errors.append("Error validating account number uniqueness.")
            finally:
                session.close()

        credit_limit_str = owner_data.get("credit_limit")
        if credit_limit_str is not None and str(credit_limit_str).strip() != "":
            try:
                credit_limit_decimal = Decimal(str(credit_limit_str))
                if credit_limit_decimal < Decimal("0.00"):
                    errors.append("Credit Limit cannot be negative.")
            except InvalidOperation:
                errors.append("Credit Limit must be a valid number (e.g., 1000.00).")

        return not errors, errors

    def create_master_owner(
        self, owner_data: dict, current_user: str
    ) -> Tuple[bool, str, Optional[Owner]]:
        # ... (implementation unchanged) ...
        is_valid, errors = self.validate_owner_data(owner_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_owner_params = {}
            allowed_keys = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",
                "phone",
                "mobile_phone",
                "email",
                "credit_limit",
                "billing_terms",
                "is_active",
                "balance",
                "service_charge_rate",
                "discount_rate",
                "notes",
            ]
            for key in allowed_keys:
                if key in owner_data:
                    value = owner_data[key]
                    if isinstance(value, str):
                        new_owner_params[key] = value.strip() or None
                    elif (
                        key == "credit_limit"
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            self.logger.warning(
                                f"Invalid decimal for credit_limit: {value}. Setting to None."
                            )
                            new_owner_params[key] = None
                    elif (
                        key == "balance"
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            new_owner_params[key] = Decimal("0.00")
                    elif (
                        key in ["service_charge_rate", "discount_rate"]
                        and value is not None
                        and str(value).strip() != ""
                    ):
                        try:
                            new_owner_params[key] = Decimal(str(value))
                        except InvalidOperation:
                            new_owner_params[key] = None
                    else:
                        new_owner_params[key] = value

            if new_owner_params.get("balance") is None:
                new_owner_params["balance"] = Decimal("0.00")

            if new_owner_params.get("is_active") is None:
                new_owner_params["is_active"] = True

            new_owner = Owner(**new_owner_params)
            new_owner.created_by = current_user
            new_owner.modified_by = current_user

            session.add(new_owner)
            session.commit()
            session.refresh(new_owner)

            log_name_parts = [
                name for name in [new_owner.first_name, new_owner.last_name] if name
            ]
            log_individual_name = " ".join(log_name_parts)
            display_name_for_log = new_owner.farm_name if new_owner.farm_name else ""
            if log_individual_name:
                display_name_for_log = (
                    f"{display_name_for_log} ({log_individual_name})"
                    if new_owner.farm_name
                    else log_individual_name
                )
            if not display_name_for_log:
                display_name_for_log = f"Owner ID {new_owner.owner_id}"

            self.logger.info(
                f"Master Owner '{display_name_for_log}' (ID: {new_owner.owner_id}) created by {current_user}."
            )
            return True, "Owner created successfully.", new_owner
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError creating master owner: {ie.orig}", exc_info=True
            )
            if "UNIQUE constraint failed: owners.account_number" in str(
                ie.orig
            ).lower() and owner_data.get("account_number"):
                return (
                    False,
                    f"Account Number '{owner_data['account_number']}' already exists.",
                    None,
                )
            return False, f"Database integrity error: {ie.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating master owner: {e}", exc_info=True)
            return False, f"Failed to create owner: {e}", None
        finally:
            session.close()

    def update_master_owner(
        self, owner_id: int, owner_data: dict, current_user: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return False, f"Owner with ID {owner_id} not found."

            original_account_number = owner.account_number
            if (
                "account_number" in owner_data
                and owner_data["account_number"] != original_account_number
            ):
                is_valid, errors = self.validate_owner_data(
                    owner_data, is_new=False, owner_id_to_ignore=owner_id
                )
            else:
                temp_data_for_validation = owner_data.copy()
                temp_data_for_validation.pop("account_number", None)
                is_valid, errors = self.validate_owner_data(
                    temp_data_for_validation, is_new=False, owner_id_to_ignore=owner_id
                )

            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)

            updatable_fields = [
                "account_number",
                "first_name",
                "last_name",
                "farm_name",
                "address_line1",
                "address_line2",
                "city",
                "state_code",
                "zip_code",
                "phone",
                "mobile_phone",
                "email",
                "is_active",
                "balance",
                "credit_limit",
                "billing_terms",
                "service_charge_rate",
                "discount_rate",
                "notes",
            ]

            for key in updatable_fields:
                if key in owner_data:
                    value = owner_data[key]
                    if isinstance(value, str):
                        setattr(
                            owner,
                            key,
                            (
                                value.strip() or None
                                if key
                                not in [
                                    "last_name",
                                    "address_line1",
                                    "city",
                                    "state_code",
                                    "zip_code",
                                ]
                                else value.strip()
                            ),
                        )
                    elif (
                        key
                        in [
                            "credit_limit",
                            "balance",
                            "service_charge_rate",
                            "discount_rate",
                        ]
                        and value is not None
                    ):
                        if str(value).strip() == "":
                            if key == "balance":
                                setattr(owner, key, Decimal("0.00"))
                            else:
                                setattr(owner, key, None)
                        else:
                            try:
                                setattr(owner, key, Decimal(str(value)))
                            except InvalidOperation:
                                self.logger.warning(
                                    f"Invalid decimal value for {key}: {value} during update. Field not updated."
                                )
                    else:
                        setattr(owner, key, value)

            owner.modified_by = current_user

            session.commit()
            return True, "Owner updated successfully."
        except sqlalchemy_exc.IntegrityError as ie:
            session.rollback()
            self.logger.error(
                f"IntegrityError updating owner ID {owner_id}: {ie.orig}", exc_info=True
            )
            if "UNIQUE constraint failed: owners.account_number" in str(
                ie.orig
            ).lower() and owner_data.get("account_number"):
                return (
                    False,
                    f"Account Number '{owner_data['account_number']}' already exists for another owner.",
                )
            return False, f"Database integrity error: {ie.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating master owner ID {owner_id}: {e}", exc_info=True
            )
            return False, f"Failed to update owner: {e}"
        finally:
            session.close()

    def delete_master_owner(
        self, owner_id_to_delete: int, current_admin_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            owner = (
                session.query(Owner)
                .filter(Owner.owner_id == owner_id_to_delete)
                .first()
            )
            if not owner:
                return False, f"Owner with ID {owner_id_to_delete} not found."

            linked_horses_count = (
                session.query(HorseOwner)
                .filter(HorseOwner.owner_id == owner_id_to_delete)
                .count()
            )
            if linked_horses_count > 0:
                self.logger.warning(
                    f"Attempt to delete owner ID {owner_id_to_delete} who is linked to {linked_horses_count} horse(s)."
                )
                return (
                    False,
                    f"Cannot delete owner. They are currently linked to {linked_horses_count} horse(s). Please unlink them from all horses first.",
                )

            owner_name_for_log_parts = [
                name
                for name in [owner.farm_name, owner.last_name, owner.first_name]
                if name
            ]
            owner_name_for_log = (
                " ".join(owner_name_for_log_parts) or f"ID {owner_id_to_delete}"
            )

            session.delete(owner)
            session.commit()
            self.logger.info(
                f"Master Owner '{owner_name_for_log}' (ID: {owner_id_to_delete}) permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"Owner '{owner_name_for_log}' deleted successfully."
        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Error deleting master owner ID {owner_id_to_delete}: {e}",
                exc_info=True,
            )
            if isinstance(e, sqlalchemy_exc.IntegrityError):
                return (
                    False,
                    f"Cannot delete owner. It might be referenced by other records (e.g., invoices, payments). Details: {e.orig}",
                )
            return False, f"Failed to delete owner due to a database error: {e}"
        finally:
            session.close()

    def get_owner_form_reference_data(self) -> Dict[str, List[Dict[str, Any]]]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            states_query = (
                session.query(
                    StateProvince.state_code,
                    StateProvince.state_name,
                    StateProvince.country_code,
                )
                .filter(StateProvince.is_active == True)
                .order_by(StateProvince.country_code, StateProvince.state_name)
                .all()
            )
            states = [
                {
                    "id": s.state_code,
                    "name": s.state_name,
                    "country_code": s.country_code,
                }
                for s in states_query
            ]
            billing_terms_list = [
                {"id": "NET30", "name": "Net 30 Days"},
                {"id": "NET15", "name": "Net 15 Days"},
                {"id": "NET60", "name": "Net 60 Days"},
                {"id": "COD", "name": "Cash on Delivery"},
                {"id": "PREPAID", "name": "Prepaid"},
                {"id": "EOM", "name": "End of Month"},
                {"id": "ONDELIVERY", "name": "Payment on Delivery"},
            ]
            return {"states": states, "billing_terms": billing_terms_list}
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching owner form reference data: {e}", exc_info=True
            )
            return {"states": [], "billing_terms": []}
        finally:
            session.close()

    def toggle_owner_active_status(
        self, owner_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            owner = session.query(Owner).filter(Owner.owner_id == owner_id).first()
            if not owner:
                return False, "Owner not found."
            owner.is_active = not owner.is_active
            owner.modified_by = current_user_id
            session.commit()
            status = "activated" if owner.is_active else "deactivated"
            self.logger.info(f"Owner ID {owner_id} {status} by {current_user_id}.")
            return True, f"Owner {status} successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error toggling active status for owner ID {owner_id}: {e}",
                exc_info=True,
            )
            return False, f"Failed to toggle owner status: {e}"
        finally:
            session.close()


=============== FILE: controllers\user_controller.py ===============

# controllers/user_controller.py
"""
EDSI Veterinary Management System - User Controller
Version: 1.3.0
Purpose: Handles user authentication, CRUD operations.
         - Standardized get_all_users filter to use a string-based status_filter.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-05):
    - Modified `get_all_users` to accept a string `status_filter` ('active',
      'inactive', 'all') for consistency with other controllers.
- v1.2.8 (2025-06-05):
    - In `toggle_user_active_status`, added a check to prevent a user from
      deactivating their own account, moving this business rule from the
      view into the controller for better enforcement.
- v1.2.7 (2025-06-05):
    - Added `toggle_user_active_status` method to handle activating and
      deactivating users, including a safeguard to prevent deactivating the
      last active ADMIN account.
"""

import logging
from typing import List, Optional, Tuple, Dict, Any
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func, exc as sqlalchemy_exc
from datetime import datetime

from config.database_config import db_manager
from models.user_models import User, Role, UserRole


class UserController:
    """Controller for user management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def authenticate_user(
        self, login_id_attempt: str, password_attempt: str
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        # ... (implementation unchanged) ...
        try:
            self.logger.info(
                f"UserController.authenticate_user received login_id: '{login_id_attempt}', "
                f"password_attempt (first 3 chars): '{password_attempt[:3] if password_attempt else ''}...'"
            )
            session = db_manager.get_session()
            try:
                user = (
                    session.query(User)
                    .filter(User.user_id.collate("NOCASE") == login_id_attempt)
                    .first()
                )
                if not user:
                    self.logger.warning(
                        f"Login ID '{login_id_attempt}' not found during authentication."
                    )
                    return False, "Invalid Login ID or Password.", None
                if not user.check_password(password_attempt):
                    self.logger.warning(
                        f"Incorrect password attempt for login ID '{user.user_id}' (input was '{login_id_attempt}')."
                    )
                    return False, "Invalid Login ID or Password.", None
                if not user.is_active:
                    self.logger.warning(
                        f"Login attempt for inactive user '{user.user_id}'."
                    )
                    return (
                        False,
                        f"User account '{user.user_id}' is inactive.",
                        {
                            "user_id": user.user_id,
                            "user_name": user.user_name,
                            "is_active": user.is_active,
                        },
                    )
                if hasattr(user, "last_login"):
                    user.last_login = datetime.utcnow()
                session.commit()
                self.logger.info(f"User '{user.user_id}' authenticated successfully.")
                return (
                    True,
                    "Login successful.",
                    {
                        "user_id": user.user_id,
                        "user_name": user.user_name,
                        "is_active": user.is_active,
                    },
                )
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                session.rollback()
                self.logger.error(
                    f"Database error during authentication for '{login_id_attempt}': {e_db}",
                    exc_info=True,
                )
                return False, "An error occurred during login. Please try again.", None
            finally:
                session.close()
        except Exception as e_outer:
            self.logger.error(
                f"Outer unexpected error during authentication for '{login_id_attempt}': {e_outer}",
                exc_info=True,
            )
            return False, "An unexpected server error occurred. Please try again.", None

    def get_all_users(self, status_filter: str = "all") -> List[User]:
        session = db_manager.get_session()
        try:
            query = session.query(User).options(joinedload(User.roles))
            if status_filter == "active":
                query = query.filter(User.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(User.is_active == False)

            users = query.order_by(User.user_id).all()
            return users
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all users: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_user_by_login_id(self, login_id_str: str) -> Optional[User]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            return user
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching user by login_id '{login_id_str}': {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_user_data(
        self,
        user_data: Dict[str, Any],
        is_new: bool = True,
        original_login_id_to_ignore: Optional[str] = None,
    ) -> Tuple[bool, List[str]]:
        # ... (implementation unchanged) ...
        try:
            from views.admin.dialogs.add_edit_user_dialog import AddEditUserDialog

            available_roles_in_dialog = AddEditUserDialog.USER_ROLES
        except ImportError:
            self.logger.warning(
                "Could not import AddEditUserDialog for role validation. Role list might be incomplete."
            )
            available_roles_in_dialog = []
        errors = []
        login_id = user_data.get("user_id", "").strip()
        display_name = user_data.get("user_name", "").strip()
        password = user_data.get("password", "")
        email_value = user_data.get("email")
        email = email_value.strip() if isinstance(email_value, str) else None
        if not login_id:
            errors.append("Login ID (Username) is required.")
        elif len(login_id) > 20:
            errors.append("Login ID (Username) cannot exceed 20 characters.")
        elif " " in login_id:
            errors.append("Login ID (Username) cannot contain spaces.")
        else:
            session = db_manager.get_session()
            try:
                query = session.query(User).filter(
                    User.user_id.collate("NOCASE") == login_id
                )
                if not is_new and original_login_id_to_ignore is not None:
                    query = query.filter(
                        User.user_id.collate("NOCASE") != original_login_id_to_ignore
                    )
                if query.first():
                    errors.append(f"Login ID (Username) '{login_id}' already exists.")
                if email:
                    email_query = session.query(User).filter(User.email == email)
                    user_to_exclude_from_email_check = None
                    if not is_new and original_login_id_to_ignore:
                        original_user = (
                            session.query(User)
                            .filter(
                                User.user_id.collate("NOCASE")
                                == original_login_id_to_ignore
                            )
                            .first()
                        )
                        if original_user:
                            user_to_exclude_from_email_check = original_user.user_id
                    if user_to_exclude_from_email_check:
                        email_query = email_query.filter(
                            User.user_id != user_to_exclude_from_email_check
                        )
                    if email_query.first():
                        errors.append(f"Email '{email}' is already in use.")
            except sqlalchemy_exc.SQLAlchemyError as e_db:
                self.logger.error(
                    f"DB error validating login_id/email uniqueness: {e_db}",
                    exc_info=True,
                )
                errors.append("Error validating login_id/email uniqueness.")
            finally:
                session.close()
        if not display_name:
            errors.append("Full Name (User Name) is required.")
        elif len(display_name) > 100:
            errors.append("Full Name (User Name) cannot exceed 100 characters.")
        if is_new:
            if not password:
                errors.append("Password is required for new users.")
            elif len(password) < 6:
                errors.append("Password must be at least 6 characters long.")
        elif password and len(password) < 6:
            errors.append("New password must be at least 6 characters long.")
        if email and (
            len(email) > 100 or ("@" not in email or "." not in email.split("@")[-1])
        ):
            errors.append(
                "Invalid email format or email too long (max 100 characters)."
            )
        role_str = user_data.get("role")
        if not role_str and is_new:
            errors.append("Role is required for new users.")
        if role_str:
            session = db_manager.get_session()
            try:
                if not session.query(Role).filter(Role.name == role_str).first():
                    errors.append(f"Role '{role_str}' does not exist in the database.")
            finally:
                session.close()
        return not errors, errors

    def create_user(
        self, user_data: Dict[str, Any], current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str, Optional[User]]:
        # ... (implementation unchanged) ...
        login_id_to_store = user_data.get("user_id", "").strip()
        if not login_id_to_store:
            return False, "Login ID (Username) cannot be empty.", None
        if login_id_to_store.upper() == "ADMIN":
            login_id_to_store = "ADMIN"
        data_for_model = {
            "user_id": login_id_to_store,
            "user_name": user_data.get("user_name", "").strip(),
            "email": user_data.get("email"),
            "is_active": user_data.get("is_active", True),
            "created_by": current_admin_id,
            "modified_by": current_admin_id,
            "printer_id": user_data.get("printer_id"),
            "default_screen_colors": user_data.get("default_screen_colors"),
        }
        password_to_set = user_data.get("password", "")
        role_name_to_assign = user_data.get("role")
        validation_payload = {
            **data_for_model,
            "password": password_to_set,
            "role": role_name_to_assign,
        }
        is_valid, errors = self.validate_user_data(validation_payload, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None
        session = db_manager.get_session()
        try:
            processed_email = data_for_model["email"]
            if isinstance(processed_email, str):
                processed_email = processed_email.strip()
                if not processed_email:
                    processed_email = None
            data_for_model["email"] = processed_email
            new_user = User(**data_for_model)
            new_user.set_password(password_to_set)
            if role_name_to_assign:
                role_obj = (
                    session.query(Role).filter(Role.name == role_name_to_assign).first()
                )
                if role_obj:
                    new_user.roles.append(role_obj)
                else:
                    self.logger.error(
                        f"Role '{role_name_to_assign}' for new user '{new_user.user_id}' not found in DB during create. Validation might have missed this."
                    )
            session.add(new_user)
            session.commit()
            session.refresh(new_user)
            self.logger.info(
                f"User '{new_user.user_id}' created successfully by {current_admin_id}."
            )
            return True, "User created successfully.", new_user
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e.orig}",
                exc_info=True,
            )
            error_str = str(e.orig).lower()
            if "unique constraint failed: users.user_id" in error_str:
                return (
                    False,
                    f"Login ID (Username) '{data_for_model['user_id']}' already exists.",
                    None,
                )
            elif (
                "unique constraint failed: users.email" in error_str
                and data_for_model["email"]
            ):
                return (
                    False,
                    f"Email '{data_for_model['email']}' is already in use.",
                    None,
                )
            return False, f"Database integrity error: {e.orig}", None
        except AttributeError as ae:
            session.rollback()
            self.logger.error(
                f"AttributeError during user creation for '{data_for_model.get('user_id')}': {ae}",
                exc_info=True,
            )
            return False, f"Failed to set user attribute during creation: {ae}", None
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error creating user '{data_for_model.get('user_id')}': {e}",
                exc_info=True,
            )
            return False, f"Failed to create user: {e}", None
        finally:
            session.close()

    def update_user(
        self,
        user_id_to_update: str,
        user_data: Dict[str, Any],
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == user_id_to_update)
                .first()
            )
            if not user:
                return False, f"User with Login ID '{user_id_to_update}' not found."
            validation_data = {
                "user_id": user.user_id,
                "user_name": user_data.get("user_name", user.user_name),
                "email": user_data.get("email", user.email),
                "role": user_data.get("role"),
            }
            if "password" in user_data and user_data["password"]:
                validation_data["password"] = user_data["password"]
            is_valid, errors = self.validate_user_data(
                validation_data, is_new=False, original_login_id_to_ignore=user.user_id
            )
            if not is_valid:
                return False, "Validation failed: " + "; ".join(errors)
            roles_modified = False
            if "user_name" in user_data:
                user.user_name = user_data["user_name"].strip()
            if "email" in user_data:
                email_val = user_data["email"]
                user.email = email_val.strip() if isinstance(email_val, str) else None
                if user.email == "":
                    user.email = None
            if "password" in user_data and user_data["password"]:
                user.set_password(user_data["password"])
            if "is_active" in user_data:
                if user.user_id.upper() == "ADMIN" and not user_data["is_active"]:
                    active_admin_query = session.query(User).filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    if user.is_active:
                        if active_admin_query.count() <= 1:
                            self.logger.warning(
                                f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') was prevented."
                            )
                            return (
                                False,
                                "Cannot deactivate the last active ADMIN user.",
                            )
                    user.is_active = user_data["is_active"]
                else:
                    user.is_active = user_data["is_active"]
            new_role_name_from_data = user_data.get("role")
            if new_role_name_from_data is not None:
                current_role_names = {r.name for r in user.roles}
                if not (
                    len(current_role_names) == 1
                    and new_role_name_from_data in current_role_names
                ):
                    roles_modified = True
                    user.roles.clear()
                    if new_role_name_from_data:
                        role_obj = (
                            session.query(Role)
                            .filter(Role.name == new_role_name_from_data)
                            .first()
                        )
                        if role_obj:
                            user.roles.append(role_obj)
                        else:
                            self.logger.error(
                                f"Role object for '{new_role_name_from_data}' not found during update. User '{user.user_id}' will have no roles."
                            )
            if "printer_id" in user_data:
                user.printer_id = user_data["printer_id"]
            if "default_screen_colors" in user_data:
                user.default_screen_colors = user_data["default_screen_colors"]
            user.modified_by = current_admin_id
            if roles_modified:
                session.add(user)
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' updated successfully by {current_admin_id}."
            )
            return True, "User updated successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e.orig}", exc_info=True
            )
            if "unique constraint failed: users.email" in str(
                e.orig
            ).lower() and validation_data.get("email"):
                return (
                    False,
                    f"Email '{validation_data['email']}' is already in use by another user.",
                )
            return False, f"Database integrity error: {e.orig}"
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating user '{user_id_to_update}': {e}", exc_info=True
            )
            return False, f"Failed to update user: {str(e)}"
        finally:
            session.close()

    def change_password(
        self,
        login_id_str: str,
        new_password: str,
        current_admin_id: Optional[str] = None,
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        if not new_password or len(new_password) < 6:
            return False, "New password must be at least 6 characters long."
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if not user:
                return False, f"User '{login_id_str}' not found."
            user.set_password(new_password)
            user.modified_by = current_admin_id
            session.commit()
            self.logger.info(
                f"Password changed successfully for user '{user.user_id}' by {current_admin_id}."
            )
            return True, "Password changed successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error changing password for user '{login_id_str}': {e}", exc_info=True
            )
            return False, f"Failed to change password: {str(e)}"
        finally:
            session.close()

    def get_user_roles(self, login_id_str: str) -> List[str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .options(joinedload(User.roles))
                .filter(User.user_id.collate("NOCASE") == login_id_str)
                .first()
            )
            if user and user.roles:
                return [role.name for role in user.roles]
            return []
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching roles for user '{login_id_str}': {e}", exc_info=True
            )
            return []
        finally:
            session.close()

    def delete_user_permanently(
        self, user_id_to_delete: str, current_admin_id: str
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_id_to_delete)
                .first()
            )
            if not user:
                return False, f"User '{user_id_to_delete}' not found."
            if user.user_id.upper() == "ADMIN":
                active_admin_count = (
                    session.query(User)
                    .filter(
                        User.is_active == True,
                        User.user_id.collate("NOCASE") == "ADMIN",
                    )
                    .count()
                )
                if active_admin_count <= 1 and user.is_active:
                    self.logger.warning(
                        f"Attempt to delete the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                    )
                    return (
                        False,
                        "Cannot delete the primary ADMIN account if it's the last active one.",
                    )
            session.delete(user)
            session.commit()
            self.logger.info(
                f"User '{user.user_id}' permanently deleted by admin '{current_admin_id}'."
            )
            return True, f"User '{user.user_id}' deleted successfully."
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(
                f"Database integrity error deleting user '{user_id_to_delete}': {e.orig}",
                exc_info=True,
            )
            return (
                False,
                f"Cannot delete user. They may be referenced by other records. ({e.orig})",
            )
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error deleting user '{user_id_to_delete}': {e}", exc_info=True
            )
            return False, f"Failed to delete user: {str(e)}"
        finally:
            session.close()

    def toggle_user_active_status(
        self, user_login_id: str, current_admin_id: Optional[str] = None
    ) -> Tuple[bool, str]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            user = (
                session.query(User)
                .filter(User.user_id.collate("NOCASE") == user_login_id)
                .first()
            )
            if not user:
                return False, f"User '{user_login_id}' not found."

            is_deactivating = user.is_active
            if is_deactivating:
                # Rule 1: Cannot deactivate yourself
                if user.user_id == current_admin_id:
                    self.logger.warning(
                        f"User '{current_admin_id}' attempted to deactivate their own account. Operation prevented."
                    )
                    return False, "You cannot deactivate your own account."

                # Rule 2: Cannot deactivate the last active admin
                if user.has_role("ADMIN"):
                    active_admin_count = (
                        session.query(User)
                        .join(User.roles)
                        .filter(Role.name == "ADMIN", User.is_active == True)
                        .count()
                    )
                    if active_admin_count <= 1:
                        self.logger.warning(
                            f"Attempt to deactivate the last active ADMIN user ('{user.user_id}') by '{current_admin_id}' was prevented."
                        )
                        return False, "Cannot deactivate the last active ADMIN user."

            # Toggle the status
            new_status = not user.is_active
            user.is_active = new_status
            user.modified_by = current_admin_id

            session.commit()

            status_str = "activated" if new_status else "deactivated"
            self.logger.info(
                f"User '{user.user_id}' has been {status_str} by {current_admin_id}."
            )
            return True, f"User '{user.user_id}' has been successfully {status_str}."

        except sqlalchemy_exc.SQLAlchemyError as e:
            session.rollback()
            self.logger.error(
                f"Database error toggling status for user '{user_login_id}': {e}",
                exc_info=True,
            )
            return False, "A database error occurred."
        finally:
            session.close()

    def get_all_roles(self) -> List[Role]:
        # ... (implementation unchanged) ...
        session = db_manager.get_session()
        try:
            roles = session.query(Role).order_by(Role.name).all()
            self.logger.info(f"Retrieved {len(roles)} roles.")
            return roles
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error retrieving roles: {e}", exc_info=True)
            session.rollback()
            return []
        finally:
            session.close()


=============== FILE: controllers\veterinarian_controller.py ===============

# controllers/veterinarian_controller.py
"""
EDSI Veterinary Management System - Veterinarian Controller
Version: 1.1.0
Purpose: Handles business logic for veterinarian records.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-09):
    - Replaced placeholder with a full implementation providing CRUD operations.
- v1.0.0 (2025-06-09):
    - Initial placeholder file created.
"""

import logging
import re
from typing import List, Optional, Tuple, Dict, Any

from sqlalchemy.orm import Session
from sqlalchemy import exc as sqlalchemy_exc

from config.database_config import db_manager
from models import Veterinarian


class VeterinarianController:
    """Controller for veterinarian management operations."""

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def get_all_veterinarians(self, status_filter: str = "all") -> List[Veterinarian]:
        """Retrieves all veterinarians, optionally filtered by active status."""
        session = db_manager.get_session()
        try:
            query = session.query(Veterinarian)
            if status_filter == "active":
                query = query.filter(Veterinarian.is_active == True)
            elif status_filter == "inactive":
                query = query.filter(Veterinarian.is_active == False)

            vets = query.order_by(Veterinarian.last_name, Veterinarian.first_name).all()
            return vets
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(f"Error fetching all veterinarians: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_veterinarian_by_id(self, vet_id: int) -> Optional[Veterinarian]:
        """Retrieves a single veterinarian by their primary key."""
        session = db_manager.get_session()
        try:
            return (
                session.query(Veterinarian)
                .filter(Veterinarian.vet_id == vet_id)
                .first()
            )
        except sqlalchemy_exc.SQLAlchemyError as e:
            self.logger.error(
                f"Error fetching veterinarian by ID {vet_id}: {e}", exc_info=True
            )
            return None
        finally:
            session.close()

    def validate_veterinarian_data(
        self,
        vet_data: Dict[str, Any],
        is_new: bool,
        vet_id_to_ignore: Optional[int] = None,
    ) -> Tuple[bool, List[str]]:
        """Validates veterinarian data for creation or update."""
        errors = []
        required_fields = ["first_name", "last_name", "license_number"]
        for field in required_fields:
            if not vet_data.get(field) or not str(vet_data[field]).strip():
                errors.append(f"{field.replace('_', ' ').title()} is required.")

        license_number = vet_data.get("license_number", "").strip()
        email = vet_data.get("email", "").strip()

        session = db_manager.get_session()
        try:
            # Check license number uniqueness
            if license_number:
                query = session.query(Veterinarian).filter(
                    Veterinarian.license_number == license_number
                )
                if not is_new and vet_id_to_ignore is not None:
                    query = query.filter(Veterinarian.vet_id != vet_id_to_ignore)
                if query.first():
                    errors.append(
                        f"License Number '{license_number}' is already in use."
                    )

            # Check email format and uniqueness
            if email:
                if not re.match(
                    r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email
                ):
                    errors.append("Invalid email format.")
                else:
                    query = session.query(Veterinarian).filter(
                        Veterinarian.email == email
                    )
                    if not is_new and vet_id_to_ignore is not None:
                        query = query.filter(Veterinarian.vet_id != vet_id_to_ignore)
                    if query.first():
                        errors.append(f"Email '{email}' is already in use.")
        finally:
            session.close()

        return not errors, errors

    def create_veterinarian(
        self, vet_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str, Optional[Veterinarian]]:
        """Creates a new veterinarian record."""
        is_valid, errors = self.validate_veterinarian_data(vet_data, is_new=True)
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors), None

        session = db_manager.get_session()
        try:
            new_vet = Veterinarian(
                first_name=vet_data["first_name"],
                last_name=vet_data["last_name"],
                license_number=vet_data["license_number"],
                specialty=vet_data.get("specialty"),
                phone=vet_data.get("phone"),
                email=vet_data.get("email"),
                is_active=vet_data.get("is_active", True),
                created_by=current_user_id,
                modified_by=current_user_id,
            )
            session.add(new_vet)
            session.commit()
            session.refresh(new_vet)
            self.logger.info(
                f"Veterinarian '{new_vet.first_name} {new_vet.last_name}' created by {current_user_id}."
            )
            return True, "Veterinarian created successfully.", new_vet
        except sqlalchemy_exc.IntegrityError as e:
            session.rollback()
            self.logger.error(f"Error creating veterinarian: {e.orig}", exc_info=True)
            return False, f"Database integrity error: {e.orig}", None
        except Exception as e:
            session.rollback()
            self.logger.error(f"Error creating veterinarian: {e}", exc_info=True)
            return False, f"Failed to create veterinarian: {e}", None
        finally:
            session.close()

    def update_veterinarian(
        self, vet_id: int, vet_data: Dict[str, Any], current_user_id: str
    ) -> Tuple[bool, str]:
        """Updates an existing veterinarian record."""
        is_valid, errors = self.validate_veterinarian_data(
            vet_data, is_new=False, vet_id_to_ignore=vet_id
        )
        if not is_valid:
            return False, "Validation failed: " + "; ".join(errors)

        session = db_manager.get_session()
        try:
            vet = (
                session.query(Veterinarian)
                .filter(Veterinarian.vet_id == vet_id)
                .first()
            )
            if not vet:
                return False, "Veterinarian not found."

            for key, value in vet_data.items():
                if hasattr(vet, key):
                    setattr(vet, key, value)

            vet.modified_by = current_user_id
            session.commit()
            self.logger.info(f"Veterinarian ID {vet_id} updated by {current_user_id}.")
            return True, "Veterinarian updated successfully."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error updating veterinarian ID {vet_id}: {e}", exc_info=True
            )
            return False, f"Failed to update veterinarian: {e}"
        finally:
            session.close()

    def toggle_veterinarian_status(
        self, vet_id: int, current_user_id: str
    ) -> Tuple[bool, str]:
        """Toggles the active status of a veterinarian."""
        session = db_manager.get_session()
        try:
            vet = (
                session.query(Veterinarian)
                .filter(Veterinarian.vet_id == vet_id)
                .first()
            )
            if not vet:
                return False, "Veterinarian not found."

            vet.is_active = not vet.is_active
            vet.modified_by = current_user_id
            new_status = "activated" if vet.is_active else "deactivated"
            session.commit()
            self.logger.info(
                f"Veterinarian '{vet.first_name} {vet.last_name}' status changed to {new_status} by {current_user_id}."
            )
            return True, f"Veterinarian has been {new_status}."
        except Exception as e:
            session.rollback()
            self.logger.error(
                f"Error toggling status for vet ID {vet_id}: {e}", exc_info=True
            )
            return False, f"Failed to toggle status: {e}"
        finally:
            session.close()


=============== FILE: models\__init__.py ===============

# models/__init__.py
"""
EDSI Veterinary Management System - Models Package
"""

from .base_model import Base, BaseModel
from .user_models import User, Role, UserRole
from .horse_models import Horse, HorseOwner, HorseLocation
from .owner_models import Owner, OwnerBillingHistory, OwnerPayment
from .reference_models import (
    StateProvince,
    ChargeCodeCategory,
    ChargeCode,
    Veterinarian,
    Location,
    Procedure,
    Drug,
    TreatmentLog,
    CommunicationLog,
    Document,
    Reminder,
    Appointment,
)
from .financial_models import Transaction, Invoice
from .company_profile_model import CompanyProfile  # ADDED

__all__ = [
    "Base",
    "BaseModel",
    "User",
    "Role",
    "UserRole",
    "Horse",
    "HorseOwner",
    "HorseLocation",
    "Owner",
    "OwnerBillingHistory",
    "OwnerPayment",
    "StateProvince",
    "ChargeCodeCategory",
    "ChargeCode",
    "Veterinarian",
    "Location",
    "Procedure",
    "Drug",
    "TreatmentLog",
    "CommunicationLog",
    "Document",
    "Reminder",
    "Appointment",
    "Transaction",
    "Invoice",
    "CompanyProfile",  # ADDED
]


=============== FILE: models\base_model.py ===============

# models/base_model.py

"""
EDSI Veterinary Management System - Base Model Definition
Version: 2.0.0
Purpose: Simplified base model with essential audit fields and clean declarative base.
         Removed over-complexity and focused on stable foundation.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Removed circular import issues by importing Base from database_config
    - Simplified BaseModel with essential audit fields only
    - Clean datetime handling without over-engineering
    - Removed unnecessary complexity in __repr__ method
    - Clear separation between Base and BaseModel
    - Focused on stable, working foundation
    - Consistent audit field naming and types
"""

from datetime import datetime
from sqlalchemy import Column, DateTime, String
from config.database_config import Base


class BaseModel(Base):
    """
    Abstract base model providing common audit fields for all database tables.

    Provides:
    - created_date: When the record was created
    - modified_date: When the record was last modified
    - created_by: User ID who created the record
    - modified_by: User ID who last modified the record
    """

    __abstract__ = True  # This class should not be mapped to a database table

    # Audit fields
    created_date = Column(
        DateTime,
        default=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was created",
    )

    modified_date = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
        doc="Timestamp when record was last modified",
    )

    created_by = Column(
        String(50), nullable=True, doc="User ID who created this record"
    )

    modified_by = Column(
        String(50), nullable=True, doc="User ID who last modified this record"
    )

    def __repr__(self):
        """
        Simple string representation of the model instance.
        Uses the first primary key column for identification.
        """
        try:
            # Get the primary key column name and value
            primary_key = self.__mapper__.primary_key[0]
            pk_name = primary_key.name
            pk_value = getattr(self, pk_name, "Unknown")

            return f"<{self.__class__.__name__}({pk_name}={pk_value})>"

        except (IndexError, AttributeError):
            # Fallback if primary key detection fails
            return f"<{self.__class__.__name__}(id=Unknown)>"

    def update_modified_by(self, user_id: str) -> None:
        """
        Update the modified_by field with the given user_id.

        Args:
            user_id: The ID of the user making the modification
        """
        self.modified_by = user_id
        # Note: modified_date will be automatically updated by SQLAlchemy onupdate

    def set_created_by(self, user_id: str) -> None:
        """
        Set the created_by field with the given user_id.
        This should only be called when creating new records.

        Args:
            user_id: The ID of the user creating the record
        """
        self.created_by = user_id
        if not self.modified_by:
            self.modified_by = user_id


=============== FILE: models\company_profile_model.py ===============

# models/company_profile_model.py
"""
EDSI Veterinary Management System - Company Profile Model
Version: 1.0.0
Purpose: Defines the data model for storing the clinic's own profile information.
Last Updated: June 8, 2025
Author: Gemini
"""

from sqlalchemy import Column, Integer, String, Text
from .base_model import BaseModel


class CompanyProfile(BaseModel):
    """
    Represents the company's profile information.
    This table is expected to contain only a single row (id=1).
    """

    __tablename__ = "company_profile"

    id = Column(Integer, primary_key=True)
    company_name = Column(String(255), nullable=False)
    address_line1 = Column(String(255), nullable=True)
    address_line2 = Column(String(255), nullable=True)
    city = Column(String(100), nullable=True)
    state = Column(String(100), nullable=True)
    zip_code = Column(String(20), nullable=True)
    phone = Column(String(50), nullable=True)
    email = Column(String(255), nullable=True)
    website = Column(String(255), nullable=True)
    logo_path = Column(String(512), nullable=True)
    notes = Column(Text, nullable=True)

    def __repr__(self):
        return f"<CompanyProfile(id={self.id}, name='{self.company_name}')>"


=============== FILE: models\financial_models.py ===============

# models/financial_models.py
"""
EDSI Veterinary Management System - Financial Data Models
Version: 1.3.0
Purpose: Defines SQLAlchemy models for financial records like Transactions and Invoices.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-09):
    - Set `autoincrement=True` on the Invoice.invoice_id primary key to ensure
      the database engine never reuses an invoice number after it has been deleted.
- v1.2.0 (2025-06-09):
    - Added a `status` column to the `Transaction` model to explicitly track
      whether a charge is active or has been processed into an invoice.
- v1.1.0 (2025-06-05):
    - Added `taxable` (Boolean) and `item_notes` (Text) columns to the `Transaction` model.
    - Added `tax_total` (Numeric) column to the `Invoice` model.
"""

from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Text,
    ForeignKey,
    Date,
    Numeric,
    DateTime,
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import date

from .base_model import BaseModel


class Transaction(BaseModel):
    """
    Represents a single billable line item for a horse.
    This is the core of all financial activity.
    """

    __tablename__ = "transactions"

    transaction_id = Column(Integer, primary_key=True, index=True)
    horse_id = Column(
        Integer, ForeignKey("horses.horse_id"), nullable=False, index=True
    )
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    invoice_id = Column(
        Integer, ForeignKey("invoices.invoice_id"), nullable=True, index=True
    )

    charge_code_id = Column(
        Integer, ForeignKey("charge_codes.id"), nullable=False, index=True
    )

    administered_by_user_id = Column(
        String(20), ForeignKey("users.user_id"), nullable=True
    )

    transaction_date = Column(Date, nullable=False, default=date.today)
    description = Column(String(255), nullable=False)
    quantity = Column(Numeric(10, 2), nullable=False, default=1)
    unit_price = Column(Numeric(10, 2), nullable=False)
    total_price = Column(Numeric(10, 2), nullable=False)
    taxable = Column(Boolean, default=False, nullable=False)
    item_notes = Column(Text, nullable=True)

    status = Column(String(50), nullable=False, default="ACTIVE", index=True)

    # Relationships
    horse = relationship("Horse")
    owner = relationship("Owner")
    invoice = relationship("Invoice", back_populates="transactions")
    charge_code = relationship("ChargeCode")
    administered_by = relationship("User")

    def __repr__(self):
        return f"<Transaction(id={self.transaction_id}, horse_id={self.horse_id}, total={self.total_price})>"


class Invoice(BaseModel):
    """
    Represents a bill sent to an owner, grouping multiple transactions.
    """

    __tablename__ = "invoices"

    invoice_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )

    invoice_date = Column(Date, nullable=False, default=date.today)
    due_date = Column(Date, nullable=True)

    subtotal = Column(Numeric(10, 2), nullable=False, default=0.00)
    tax_total = Column(Numeric(10, 2), nullable=True)
    grand_total = Column(Numeric(10, 2), nullable=False, default=0.00)
    amount_paid = Column(Numeric(10, 2), nullable=False, default=0.00)
    balance_due = Column(Numeric(10, 2), nullable=False, default=0.00)

    status = Column(String(50), nullable=False, default="Unpaid", index=True)

    # Relationships
    owner = relationship("Owner", backref="invoices")
    transactions = relationship(
        "Transaction", back_populates="invoice", cascade="all, delete-orphan"
    )

    def __repr__(self):
        return f"<Invoice(id={self.invoice_id}, owner_id={self.owner_id}, total={self.grand_total}, status='{self.status}')>"


=============== FILE: models\horse_models.py ===============

# models/horse_models.py
"""
EDSI Veterinary Management System - Horse Related SQLAlchemy Models
Version: 1.3.0
Purpose: Defines the data models for horses, owners, and their relationships.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-10):
    - Added missing columns to the Horse model: `reg_number`, `brand`, `band_tag`.
      This resolves warnings during horse creation and ensures all form data is saved.
- v1.2.17 (2025-05-25):
    - Reverted `back_populates` on HorseLocation.location relationship
      to "current_horses" to match expected relationship name on Location model.
- v1.2.16 (2025-05-25):
    - HorseLocation model: Added `is_current_location` (Boolean) column.
- v1.2.15 (2025-05-23):
    - Horse model: Removed `species_id` column and `species` relationship.
"""
from sqlalchemy import Column, Integer, String, Date, Boolean, ForeignKey, Numeric, Text
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.hybrid import hybrid_property
from datetime import date

from .base_model import Base, BaseModel


class HorseOwner(Base):
    __tablename__ = "horse_owners"
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), primary_key=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), primary_key=True)
    percentage_ownership = Column(Numeric(5, 2), nullable=True)

    horse = relationship("Horse", back_populates="owner_associations")
    owner = relationship("Owner", back_populates="horse_associations")


class HorseLocation(BaseModel):
    __tablename__ = "horse_locations"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=False)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=False)
    date_arrived = Column(Date, nullable=False, default=date.today)
    date_departed = Column(Date, nullable=True)
    notes = Column(Text, nullable=True)
    is_current_location = Column(Boolean, default=False, nullable=False, index=True)

    horse = relationship("Horse", back_populates="location_history")
    location = relationship("Location", back_populates="current_horses")


class Horse(BaseModel):
    __tablename__ = "horses"

    horse_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    horse_name = Column(String(255), nullable=False, index=True)
    account_number = Column(String(50), index=True, nullable=True)
    breed = Column(String(100), nullable=True)
    color = Column(String(50), nullable=True)
    sex = Column(String(20), nullable=True)
    date_of_birth = Column(Date, nullable=True)
    height_hands = Column(Numeric(4, 2), nullable=True)

    chip_number = Column(String(50), nullable=True, unique=True)
    tattoo_number = Column(String(50), nullable=True, unique=True)

    # ADDED Missing columns
    reg_number = Column(String(50), nullable=True)
    brand = Column(String(50), nullable=True)
    band_tag = Column(String(50), nullable=True)

    description = Column(Text, nullable=True)

    is_active = Column(Boolean, default=True, nullable=False)
    date_deceased = Column(Date, nullable=True)
    coggins_date = Column(Date, nullable=True)

    current_location_id = Column(
        Integer, ForeignKey("locations.location_id"), nullable=True
    )

    owner_associations = relationship(
        "HorseOwner", back_populates="horse", cascade="all, delete-orphan"
    )
    owners = relationship(
        "Owner",
        secondary="horse_owners",
        back_populates="horses",
        viewonly=True,
        lazy="selectin",
    )

    location_history = relationship(
        "HorseLocation",
        back_populates="horse",
        order_by="desc(HorseLocation.date_arrived)",
        cascade="all, delete-orphan",
        lazy="selectin",
    )
    location = relationship(
        "Location", foreign_keys=[current_location_id], lazy="joined"
    )

    @hybrid_property
    def age(self):
        if self.date_of_birth:
            today = date.today()
            return (
                today.year
                - self.date_of_birth.year
                - (
                    (today.month, today.day)
                    < (self.date_of_birth.month, self.date_of_birth.day)
                )
            )
        return None

    @validates("chip_number", "tattoo_number")
    def convert_empty_to_none(self, key, value):
        if isinstance(value, str) and not value.strip():
            return None
        return value


=============== FILE: models\owner_models.py ===============

# models/owner_models.py
"""
EDSI Veterinary Management System - Owner Related Models
Version: 1.1.7
Purpose: Defines SQLAlchemy models for Owner and related entities.
         - Removed the placeholder Invoice model to avoid conflict with the
           definitive Invoice model in financial_models.py.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.7 (2025-06-04):
    - Removed the placeholder `Invoice` class definition. The definitive `Invoice`
      model is now in `models/financial_models.py`.
      The backref from Owner to the new Invoice model is handled in financial_models.py.
- v1.1.6 (2025-05-23):
    - Ensured the `Invoice` class is correctly defined.
    - Imported `sqlalchemy.sql.func` for `func.current_date()` default in `Invoice.invoice_date`.
# ... (rest of previous changelog)
"""

from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Numeric,
    Text,
    ForeignKey,
    Date,
    DateTime,
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import datetime

from .base_model import BaseModel


class Owner(BaseModel):
    """Model for horse owners (master list)."""

    __tablename__ = "owners"

    # Changed owner_id to id for potential consistency, but will keep owner_id if it's deeply embedded.
    # For now, keeping owner_id as per existing structure.
    # If financial_models.Transaction.owner_id refers to 'owners.id', then this needs to be 'id'.
    # Checking financial_models.py: owner_id = Column(Integer, ForeignKey("owners.owner_id") ...
    # So, owner_id is correct here.
    owner_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    account_number = Column(String(20), unique=True, nullable=True, index=True)
    farm_name = Column(String(100), nullable=True, index=True)
    first_name = Column(String(50), nullable=True)
    last_name = Column(String(50), nullable=True, index=True)

    address_line1 = Column(String(100))
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50))

    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), index=True
    )

    zip_code = Column(String(20))

    phone = Column(String(20), nullable=True)
    mobile_phone = Column(String(20), nullable=True)
    email = Column(String(100), nullable=True, index=True)

    is_active = Column(Boolean, default=True, nullable=False)

    balance = Column(Numeric(10, 2), default=0.00)
    credit_limit = Column(Numeric(10, 2), nullable=True)
    billing_terms = Column(String(50), nullable=True)
    service_charge_rate = Column(Numeric(5, 2), nullable=True)
    discount_rate = Column(Numeric(5, 2), nullable=True)

    notes = Column(Text, nullable=True)

    state = relationship("StateProvince", foreign_keys=[state_code], backref="owners")

    horse_associations = relationship(
        "HorseOwner", back_populates="owner", cascade="all, delete-orphan"
    )

    horses = relationship(
        "Horse", secondary="horse_owners", back_populates="owners", viewonly=True
    )

    billing_history = relationship(
        "OwnerBillingHistory", back_populates="owner", cascade="all, delete-orphan"
    )
    payments_made = relationship(
        "OwnerPayment", back_populates="owner", cascade="all, delete-orphan"
    )

    # The 'invoices' backref is now defined in financial_models.Invoice linking to this Owner model.
    # No need for: # invoices = relationship("Invoice", back_populates="owner")

    def __repr__(self):
        display_name = (
            self.farm_name
            or f"{self.first_name or ''} {self.last_name or ''}".strip()
            or f"ID:{self.owner_id}"
        )
        return f"<Owner(owner_id={self.owner_id}, name='{display_name}')>"


class OwnerBillingHistory(BaseModel):
    """Billing history entries for an owner."""

    __tablename__ = "owner_billing_history"

    history_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    entry_date = Column(DateTime, default=datetime.utcnow)
    description = Column(String(255), nullable=False)
    amount_change = Column(Numeric(10, 2), nullable=False)  # Made non-nullable
    new_balance = Column(Numeric(10, 2), nullable=False)  # Made non-nullable

    owner = relationship("Owner", back_populates="billing_history")

    def __repr__(self):
        return f"<OwnerBillingHistory(owner_id={self.owner_id}, date='{self.entry_date}', desc='{self.description}')>"


class OwnerPayment(BaseModel):
    """Payments made by an owner."""

    __tablename__ = "owner_payments"

    payment_id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    owner_id = Column(
        Integer, ForeignKey("owners.owner_id"), nullable=False, index=True
    )
    payment_date = Column(Date, nullable=False, default=func.current_date)
    amount = Column(Numeric(10, 2), nullable=False)
    payment_method = Column(String(50), nullable=False)  # Made non-nullable
    reference_number = Column(String(100), nullable=True)
    notes = Column(Text, nullable=True)  # Nullable is fine for notes

    owner = relationship(
        "Owner", foreign_keys=[owner_id], back_populates="payments_made"
    )

    def __repr__(self):
        return f"<OwnerPayment(owner_id={self.owner_id}, date='{self.payment_date}', amount={self.amount})>"


# class Invoice(BaseModel): # REMOVED - Definitive model is in financial_models.py
#    pass


=============== FILE: models\reference_models.py ===============

# models/reference_models.py
"""
EDSI Veterinary Management System - Reference Data Models
Version: 1.1.22
Purpose: Defines SQLAlchemy models for various reference data entities.
         - Removed placeholder Transaction and TransactionDetail models
           to avoid conflict with definitive models in financial_models.py.
Last Updated: June 4, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.1.22 (2025-06-04):
    - Removed placeholder `Transaction` and `TransactionDetail` class definitions
      as these are now fully defined in `models/financial_models.py`.
- v1.1.21 (2025-06-03):
    - In `Location` model: Uncommented the `current_horses` relationship to
      `HorseLocation` and ensured `back_populates="location"` is correct.
      This fixes the `InvalidRequestError: Mapper 'Mapper[Location(locations)]'
      has no property 'current_horses'` during mapper configuration.
# ... (rest of previous changelog)
"""
from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Text,
    ForeignKey,
    Date,
    Numeric,
    DateTime,
    Table,
)
from sqlalchemy.orm import (
    relationship,
    backref,
)
from sqlalchemy.sql import func

from .base_model import (
    Base,
    BaseModel,
)


class StateProvince(
    BaseModel, Base
):  # BaseModel already inherits Base, so just BaseModel is fine.
    # Or if Base is intended to be mixed in for some reason, it's okay.
    # For consistency, let's assume BaseModel is sufficient as it inherits Base.
    # Will correct to just BaseModel if this is the standard in your other models.
    # Re-checking your base_model.py: BaseModel(Base). So this is fine.
    __tablename__ = "state_provinces"
    state_province_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )
    state_code = Column(String(10), nullable=False, unique=True, index=True)
    state_name = Column(String(50), nullable=False)
    country_code = Column(String(10), nullable=False, default="USA")
    is_active = Column(Boolean, default=True, nullable=False)

    def __repr__(self):
        return (
            f"<StateProvince(state_code='{self.state_code}', name='{self.state_name}')>"
        )


class ChargeCodeCategory(BaseModel, Base):
    __tablename__ = "charge_code_categories"

    category_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique category identifier",
    )
    name = Column(
        String(100),
        nullable=False,
        index=True,
        doc="Name of the category level (e.g., 'Anthelmintics', 'Administered')",
    )
    parent_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
        doc="ID of the parent category, if any",
    )
    level = Column(
        Integer,
        nullable=False,
        index=True,
        doc="Hierarchy level (e.g., 1 for main Category, 2 for Process)",
    )
    is_active = Column(Boolean, default=True, nullable=False, index=True)

    parent = relationship(
        "ChargeCodeCategory", remote_side=[category_id], backref=backref("children")
    )

    charge_codes = relationship("ChargeCode", back_populates="category")

    def __repr__(self):
        return f"<ChargeCodeCategory(id={self.category_id}, name='{self.name}', level={self.level}, parent_id={self.parent_id})>"


class ChargeCode(BaseModel, Base):
    __tablename__ = "charge_codes"
    # Changed from charge_code_id to id to match financial_models.Transaction.charge_code_id ForeignKey target
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    code = Column(String(20), nullable=False, unique=True, index=True)
    alternate_code = Column(String(50), nullable=True, index=True)
    description = Column(String(255), nullable=False)

    category_id = Column(
        Integer,
        ForeignKey("charge_code_categories.category_id"),
        nullable=True,
        index=True,
    )

    standard_charge = Column(Numeric(10, 2), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    taxable = Column(Boolean, default=False)

    category = relationship("ChargeCodeCategory", back_populates="charge_codes")

    def __repr__(self):
        return f"<ChargeCode(code='{self.code}', description='{self.description}')>"


class Veterinarian(BaseModel, Base):
    __tablename__ = "veterinarians"
    vet_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )  # Consider renaming to 'id' for consistency if preferred
    first_name = Column(String(50), nullable=False)
    last_name = Column(String(50), nullable=False, index=True)
    license_number = Column(String(50), unique=True)
    specialty = Column(String(100))
    phone = Column(String(20))
    email = Column(String(100), unique=True)
    is_active = Column(Boolean, default=True)

    def __repr__(self):
        return f"<Veterinarian(vet_id={self.vet_id}, name='{self.first_name} {self.last_name}')>"


class Location(BaseModel, Base):
    __tablename__ = "locations"
    location_id = Column(
        Integer, primary_key=True, index=True, autoincrement=True
    )  # Consider renaming to 'id'
    location_name = Column(String(100), nullable=False, unique=True, index=True)
    address_line1 = Column(String(100), nullable=True)
    address_line2 = Column(String(100), nullable=True)
    city = Column(String(50), nullable=True)
    state_code = Column(
        String(10), ForeignKey("state_provinces.state_code"), nullable=True, index=True
    )
    zip_code = Column(String(20), nullable=True)
    country_code = Column(String(10), default="USA", nullable=True)
    phone = Column(String(20), nullable=True)
    contact_person = Column(String(100), nullable=True)
    email = Column(String(100), nullable=True, index=True)
    is_active = Column(Boolean, default=True, nullable=False)

    state = relationship("StateProvince")
    current_horses = relationship("HorseLocation", back_populates="location")

    def __repr__(self):
        return (
            f"<Location(location_id={self.location_id}, name='{self.location_name}')>"
        )


# --- Placeholder models removed ---
# class Transaction(BaseModel, Base): # REMOVED
#     __tablename__ = "transactions"
#     transaction_id = Column(Integer, primary_key=True)
#     description = Column(String(100))

# class TransactionDetail(BaseModel, Base): # REMOVED
#     __tablename__ = "transaction_details"
#     detail_id = Column(Integer, primary_key=True)
#     transaction_id = Column(Integer, ForeignKey("transactions.transaction_id")) # This would now be an error if Transaction was removed
#     notes = Column(String(100))


class Procedure(BaseModel, Base):
    __tablename__ = "procedures"
    procedure_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class Drug(BaseModel, Base):
    __tablename__ = "drugs"
    drug_id = Column(Integer, primary_key=True)
    name = Column(String(100))


class TreatmentLog(BaseModel, Base):
    __tablename__ = "treatment_logs"
    log_id = Column(Integer, primary_key=True)
    details = Column(String(255))


class CommunicationLog(BaseModel, Base):
    __tablename__ = "communication_logs"
    log_id = Column(Integer, primary_key=True)
    summary = Column(String(255))


class Document(BaseModel, Base):
    __tablename__ = "documents"
    document_id = Column(Integer, primary_key=True)
    file_path = Column(String(255))


class Reminder(BaseModel, Base):
    __tablename__ = "reminders"
    reminder_id = Column(Integer, primary_key=True)
    due_date = Column(Date)


class Appointment(BaseModel, Base):
    __tablename__ = "appointments"
    appointment_id = Column(Integer, primary_key=True, index=True)
    horse_id = Column(Integer, ForeignKey("horses.horse_id"), nullable=True)
    owner_id = Column(Integer, ForeignKey("owners.owner_id"), nullable=True)
    vet_id = Column(Integer, ForeignKey("veterinarians.vet_id"), nullable=True)
    location_id = Column(Integer, ForeignKey("locations.location_id"), nullable=True)
    appointment_datetime = Column(DateTime, nullable=False, server_default=func.now())
    duration_minutes = Column(Integer, default=30)
    reason = Column(String(255))
    notes = Column(Text)
    status = Column(String(50), default="Scheduled")
    is_confirmed = Column(Boolean, default=False)

    def __repr__(self):
        return f"<Appointment(id={self.appointment_id}, datetime='{self.appointment_datetime}', reason='{self.reason}')>"


=============== FILE: models\user_models.py ===============

# models/user_models.py

"""
EDSI Veterinary Management System - User and Authentication Models
Version: 2.0.1
Purpose: Simplified user authentication models with clean relationships.
         Added password hashing and verification methods to User model.
Last Updated: May 29, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v2.0.1 (2025-05-29):
    - Added bcrypt import for password hashing.
    - Added set_password(self, password) method to User class to hash
      and store passwords using bcrypt.
    - Added check_password(self, password) method to User class to verify
      passwords against the stored bcrypt hash.
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Simplified User model with essential fields only
    - Clean Role and UserRole relationship management
    - Removed SystemConfig (deferred to future phases)
    - Fixed circular import issues
    - Clean inheritance from BaseModel and Base
    - Simplified field definitions and constraints
    - Focused on working authentication foundation
    - Consistent naming and documentation
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
import bcrypt  # Added for password hashing

from config.database_config import Base
from models.base_model import BaseModel


class Role(BaseModel):
    """
    User roles for permission management.
    """

    __tablename__ = "roles"

    role_id = Column(
        Integer,
        primary_key=True,
        index=True,
        autoincrement=True,
        doc="Unique role identifier",
    )

    name = Column(
        String(50),
        unique=True,
        index=True,
        nullable=False,
        doc="Role name (e.g., 'ADMIN', 'USER', 'VETERINARIAN')",  # Doc updated
    )

    description = Column(String(255), nullable=True, doc="Role description")

    # Relationships
    users = relationship(
        "User",
        secondary="user_roles",
        back_populates="roles",
        doc="Users assigned to this role",
    )

    def __repr__(self):
        return f"<Role(role_id={self.role_id}, name='{self.name}')>"


class UserRole(Base):
    """
    Association table for User-Role many-to-many relationship.
    This is a simple link table without audit fields.
    """

    __tablename__ = "user_roles"

    user_id = Column(
        String(20), ForeignKey("users.user_id"), primary_key=True, doc="User identifier"
    )

    role_id = Column(
        Integer, ForeignKey("roles.role_id"), primary_key=True, doc="Role identifier"
    )

    def __repr__(self):
        return f"<UserRole(user_id='{self.user_id}', role_id={self.role_id})>"


class User(BaseModel):
    """
    User account for authentication and system access.
    """

    __tablename__ = "users"

    user_id = Column(
        String(20), primary_key=True, index=True, doc="Unique user login identifier"
    )

    password_hash = Column(
        String(255),  # bcrypt hashes are typically 60 chars, 255 is ample
        nullable=False,
        doc="Hashed password for authentication",
    )

    user_name = Column(String(100), nullable=True, doc="Display name for the user")

    email = Column(
        String(100), unique=True, index=True, nullable=True, doc="User email address"
    )

    is_active = Column(
        Boolean,
        default=True,
        nullable=False,
        index=True,
        doc="Whether the user account is active",
    )

    last_login = Column(
        DateTime, nullable=True, doc="Timestamp of last successful login"
    )

    # Optional user preferences (simplified)
    printer_id = Column(String(20), nullable=True, doc="Default printer for this user")

    default_screen_colors = Column(
        String(100), nullable=True, doc="User's preferred screen color scheme"
    )

    # Relationships
    roles = relationship(
        "Role",
        secondary="user_roles",
        back_populates="users",
        doc="Roles assigned to this user",
    )

    def set_password(self, password: str):
        """
        Hashes the provided password and stores it.
        """
        if not password:
            # Or raise an error, depending on policy for empty passwords
            # For now, assuming controller validates non-empty password for new users.
            # If an empty password is to be disallowed universally, raise ValueError here.
            return
        # Generate a salt and hash the password
        salt = bcrypt.gensalt()
        hashed_password = bcrypt.hashpw(password.encode("utf-8"), salt)
        # Store the hash as a string
        self.password_hash = hashed_password.decode("utf-8")

    def check_password(self, password: str) -> bool:
        """
        Checks the provided password against the stored hash.
        """
        if not self.password_hash or not password:
            return False
        return bcrypt.checkpw(
            password.encode("utf-8"), self.password_hash.encode("utf-8")
        )

    def __repr__(self):
        return f"<User(user_id='{self.user_id}', user_name='{self.user_name}', active={self.is_active})>"

    def has_role(self, role_name: str) -> bool:
        """
        Check if user has a specific role.

        Args:
            role_name: Name of the role to check

        Returns:
            True if user has the role, False otherwise
        """
        return any(
            role.name.upper() == role_name.upper() for role in self.roles
        )  # Made case-insensitive for robustness

    def is_admin(self) -> bool:
        """
        Check if user has admin privileges.

        Returns:
            True if user is an admin, False otherwise
        """
        return self.has_role("ADMIN")  # Ensure "ADMIN" matches the actual role name

    def update_last_login(self) -> None:
        """
        Update the last login timestamp to current time.
        """
        self.last_login = datetime.utcnow()

    def deactivate(self) -> None:
        """
        Deactivate the user account.
        """
        self.is_active = False

    def activate(self) -> None:
        """
        Activate the user account.
        """
        self.is_active = True


=============== FILE: views\__init__.py ===============

# views/__init__.py

"""Views package for EDSI application"""


=============== FILE: views\base_view.py ===============

# views/base_view.py
"""
EDSI Veterinary Management System - Base View Class
Version: 1.3.2
Purpose: Provides a base class for all main views/screens in the application,
         handling common UI setup like dark theme and status messages.
Last Updated: June 8, 2025
Author: Gemini

Changelog:
- v1.3.2 (2025-06-08):
    - Corrected the import path for CustomQuestionDialog to point to the
      `views.horse.widgets` sub-package, resolving the ModuleNotFoundError.
- v1.3.1 (2025-06-08):
    - Bug Fix: Changed the import for CustomQuestionDialog to a relative path.
- v1.3.0 (2025-06-08):
    - Refactored `show_question` to use a new `CustomQuestionDialog`.
"""

import logging
from PySide6.QtWidgets import (
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QLabel,
    QApplication,
    QMessageBox,
    QStatusBar,
    QDialog,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer

from config.app_config import (
    DARK_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_WIDGET_BACKGROUND,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DEFAULT_FONT_FAMILY,
    DARK_HEADER_FOOTER,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
    DARK_TEXT_TERTIARY,
    DARK_SUCCESS_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
)
from .horse.widgets.custom_question_dialog import CustomQuestionDialog


class BaseView(QMainWindow):
    """
    Base class for all main views/screens in the application.
    Handles common setup like dark theme, status messages, and basic layout.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} started.")

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.logger.info(
            f"BaseView __init__ for {self.__class__.__name__}: central_widget created."
        )

        if hasattr(self, "setup_ui") and callable(self.setup_ui):
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Calling overridden setup_ui()."
            )
            self.setup_ui()
        else:
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Using default BaseView setup_ui()."
            )
            default_layout = QVBoxLayout(self.central_widget)
            default_label = QLabel(f"Welcome to {self.__class__.__name__}")
            default_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            default_layout.addWidget(default_label)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QVBoxLayout set on central_widget."
            )

        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: BEFORE apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        self.apply_dark_theme_palette_and_global_styles()

        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.__INIT__: AFTER apply_dark_theme. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        if not hasattr(self, "status_bar") or self.status_bar is None:
            self.status_bar = QStatusBar()
            self.setStatusBar(self.status_bar)
            self.logger.info(
                f"BaseView __init__ for {self.__class__.__name__}: Default QStatusBar created and set."
            )
        self.update_status("Ready", 0)

        self.logger.info(f"BaseView __init__ for {self.__class__.__name__} finished.")

    def set_title(self, title: str):
        self.setWindowTitle(title)

    def apply_dark_theme_palette_and_global_styles(self):
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: START. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )

        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Text,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.ButtonText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.WindowText,
            QColor(DARK_TEXT_TERTIARY),
        )
        palette.setColor(
            QPalette.ColorGroup.Disabled,
            QPalette.ColorRole.Base,
            QColor(DARK_HEADER_FOOTER),
        )

        QApplication.setPalette(palette)
        QApplication.instance().setPalette(palette)

        QApplication.instance().setStyleSheet(
            f"""
            QMainWindow, QDialog, QWidget {{
                font-family: "{DEFAULT_FONT_FAMILY}";
                font-size: 13px;
                color: {DARK_TEXT_PRIMARY};
                background-color: {DARK_BACKGROUND};
            }}
            """
        )
        self.logger.info(
            f"Dark theme palette and global styles applied for {self.__class__.__name__}."
        )
        if self.__class__.__name__ == "HorseUnifiedManagement":
            print(
                f"--- BASEVIEW.APPLY_DARK_THEME: END. self.tab_widget is {type(getattr(self, 'tab_widget', None))} ---"
            )

    def update_status(self, message: str, timeout: int = 5000):
        """Displays a message on the status bar for a specified duration."""
        if hasattr(self, "status_bar") and self.status_bar:
            self.status_bar.showMessage(message, timeout)
            self.logger.info(f"Status update: {message}")
        else:
            self.logger.warning(
                f"Attempted to update status for {self.__class__.__name__}, but no status_bar attribute found or it is None."
            )

    def show_info(self, title: str, message: str):
        self.logger.info(f"Displaying Info: {title} - {message}")
        QMessageBox.information(self, title, message)

    def show_warning(self, title: str, message: str):
        self.logger.warning(f"Displaying Warning: {title} - {message}")
        QMessageBox.warning(self, title, message)

    def show_error(self, title: str, message: str):
        self.logger.error(f"Displaying Error: {title} - {message}")
        QMessageBox.critical(self, title, message)

    def show_question(self, title: str, message: str) -> bool:
        self.logger.info(f"Asking Question: {title} - {message}")
        dialog = CustomQuestionDialog(title, message, self)
        return dialog.exec() == QDialog.DialogCode.Accepted


=============== FILE: views\main_menu.py ===============

# views/main_menu.py

"""
EDSI Veterinary Management System - Main Menu
Version: 1.0.2
Purpose: Modern unified main menu with consolidated management screens.
         Fixed PyQt6 to PySide6 imports for consistency.
Last Updated: May 24, 2025
Author: Claude Assistant

Changelog:
- v1.0.2 (2025-05-24):
    - Fixed imports from PyQt6 to PySide6 for consistency with rest of application
    - Changed pyqtSignal to Signal from PySide6.QtCore
- v1.0.1 (2025-05-12): Updated for unified management approach
  - Replaced separate horse operations (Add, Edit, Delete) with single "Horse Management"
  - Removed horse_review_update_selected, add_new_horse_selected, delete_horse_selected signals
  - Added horse_management_selected signal for unified interface
  - Updated menu options to reflect modern management screens
  - Simplified menu structure for better user experience
- v1.0.0 (2025-05-12): Initial implementation
  - Created complete main menu matching COBOL layout
  - Implemented all menu option signals
  - Added keyboard navigation support
  - Included proper styling and layout
"""

from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QGridLayout,
    QLabel,
    QPushButton,
    QFrame,
    QSpacerItem,
    QSizePolicy,
    QGroupBox,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QFont
from views.base_view import BaseView
from config.app_config import AppConfig
import logging


class MainMenu(BaseView):
    """Primary menu screen with unified management approach"""

    # Signals for menu selections
    horse_management_selected = Signal()  # Option 1 - Unified horse operations
    table_maintenance_selected = Signal()  # Option 2
    print_reports_selected = Signal()  # Option 3
    owners_ar_selected = Signal()  # Option 4
    system_utilities_selected = Signal()  # Option 5
    mass_update_selected = Signal()  # Option 6
    logoff_exit_selected = Signal()  # Option 9
    logoff_no_exit_selected = Signal()  # Option X

    def __init__(self, current_user=None):
        self.current_user = current_user or "Unknown"
        super().__init__()
        self.setup_main_menu_ui()
        self.logger = logging.getLogger(self.__class__.__name__)

    def setup_main_menu_ui(self):
        """Setup the main menu UI"""
        self.set_title("Primary Menu")
        self.resize(700, 600)
        self.center_on_screen()

        # Header section
        self.setup_header()

        # Main menu options
        self.setup_menu_options()

        # Footer section
        self.setup_footer()

    def setup_header(self):
        """Setup header with title and user info"""
        header_frame = QFrame()
        header_layout = QVBoxLayout(header_frame)

        # Main title
        title_label = QLabel("EDSI Primary Menu")
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 24, QFont.Weight.Bold)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_PRIMARY_ACTION};
            padding: 10px;
        """
        )

        # User info
        user_info_label = QLabel(f"Current User: {self.current_user}")
        user_info_label.setAlignment(Qt.AlignmentFlag.AlignRight)
        user_info_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_TEXT_SECONDARY};
            font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
            padding: 5px;
        """
        )

        header_layout.addWidget(title_label)
        header_layout.addWidget(user_info_label)

        # Set up the main window layout instead of using the base view methods
        if not hasattr(self, "main_layout"):
            self.main_layout = QVBoxLayout(self.central_widget)
            self.main_layout.setContentsMargins(20, 20, 20, 20)

        self.main_layout.addWidget(header_frame)

    def setup_menu_options(self):
        """Setup main menu options grid"""
        # Create menu group box
        menu_group = QGroupBox("Select an option:")
        menu_group.setStyleSheet(
            f"""
            QGroupBox {{
                font-size: {AppConfig.DEFAULT_FONT_SIZE + 2}pt;
                font-weight: bold;
                color: {AppConfig.DARK_TEXT_PRIMARY};
                padding-top: 15px;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 8px 0 8px;
            }}
        """
        )

        # Create grid layout for menu options
        menu_layout = QGridLayout(menu_group)
        menu_layout.setSpacing(15)
        menu_layout.setContentsMargins(20, 20, 20, 20)

        # Define menu options (number, text, signal) - Updated for unified approach
        menu_options = [
            ("1.", "Horse Management", self.horse_management_selected),
            ("2.", "Table Maintenance", self.table_maintenance_selected),
            ("3.", "Print Reports & Billing", self.print_reports_selected),
            ("4.", "Owners A/R", self.owners_ar_selected),
            ("5.", "System Utilities", self.system_utilities_selected),
            ("6.", "Mass Update", self.mass_update_selected),
            ("9.", "Logoff & Exit", self.logoff_exit_selected),
            ("X.", "Logoff, No Exit", self.logoff_no_exit_selected),
        ]

        # Create buttons for each option
        self.menu_buttons = {}
        row = 0
        col = 0
        max_cols = 2

        for number, text, signal in menu_options:
            button = self.create_menu_button(number, text, signal)
            menu_layout.addWidget(button, row, col)
            self.menu_buttons[number] = button

            col += 1
            if col >= max_cols:
                col = 0
                row += 1

        # Add the menu group to content area
        self.main_layout.addWidget(menu_group, 1)  # Take up most space

    def create_menu_button(self, number, text, signal):
        """Create a styled menu button"""
        button = QPushButton(f"{number} {text}")
        button.setMinimumHeight(50)
        button.setMinimumWidth(280)

        # Special styling for exit options
        if number in ["9.", "X."]:
            button.setStyleSheet(
                f"""
                QPushButton {{
                    background-color: {AppConfig.DARK_DANGER_ACTION};
                    color: white;
                    border: none;
                    padding: 10px;
                    text-align: left;
                    font-size: {AppConfig.DEFAULT_FONT_SIZE + 1}pt;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background-color: #5a6268;
                }}
                QPushButton:pressed {{
                    background-color: #495057;
                }}
            """
            )
        else:
            button.setStyleSheet(
                f"""
                QPushButton {{
                    background-color: {AppConfig.DARK_PRIMARY_ACTION};
                    color: white;
                    border: none;
                    padding: 10px;
                    text-align: left;
                    font-size: {AppConfig.DEFAULT_FONT_SIZE + 1}pt;
                    border-radius: 6px;
                }}
                QPushButton:hover {{
                    background-color: #106ebe;
                }}
                QPushButton:pressed {{
                    background-color: #005a9e;
                }}
            """
            )

        button.clicked.connect(lambda checked, s=signal: s.emit())
        return button

    def setup_footer(self):
        """Setup footer with instructions"""
        footer_frame = QFrame()
        footer_layout = QHBoxLayout(footer_frame)

        instruction_label = QLabel(
            "Select an option by clicking or pressing the corresponding number/letter"
        )
        instruction_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        instruction_label.setStyleSheet(
            f"""
            color: {AppConfig.DARK_TEXT_SECONDARY};
            font-style: italic;
            font-size: {AppConfig.SMALL_FONT_SIZE + 1}pt;
            padding: 10px;
        """
        )

        footer_layout.addWidget(instruction_label)
        self.main_layout.addWidget(footer_frame)

    def center_on_screen(self):
        """Center the main menu on the display"""
        screen = self.screen().availableGeometry()
        size = self.geometry()
        self.move(
            (screen.width() - size.width()) // 2, (screen.height() - size.height()) // 2
        )

    def keyPressEvent(self, event):
        """Handle keyboard shortcuts for menu options"""
        key = event.text().upper()

        # Map keys to signals - Updated for unified approach
        key_mappings = {
            "1": self.horse_management_selected,
            "2": self.table_maintenance_selected,
            "3": self.print_reports_selected,
            "4": self.owners_ar_selected,
            "5": self.system_utilities_selected,
            "6": self.mass_update_selected,
            "9": self.logoff_exit_selected,
            "X": self.logoff_no_exit_selected,
        }

        if key in key_mappings:
            self.logger.info(f"Menu option {key} selected via keyboard")
            key_mappings[key].emit()
        else:
            super().keyPressEvent(event)


=============== FILE: views\admin\user_management_screen.py ===============

# views/admin/user_management_screen.py
"""
EDSI Veterinary Management System - User Management Screen
Version: 1.6.3
Purpose: Admin screen for managing users, locations, veterinarians, charge codes,
         categories, owners, and the company profile.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.6.3 (2025-06-09):
    - Providing the single, complete, and unabridged file containing the full
      implementations for all seven tabs.
- v1.6.2 (2025-06-09):
    - Bug Fix: Removed redundant message helper methods.
- v1.6.1 (2025-06-09):
    - Bug Fix: Restored the full implementations for all original tab methods.
    - Feature: Correctly integrated the new "Manage Veterinarians" and "Company Profile" tabs.
"""

import logging
from typing import Optional, List, Dict, Any, Union

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QTabWidget,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QHeaderView,
    QAbstractItemView,
    QLabel,
    QFrame,
    QMessageBox,
    QMenu,
    QTreeWidget,
    QTreeWidgetItem,
    QComboBox,
    QDialog,
)
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QAction, QColor, QFont

from views.base_view import BaseView
from config.app_config import AppConfig

from controllers import (
    UserController,
    LocationController,
    ChargeCodeController,
    OwnerController,
    CompanyProfileController,
    VeterinarianController,
)

from models import (
    User,
    Location,
    ChargeCode,
    Owner as OwnerModel,
    ChargeCodeCategory,
    Veterinarian,
)

from .dialogs.add_edit_user_dialog import AddEditUserDialog
from .dialogs.add_edit_location_dialog import AddEditLocationDialog
from .dialogs.add_edit_charge_code_dialog import AddEditChargeCodeDialog
from .dialogs.add_edit_owner_dialog import AddEditOwnerDialog
from .dialogs.add_edit_charge_code_category_dialog import (
    AddEditChargeCodeCategoryDialog,
)
from .dialogs.add_edit_veterinarian_dialog import AddEditVeterinarianDialog
from .dialogs.company_profile_dialog import CompanyProfileDialog
from ..horse.widgets.custom_question_dialog import CustomQuestionDialog


class UserManagementScreen(BaseView):
    back_to_main_menu = Signal()
    entity_updated = Signal(str)

    USER_TAB_INDEX = 0
    LOCATION_TAB_INDEX = 1
    VETERINARIAN_TAB_INDEX = 2
    CATEGORY_PROCESS_TAB_INDEX = 3
    CHARGE_CODE_TAB_INDEX = 4
    OWNER_TAB_INDEX = 5
    PROFILE_TAB_INDEX = 6

    def __init__(self, current_user_id: str, parent: Optional[QWidget] = None):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(
            f"UserManagementScreen __init__ called for user: {current_user_id}"
        )

        self.current_user_id = current_user_id
        if not self.current_user_id:
            self.logger.error(
                "UserManagementScreen initialized without a current_user_id!"
            )

        self.user_controller = UserController()
        self.location_controller = LocationController()
        self.veterinarian_controller = VeterinarianController()
        self.charge_code_controller = ChargeCodeController()
        self.owner_controller = OwnerController()
        self.company_profile_controller = CompanyProfileController()

        # Widget Attributes
        self.users_table: Optional[QTableWidget] = None
        self.add_user_btn: Optional[QPushButton] = None
        self.edit_user_btn: Optional[QPushButton] = None
        self.toggle_user_active_btn: Optional[QPushButton] = None
        self.delete_user_btn: Optional[QPushButton] = None
        self.user_status_filter_combo: Optional[QComboBox] = None

        self.locations_table: Optional[QTableWidget] = None
        self.add_location_btn: Optional[QPushButton] = None
        self.edit_location_btn: Optional[QPushButton] = None
        self.toggle_location_active_btn: Optional[QPushButton] = None
        self.delete_location_btn: Optional[QPushButton] = None
        self.location_status_filter_combo: Optional[QComboBox] = None

        self.vets_table: Optional[QTableWidget] = None
        self.add_vet_btn: Optional[QPushButton] = None
        self.edit_vet_btn: Optional[QPushButton] = None
        self.toggle_vet_active_btn: Optional[QPushButton] = None
        self.vet_status_filter_combo: Optional[QComboBox] = None

        self.categories_tree: Optional[QTreeWidget] = None
        self.add_category_btn: Optional[QPushButton] = None
        self.add_process_btn: Optional[QPushButton] = None
        self.edit_category_process_btn: Optional[QPushButton] = None
        self.toggle_category_process_active_btn: Optional[QPushButton] = None
        self.delete_category_process_btn: Optional[QPushButton] = None
        self.category_filter_combo: Optional[QComboBox] = None

        self.charge_codes_table: Optional[QTableWidget] = None
        self.add_charge_code_btn: Optional[QPushButton] = None
        self.edit_charge_code_btn: Optional[QPushButton] = None
        self.toggle_charge_code_active_btn: Optional[QPushButton] = None
        self.delete_charge_code_btn: Optional[QPushButton] = None
        self.charge_code_status_filter_combo: Optional[QComboBox] = None

        self.owners_table: Optional[QTableWidget] = None
        self.add_owner_btn: Optional[QPushButton] = None
        self.edit_owner_btn: Optional[QPushButton] = None
        self.toggle_owner_active_btn: Optional[QPushButton] = None
        self.delete_owner_btn: Optional[QPushButton] = None
        self.owner_status_filter_combo: Optional[QComboBox] = None

        self.edit_profile_btn: Optional[QPushButton] = None
        self.tab_widget: Optional[QTabWidget] = None

        self._active_filters: Dict[int, str] = {
            self.USER_TAB_INDEX: "active",
            self.LOCATION_TAB_INDEX: "active",
            self.VETERINARIAN_TAB_INDEX: "active",
            self.CATEGORY_PROCESS_TAB_INDEX: "active",
            self.CHARGE_CODE_TAB_INDEX: "active",
            self.OWNER_TAB_INDEX: "active",
        }

        super().__init__(parent)

        self.refresh_timer = QTimer(self)
        self.refresh_timer.setSingleShot(True)
        self.refresh_timer.timeout.connect(self._refresh_current_tab_data)

        self.setWindowTitle("User and System Management")
        self.resize(1200, 800)
        self.logger.info("UserManagementScreen __init__ completed.")

    def setup_ui(self):
        self.logger.info("Setting up UserManagementScreen UI...")

        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet(self._get_tab_widget_style())

        users_tab_widget = self._create_users_tab()
        locations_tab_widget = self._create_locations_tab()
        veterinarians_tab_widget = self._create_veterinarians_tab()
        categories_processes_tab_widget = self._create_categories_processes_tab()
        charge_codes_tab_widget = self._create_charge_codes_tab()
        owners_tab_widget = self._create_owners_tab()
        company_profile_tab_widget = self._create_company_profile_tab()

        self.tab_widget.addTab(users_tab_widget, " Manage Users")
        self.tab_widget.addTab(locations_tab_widget, " Manage Locations")
        self.tab_widget.addTab(veterinarians_tab_widget, " Manage Veterinarians")
        self.tab_widget.addTab(
            categories_processes_tab_widget, " Manage Categories/Processes"
        )
        self.tab_widget.addTab(charge_codes_tab_widget, " Manage Charge Codes")
        self.tab_widget.addTab(owners_tab_widget, " Manage Master Owners")
        self.tab_widget.addTab(company_profile_tab_widget, " Company Profile")

        main_layout.addWidget(self.tab_widget)

        self._setup_connections()
        if self.tab_widget:
            self.tab_widget.setCurrentIndex(0)
            self._refresh_current_tab_data()

        self.logger.info("UserManagementScreen UI setup complete.")

    def _get_tab_widget_style(self) -> str:
        return f"""
            QTabWidget::pane {{
                border: 1px solid {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                border-radius: 6px;
                margin-top: -1px; 
            }}
            QTabBar::tab {{
                padding: 10px 20px;
                margin-right: 2px;
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-bottom: none; 
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                min-width: 120px; 
                font-size: 13px;
                font-weight: 500;
            }}
            QTabBar::tab:selected {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border-color: {AppConfig.DARK_BORDER};
                border-bottom-color: {AppConfig.DARK_WIDGET_BACKGROUND}; 
            }}
            QTabBar::tab:!selected:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QTabWidget::tab-bar {{
                alignment: left;
                border: none; 
                background-color: transparent; 
                margin-bottom: 0px; 
            }}
        """

    def _create_standard_button_layout(self) -> QHBoxLayout:
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        return button_layout

    def _apply_standard_button_style(
        self, button: QPushButton, button_type: str = "standard"
    ):
        base_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 15px;
                font-size: 12px;
                font-weight: 500;
                min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
            }}
            QPushButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
            }}
        """
        if button_type == "add":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_SUCCESS_ACTION
                )
                + "color: white;"
            )
        elif button_type == "edit":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_PRIMARY_ACTION
                )
                + "color: white;"
            )
        elif button_type == "delete" or button_type == "toggle_inactive":
            button.setStyleSheet(
                base_style.replace(
                    AppConfig.DARK_BUTTON_BG, AppConfig.DARK_DANGER_ACTION
                )
                + "color: white;"
            )
        else:
            button.setStyleSheet(base_style)

    def get_form_input_style(self) -> str:
        return f"""
            QComboBox {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
                min-height: 20px;
            }}
            QComboBox:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QComboBox::drop-down {{
                border: none;
                background-color: transparent;
            }}
            QComboBox QAbstractItemView {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                selection-background-color: {AppConfig.DARK_HIGHLIGHT_BG};
                selection-color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _setup_connections(self):
        self.logger.debug("Setting up connections for UserManagementScreen.")
        if self.tab_widget:
            self.tab_widget.currentChanged.connect(self._on_tab_changed)

        if self.add_user_btn:
            self.add_user_btn.clicked.connect(self._add_user)
        if self.edit_user_btn:
            self.edit_user_btn.clicked.connect(self._edit_selected_user)
        if self.toggle_user_active_btn:
            self.toggle_user_active_btn.clicked.connect(
                self._toggle_selected_user_active_status
            )
        if self.delete_user_btn:
            self.delete_user_btn.clicked.connect(self._delete_selected_user)
        if self.users_table:
            self.users_table.itemSelectionChanged.connect(
                self._update_user_action_buttons_state
            )
        if self.user_status_filter_combo:
            self.user_status_filter_combo.currentIndexChanged.connect(
                self._on_user_filter_changed
            )

        if self.add_location_btn:
            self.add_location_btn.clicked.connect(self._add_location)
        if self.edit_location_btn:
            self.edit_location_btn.clicked.connect(self._edit_selected_location)
        if self.toggle_location_active_btn:
            self.toggle_location_active_btn.clicked.connect(
                self._toggle_selected_location_active_status
            )
        if self.delete_location_btn:
            self.delete_location_btn.clicked.connect(self._delete_selected_location)
        if self.locations_table:
            self.locations_table.itemSelectionChanged.connect(
                self._update_location_action_buttons_state
            )
        if self.location_status_filter_combo:
            self.location_status_filter_combo.currentIndexChanged.connect(
                self._on_location_filter_changed
            )

        if self.add_vet_btn:
            self.add_vet_btn.clicked.connect(self._add_veterinarian)
        if self.edit_vet_btn:
            self.edit_vet_btn.clicked.connect(self._edit_selected_veterinarian)
        if self.toggle_vet_active_btn:
            self.toggle_vet_active_btn.clicked.connect(
                self._toggle_selected_veterinarian_status
            )
        if self.vets_table:
            self.vets_table.itemSelectionChanged.connect(
                self._update_veterinarian_action_buttons_state
            )
        if self.vet_status_filter_combo:
            self.vet_status_filter_combo.currentIndexChanged.connect(
                self._on_vet_filter_changed
            )

        if self.add_category_btn:
            self.add_category_btn.clicked.connect(self._add_category_or_process)
        if self.add_process_btn:
            self.add_process_btn.clicked.connect(
                lambda: self._add_category_or_process(is_process=True)
            )
        if self.edit_category_process_btn:
            self.edit_category_process_btn.clicked.connect(
                self._edit_selected_category_process
            )
        if self.toggle_category_process_active_btn:
            self.toggle_category_process_active_btn.clicked.connect(
                self._toggle_selected_category_process_active_status
            )
        if self.delete_category_process_btn:
            self.delete_category_process_btn.clicked.connect(
                self._delete_selected_category_process
            )
        if self.categories_tree:
            self.categories_tree.itemSelectionChanged.connect(
                self._update_category_action_buttons_state
            )
        if self.category_filter_combo:
            self.category_filter_combo.currentIndexChanged.connect(
                self._on_category_filter_changed
            )

        if self.add_charge_code_btn:
            self.add_charge_code_btn.clicked.connect(self._add_charge_code)
        if self.edit_charge_code_btn:
            self.edit_charge_code_btn.clicked.connect(self._edit_selected_charge_code)
        if self.toggle_charge_code_active_btn:
            self.toggle_charge_code_active_btn.clicked.connect(
                self._toggle_selected_charge_code_active_status
            )
        if self.delete_charge_code_btn:
            self.delete_charge_code_btn.clicked.connect(
                self._delete_selected_charge_code
            )
        if self.charge_codes_table:
            self.charge_codes_table.itemSelectionChanged.connect(
                self._update_charge_code_action_buttons_state
            )
        if self.charge_code_status_filter_combo:
            self.charge_code_status_filter_combo.currentIndexChanged.connect(
                self._on_charge_code_filter_changed
            )

        if self.add_owner_btn:
            self.add_owner_btn.clicked.connect(self._add_owner)
        if self.edit_owner_btn:
            self.edit_owner_btn.clicked.connect(self._edit_selected_owner)
        if self.toggle_owner_active_btn:
            self.toggle_owner_active_btn.clicked.connect(
                self._toggle_selected_owner_active_status
            )
        if self.delete_owner_btn:
            self.delete_owner_btn.clicked.connect(self._delete_selected_owner)
        if self.owners_table:
            self.owners_table.itemSelectionChanged.connect(
                self._update_owner_action_buttons_state
            )
        if self.owner_status_filter_combo:
            self.owner_status_filter_combo.currentIndexChanged.connect(
                self._on_owner_filter_changed
            )

        if self.edit_profile_btn:
            self.edit_profile_btn.clicked.connect(self._launch_company_profile_dialog)
        self.logger.debug("Connections setup complete.")

    def _on_tab_changed(self, index: int):
        self.logger.info(
            f"Tab changed to index: {index}, new tab title: {self.tab_widget.tabText(index) if self.tab_widget else 'N/A'}"
        )
        self._refresh_current_tab_data()

    def _refresh_current_tab_data(self, force_reload: bool = False):
        if not self.tab_widget:
            self.logger.warning("Tab widget not available for refresh.")
            return
        current_index = self.tab_widget.currentIndex()
        self.logger.debug(f"Refreshing data for tab index: {current_index}")

        if current_index == self.USER_TAB_INDEX:
            self.load_users_data()
        elif current_index == self.LOCATION_TAB_INDEX:
            self.load_locations_data()
        elif current_index == self.VETERINARIAN_TAB_INDEX:
            self.load_veterinarians_data()
        elif current_index == self.CATEGORY_PROCESS_TAB_INDEX:
            self.load_categories_processes_data()
        elif current_index == self.CHARGE_CODE_TAB_INDEX:
            self.load_charge_codes_data()
        elif current_index == self.OWNER_TAB_INDEX:
            self.load_owners_data()
        elif current_index == self.PROFILE_TAB_INDEX:
            pass
        else:
            self.logger.warning(
                f"No data loading action defined for tab index {current_index}"
            )

    def _create_table_widget(self, headers: List[str]) -> QTableWidget:
        table = QTableWidget()
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        table.verticalHeader().setVisible(False)
        table.setShowGrid(True)
        table.setStyleSheet(
            f"""
            QTableWidget {{
                gridline-color: {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
            }}
            QHeaderView::section {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                padding: 5px;
                border: none; 
                border-bottom: 1px solid {AppConfig.DARK_BORDER};
                font-weight: 500;
            }}
            QTableWidget::item {{ padding: 5px; }}
            QTableWidget::item:selected {{ background-color: {AppConfig.DARK_HIGHLIGHT_BG}; color: {AppConfig.DARK_HIGHLIGHT_TEXT}; }}
            """
        )
        table.horizontalHeader().setStretchLastSection(True)
        for i in range(len(headers) - 1):
            table.horizontalHeader().setSectionResizeMode(
                i, QHeaderView.ResizeMode.ResizeToContents
            )
        return table

    # --- Users Tab Methods ---
    def _create_users_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_user_btn = QPushButton(" Add New User")
        self._apply_standard_button_style(self.add_user_btn, "add")
        self.edit_user_btn = QPushButton(" Edit Selected")
        self._apply_standard_button_style(self.edit_user_btn, "edit")
        self.toggle_user_active_btn = QPushButton(" Toggle Active Status")
        self._apply_standard_button_style(self.toggle_user_active_btn)
        self.delete_user_btn = QPushButton(" Delete Selected")
        self._apply_standard_button_style(self.delete_user_btn, "delete")
        button_layout.addWidget(self.add_user_btn)
        button_layout.addWidget(self.edit_user_btn)
        button_layout.addWidget(self.toggle_user_active_btn)
        button_layout.addWidget(self.delete_user_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.user_status_filter_combo = QComboBox()
        self.user_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.user_status_filter_combo.setCurrentText(
            self._active_filters.get(self.USER_TAB_INDEX, "active")
        )
        self.user_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.user_status_filter_combo)
        layout.addLayout(top_bar_layout)
        self.users_table = self._create_table_widget(
            ["Login ID", "Full Name", "Email", "Roles", "Active", "Last Login"]
        )
        layout.addWidget(self.users_table)
        self._update_user_action_buttons_state()
        return tab

    def load_users_data(self):
        self.logger.info("Loading users data for tab...")
        if not self.users_table or not self.user_status_filter_combo:
            self.logger.error("Users table or filter combo not initialized.")
            return
        try:
            status_filter = self.user_status_filter_combo.currentText().lower()
            self._active_filters[self.USER_TAB_INDEX] = status_filter
            users = self.user_controller.get_all_users(status_filter=status_filter)
            self.users_table.setRowCount(0)
            for user_obj in users:
                row_position = self.users_table.rowCount()
                self.users_table.insertRow(row_position)
                self.users_table.setItem(
                    row_position, 0, QTableWidgetItem(user_obj.user_id)
                )
                self.users_table.setItem(
                    row_position, 1, QTableWidgetItem(user_obj.user_name or "")
                )
                self.users_table.setItem(
                    row_position, 2, QTableWidgetItem(user_obj.email or "")
                )
                roles_str = ", ".join([role.name for role in user_obj.roles])
                self.users_table.setItem(row_position, 3, QTableWidgetItem(roles_str))
                active_str = "Yes" if user_obj.is_active else "No"
                self.users_table.setItem(row_position, 4, QTableWidgetItem(active_str))
                last_login_str = (
                    user_obj.last_login.strftime("%Y-%m-%d %H:%M")
                    if user_obj.last_login
                    else "Never"
                )
                self.users_table.setItem(
                    row_position, 5, QTableWidgetItem(last_login_str)
                )
                self.users_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, user_obj.user_id
                )
            self.logger.info(f"Loaded {len(users)} users.")
        except Exception as e:
            self.logger.error(f"Error loading users: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load users: {e}")
        self._update_user_action_buttons_state()

    def _on_user_filter_changed(self, index: int):
        self.load_users_data()

    def _add_user(self):
        dialog = AddEditUserDialog(
            self,
            user_controller=self.user_controller,
            current_user_object=None,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_users_data()
            self.entity_updated.emit("user")

    def _edit_selected_user(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Edit User", "Please select a user to edit.")
            return
        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        if not user_id_item:
            self.show_error("Error", "Could not retrieve user ID for selected row.")
            return
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )
        user_to_edit = self.user_controller.get_user_by_login_id(user_login_id)
        if user_to_edit:
            dialog = AddEditUserDialog(
                self,
                user_controller=self.user_controller,
                current_user_object=user_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_users_data()
                self.entity_updated.emit("user")
        else:
            self.show_error("Error", f"User with Login ID '{user_login_id}' not found.")
            self.load_users_data()

    def _toggle_selected_user_active_status(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a user.")
            return
        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )
        user_obj = self.user_controller.get_user_by_login_id(user_login_id)
        if not user_obj:
            self.show_error("Error", f"User {user_login_id} not found.")
            return
        action = "deactivate" if user_obj.is_active else "activate"
        name_display = user_obj.user_name or user_obj.user_id
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} user '{name_display}'?",
        ):
            success, message = self.user_controller.toggle_user_active_status(
                user_login_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_users_data()
                self.entity_updated.emit("user")
            else:
                self.show_error("Error", message)

    def _delete_selected_user(self):
        if not self.users_table or not self.users_table.currentItem():
            self.show_info("Delete User", "Please select a user to delete.")
            return
        selected_row = self.users_table.currentRow()
        user_id_item = self.users_table.item(selected_row, 0)
        user_login_id = (
            user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
        )
        user_name_item = self.users_table.item(selected_row, 1)
        display_name = user_name_item.text() if user_name_item else user_login_id
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete user '{display_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.user_controller.delete_user_permanently(
                user_login_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_users_data()
                self.entity_updated.emit("user_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_user_action_buttons_state(self):
        has_selection = (
            self.users_table is not None and self.users_table.currentItem() is not None
        )
        if self.edit_user_btn:
            self.edit_user_btn.setEnabled(has_selection)
        if self.toggle_user_active_btn:
            self.toggle_user_active_btn.setEnabled(has_selection)
        if self.delete_user_btn:
            self.delete_user_btn.setEnabled(has_selection)
        if has_selection and self.toggle_user_active_btn and self.users_table:
            selected_row = self.users_table.currentRow()
            user_id_item = self.users_table.item(selected_row, 0)
            if not user_id_item:
                return
            user_login_id = (
                user_id_item.data(Qt.ItemDataRole.UserRole) or user_id_item.text()
            )
            user_obj = self.user_controller.get_user_by_login_id(user_login_id)
            if user_obj:
                action_text = "Deactivate" if user_obj.is_active else "Activate"
                self.toggle_user_active_btn.setText(f" {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_user_active_btn,
                    "toggle_inactive" if user_obj.is_active else "standard",
                )

    # --- Locations Tab Methods ---
    def _create_locations_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_location_btn = QPushButton(" Add New Location")
        self._apply_standard_button_style(self.add_location_btn, "add")
        self.edit_location_btn = QPushButton(" Edit Selected")
        self._apply_standard_button_style(self.edit_location_btn, "edit")
        self.toggle_location_active_btn = QPushButton(" Toggle Active Status")
        self._apply_standard_button_style(self.toggle_location_active_btn)
        self.delete_location_btn = QPushButton(" Delete Selected")
        self._apply_standard_button_style(self.delete_location_btn, "delete")
        button_layout.addWidget(self.add_location_btn)
        button_layout.addWidget(self.edit_location_btn)
        button_layout.addWidget(self.toggle_location_active_btn)
        button_layout.addWidget(self.delete_location_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.location_status_filter_combo = QComboBox()
        self.location_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.location_status_filter_combo.setCurrentText(
            self._active_filters.get(self.LOCATION_TAB_INDEX, "active")
        )
        self.location_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.location_status_filter_combo)
        layout.addLayout(top_bar_layout)
        self.locations_table = self._create_table_widget(
            ["Name", "Address", "City", "State", "Zip", "Contact", "Active"]
        )
        layout.addWidget(self.locations_table)
        self._update_location_action_buttons_state()
        return tab

    def load_locations_data(self):
        self.logger.info("Loading locations data for tab...")
        if not self.locations_table or not self.location_status_filter_combo:
            self.logger.error("Locations table or filter combo not initialized.")
            return
        try:
            status_filter = self.location_status_filter_combo.currentText().lower()
            self._active_filters[self.LOCATION_TAB_INDEX] = status_filter
            locations = self.location_controller.get_all_locations(
                status_filter=status_filter
            )
            self.locations_table.setRowCount(0)
            for loc_obj in locations:
                row_position = self.locations_table.rowCount()
                self.locations_table.insertRow(row_position)
                self.locations_table.setItem(
                    row_position, 0, QTableWidgetItem(loc_obj.location_name)
                )
                address_parts = [loc_obj.address_line1, loc_obj.address_line2]
                self.locations_table.setItem(
                    row_position,
                    1,
                    QTableWidgetItem(" ".join(filter(None, address_parts))),
                )
                self.locations_table.setItem(
                    row_position, 2, QTableWidgetItem(loc_obj.city or "")
                )
                state_display = loc_obj.state_code or ""
                if (
                    hasattr(loc_obj, "state")
                    and loc_obj.state
                    and hasattr(loc_obj.state, "state_code")
                ):
                    state_display = loc_obj.state.state_code
                self.locations_table.setItem(
                    row_position, 3, QTableWidgetItem(state_display)
                )
                self.locations_table.setItem(
                    row_position, 4, QTableWidgetItem(loc_obj.zip_code or "")
                )
                self.locations_table.setItem(
                    row_position, 5, QTableWidgetItem(loc_obj.contact_person or "")
                )
                self.locations_table.setItem(
                    row_position,
                    6,
                    QTableWidgetItem("Yes" if loc_obj.is_active else "No"),
                )
                self.locations_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, loc_obj.location_id
                )
            self.logger.info(f"Loaded {len(locations)} locations.")
        except Exception as e:
            self.logger.error(f"Error loading locations: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load locations: {e}")
        self._update_location_action_buttons_state()

    def _on_location_filter_changed(self, index: int):
        self.load_locations_data()

    def _add_location(self):
        dialog = AddEditLocationDialog(
            self,
            controller=self.location_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_locations_data()
            self.entity_updated.emit("location")

    def _edit_selected_location(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Edit Location", "Please select a location to edit.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        location_to_edit = self.location_controller.get_location_by_id(location_id)
        if location_to_edit:
            dialog = AddEditLocationDialog(
                self,
                controller=self.location_controller,
                location=location_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_locations_data()
                self.entity_updated.emit("location")
        else:
            self.show_error("Error", f"Location with ID '{location_id}' not found.")
            self.load_locations_data()

    def _toggle_selected_location_active_status(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a location.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        loc_obj = self.location_controller.get_location_by_id(location_id)
        if not loc_obj:
            self.show_error("Error", f"Location {location_id} not found.")
            return
        action = "deactivate" if loc_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} location '{loc_obj.location_name}'?",
        ):
            success, message = self.location_controller.toggle_location_active_status(
                location_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_locations_data()
                self.entity_updated.emit("location")
            else:
                self.show_error("Error", message)

    def _delete_selected_location(self):
        if not self.locations_table or not self.locations_table.currentItem():
            self.show_info("Delete Location", "Please select a location to delete.")
            return
        selected_row = self.locations_table.currentRow()
        location_id_item = self.locations_table.item(selected_row, 0)
        location_id = (
            location_id_item.data(Qt.ItemDataRole.UserRole) or location_id_item.text()
        )
        location_name = location_id_item.text()
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete location '{location_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.location_controller.delete_location(
                location_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_locations_data()
                self.entity_updated.emit("location_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_location_action_buttons_state(self):
        has_selection = (
            self.locations_table is not None
            and self.locations_table.currentItem() is not None
        )
        if self.edit_location_btn:
            self.edit_location_btn.setEnabled(has_selection)
        if self.toggle_location_active_btn:
            self.toggle_location_active_btn.setEnabled(has_selection)
        if self.delete_location_btn:
            self.delete_location_btn.setEnabled(has_selection)
        if has_selection and self.toggle_location_active_btn and self.locations_table:
            selected_row = self.locations_table.currentRow()
            location_id_item = self.locations_table.item(selected_row, 0)
            if not location_id_item:
                return
            loc_id = (
                location_id_item.data(Qt.ItemDataRole.UserRole)
                or location_id_item.text()
            )
            loc_obj = self.location_controller.get_location_by_id(loc_id)
            if loc_obj:
                action_text = "Deactivate" if loc_obj.is_active else "Activate"
                self.toggle_location_active_btn.setText(f" {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_location_active_btn,
                    "toggle_inactive" if loc_obj.is_active else "standard",
                )

    # --- Veterinarians Tab Methods ---
    def _create_veterinarians_tab(self):
        tab_widget = QWidget()
        main_layout = QVBoxLayout(tab_widget)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_vet_btn = QPushButton(" Add New Veterinarian")
        self._apply_standard_button_style(self.add_vet_btn, "add")
        self.edit_vet_btn = QPushButton(" Edit Selected")
        self._apply_standard_button_style(self.edit_vet_btn, "edit")
        self.toggle_vet_active_btn = QPushButton(" Toggle Active Status")
        self._apply_standard_button_style(self.toggle_vet_active_btn)
        button_layout.addWidget(self.add_vet_btn)
        button_layout.addWidget(self.edit_vet_btn)
        button_layout.addWidget(self.toggle_vet_active_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.vet_status_filter_combo = QComboBox()
        self.vet_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.vet_status_filter_combo.setCurrentText(
            self._active_filters.get(self.VETERINARIAN_TAB_INDEX, "active")
        )
        self.vet_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.vet_status_filter_combo)
        main_layout.addLayout(top_bar_layout)
        self.vets_table = self._create_table_widget(
            ["Name", "License #", "Specialty", "Phone", "Email", "Status"]
        )
        main_layout.addWidget(self.vets_table)
        self._update_veterinarian_action_buttons_state()
        return tab_widget

    def load_veterinarians_data(self):
        self.logger.info("Loading veterinarians data for tab...")
        if not self.vets_table or not self.vet_status_filter_combo:
            self.logger.error("Veterinarians table or filter combo not initialized.")
            return
        try:
            status_filter = self.vet_status_filter_combo.currentText().lower()
            self._active_filters[self.VETERINARIAN_TAB_INDEX] = status_filter
            vets = self.veterinarian_controller.get_all_veterinarians(
                status_filter=status_filter
            )
            self.vets_table.setRowCount(0)
            for vet in vets:
                row_position = self.vets_table.rowCount()
                self.vets_table.insertRow(row_position)
                name_item = QTableWidgetItem(f"{vet.first_name} {vet.last_name}")
                name_item.setData(Qt.ItemDataRole.UserRole, vet.vet_id)
                status_item = QTableWidgetItem(
                    "Active" if vet.is_active else "Inactive"
                )
                status_item.setForeground(
                    QColor("#68D391") if vet.is_active else QColor("#FC8181")
                )
                self.vets_table.setItem(row_position, 0, name_item)
                self.vets_table.setItem(
                    row_position, 1, QTableWidgetItem(vet.license_number or "")
                )
                self.vets_table.setItem(
                    row_position, 2, QTableWidgetItem(vet.specialty or "")
                )
                self.vets_table.setItem(
                    row_position, 3, QTableWidgetItem(vet.phone or "")
                )
                self.vets_table.setItem(
                    row_position, 4, QTableWidgetItem(vet.email or "")
                )
                self.vets_table.setItem(row_position, 5, status_item)
            self.logger.info(f"Loaded {len(vets)} veterinarians.")
        except Exception as e:
            self.logger.error(f"Error loading veterinarians: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load veterinarians: {e}")
        self._update_veterinarian_action_buttons_state()

    def _on_vet_filter_changed(self, index: int):
        self.load_veterinarians_data()

    def _add_veterinarian(self):
        dialog = AddEditVeterinarianDialog(
            parent_view=self,
            controller=self.veterinarian_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_veterinarians_data()
            self.entity_updated.emit("veterinarian")
            self.show_info("Success", "Veterinarian added successfully.")

    def _edit_selected_veterinarian(self):
        selected_rows = self.vets_table.selectionModel().selectedRows()
        if not selected_rows:
            self.show_info("Edit Veterinarian", "Please select a veterinarian to edit.")
            return
        vet_id = selected_rows[0].data(Qt.ItemDataRole.UserRole)
        vet_to_edit = self.veterinarian_controller.get_veterinarian_by_id(vet_id)
        if not vet_to_edit:
            self.show_error("Error", "Could not retrieve veterinarian details.")
            return
        dialog = AddEditVeterinarianDialog(
            parent_view=self,
            controller=self.veterinarian_controller,
            current_user_id=self.current_user_id,
            veterinarian=vet_to_edit,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_veterinarians_data()
            self.entity_updated.emit("veterinarian")
            self.show_info("Success", "Veterinarian updated successfully.")

    def _toggle_selected_veterinarian_status(self):
        selected_rows = self.vets_table.selectionModel().selectedRows()
        if not selected_rows:
            self.show_info("Toggle Status", "Please select a veterinarian.")
            return
        vet_id = selected_rows[0].data(Qt.ItemDataRole.UserRole)
        vet_name = self.vets_table.item(selected_rows[0].row(), 0).text()
        current_status_text = self.vets_table.item(selected_rows[0].row(), 5).text()
        action_text = "deactivate" if current_status_text == "Active" else "activate"
        if self.show_question(
            "Confirm Status Change",
            f"Are you sure you want to {action_text} {vet_name}?",
        ):
            success, message = self.veterinarian_controller.toggle_veterinarian_status(
                vet_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_veterinarians_data()
            else:
                self.show_error("Error", message)

    def _update_veterinarian_action_buttons_state(self):
        has_selection = bool(
            self.vets_table is not None
            and self.vets_table.selectionModel().hasSelection()
        )
        if self.edit_vet_btn:
            self.edit_vet_btn.setEnabled(has_selection)
        if self.toggle_vet_active_btn:
            self.toggle_vet_active_btn.setEnabled(has_selection)
            if has_selection:
                selected_row = self.vets_table.currentRow()
                status_text = self.vets_table.item(selected_row, 5).text()
                action_text = "Deactivate" if status_text == "Active" else "Activate"
                self.toggle_vet_active_btn.setText(f" {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_vet_active_btn,
                    "toggle_inactive" if status_text == "Active" else "standard",
                )

    # --- Categories/Processes Tab Methods ---
    def _create_categories_processes_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        self.add_category_btn = QPushButton(" Add Category (L1)")
        self._apply_standard_button_style(self.add_category_btn, "add")
        self.add_process_btn = QPushButton(" Add Process (L2)")
        self._apply_standard_button_style(self.add_process_btn, "add")
        self.edit_category_process_btn = QPushButton(" Edit Selected")
        self._apply_standard_button_style(self.edit_category_process_btn, "edit")
        self.toggle_category_process_active_btn = QPushButton(" Toggle Active Status")
        self._apply_standard_button_style(self.toggle_category_process_active_btn)
        self.delete_category_process_btn = QPushButton(" Delete Selected")
        self._apply_standard_button_style(self.delete_category_process_btn, "delete")
        top_bar_layout.addWidget(self.add_category_btn)
        top_bar_layout.addWidget(self.add_process_btn)
        top_bar_layout.addWidget(self.edit_category_process_btn)
        top_bar_layout.addWidget(self.toggle_category_process_active_btn)
        top_bar_layout.addWidget(self.delete_category_process_btn)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.category_filter_combo = QComboBox()
        self.category_filter_combo.addItems(["Active", "Inactive", "All"])
        self.category_filter_combo.setCurrentText(
            self._active_filters.get(self.CATEGORY_PROCESS_TAB_INDEX, "active")
        )
        self.category_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.category_filter_combo)
        layout.addLayout(top_bar_layout)
        self.categories_tree = QTreeWidget()
        self.categories_tree.setHeaderLabels(
            ["Category/Process Name", "Level", "Status", "ID"]
        )
        self.categories_tree.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.categories_tree.setStyleSheet(
            f"""QTreeWidget {{ background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_BORDER}; border-radius: 4px; }} QHeaderView::section {{ background-color: {AppConfig.DARK_HEADER_FOOTER}; color: {AppConfig.DARK_TEXT_SECONDARY}; padding: 5px; border: none; border-bottom: 1px solid {AppConfig.DARK_BORDER}; font-weight: 500; }} QTreeWidget::item:selected {{ background-color: {AppConfig.DARK_HIGHLIGHT_BG}; color: {AppConfig.DARK_HIGHLIGHT_TEXT}; }} QTreeWidget::item {{ padding: 3px; }}"""
        )
        header = self.categories_tree.header()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        for i in range(1, 4):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)
        layout.addWidget(self.categories_tree)
        self._update_category_action_buttons_state()
        return tab

    def load_categories_processes_data(self):
        self.logger.info("Loading charge code categories/processes data...")
        if not self.categories_tree or not self.category_filter_combo:
            self.logger.error("Categories tree or filter combo not initialized.")
            return
        self.categories_tree.clear()
        try:
            level1_categories = (
                self.charge_code_controller.get_all_charge_code_categories_hierarchical()
            )
            ui_status_filter = self.category_filter_combo.currentText().lower()
            self._active_filters[self.CATEGORY_PROCESS_TAB_INDEX] = ui_status_filter
            for cat_l1 in level1_categories:
                has_visible_children = False
                child_items = []
                for cat_l2 in cat_l1.children:
                    if (
                        ui_status_filter == "all"
                        or (ui_status_filter == "active" and cat_l2.is_active)
                        or (ui_status_filter == "inactive" and not cat_l2.is_active)
                    ):
                        l2_item = QTreeWidgetItem()
                        l2_item.setText(0, cat_l2.name)
                        l2_item.setText(1, str(cat_l2.level))
                        l2_item.setText(2, "Active" if cat_l2.is_active else "Inactive")
                        l2_item.setText(3, str(cat_l2.category_id))
                        l2_item.setData(
                            0,
                            Qt.ItemDataRole.UserRole,
                            {"id": cat_l2.category_id, "level": 2, "obj": cat_l2},
                        )
                        child_items.append(l2_item)
                        has_visible_children = True
                is_l1_visible = (
                    ui_status_filter == "all"
                    or (ui_status_filter == "active" and cat_l1.is_active)
                    or (ui_status_filter == "inactive" and not cat_l1.is_active)
                )
                if is_l1_visible or has_visible_children:
                    l1_item = QTreeWidgetItem(self.categories_tree)
                    l1_item.setText(0, cat_l1.name)
                    l1_item.setText(1, str(cat_l1.level))
                    l1_item.setText(2, "Active" if cat_l1.is_active else "Inactive")
                    l1_item.setText(3, str(cat_l1.category_id))
                    l1_item.setData(
                        0,
                        Qt.ItemDataRole.UserRole,
                        {"id": cat_l1.category_id, "level": 1, "obj": cat_l1},
                    )
                    l1_item.addChildren(child_items)
            self.categories_tree.expandAll()
            self.logger.info(
                f"Displayed categories in tree (UI filter: '{ui_status_filter}')."
            )
        except Exception as e:
            self.logger.error(f"Error loading categories/processes: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load categories: {e}")
        self._update_category_action_buttons_state()

    def _on_category_filter_changed(self, index: int):
        self.load_categories_processes_data()

    def _add_category_or_process(self, is_process: bool = False):
        selected_item = (
            self.categories_tree.currentItem() if self.categories_tree else None
        )
        parent_category: Optional[ChargeCodeCategory] = None
        if is_process:
            if not selected_item:
                self.show_warning(
                    "Add Process",
                    "Please select a Level 1 Category to add a Process under.",
                )
                return
            item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
            if item_data.get("level") != 1:
                self.show_warning(
                    "Add Process",
                    "Processes (Level 2) can only be added under a Level 1 Category.",
                )
                return
            parent_category = item_data.get("obj")
        dialog = AddEditChargeCodeCategoryDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
            category_to_edit=None,
            parent_category=parent_category,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_categories_processes_data()
            self.entity_updated.emit("charge_code_category")

    def _edit_selected_category_process(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Edit Item", "Please select a category or process to edit.")
            return
        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        category_to_edit: Optional[ChargeCodeCategory] = item_data.get("obj")
        if not category_to_edit:
            self.show_error("Error", "Could not retrieve item details to edit.")
            self.load_categories_processes_data()
            return
        dialog = AddEditChargeCodeCategoryDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
            category_to_edit=category_to_edit,
            parent_category=category_to_edit.parent,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_categories_processes_data()
            self.entity_updated.emit("charge_code_category")

    def _toggle_selected_category_process_active_status(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Toggle Status", "Please select an item.")
            return
        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        item_id = item_data.get("id")
        item_obj: Optional[ChargeCodeCategory] = item_data.get("obj")
        if not item_obj:
            self.show_error("Error", f"Item with ID {item_id} not found.")
            return
        action = "deactivate" if item_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} '{item_obj.name}'?",
        ):
            success, message = (
                self.charge_code_controller.toggle_charge_code_category_status(
                    item_id, self.current_user_id
                )
            )
            if success:
                self.show_info("Success", message)
                self.load_categories_processes_data()
            else:
                self.show_error("Error", message)

    def _delete_selected_category_process(self):
        if not self.categories_tree or not self.categories_tree.currentItem():
            self.show_info("Delete Item", "Please select an item to delete.")
            return
        selected_item = self.categories_tree.currentItem()
        item_data = selected_item.data(0, Qt.ItemDataRole.UserRole)
        item_id = item_data.get("id")
        item_name = selected_item.text(0)
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete '{item_name}'?\nThis may fail if it is in use.\nThis action cannot be undone.",
        ):
            success, message = self.charge_code_controller.delete_charge_code_category(
                item_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_categories_processes_data()
            else:
                self.show_error("Delete Failed", message)

    def _update_category_action_buttons_state(self):
        if not self.categories_tree:
            return
        has_selection = self.categories_tree.currentItem() is not None
        is_l1_selected = False
        item_obj: Optional[ChargeCodeCategory] = None
        if has_selection:
            item_data = self.categories_tree.currentItem().data(
                0, Qt.ItemDataRole.UserRole
            )
            if item_data:
                is_l1_selected = item_data.get("level") == 1
                item_obj = item_data.get("obj")
        if self.add_category_btn:
            self.add_category_btn.setEnabled(True)
        if self.add_process_btn:
            self.add_process_btn.setEnabled(is_l1_selected)
        if self.edit_category_process_btn:
            self.edit_category_process_btn.setEnabled(has_selection)
        if self.toggle_category_process_active_btn:
            self.toggle_category_process_active_btn.setEnabled(has_selection)
        if self.delete_category_process_btn:
            self.delete_category_process_btn.setEnabled(has_selection)
        if has_selection and self.toggle_category_process_active_btn and item_obj:
            action_text = "Deactivate" if item_obj.is_active else "Activate"
            self.toggle_category_process_active_btn.setText(
                f" {action_text} Selected"
            )
            self._apply_standard_button_style(
                self.toggle_category_process_active_btn,
                "toggle_inactive" if item_obj.is_active else "standard",
            )

    # --- Charge Codes Tab Methods ---
    def _create_charge_codes_tab(self):
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_charge_code_btn = QPushButton(" Add New Charge Code")
        self._apply_standard_button_style(self.add_charge_code_btn, "add")
        self.edit_charge_code_btn = QPushButton(" Edit Selected")
        self._apply_standard_button_style(self.edit_charge_code_btn, "edit")
        self.toggle_charge_code_active_btn = QPushButton(" Toggle Active Status")
        self._apply_standard_button_style(self.toggle_charge_code_active_btn)
        self.delete_charge_code_btn = QPushButton(" Delete Selected")
        self._apply_standard_button_style(self.delete_charge_code_btn, "delete")
        button_layout.addWidget(self.add_charge_code_btn)
        button_layout.addWidget(self.edit_charge_code_btn)
        button_layout.addWidget(self.toggle_charge_code_active_btn)
        button_layout.addWidget(self.delete_charge_code_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.charge_code_status_filter_combo = QComboBox()
        self.charge_code_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.charge_code_status_filter_combo.setCurrentText(
            self._active_filters.get(self.CHARGE_CODE_TAB_INDEX, "active")
        )
        self.charge_code_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.charge_code_status_filter_combo)
        layout.addLayout(top_bar_layout)
        self.charge_codes_table = self._create_table_widget(
            [
                "Code",
                "Alternate Code",
                "Category",
                "Description",
                "Std. Price",
                "Active",
            ]
        )
        if self.charge_codes_table:
            self.charge_codes_table.horizontalHeader().setSectionResizeMode(
                3, QHeaderView.ResizeMode.Stretch
            )
            for i in [0, 1, 2, 4, 5]:
                self.charge_codes_table.horizontalHeader().setSectionResizeMode(
                    i, QHeaderView.ResizeMode.ResizeToContents
                )
        layout.addWidget(self.charge_codes_table)
        self._update_charge_code_action_buttons_state()
        return tab

    def load_charge_codes_data(self):
        self.logger.info("Loading charge codes data for tab...")
        if not self.charge_codes_table or not self.charge_code_status_filter_combo:
            self.logger.error("Charge codes table or filter combo not initialized.")
            return
        try:
            status_filter = self.charge_code_status_filter_combo.currentText().lower()
            self.logger.info(f"Charge code status filter: {status_filter}")
            self._active_filters[self.CHARGE_CODE_TAB_INDEX] = status_filter
            charge_codes = self.charge_code_controller.get_all_charge_codes(
                status_filter=status_filter
            )
            self.charge_codes_table.setRowCount(0)
            for c_obj in charge_codes:
                row_position = self.charge_codes_table.rowCount()
                self.charge_codes_table.insertRow(row_position)
                self.charge_codes_table.setItem(
                    row_position, 0, QTableWidgetItem(c_obj.code)
                )
                self.charge_codes_table.setItem(
                    row_position, 1, QTableWidgetItem(c_obj.alternate_code or "")
                )
                category_path_str = "N/A"
                if c_obj.category_id:
                    path_objects = self.charge_code_controller.get_category_path(
                        c_obj.category_id
                    )
                    if path_objects:
                        category_path_str = " > ".join(
                            [p["name"] for p in path_objects]
                        )
                self.charge_codes_table.setItem(
                    row_position, 2, QTableWidgetItem(category_path_str)
                )
                self.charge_codes_table.setItem(
                    row_position, 3, QTableWidgetItem(c_obj.description)
                )
                price_str = (
                    f"${c_obj.standard_charge:.2f}"
                    if c_obj.standard_charge is not None
                    else "$0.00"
                )
                price_item = QTableWidgetItem(price_str)
                price_item.setTextAlignment(
                    Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
                )
                self.charge_codes_table.setItem(row_position, 4, price_item)
                self.charge_codes_table.setItem(
                    row_position,
                    5,
                    QTableWidgetItem("Yes" if c_obj.is_active else "No"),
                )
                self.charge_codes_table.item(row_position, 0).setData(
                    Qt.ItemDataRole.UserRole, c_obj.id
                )
            self.logger.info(
                f"Loaded {len(charge_codes)} charge codes based on filter '{status_filter}'."
            )
        except AttributeError as ae:
            self.logger.error(f"Error loading charge codes: {ae}", exc_info=True)
            self.show_error("Load Error", f"Could not load charge codes: {ae}")
        except Exception as e:
            self.logger.error(f"General error loading charge codes: {e}", exc_info=True)
            self.show_error("Load Error", f"An unexpected error occurred: {e}")
        self._update_charge_code_action_buttons_state()

    def _on_charge_code_filter_changed(self, index: int):
        self.load_charge_codes_data()

    def _add_charge_code(self):
        dialog = AddEditChargeCodeDialog(
            self,
            controller=self.charge_code_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_charge_codes_data()
            self.entity_updated.emit("charge_code")

    def _edit_selected_charge_code(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info("Edit Charge Code", "Please select a charge code to edit.")
            return
        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        charge_code_to_edit = self.charge_code_controller.get_charge_code_by_id(
            charge_code_id
        )
        if charge_code_to_edit:
            dialog = AddEditChargeCodeDialog(
                self,
                controller=self.charge_code_controller,
                charge_code=charge_code_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code")
        else:
            self.show_error(
                "Error", f"Charge code with ID '{charge_code_id}' not found."
            )
            self.load_charge_codes_data()

    def _toggle_selected_charge_code_active_status(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info("Toggle Active Status", "Please select a charge code.")
            return
        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        cc_obj = self.charge_code_controller.get_charge_code_by_id(charge_code_id)
        if not cc_obj:
            self.show_error("Error", f"Charge code {charge_code_id} not found.")
            return
        action = "deactivate" if cc_obj.is_active else "activate"
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} charge code '{cc_obj.code} - {cc_obj.description}'?",
        ):
            success, message = self.charge_code_controller.toggle_charge_code_status(
                charge_code_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code")
            else:
                self.show_error("Error", message)

    def _delete_selected_charge_code(self):
        if not self.charge_codes_table or not self.charge_codes_table.currentItem():
            self.show_info(
                "Delete Charge Code", "Please select a charge code to delete."
            )
            return
        selected_row = self.charge_codes_table.currentRow()
        charge_code_id = self.charge_codes_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        charge_code_name = self.charge_codes_table.item(selected_row, 0).text()
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete charge code '{charge_code_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.charge_code_controller.delete_charge_code(
                charge_code_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_charge_codes_data()
                self.entity_updated.emit("charge_code_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_charge_code_action_buttons_state(self):
        has_selection = (
            self.charge_codes_table is not None
            and self.charge_codes_table.currentItem() is not None
        )
        if self.edit_charge_code_btn:
            self.edit_charge_code_btn.setEnabled(has_selection)
        if self.toggle_charge_code_active_btn:
            self.toggle_charge_code_active_btn.setEnabled(has_selection)
        if self.delete_charge_code_btn:
            self.delete_charge_code_btn.setEnabled(has_selection)
        if (
            has_selection
            and self.toggle_charge_code_active_btn
            and self.charge_codes_table
        ):
            selected_row = self.charge_codes_table.currentRow()
            charge_code_id_item = self.charge_codes_table.item(selected_row, 0)
            if not charge_code_id_item:
                return
            charge_code_id = charge_code_id_item.data(Qt.ItemDataRole.UserRole)
            cc_obj = self.charge_code_controller.get_charge_code_by_id(charge_code_id)
            if cc_obj:
                action_text = "Deactivate" if cc_obj.is_active else "Activate"
                self.toggle_charge_code_active_btn.setText(f" {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_charge_code_active_btn,
                    "toggle_inactive" if cc_obj.is_active else "standard",
                )

    # --- Owners Tab Methods ---
    def _create_owners_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        top_bar_layout = QHBoxLayout()
        button_layout = self._create_standard_button_layout()
        self.add_owner_btn = QPushButton(" Add New Owner")
        self._apply_standard_button_style(self.add_owner_btn, "add")
        self.edit_owner_btn = QPushButton(" Edit Selected")
        self._apply_standard_button_style(self.edit_owner_btn, "edit")
        self.toggle_owner_active_btn = QPushButton(" Toggle Active Status")
        self._apply_standard_button_style(self.toggle_owner_active_btn)
        self.delete_owner_btn = QPushButton(" Delete Selected")
        self._apply_standard_button_style(self.delete_owner_btn, "delete")
        button_layout.addWidget(self.add_owner_btn)
        button_layout.addWidget(self.edit_owner_btn)
        button_layout.addWidget(self.toggle_owner_active_btn)
        button_layout.addWidget(self.delete_owner_btn)
        top_bar_layout.addLayout(button_layout)
        top_bar_layout.addStretch(1)
        top_bar_layout.addWidget(QLabel("Filter Status:"))
        self.owner_status_filter_combo = QComboBox()
        self.owner_status_filter_combo.addItems(["Active", "Inactive", "All"])
        self.owner_status_filter_combo.setCurrentText(
            self._active_filters.get(self.OWNER_TAB_INDEX, "active")
        )
        self.owner_status_filter_combo.setStyleSheet(self.get_form_input_style())
        top_bar_layout.addWidget(self.owner_status_filter_combo)
        layout.addLayout(top_bar_layout)
        self.owners_table = self._create_table_widget(
            [
                "Account #",
                "Farm Name",
                "Last Name",
                "First Name",
                "City",
                "State",
                "Phone",
                "Active",
            ]
        )
        if self.owners_table:
            self.owners_table.horizontalHeader().setSectionResizeMode(
                1, QHeaderView.ResizeMode.Stretch
            )
            self.owners_table.horizontalHeader().setSectionResizeMode(
                2, QHeaderView.ResizeMode.Stretch
            )
        layout.addWidget(self.owners_table)
        self._update_owner_action_buttons_state()
        return tab

    def load_owners_data(self):
        self.logger.info("Loading owners data for tab...")
        if not self.owners_table or not self.owner_status_filter_combo:
            self.logger.error("Owners table or filter combo not initialized.")
            return
        try:
            status_filter = self.owner_status_filter_combo.currentText().lower()
            self._active_filters[self.OWNER_TAB_INDEX] = status_filter
            owners = self.owner_controller.get_all_master_owners(
                status_filter=status_filter
            )
            self.owners_table.setRowCount(0)
            for owner_obj in owners:
                row_pos = self.owners_table.rowCount()
                self.owners_table.insertRow(row_pos)
                self.owners_table.setItem(
                    row_pos, 0, QTableWidgetItem(owner_obj.account_number or "")
                )
                self.owners_table.setItem(
                    row_pos, 1, QTableWidgetItem(owner_obj.farm_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 2, QTableWidgetItem(owner_obj.last_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 3, QTableWidgetItem(owner_obj.first_name or "")
                )
                self.owners_table.setItem(
                    row_pos, 4, QTableWidgetItem(owner_obj.city or "")
                )
                state_display = owner_obj.state_code or ""
                if (
                    hasattr(owner_obj, "state")
                    and owner_obj.state
                    and hasattr(owner_obj.state, "state_code")
                ):
                    state_display = owner_obj.state.state_code
                self.owners_table.setItem(row_pos, 5, QTableWidgetItem(state_display))
                self.owners_table.setItem(
                    row_pos, 6, QTableWidgetItem(owner_obj.phone or "")
                )
                self.owners_table.setItem(
                    row_pos, 7, QTableWidgetItem("Yes" if owner_obj.is_active else "No")
                )
                self.owners_table.item(row_pos, 0).setData(
                    Qt.ItemDataRole.UserRole, owner_obj.owner_id
                )
            self.logger.info(f"Loaded {len(owners)} owners.")
        except Exception as e:
            self.logger.error(f"Error loading owners: {e}", exc_info=True)
            self.show_error("Load Error", f"Could not load owners: {e}")
        self._update_owner_action_buttons_state()

    def _on_owner_filter_changed(self, index: int):
        self.load_owners_data()

    def _add_owner(self):
        dialog = AddEditOwnerDialog(
            self,
            owner_controller=self.owner_controller,
            current_user_id=self.current_user_id,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.load_owners_data()
            self.entity_updated.emit("owner")

    def _edit_selected_owner(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Edit Owner", "Please select an owner.")
            return
        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
        owner_to_edit = self.owner_controller.get_owner_by_id(owner_id)
        if owner_to_edit:
            dialog = AddEditOwnerDialog(
                self,
                owner_controller=self.owner_controller,
                owner_object=owner_to_edit,
                current_user_id=self.current_user_id,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_owners_data()
                self.entity_updated.emit("owner")
        else:
            self.show_error("Error", f"Owner ID '{owner_id}' not found.")
            self.load_owners_data()

    def _toggle_selected_owner_active_status(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Toggle Status", "Please select an owner.")
            return
        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
        owner_obj = self.owner_controller.get_owner_by_id(owner_id)
        if not owner_obj:
            self.show_error("Error", f"Owner ID {owner_id} not found.")
            return
        action = "deactivate" if owner_obj.is_active else "activate"
        name_display = (
            owner_obj.farm_name
            or f"{owner_obj.first_name or ''} {owner_obj.last_name or ''}".strip()
            or f"ID: {owner_obj.owner_id}"
        )
        if self.show_question(
            f"Confirm {action.capitalize()}",
            f"Are you sure you want to {action} owner '{name_display}'?",
        ):
            success, message = self.owner_controller.toggle_owner_active_status(
                owner_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_owners_data()
                self.entity_updated.emit("owner")
            else:
                self.show_error("Error", message)

    def _delete_selected_owner(self):
        if not self.owners_table or not self.owners_table.currentItem():
            self.show_info("Delete Owner", "Please select an owner to delete.")
            return
        selected_row = self.owners_table.currentRow()
        owner_id_item = self.owners_table.item(selected_row, 0)
        owner_id = owner_id_item.data(Qt.ItemDataRole.UserRole)
        display_name = (
            self.owners_table.item(selected_row, 1).text()
            or self.owners_table.item(selected_row, 2).text()
        )
        if self.show_question(
            "Confirm Delete",
            f"Are you sure you want to permanently delete owner '{display_name}'?\nThis action cannot be undone.",
        ):
            success, message = self.owner_controller.delete_master_owner(
                owner_id, self.current_user_id
            )
            if success:
                self.show_info("Success", message)
                self.load_owners_data()
                self.entity_updated.emit("owner_deleted")
            else:
                self.show_error("Delete Failed", message)

    def _update_owner_action_buttons_state(self):
        has_selection = (
            self.owners_table is not None
            and self.owners_table.currentItem() is not None
        )
        if self.edit_owner_btn:
            self.edit_owner_btn.setEnabled(has_selection)
        if self.toggle_owner_active_btn:
            self.toggle_owner_active_btn.setEnabled(has_selection)
        if self.delete_owner_btn:
            self.delete_owner_btn.setEnabled(has_selection)
        if has_selection and self.toggle_owner_active_btn and self.owners_table:
            selected_row = self.owners_table.currentRow()
            owner_id_item = self.owners_table.item(selected_row, 0)
            if not owner_id_item:
                return
            owner_id = (
                owner_id_item.data(Qt.ItemDataRole.UserRole) or owner_id_item.text()
            )
            owner_obj = self.owner_controller.get_owner_by_id(owner_id)
            if owner_obj:
                action_text = "Deactivate" if owner_obj.is_active else "Activate"
                self.toggle_owner_active_btn.setText(f" {action_text} Selected")
                self._apply_standard_button_style(
                    self.toggle_owner_active_btn,
                    "toggle_inactive" if owner_obj.is_active else "standard",
                )

    # --- Company Profile Tab ---
    def _create_company_profile_tab(self) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(25, 25, 25, 25)
        layout.setSpacing(15)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        title = QLabel("Company Profile Management")
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 14, QFont.Weight.Bold)
        title.setFont(title_font)
        title.setStyleSheet(f"color: {AppConfig.DARK_TEXT_PRIMARY};")
        description = QLabel(
            "Here you can set your company's information, which will be used on invoices and other reports."
        )
        description.setStyleSheet(f"color: {AppConfig.DARK_TEXT_SECONDARY};")
        description.setWordWrap(True)
        self.edit_profile_btn = QPushButton(" Edit Company Profile")
        self._apply_standard_button_style(self.edit_profile_btn, "edit")
        self.edit_profile_btn.setMinimumHeight(40)
        self.edit_profile_btn.setFixedWidth(250)
        layout.addWidget(title)
        layout.addWidget(description)
        layout.addSpacing(20)
        layout.addWidget(self.edit_profile_btn)
        return tab

    def _launch_company_profile_dialog(self):
        dialog = CompanyProfileDialog(self, self.current_user_id)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.entity_updated.emit("company_profile")
            self.show_info("Success", "Company profile has been updated.")


=============== FILE: views\admin\dialogs\__init__.py ===============

# views/admin/dialogs/__init__.py
"""
EDSI Veterinary Management System - Admin Dialogs Package
"""
from .add_edit_user_dialog import AddEditUserDialog
from .add_edit_location_dialog import AddEditLocationDialog
from .add_edit_charge_code_dialog import AddEditChargeCodeDialog
from .add_edit_charge_code_category_dialog import AddEditChargeCodeCategoryDialog
from .add_edit_owner_dialog import AddEditOwnerDialog
from .company_profile_dialog import CompanyProfileDialog
from .add_edit_veterinarian_dialog import AddEditVeterinarianDialog

__all__ = [
    "AddEditUserDialog",
    "AddEditLocationDialog",
    "AddEditChargeCodeDialog",
    "AddEditChargeCodeCategoryDialog",
    "AddEditOwnerDialog",
    "CompanyProfileDialog",
    "AddEditVeterinarianDialog",
]


=============== FILE: views\admin\dialogs\add_edit_charge_code_category_dialog.py ===============

# views/admin/dialogs/add_edit_charge_code_category_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Category/Process Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing charge code categories (Level 1)
         and processes (Level 2).
Last Updated: June 3, 2025
Author: Gemini
"""

import logging
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCodeCategory

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeCategoryDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        category_to_edit: Optional[ChargeCodeCategory] = None,
        parent_category: Optional[
            ChargeCodeCategory
        ] = None,  # For adding a new Level 2 Process
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.category_to_edit = category_to_edit
        self.parent_category = (
            parent_category  # Will be None if adding/editing a Level 1 Category
        )

        self.is_edit_mode = self.category_to_edit is not None

        # Determine level
        if self.is_edit_mode:
            self.current_level = self.category_to_edit.level
            self.current_parent_id = self.category_to_edit.parent_id
            if (
                self.current_parent_id and not self.parent_category
            ):  # Fetch parent if editing L2 and not passed
                self.parent_category = self.controller.get_category_by_id_internal(
                    self.current_parent_id
                )

        elif self.parent_category:  # Adding a new Level 2 Process
            self.current_level = 2
            self.current_parent_id = self.parent_category.category_id
        else:  # Adding a new Level 1 Category
            self.current_level = 1
            self.current_parent_id = None

        self.item_type_name = "Process" if self.current_level == 2 else "Category"

        self.setWindowTitle(
            f"{'Edit' if self.is_edit_mode else 'Add New'} {self.item_type_name}"
        )
        self.setMinimumWidth(450)

        # Input Fields
        self.name_input: Optional[QLineEdit] = None
        self.parent_name_label: Optional[QLabel] = None  # To display parent name
        self.level_label: Optional[QLabel] = None  # To display level
        self.is_active_checkbox: Optional[QCheckBox] = None

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.category_to_edit:
            self._populate_fields()
        else:  # New item
            self.is_active_checkbox.setChecked(True)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {base_bg};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px;
                padding: 6px 10px; font-size: 13px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled {{ 
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QCheckBox::indicator {{ width: 13px; height: 13px; }}
            QCheckBox {{ color: {DARK_TEXT_PRIMARY}; background-color: transparent; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        # ... (rest of palette setup - can be copied from another dialog) ...
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str, is_field_value: bool = False) -> QLabel:
        label = QLabel(text)
        style = f"color: {DARK_TEXT_PRIMARY if is_field_value else DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        if is_field_value:
            style += f" padding-left: 5px; border: 1px solid {DARK_BORDER}; border-radius: 4px; background-color: {DARK_HEADER_FOOTER}; min-height: 20px;"

        label.setStyleSheet(style)
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText(f"Enter {self.item_type_name} Name")

        # Display Parent Category Name (if applicable)
        parent_display_name = (
            self.parent_category.name if self.parent_category else "N/A (Top Level)"
        )
        self.parent_name_label = self._create_label(
            parent_display_name, is_field_value=True
        )

        # Display Level
        self.level_label = self._create_label(
            str(self.current_level), is_field_value=True
        )

        self.is_active_checkbox = QCheckBox("Is Active")

        form_layout.addRow(
            self._create_label(f"{self.item_type_name} Name*:"), self.name_input
        )
        if self.current_level == 2:  # Only show parent for Processes (Level 2)
            form_layout.addRow(
                self._create_label("Parent Category:"), self.parent_name_label
            )
        form_layout.addRow(self._create_label("Level:"), self.level_label)
        form_layout.addRow(self._create_label("Status:"), self.is_active_checkbox)

        input_style = self._get_form_input_style()
        self.name_input.setStyleSheet(input_style)
        self.is_active_checkbox.setStyleSheet(input_style)  # For QCheckBox part

        layout.addLayout(form_layout)
        layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        if self.category_to_edit:
            self.name_input.setText(self.category_to_edit.name)
            self.is_active_checkbox.setChecked(self.category_to_edit.is_active)
            # Parent and Level are already set in __init__ and displayed by labels

    def get_data(self) -> Optional[Dict[str, Any]]:
        name = self.name_input.text().strip()
        if not name:
            QMessageBox.warning(
                self, "Input Error", f"{self.item_type_name} Name is required."
            )
            return None

        return {
            "name": name,
            "is_active": self.is_active_checkbox.isChecked(),
            "level": self.current_level,
            "parent_id": self.current_parent_id,
        }

    def validate_and_accept(self):
        data = self.get_data()
        if data is None:
            return

        # Use the controller's validation method
        is_valid, errors = self.controller.validate_charge_code_category_data(
            data,
            is_new=(not self.is_edit_mode),
            category_id=(
                self.category_to_edit.category_id if self.is_edit_mode else None
            ),
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Validation Error",
                "Please correct errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.category_to_edit:
                success, message = self.controller.update_charge_code_category(
                    self.category_to_edit.category_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code_category(
                    data, self.current_user_id
                )

            if success:
                if hasattr(
                    self.parent_view, "show_info"
                ):  # Check if parent_view has show_info
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error saving category/process: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {str(e)}"
            )


=============== FILE: views\admin\dialogs\add_edit_charge_code_dialog.py ===============

# views/admin/dialogs/add_edit_charge_code_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Charge Code Dialog
Version: 1.1.12
Purpose: Dialog for creating and editing charge codes.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.1.12 (2025-06-09):
    - Bug Fix: In `validate_and_accept`, correctly pass the `charge_code_id_to_ignore`
      parameter to the validation method to allow saving of edited records.
- v1.1.11 (2025-06-05):
    - Bug Fix: Corrected dictionary key access for category path population.
"""

import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QTextEdit,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QHBoxLayout,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt, QTimer, Slot

from controllers.charge_code_controller import ChargeCodeController
from models import ChargeCode as ChargeCodeModel
from models import ChargeCodeCategory

from config.app_config import AppConfig
import os

try:
    current_script_path_for_assets = os.path.dirname(os.path.abspath(__file__))
    project_root_for_assets = os.path.abspath(
        os.path.join(current_script_path_for_assets, "..", "..", "..")
    )
    assets_path = os.path.join(project_root_for_assets, "assets", "icons")
    if not os.path.exists(os.path.join(assets_path, "checkmark_light.svg")):
        assets_path = "assets/icons"
except Exception:
    assets_path = "assets/icons"


from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditChargeCodeDialog(QDialog):
    def __init__(
        self,
        parent,
        controller: ChargeCodeController,
        current_user_id: str,
        charge_code: Optional[ChargeCodeModel] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.controller = controller
        self.current_user_id = current_user_id
        self.charge_code = charge_code
        self.is_edit_mode = charge_code is not None

        self.code_input: Optional[QLineEdit] = None
        self.alt_code_input: Optional[QLineEdit] = None
        self.description_input: Optional[QTextEdit] = None
        self.main_category_combo: Optional[QComboBox] = None
        self.sub_category_combo: Optional[QComboBox] = None
        self.standard_charge_input: Optional[QDoubleSpinBox] = None
        self.taxable_checkbox: Optional[QCheckBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Charge Code")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_main_categories()

        if self.is_edit_mode and self.charge_code:
            self._populate_fields()
        else:
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(True)
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(False)
            if self.sub_category_combo:
                self.sub_category_combo.setEnabled(False)

        if self.is_active_checkbox:
            self.is_active_checkbox.setEnabled(False)
        if self.taxable_checkbox:
            self.taxable_checkbox.setEnabled(False)

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        checkmark_path = os.path.join(assets_path, "checkmark_light.svg").replace(
            os.sep, "/"
        )
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY};
            border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled, QTextEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER};
            color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER};
            }}
            QLineEdit[readOnly="true"] {{ background-color: {DARK_HEADER_FOOTER};
            color: {DARK_TEXT_TERTIARY}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent;
            }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY};
            }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
            border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
            QCheckBox::indicator:disabled {{ background-color: {DARK_INPUT_FIELD_BACKGROUND};
            border: 1px solid {DARK_TEXT_TERTIARY}; }}
            QCheckBox::indicator:checked:disabled {{ background-color: {DARK_PRIMARY_ACTION};
            border: 1px solid {DARK_PRIMARY_ACTION}; image: url({checkmark_path}); }}
            QCheckBox:disabled {{ color: {DARK_TEXT_SECONDARY};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)
        self.code_input = QLineEdit()
        self.code_input.setPlaceholderText("Unique code (e.g., EXAM01)")
        self.alt_code_input = QLineEdit()
        self.alt_code_input.setPlaceholderText("Alternative code (optional)")
        if self.alt_code_input:
            self.alt_code_input.textEdited.connect(self._on_alt_code_text_edited)

        self.main_category_combo = QComboBox()
        self.main_category_combo.setPlaceholderText("Select Main Category")
        self.sub_category_combo = QComboBox()
        self.sub_category_combo.setPlaceholderText("Select Sub-Category")
        self.description_input = QTextEdit()
        self.description_input.setPlaceholderText("Detailed description")
        self.description_input.setFixedHeight(70)
        self.standard_charge_input = QDoubleSpinBox()
        self.standard_charge_input.setDecimals(2)
        self.standard_charge_input.setRange(0.00, 99999.99)
        self.standard_charge_input.setPrefix("$ ")
        self.standard_charge_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.taxable_checkbox = QCheckBox("Taxable")
        self.taxable_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )
        self.is_active_checkbox = QCheckBox("Active")
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Alt. Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.alt_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Main Category*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.main_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Sub-Category:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.sub_category_combo, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Standard Charge*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.standard_charge_input, row, 1)
        status_layout = QHBoxLayout()
        status_layout.addWidget(self.taxable_checkbox)
        status_layout.addSpacing(20)
        status_layout.addWidget(self.is_active_checkbox)
        status_layout.addStretch()
        grid_layout.addLayout(
            status_layout,
            row,
            2,
            1,
            2,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )
        row += 1
        grid_layout.addWidget(
            self._create_label("Description*:"),
            row,
            0,
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight,
        )
        grid_layout.addWidget(self.description_input, row, 1, 1, 3)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        fields_to_style = [
            self.code_input,
            self.alt_code_input,
            self.description_input,
            self.main_category_combo,
            self.sub_category_combo,
            self.standard_charge_input,
        ]
        for field in fields_to_style:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_style = (
                    generic_button_style
                    + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
                )
                button.setStyleSheet(ok_style)
        overall_layout.addWidget(self.button_box)
        if self.main_category_combo:
            self.main_category_combo.currentIndexChanged.connect(
                self._on_main_category_changed
            )

    @Slot(str)
    def _on_alt_code_text_edited(self, text: str):
        if self.alt_code_input:
            current_text = text
            uppercase_text = current_text.upper()
            if current_text != uppercase_text:
                self.alt_code_input.blockSignals(True)
                cursor_pos = self.alt_code_input.cursorPosition()
                self.alt_code_input.setText(uppercase_text)
                self.alt_code_input.setCursorPosition(cursor_pos)
                self.alt_code_input.blockSignals(False)

    def _load_main_categories(self):
        if not self.main_category_combo:
            return
        self.main_category_combo.clear()
        self.main_category_combo.addItem("Select Main Category...", None)
        try:
            categories = self.controller.get_charge_code_categories(level=1)
            for cat in categories:
                self.main_category_combo.addItem(cat.name, cat.category_id)
        except Exception as e:
            self.logger.error(f"Error loading main categories: {e}", exc_info=True)

    def _on_main_category_changed(self, index: int):
        if not self.main_category_combo or not self.sub_category_combo:
            return
        self.sub_category_combo.clear()
        self.sub_category_combo.addItem("Select Sub-Category...", None)
        parent_id = self.main_category_combo.itemData(index)
        if parent_id is not None:
            try:
                sub_categories = self.controller.get_charge_code_categories(
                    parent_id=parent_id, level=2
                )
                if sub_categories:
                    for cat in sub_categories:
                        self.sub_category_combo.addItem(cat.name, cat.category_id)
                    self.sub_category_combo.setEnabled(True)
                else:
                    self.sub_category_combo.setEnabled(False)
            except Exception as e:
                self.logger.error(
                    f"Error loading sub-categories for parent_id {parent_id}: {e}",
                    exc_info=True,
                )
                self.sub_category_combo.setEnabled(False)
        else:
            self.sub_category_combo.setEnabled(False)

    def _populate_fields(self):
        if self.is_edit_mode and self.charge_code:
            self.code_input.setText(self.charge_code.code)
            self.code_input.setReadOnly(True)
            self.code_input.setStyleSheet(
                self._get_form_input_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
            )
            self.alt_code_input.setText(self.charge_code.alternate_code or "")
            self.description_input.setPlainText(self.charge_code.description)
            self.standard_charge_input.setValue(
                float(self.charge_code.standard_charge)
                if self.charge_code.standard_charge is not None
                else 0.0
            )
            if self.taxable_checkbox:
                self.taxable_checkbox.setChecked(self.charge_code.taxable or False)
            if self.is_active_checkbox:
                self.is_active_checkbox.setChecked(self.charge_code.is_active)
            if self.charge_code.category_id is not None:
                path = self.controller.get_category_path(self.charge_code.category_id)
                if path:
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(True)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(True)
                    if len(path) > 0 and self.main_category_combo:
                        main_cat_id = path[0]["id"]
                        index = self.main_category_combo.findData(main_cat_id)
                        if index >= 0:
                            self.main_category_combo.setCurrentIndex(index)
                        self._on_main_category_changed(
                            self.main_category_combo.currentIndex()
                        )
                    if len(path) > 1 and self.sub_category_combo:
                        sub_cat_id = path[1]["id"]
                        QTimer.singleShot(
                            0,
                            lambda: self._select_combo_item(
                                self.sub_category_combo, sub_cat_id, False
                            ),
                        )
                    if self.main_category_combo:
                        self.main_category_combo.blockSignals(False)
                    if self.sub_category_combo:
                        self.sub_category_combo.blockSignals(False)
            else:
                if self.sub_category_combo:
                    self.sub_category_combo.setEnabled(False)

    def _select_combo_item(
        self, combo: QComboBox, item_id_to_select: int, trigger_next_load: bool
    ):
        if not combo:
            return
        index = combo.findData(item_id_to_select)
        if index >= 0:
            combo.setCurrentIndex(index)

    def get_data(self) -> Optional[Dict[str, Any]]:
        code = self.code_input.text().strip().upper()
        description = self.description_input.toPlainText().strip()
        standard_charge_value = self.standard_charge_input.value()
        errors = []
        if not code:
            errors.append("Code is required.")
        if not description:
            errors.append("Description is required.")
        charge_decimal: Optional[Decimal] = None
        try:
            charge_decimal = Decimal(str(standard_charge_value))
            if charge_decimal < Decimal("0.00"):
                errors.append("Standard Charge cannot be negative.")
        except InvalidOperation:
            errors.append("Standard Charge must be a valid number (e.g., 25.00).")
        selected_category_id: Optional[int] = None
        if (
            self.sub_category_combo
            and self.sub_category_combo.currentIndex() > 0
            and self.sub_category_combo.isEnabled()
        ):
            selected_category_id = self.sub_category_combo.currentData()
        elif self.main_category_combo and self.main_category_combo.currentIndex() > 0:
            selected_category_id = self.main_category_combo.currentData()
        if selected_category_id is None:
            errors.append(
                "A category selection (Main Category, or Sub-Category if applicable) is required."
            )
        if errors:
            QMessageBox.warning(self, "Input Error", "\n".join(errors))
            return None
        return {
            "code": code,
            "alternate_code": self.alt_code_input.text().strip().upper() or None,
            "description": description,
            "category_id": selected_category_id,
            "standard_charge": charge_decimal,
        }

    def validate_and_accept(self):
        data = self.get_data()
        if data is None:
            return

        charge_code_id_to_ignore = (
            self.charge_code.id if self.is_edit_mode and self.charge_code else None
        )

        is_valid, errors = self.controller.validate_charge_code_data(
            data,
            is_new=(not self.is_edit_mode),
            charge_code_id_to_ignore=charge_code_id_to_ignore,
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.charge_code:
                success, message = self.controller.update_charge_code(
                    self.charge_code.id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_charge_code(
                    data, self.current_user_id
                )

            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(
                f"Error during charge code save/update: {e}", exc_info=True
            )
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views\admin\dialogs\add_edit_location_dialog.py ===============

# views/admin/dialogs/add_edit_location_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Location Dialog
Version: 1.1.6
Purpose: Dialog for creating and editing practice locations with detailed address fields,
         phone, email, contact person, and auto-populating country code.
Last Updated: June 5, 2025
Author: Gemini

Changelog:
- v1.1.6 (2025-06-05):
    - In `validate_and_accept`, corrected the tuple unpacking for the `update_location`
      call to expect two return values (success, message) instead of three,
      resolving a ValueError.
- v1.1.5 (2025-06-02):
    - Added QLineEdit fields for Phone, Email, and Contact Person.
    - Updated QGridLayout in _setup_ui to include new fields.
    - Updated _populate_fields to load data for new fields.
    - Updated get_data to collect data from new fields.
    - Implemented _on_state_changed slot to auto-populate Country Code.
    - Modified _load_states_into_combobox to store country_code with state_code.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.location_controller import LocationController
from models import Location as LocationModel
from models import StateProvince as StateProvinceModel

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)


class AddEditLocationDialog(QDialog):
    def __init__(
        self,
        parent_view,
        controller: LocationController,
        current_user_id: str,
        location: Optional[LocationModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.controller = controller
        self.current_user_id = current_user_id
        self.location = location
        self.is_edit_mode = location is not None

        self.location_name_input: Optional[QLineEdit] = None
        self.contact_person_input: Optional[QLineEdit] = None
        self.address_line1_input: Optional[QLineEdit] = None
        self.address_line2_input: Optional[QLineEdit] = None
        self.city_input: Optional[QLineEdit] = None
        self.state_combo: Optional[QComboBox] = None
        self.zip_code_input: Optional[QLineEdit] = None
        self.country_code_input: Optional[QLineEdit] = None
        self.phone_input: Optional[QLineEdit] = None
        self.email_input: Optional[QLineEdit] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Location")
        self.setMinimumWidth(650)

        self._setup_palette()
        self._setup_ui()
        self._load_states_into_combobox()
        if self.is_edit_mode and self.location:
            self._populate_fields()

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox {{
                background-color: {base_bg};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; 
                border-radius: 4px;
                padding: 6px 10px; 
                font-size: 13px; 
                min-height: 20px; 
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled {{ 
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QComboBox::drop-down {{ 
                border: none;
                background-color: transparent;
            }}
            QComboBox::down-arrow {{ 
                color: {DARK_TEXT_SECONDARY}; 
            }}
            QComboBox QAbstractItemView {{ 
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)

        self.location_name_input = QLineEdit()
        self.location_name_input.setPlaceholderText("e.g., Main Barn, Paddock A")

        self.contact_person_input = QLineEdit()
        self.contact_person_input.setPlaceholderText("Name of contact person")

        self.address_line1_input = QLineEdit()
        self.address_line1_input.setPlaceholderText("Street Address")

        self.address_line2_input = QLineEdit()
        self.address_line2_input.setPlaceholderText("Apartment, Suite, etc. (Optional)")

        self.city_input = QLineEdit()
        self.city_input.setPlaceholderText("City/Town")

        self.state_combo = QComboBox()
        self.state_combo.setPlaceholderText("Select State/Province")
        self.state_combo.currentIndexChanged.connect(self._on_state_changed)

        self.zip_code_input = QLineEdit()
        self.zip_code_input.setPlaceholderText("Zip/Postal Code")

        self.country_code_input = QLineEdit()
        self.country_code_input.setPlaceholderText("e.g., USA, CAN")
        self.country_code_input.setMaxLength(10)

        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText("Primary phone number")

        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Contact email address")

        self.is_active_checkbox = QCheckBox("Location is Active")
        self.is_active_checkbox.setChecked(True)
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        grid_layout.addWidget(
            self._create_label("Location Name*:"), 0, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.location_name_input, 0, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Contact Person:"), 1, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.contact_person_input, 1, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Address Line 1:"), 2, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line1_input, 2, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("Address Line 2:"), 3, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line2_input, 3, 1, 1, 3)
        grid_layout.addWidget(
            self._create_label("City:"), 4, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.city_input, 4, 1)
        grid_layout.addWidget(
            self._create_label("State/Province:"), 4, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.state_combo, 4, 3)
        grid_layout.addWidget(
            self._create_label("Zip/Postal Code:"), 5, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.zip_code_input, 5, 1)
        grid_layout.addWidget(
            self._create_label("Country Code:"), 5, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.country_code_input, 5, 3)
        grid_layout.addWidget(
            self._create_label("Phone:"), 6, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.phone_input, 6, 1)
        grid_layout.addWidget(
            self._create_label("Email:"), 6, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.email_input, 6, 3)
        grid_layout.addWidget(
            self.is_active_checkbox, 7, 1, 1, 1, Qt.AlignmentFlag.AlignLeft
        )

        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 110)
        grid_layout.setColumnMinimumWidth(2, 110)

        form_style = self._get_form_input_style()
        for field in [
            self.location_name_input,
            self.contact_person_input,
            self.address_line1_input,
            self.address_line2_input,
            self.city_input,
            self.state_combo,
            self.zip_code_input,
            self.country_code_input,
            self.phone_input,
            self.email_input,
        ]:
            if field:
                field.setStyleSheet(form_style)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_button_specific_style = (
                    f"background-color: {DARK_SUCCESS_ACTION}; color: white;"
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ {ok_button_specific_style} }}"
                )

        overall_layout.addWidget(self.button_box)

    def _load_states_into_combobox(self):
        if not self.state_combo:
            return
        self.state_combo.addItem("", None)
        session = None
        try:
            from config.database_config import db_manager

            session = db_manager.get_session()
            states: List[StateProvinceModel] = (
                session.query(StateProvinceModel)
                .filter(StateProvinceModel.is_active == True)
                .order_by(
                    StateProvinceModel.country_code, StateProvinceModel.state_name
                )
                .all()
            )
            for state in states:
                display_name = f"{state.state_name} ({state.state_code})"
                self.state_combo.addItem(
                    display_name,
                    {
                        "state_code": state.state_code,
                        "country_code": state.country_code,
                    },
                )
            self.logger.info(f"Loaded {len(states)} states into combobox.")
        except Exception as e:
            self.logger.error(f"Error loading states into combobox: {e}", exc_info=True)
            QMessageBox.warning(
                self, "Data Load Error", "Could not load states for selection."
            )
        finally:
            if session:
                session.close()

    def _on_state_changed(self, index: int):
        if not self.state_combo or not self.country_code_input:
            return
        selected_data = self.state_combo.itemData(index)
        if selected_data and isinstance(selected_data, dict):
            country_code = selected_data.get("country_code", "")
            self.country_code_input.setText(country_code)
        else:
            self.country_code_input.clear()

    def _populate_fields(self):
        if self.location:
            self.location_name_input.setText(self.location.location_name or "")
            self.contact_person_input.setText(self.location.contact_person or "")
            self.address_line1_input.setText(self.location.address_line1 or "")
            self.address_line2_input.setText(self.location.address_line2 or "")
            self.city_input.setText(self.location.city or "")
            if self.location.state_code:
                for i in range(self.state_combo.count()):
                    item_data = self.state_combo.itemData(i)
                    if (
                        item_data
                        and isinstance(item_data, dict)
                        and item_data.get("state_code") == self.location.state_code
                    ):
                        self.state_combo.setCurrentIndex(i)
                        break
                else:
                    self.logger.warning(
                        f"State code '{self.location.state_code}' not found in combobox. Location: {self.location.location_name}"
                    )
            else:
                self.state_combo.setCurrentIndex(0)
            self.zip_code_input.setText(self.location.zip_code or "")
            self.country_code_input.setText(self.location.country_code or "")
            self.phone_input.setText(self.location.phone or "")
            self.email_input.setText(self.location.email or "")
            self.is_active_checkbox.setChecked(self.location.is_active)

    def get_data(self) -> Dict[str, Any]:
        selected_state_code = None
        if self.state_combo.currentIndex() > 0:
            item_data = self.state_combo.currentData()
            if item_data and isinstance(item_data, dict):
                selected_state_code = item_data.get("state_code")

        return {
            "location_name": self.location_name_input.text(),
            "contact_person": self.contact_person_input.text(),
            "address_line1": self.address_line1_input.text(),
            "address_line2": self.address_line2_input.text(),
            "city": self.city_input.text(),
            "state_code": selected_state_code,
            "zip_code": self.zip_code_input.text(),
            "country_code": self.country_code_input.text(),
            "phone": self.phone_input.text(),
            "email": self.email_input.text(),
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        data = self.get_data()
        is_valid, errors = self.controller.validate_location_data(
            data,
            is_new=(not self.is_edit_mode),
            location_id_to_check_for_unique=(
                self.location.location_id
                if self.is_edit_mode and self.location
                else None
            ),
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.location:
                # MODIFIED: Correctly unpack the two return values from update_location
                success, message = self.controller.update_location(
                    self.location.location_id, data, self.current_user_id
                )
            else:
                # create_location returns three values
                success, message, _ = self.controller.create_location(
                    data, self.current_user_id
                )

            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    self.logger.warning(
                        "parent_view does not have show_info method. Using local QMessageBox."
                    )
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during location save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views\admin\dialogs\add_edit_owner_dialog.py ===============

# views/admin/dialogs/add_edit_owner_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Owner Dialog
Version: 1.1.0
Purpose: Dialog for creating and editing Owner master file records,
         including contact, address, and financial information.
         Styled to match HorseUnifiedManagement forms, using QGridLayout.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-09):
    - Fixed validation logic to correctly ignore the current record's own
      account number when checking for duplicates in edit mode.
    - Updated the main action button text to display "Save Owner" in edit mode
      and "Create Owner" in add mode for better clarity.
- v1.0.0 (2025-06-02):
    - Initial implementation.
    - Includes fields for account info, name, address (with state dropdown
      and auto-populated, read-only country), contact details, and financial info
      (Balance (display-only), Credit Limit, Billing Terms dropdown).
    - Uses QGridLayout for layout.
    - Styled using _get_form_input_style (adapted from HorseUnifiedManagement)
      and _create_label helper.
    - Populates states from OwnerController and billing terms from a predefined list.
    - Implements _on_state_changed to auto-populate country code.
    - Implements _populate_fields, get_data, and validate_and_accept methods.
"""

import logging
from typing import Optional, Dict, Any, List
from decimal import Decimal, InvalidOperation

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QComboBox,
    QDoubleSpinBox,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController
from models import Owner as OwnerModel

from config.app_config import AppConfig
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DEFAULT_FONT_FAMILY,
)

PREDEFINED_BILLING_TERMS = [
    "Net 30 Days",
    "Net 60 Days",
    "Net 90 Days",
    "Due on Receipt",
    "COD",
    "Prepay",
    "Monthly Statement",
]


class AddEditOwnerDialog(QDialog):
    def __init__(
        self,
        parent_view,
        owner_controller: OwnerController,
        current_user_id: str,
        owner_object: Optional[OwnerModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.owner_controller = owner_controller
        self.current_user_id = current_user_id
        self.owner = owner_object
        self.is_edit_mode = owner_object is not None

        self.account_number_input: Optional[QLineEdit] = None
        self.farm_name_input: Optional[QLineEdit] = None
        self.first_name_input: Optional[QLineEdit] = None
        self.last_name_input: Optional[QLineEdit] = None
        self.address_line1_input: Optional[QLineEdit] = None
        self.address_line2_input: Optional[QLineEdit] = None
        self.city_input: Optional[QLineEdit] = None
        self.state_combo: Optional[QComboBox] = None
        self.zip_code_input: Optional[QLineEdit] = None
        self.country_code_input: Optional[QLineEdit] = None
        self.phone_input: Optional[QLineEdit] = None
        self.mobile_phone_input: Optional[QLineEdit] = None
        self.email_input: Optional[QLineEdit] = None
        self.balance_display_input: Optional[QLineEdit] = None
        self.credit_limit_input: Optional[QDoubleSpinBox] = None
        self.billing_terms_combo: Optional[QComboBox] = None
        self.is_active_checkbox: Optional[QCheckBox] = None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Owner")
        self.setMinimumWidth(700)

        self._setup_palette()
        self._setup_ui()
        self._load_reference_data_into_combos()
        if self.is_edit_mode and self.owner:
            self._populate_fields()

    def _get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND) -> str:
        return f"""
            QLineEdit, QComboBox, QDoubleSpinBox {{
                background-color: {base_bg}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px;
                padding: 6px 10px; font-size: 13px; min-height: 20px; 
            }}
            QLineEdit:focus, QComboBox:focus, QDoubleSpinBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QLineEdit:disabled, QComboBox:disabled, QDoubleSpinBox:disabled {{ 
                background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY};
                border-color: {DARK_HEADER_FOOTER};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
            }}
            QComboBox::drop-down {{ border: none; background-color: transparent; }}
            QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QComboBox QAbstractItemView {{ 
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _create_label(self, text: str) -> QLabel:
        label = QLabel(text)
        label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background-color: transparent; padding-top: 3px; font-size: 13px;"
        )
        font_size = (
            AppConfig.DEFAULT_FONT_SIZE
            if hasattr(AppConfig, "DEFAULT_FONT_SIZE")
            else 10
        )
        label.setFont(QFont(DEFAULT_FONT_FAMILY, font_size))
        return label

    def _setup_ui(self):
        overall_layout = QVBoxLayout(self)
        grid_layout = QGridLayout()
        grid_layout.setContentsMargins(20, 20, 20, 15)
        grid_layout.setSpacing(10)
        grid_layout.setVerticalSpacing(15)

        self.account_number_input = QLineEdit()
        self.account_number_input.setPlaceholderText("e.g., SMIJ01")
        self.farm_name_input = QLineEdit()
        self.farm_name_input.setPlaceholderText("Optional")
        self.first_name_input = QLineEdit()
        self.first_name_input.setPlaceholderText("Contact's First Name")
        self.last_name_input = QLineEdit()
        self.last_name_input.setPlaceholderText("Contact's Last Name")
        self.address_line1_input = QLineEdit()
        self.address_line1_input.setPlaceholderText("Street address, P.O. box")
        self.address_line2_input = QLineEdit()
        self.address_line2_input.setPlaceholderText("Apt, suite, etc. (Optional)")
        self.city_input = QLineEdit()
        self.city_input.setPlaceholderText("City/Town")
        self.state_combo = QComboBox()
        self.state_combo.setPlaceholderText("Select State/Province")
        self.zip_code_input = QLineEdit()
        self.zip_code_input.setPlaceholderText("Zip/Postal Code")
        self.country_code_input = QLineEdit()
        self.country_code_input.setPlaceholderText("Auto (e.g. USA, CAN)")
        self.country_code_input.setReadOnly(True)
        self.phone_input = QLineEdit()
        self.phone_input.setPlaceholderText("(xxx) xxx-xxxx")
        self.mobile_phone_input = QLineEdit()
        self.mobile_phone_input.setPlaceholderText("Optional")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("example@domain.com")
        self.balance_display_input = QLineEdit("0.00")
        self.balance_display_input.setReadOnly(True)
        self.balance_display_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.credit_limit_input = QDoubleSpinBox()
        self.credit_limit_input.setDecimals(2)
        self.credit_limit_input.setRange(0.00, 9999999.99)
        self.credit_limit_input.setPrefix("$ ")
        self.credit_limit_input.setAlignment(Qt.AlignmentFlag.AlignRight)
        self.credit_limit_input.setValue(0.00)
        self.billing_terms_combo = QComboBox()
        self.is_active_checkbox = QCheckBox("Owner is Active")
        self.is_active_checkbox.setChecked(True)
        self.is_active_checkbox.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 13px;"
        )

        row = 0
        grid_layout.addWidget(
            self._create_label("Account #:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.account_number_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Farm Name:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.farm_name_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("First Name:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.first_name_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Last Name:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.last_name_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Address Line 1*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line1_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Address Line 2:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.address_line2_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("City*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.city_input, row, 1)
        grid_layout.addWidget(
            self._create_label("State/Province*:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.state_combo, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Zip/Postal Code*:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.zip_code_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Country Code:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.country_code_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Phone:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.phone_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Mobile Phone:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.mobile_phone_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Email:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.email_input, row, 1, 1, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Balance:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.balance_display_input, row, 1)
        grid_layout.addWidget(
            self._create_label("Credit Limit:"), row, 2, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.credit_limit_input, row, 3)
        row += 1
        grid_layout.addWidget(
            self._create_label("Billing Terms:"), row, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.billing_terms_combo, row, 1)
        grid_layout.addWidget(
            self.is_active_checkbox, row, 3, Qt.AlignmentFlag.AlignLeft
        )

        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)
        grid_layout.setColumnMinimumWidth(0, 120)
        grid_layout.setColumnMinimumWidth(2, 120)

        form_style = self._get_form_input_style()
        all_fields = [
            self.account_number_input,
            self.farm_name_input,
            self.first_name_input,
            self.last_name_input,
            self.address_line1_input,
            self.address_line2_input,
            self.city_input,
            self.state_combo,
            self.zip_code_input,
            self.country_code_input,
            self.phone_input,
            self.mobile_phone_input,
            self.email_input,
            self.balance_display_input,
            self.credit_limit_input,
            self.billing_terms_combo,
        ]
        for field in all_fields:
            if field:
                field.setStyleSheet(form_style)

        read_only_style_addon = f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        if self.balance_display_input:
            self.balance_display_input.setStyleSheet(form_style + read_only_style_addon)
        if self.country_code_input:
            self.country_code_input.setStyleSheet(form_style + read_only_style_addon)

        overall_layout.addLayout(grid_layout)
        overall_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )

        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Save Owner" if self.is_edit_mode else "Create Owner")

        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_button_specific_style = (
                    f"background-color: {DARK_SUCCESS_ACTION}; color: white;"
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ {ok_button_specific_style} }}"
                )
        overall_layout.addWidget(self.button_box)

        self.state_combo.currentIndexChanged.connect(self._on_state_changed)

    def _load_reference_data_into_combos(self):
        if not self.state_combo:
            self.logger.error("State combo not initialized.")
            return
        self.state_combo.addItem("", None)
        try:
            ref_data = self.owner_controller.get_owner_form_reference_data()
            states = ref_data.get("states", [])
            for state_data in states:
                display_name = f"{state_data['name']} ({state_data['id']})"
                country_code = state_data.get("country_code", "USA")
                if country_code.upper() != "USA":
                    display_name += f" - {country_code}"
                self.state_combo.addItem(
                    display_name,
                    {"state_code": state_data["id"], "country_code": country_code},
                )
            self.logger.info(f"Loaded {len(states)} states into combobox.")
        except Exception as e:
            self.logger.error(
                f"Error loading states from controller: {e}", exc_info=True
            )
            QMessageBox.warning(
                self, "Data Load Error", "Could not load states for selection."
            )

        if not self.billing_terms_combo:
            self.logger.error("Billing terms combo not initialized.")
            return
        self.billing_terms_combo.addItem("", "")
        self.billing_terms_combo.addItems(PREDEFINED_BILLING_TERMS)
        self.billing_terms_combo.setCurrentIndex(0)
        self.logger.info(f"Loaded {len(PREDEFINED_BILLING_TERMS)} billing terms.")

    def _on_state_changed(self, index: int):
        if not self.state_combo or not self.country_code_input:
            return
        selected_data = self.state_combo.itemData(index)
        if selected_data and isinstance(selected_data, dict):
            country_code = selected_data.get("country_code", "")
            self.country_code_input.setText(country_code)
        else:
            self.country_code_input.clear()

    def _populate_fields(self):
        if self.owner:
            self.account_number_input.setText(self.owner.account_number or "")
            if self.is_edit_mode:
                self.account_number_input.setReadOnly(True)
                self.account_number_input.setStyleSheet(
                    self._get_form_input_style()
                    + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
                )

            self.farm_name_input.setText(self.owner.farm_name or "")
            self.first_name_input.setText(self.owner.first_name or "")
            self.last_name_input.setText(self.owner.last_name or "")
            self.address_line1_input.setText(self.owner.address_line1 or "")
            self.address_line2_input.setText(self.owner.address_line2 or "")
            self.city_input.setText(self.owner.city or "")

            current_state_code = self.owner.state_code
            if current_state_code:
                for i in range(self.state_combo.count()):
                    item_data = self.state_combo.itemData(i)
                    if (
                        item_data
                        and isinstance(item_data, dict)
                        and item_data.get("state_code") == current_state_code
                    ):
                        self.state_combo.setCurrentIndex(i)
                        break
            else:
                self.state_combo.setCurrentIndex(0)
                self.country_code_input.clear()

            self.zip_code_input.setText(self.owner.zip_code or "")

            self.phone_input.setText(self.owner.phone or "")
            self.mobile_phone_input.setText(self.owner.mobile_phone or "")
            self.email_input.setText(self.owner.email or "")

            self.balance_display_input.setText(
                f"{self.owner.balance:.2f}"
                if self.owner.balance is not None
                else "0.00"
            )
            self.credit_limit_input.setValue(
                float(self.owner.credit_limit)
                if self.owner.credit_limit is not None
                else 0.00
            )

            if self.owner.billing_terms:
                index = self.billing_terms_combo.findText(
                    self.owner.billing_terms, Qt.MatchFlag.MatchExactly
                )
                if index >= 0:
                    self.billing_terms_combo.setCurrentIndex(index)
                else:
                    self.billing_terms_combo.addItem(self.owner.billing_terms)
                    self.billing_terms_combo.setCurrentText(self.owner.billing_terms)
            else:
                if self.billing_terms_combo.count() > 0:
                    self.billing_terms_combo.setCurrentIndex(0)

            self.is_active_checkbox.setChecked(self.owner.is_active)

    def get_data(self) -> Optional[Dict[str, Any]]:
        selected_state_item_data = self.state_combo.currentData()
        selected_state_code = None
        if selected_state_item_data and isinstance(selected_state_item_data, dict):
            selected_state_code = selected_state_item_data.get("state_code")

        credit_limit_val = self.credit_limit_input.value()
        credit_limit_decimal: Optional[Decimal] = None
        try:
            credit_limit_decimal = Decimal(str(credit_limit_val))
        except InvalidOperation:
            self.logger.warning(
                f"Invalid decimal value for credit limit: {credit_limit_val}, treating as None."
            )

        data = {
            "account_number": self.account_number_input.text().strip() or None,
            "farm_name": self.farm_name_input.text().strip() or None,
            "first_name": self.first_name_input.text().strip() or None,
            "last_name": self.last_name_input.text().strip() or None,
            "address_line1": self.address_line1_input.text().strip() or None,
            "address_line2": self.address_line2_input.text().strip() or None,
            "city": self.city_input.text().strip() or None,
            "state_code": selected_state_code,
            "zip_code": self.zip_code_input.text().strip() or None,
            "phone": self.phone_input.text().strip() or None,
            "mobile_phone": self.mobile_phone_input.text().strip() or None,
            "email": self.email_input.text().strip() or None,
            "credit_limit": credit_limit_decimal,
            "billing_terms": (
                self.billing_terms_combo.currentText()
                if self.billing_terms_combo.currentIndex() > 0
                else None
            ),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        return data

    def validate_and_accept(self):
        owner_data = self.get_data()
        if owner_data is None:
            return

        owner_id_to_ignore = (
            self.owner.owner_id if self.is_edit_mode and self.owner else None
        )

        is_valid, errors = self.owner_controller.validate_owner_data(
            owner_data,
            is_new=(not self.is_edit_mode),
            owner_id_to_ignore=owner_id_to_ignore,
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode and self.owner:
                success, message = self.owner_controller.update_master_owner(
                    self.owner.owner_id, owner_data, self.current_user_id
                )
            else:
                success, message, _ = self.owner_controller.create_master_owner(
                    owner_data, self.current_user_id
                )
            if success:
                if hasattr(self.parent_view, "show_info") and callable(
                    getattr(self.parent_view, "show_info")
                ):
                    self.parent_view.show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error during owner save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views\admin\dialogs\add_edit_user_dialog.py ===============

# views/admin/dialogs/add_edit_user_dialog.py
"""
EDSI Veterinary Management System - Add/Edit User Dialog
Version: 1.0.5
Purpose: Dialog for creating new users and editing existing user details.
         - Added current_user_id parameter to __init__ for auditing.
Last Updated: June 3, 2025
Author: Gemini (Modified by User's AI Assistant)

Changelog:
- v1.0.5 (2025-06-03):
    - Added `current_user_id: Optional[str] = None` to the `__init__`
      method signature to correctly accept the auditing user ID passed
      from UserManagementScreen. Stored as `self.audit_user_id`.
- v1.0.4 (2025-05-29):
    - Corrected attribute access in _populate_fields method:
        - Changed self.current_user_object.username to self.current_user_object.user_id.
        - Changed self.current_user_object.full_name to self.current_user_object.user_name.
- v1.0.3 (2025-05-29):
    - Modified USER_ROLES list to ["ADMIN", "VETERINARIAN"].
- v1.0.2 (2025-05-29):
    - Refactored _get_dialog_button_style() to use a triple-quoted f-string.
- v1.0.1 (2025-05-27):
    - Modified get_user_data() to return 'user_id' and 'user_name'.
    - Changed 'vet' to 'VETERINARIAN' in USER_ROLES.
- v1.0.0 (2025-05-20):
    - Initial implementation.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QComboBox,
    QCheckBox,
    QDialogButtonBox,
    QLabel,
    QMessageBox,
)
from PySide6.QtGui import QPalette, QColor, QFont  # Added QFont
from PySide6.QtCore import Qt

from controllers.user_controller import UserController
from models.user_models import User
from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_BORDER,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_SUCCESS_ACTION,
    DARK_HEADER_FOOTER,
    DEFAULT_FONT_FAMILY,  # Added
)


class AddEditUserDialog(QDialog):
    """Dialog for adding or editing user information."""

    USER_ROLES = [
        "ADMIN",
        "VETERINARIAN",
        "MANAGER",
        "TECHNICIAN",
        "RECEPTIONIST",
    ]  # Restored full list for now

    def __init__(
        self,
        parent_view,
        user_controller: UserController,
        current_user_object: Optional[User] = None,
        current_user_id: Optional[
            str
        ] = None,  # MODIFIED: Added current_user_id for auditing
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.user_controller = user_controller
        self.current_user_object = current_user_object
        self.audit_user_id = current_user_id  # MODIFIED: Store the audit user ID

        self.is_edit_mode = self.current_user_object is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} User")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode and self.current_user_object:
            self._populate_fields()

        self.logger.info(
            f"AddEditUserDialog initialized. Edit mode: {self.is_edit_mode}, Audit User: {self.audit_user_id}"
        )

    def _setup_palette(self):
        # ... (method remains unchanged from v1.0.4) ...
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(
            QPalette.ColorRole.AlternateBase, QColor(DARK_WIDGET_BACKGROUND)
        )  # Was DARK_ITEM_HOVER, check consistency
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(
            QPalette.ColorRole.Highlight, QColor(DARK_PRIMARY_ACTION)
        )  # Or DARK_HIGHLIGHT_BG
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_TEXT_PRIMARY)
        )  # Or DARK_HIGHLIGHT_TEXT
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _get_input_field_style(self) -> str:
        # ... (method remains unchanged from v1.0.4) ...
        return f"""
            QLineEdit, QComboBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                selection-background-color: {QColor(DARK_PRIMARY_ACTION).darker(130).name()}; /* Adjusted for better visibility */
            }}
            QCheckBox {{
                color: {DARK_TEXT_PRIMARY};
                background-color: transparent;
            }}
            QCheckBox::indicator {{
                width: 13px;
                height: 13px;
            }}
        """

    def _get_dialog_button_style(self) -> str:
        # ... (method remains unchanged from v1.0.4) ...
        return f"""
            QPushButton {{
                background-color: {DARK_BUTTON_BG};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px;
                font-size: 12px; font-weight: 500; min-height: 28px;
            }}
            QPushButton:hover {{
                background-color: {DARK_BUTTON_HOVER};
            }}
            QPushButton:disabled {{
                background-color: {DARK_HEADER_FOOTER};
                color: {DARK_TEXT_TERTIARY};
            }}
        """

    def _setup_ui(self):
        # ... (method remains unchanged from v1.0.4) ...
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        form_layout = QFormLayout()
        form_layout.setSpacing(10)
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setFieldGrowthPolicy(
            QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow
        )

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter unique username (Login ID)")
        self.full_name_input = QLineEdit()
        self.full_name_input.setPlaceholderText("Enter user's full name (Display Name)")
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("Enter user's email address")
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setPlaceholderText(
            "Enter password (leave blank to keep current)"
        )
        self.confirm_password_input = QLineEdit()
        self.confirm_password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.confirm_password_input.setPlaceholderText("Confirm new password")
        self.role_combo = QComboBox()
        self.role_combo.addItems(self.USER_ROLES)
        self.is_active_checkbox = QCheckBox("User is Active")
        self.is_active_checkbox.setChecked(True)

        input_style = self._get_input_field_style()
        for field in [
            self.username_input,
            self.full_name_input,
            self.email_input,
            self.password_input,
            self.confirm_password_input,
            self.role_combo,
            self.is_active_checkbox,
        ]:
            if field:
                field.setStyleSheet(input_style)

        form_layout.addRow(QLabel("Login ID*:"), self.username_input)
        form_layout.addRow(QLabel("Full Name*:"), self.full_name_input)
        form_layout.addRow(QLabel("Email:"), self.email_input)
        form_layout.addRow(
            QLabel("Password:" if self.is_edit_mode else "Password*:"),
            self.password_input,
        )
        form_layout.addRow(QLabel("Confirm Password:"), self.confirm_password_input)
        form_layout.addRow(QLabel("Role*:"), self.role_combo)
        form_layout.addRow(QLabel("Status:"), self.is_active_checkbox)

        for i in range(form_layout.rowCount()):
            label_widget = form_layout.labelForField(
                form_layout.itemAt(i, QFormLayout.ItemRole.FieldRole).widget()
            )
            if label_widget:
                label_widget.setStyleSheet(
                    f"color: {DARK_TEXT_SECONDARY}; background: transparent; padding-top: 3px; font-family: {DEFAULT_FONT_FAMILY};"
                )
                # label_widget.setFont(QFont(DEFAULT_FONT_FAMILY)) # Ensure font consistency

        layout.addLayout(form_layout)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Save User" if self.is_edit_mode else "Add User")
        dialog_button_style = self._get_dialog_button_style()
        for button in self.button_box.buttons():
            button.setStyleSheet(dialog_button_style)
        ok_button.setStyleSheet(
            dialog_button_style
            + f"QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}"
        )
        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        # ... (method remains unchanged from v1.0.4) ...
        if self.current_user_object:
            self.username_input.setText(self.current_user_object.user_id)
            self.username_input.setReadOnly(True)
            self.username_input.setStyleSheet(
                self._get_input_field_style()
                + f"QLineEdit {{ background-color: {DARK_HEADER_FOOTER}; }}"
            )
            self.full_name_input.setText(self.current_user_object.user_name or "")
            self.email_input.setText(self.current_user_object.email or "")
            user_role_name_to_select = ""
            if self.current_user_object.roles:
                for role_obj in self.current_user_object.roles:
                    if role_obj.name in self.USER_ROLES:
                        user_role_name_to_select = role_obj.name
                        break
                if not user_role_name_to_select:
                    self.logger.warning(
                        f"User {self.current_user_object.user_id} has roles, but none match current dialog options: {[r.name for r in self.current_user_object.roles]}. Defaulting selection."
                    )
            role_index = -1
            if user_role_name_to_select:
                role_index = self.role_combo.findText(
                    user_role_name_to_select, Qt.MatchFlag.MatchExactly
                )
            if role_index >= 0:
                self.role_combo.setCurrentIndex(role_index)
            else:
                self.logger.warning(
                    f"Role '{user_role_name_to_select}' for user '{self.current_user_object.user_id}' not found in USER_ROLES dropdown. Defaulting."
                )
                if self.role_combo.count() > 0:
                    self.role_combo.setCurrentIndex(0)
                else:
                    self.logger.error(
                        "USER_ROLES is empty, cannot set default role index."
                    )
            self.is_active_checkbox.setChecked(self.current_user_object.is_active)

    def _validate_input(self) -> bool:
        # ... (method remains unchanged from v1.0.4) ...
        login_id = self.username_input.text().strip()
        user_name_val = self.full_name_input.text().strip()
        password = self.password_input.text()
        confirm_password = self.confirm_password_input.text()
        if not login_id:
            QMessageBox.warning(self, "Validation Error", "Login ID cannot be empty.")
            self.username_input.setFocus()
            return False
        if not user_name_val:
            QMessageBox.warning(self, "Validation Error", "Full Name cannot be empty.")
            self.full_name_input.setFocus()
            return False
        if not self.is_edit_mode and not password:
            QMessageBox.warning(
                self, "Validation Error", "Password cannot be empty for new users."
            )
            self.password_input.setFocus()
            return False
        if password and password != confirm_password:
            QMessageBox.warning(self, "Validation Error", "Passwords do not match.")
            self.confirm_password_input.setFocus()
            return False
        email = self.email_input.text().strip()
        if email and ("@" not in email or "." not in email.split("@")[-1]):
            QMessageBox.warning(
                self, "Validation Error", "Please enter a valid email address."
            )
            self.email_input.setFocus()
            return False
        if self.role_combo.currentIndex() == -1 and self.USER_ROLES:
            QMessageBox.warning(self, "Validation Error", "A role must be selected.")
            self.role_combo.setFocus()
            return False
        return True

    def get_user_data(self) -> Optional[Dict]:
        # ... (method remains unchanged from v1.0.4) ...
        if not self._validate_input():
            return None
        data = {
            "user_id": self.username_input.text().strip(),
            "user_name": self.full_name_input.text().strip(),
            "email": self.email_input.text().strip() or None,
            "role": self.role_combo.currentText(),
            "is_active": self.is_active_checkbox.isChecked(),
        }
        password = self.password_input.text()
        if password:
            data["password"] = password
        return data

    def _on_accept(self):
        user_data = self.get_user_data()
        if user_data is None:
            return

        try:
            # Use self.audit_user_id for who is performing the action
            performing_user_id = self.audit_user_id

            if self.is_edit_mode and self.current_user_object:
                self.logger.info(
                    f"Attempting to update user ID: {self.current_user_object.user_id} by {performing_user_id}"
                )
                success, message = self.user_controller.update_user(
                    self.current_user_object.user_id, user_data, performing_user_id
                )
            else:
                self.logger.info(
                    f"Attempting to create new user: {user_data['user_id']} by {performing_user_id}"
                )
                success, message, _ = self.user_controller.create_user(
                    user_data, performing_user_id
                )

            if success:
                self.logger.info(f"User operation successful: {message}")
                self.accept()
            else:
                self.logger.warning(f"User operation failed: {message}")
                QMessageBox.critical(self, "Operation Failed", message)
        except Exception as e:
            self.logger.error(f"Error during user save/update: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An unexpected error occurred: {e}")


=============== FILE: views\admin\dialogs\add_edit_veterinarian_dialog.py ===============

# views/admin/dialogs/add_edit_veterinarian_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Veterinarian Dialog
Version: 1.1.0
Purpose: UI dialog for creating and editing veterinarian records.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.1.0 (2025-06-09):
    - Replaced placeholder with a full UI implementation for data entry.
    - Added validation and interaction with VeterinarianController.
- v1.0.0 (2025-06-09):
    - Initial placeholder file created.
"""
import logging
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import Qt

from controllers import VeterinarianController
from models import Veterinarian
from config.app_config import AppConfig


class AddEditVeterinarianDialog(QDialog):
    """A dialog for creating or editing veterinarian records."""

    def __init__(
        self,
        parent_view,
        controller: VeterinarianController,
        current_user_id: str,
        veterinarian: Optional[Veterinarian] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.controller = controller
        self.current_user_id = current_user_id
        self.veterinarian = veterinarian
        self.is_edit_mode = veterinarian is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Veterinarian")
        self.setMinimumWidth(500)

        self._setup_palette()
        self._setup_ui()

        if self.is_edit_mode:
            self._populate_fields()

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(
            QPalette.ColorRole.Window, QColor(AppConfig.DARK_WIDGET_BACKGROUND)
        )
        palette.setColor(
            QPalette.ColorRole.WindowText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        palette.setColor(
            QPalette.ColorRole.Base, QColor(AppConfig.DARK_INPUT_FIELD_BACKGROUND)
        )
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _get_input_field_style(self) -> str:
        return f"""
            QLineEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
        """

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setSpacing(10)

        input_style = self._get_input_field_style()

        self.first_name_input = QLineEdit()
        self.last_name_input = QLineEdit()
        self.license_number_input = QLineEdit()
        self.specialty_input = QLineEdit()
        self.phone_input = QLineEdit()
        self.email_input = QLineEdit()
        self.is_active_checkbox = QCheckBox("Veterinarian is Active")
        self.is_active_checkbox.setChecked(True)

        for field in [
            self.first_name_input,
            self.last_name_input,
            self.license_number_input,
            self.specialty_input,
            self.phone_input,
            self.email_input,
        ]:
            field.setStyleSheet(input_style)

        form_layout.addRow("First Name*:", self.first_name_input)
        form_layout.addRow("Last Name*:", self.last_name_input)
        form_layout.addRow("License #*:", self.license_number_input)
        form_layout.addRow("Specialty:", self.specialty_input)
        form_layout.addRow("Phone:", self.phone_input)
        form_layout.addRow("Email:", self.email_input)
        form_layout.addRow("", self.is_active_checkbox)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        main_layout.addLayout(form_layout)
        main_layout.addWidget(self.button_box)

    def _populate_fields(self):
        if self.veterinarian:
            self.first_name_input.setText(self.veterinarian.first_name)
            self.last_name_input.setText(self.veterinarian.last_name)
            self.license_number_input.setText(self.veterinarian.license_number)
            self.specialty_input.setText(self.veterinarian.specialty or "")
            self.phone_input.setText(self.veterinarian.phone or "")
            self.email_input.setText(self.veterinarian.email or "")
            self.is_active_checkbox.setChecked(self.veterinarian.is_active)

    def get_data(self) -> Dict[str, Any]:
        """Collects data from the form fields."""
        return {
            "first_name": self.first_name_input.text().strip(),
            "last_name": self.last_name_input.text().strip(),
            "license_number": self.license_number_input.text().strip(),
            "specialty": self.specialty_input.text().strip() or None,
            "phone": self.phone_input.text().strip() or None,
            "email": self.email_input.text().strip() or None,
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        vet_data = self.get_data()
        vet_id_to_ignore = self.veterinarian.vet_id if self.is_edit_mode else None

        is_valid, errors = self.controller.validate_veterinarian_data(
            vet_data, self.is_edit_mode, vet_id_to_ignore
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Validation Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return

        try:
            if self.is_edit_mode:
                success, message = self.controller.update_veterinarian(
                    self.veterinarian.vet_id, vet_data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_veterinarian(
                    vet_data, self.current_user_id
                )

            if success:
                QMessageBox.information(self, "Success", message)
                self.accept()
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
        except Exception as e:
            self.logger.error(f"Error saving veterinarian: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )


=============== FILE: views\admin\dialogs\company_profile_dialog.py ===============

# views/admin/dialogs/company_profile_dialog.py
"""
EDSI Veterinary Management System - Company Profile Dialog
Version: 1.0.1
Purpose: Dialog for editing the main company profile information.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-06-09):
    - Bug Fix: Added QHBoxLayout to the PySide6.QtWidgets import list to resolve
      a NameError during UI setup.
- v1.0.0 (2025-06-08):
    - Initial creation of the dialog.
"""
import logging
from typing import Optional

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QFormLayout,
    QLineEdit,
    QTextEdit,
    QPushButton,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QFileDialog,
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QPalette, QColor

from controllers.company_profile_controller import CompanyProfileController
from config.app_config import AppConfig


class CompanyProfileDialog(QDialog):
    def __init__(self, parent, current_user_id: str):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.current_user_id = current_user_id
        self.controller = CompanyProfileController()

        self.setWindowTitle("Manage Company Profile")
        self.setMinimumWidth(600)

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()
        self._load_profile()

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.company_name_input = QLineEdit()
        self.address1_input = QLineEdit()
        self.address2_input = QLineEdit()
        self.city_input = QLineEdit()
        self.state_input = QLineEdit()
        self.zip_input = QLineEdit()
        self.phone_input = QLineEdit()
        self.email_input = QLineEdit()
        self.website_input = QLineEdit()
        self.logo_path_input = QLineEdit()
        self.browse_logo_btn = QPushButton("Browse...")

        logo_layout = QHBoxLayout()
        logo_layout.addWidget(self.logo_path_input)
        logo_layout.addWidget(self.browse_logo_btn)

        form_layout.addRow("Company Name*:", self.company_name_input)
        form_layout.addRow("Address 1:", self.address1_input)
        form_layout.addRow("Address 2:", self.address2_input)
        form_layout.addRow("City:", self.city_input)
        form_layout.addRow("State:", self.state_input)
        form_layout.addRow("Zip Code:", self.zip_input)
        form_layout.addRow("Phone:", self.phone_input)
        form_layout.addRow("Email:", self.email_input)
        form_layout.addRow("Website:", self.website_input)
        form_layout.addRow("Logo Path:", logo_layout)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Save
            | QDialogButtonBox.StandardButton.Cancel
        )

        layout.addLayout(form_layout)
        layout.addWidget(self.button_box)

    def _apply_styles(self):
        field_style = f"""
            QLineEdit, QTextEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QTextEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
        """
        for widget in self.findChildren(QLineEdit):
            widget.setStyleSheet(field_style)

    def _setup_connections(self):
        self.button_box.accepted.connect(self._save_profile)
        self.button_box.rejected.connect(self.reject)
        self.browse_logo_btn.clicked.connect(self._browse_for_logo)

    def _load_profile(self):
        profile = self.controller.get_company_profile()
        if profile:
            self.company_name_input.setText(profile.company_name or "")
            self.address1_input.setText(profile.address_line1 or "")
            self.address2_input.setText(profile.address_line2 or "")
            self.city_input.setText(profile.city or "")
            self.state_input.setText(profile.state or "")
            self.zip_input.setText(profile.zip_code or "")
            self.phone_input.setText(profile.phone or "")
            self.email_input.setText(profile.email or "")
            self.website_input.setText(profile.website or "")
            self.logo_path_input.setText(profile.logo_path or "")

    def _browse_for_logo(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Select Logo Image", "", "Image Files (*.png *.jpg *.jpeg *.bmp)"
        )
        if file_path:
            self.logo_path_input.setText(file_path)

    def _save_profile(self):
        if not self.company_name_input.text().strip():
            QMessageBox.warning(self, "Validation Error", "Company Name is required.")
            return

        data = {
            "company_name": self.company_name_input.text().strip(),
            "address_line1": self.address1_input.text().strip(),
            "address_line2": self.address2_input.text().strip(),
            "city": self.city_input.text().strip(),
            "state": self.state_input.text().strip(),
            "zip_code": self.zip_input.text().strip(),
            "phone": self.phone_input.text().strip(),
            "email": self.email_input.text().strip(),
            "website": self.website_input.text().strip(),
            "logo_path": self.logo_path_input.text().strip(),
        }

        success, message = self.controller.update_company_profile(
            data, self.current_user_id
        )
        if success:
            QMessageBox.information(self, "Success", message)
            self.accept()
        else:
            QMessageBox.critical(self, "Error", message)


=============== FILE: views\auth\login_screen.py ===============

# views/auth/login_screen.py

"""
EDSI Veterinary Management System - Login Screen
Version: 1.1.2
Purpose: Handles user authentication (username and password).
Last Updated: May 12, 2025
Author: Claude Assistant

Changelog:
- v1.1.2 (2025-05-12): Debug password validation and fix styling.
  - Added detailed logging in `validate_credentials` to compare input hash vs stored hash.
  - Removed unsupported 'box-shadow' property from input field focus style.
- v1.1.1 (2025-05-12): Fixed TypeError on layout initialization.
  - Changed layout creation in setup_ui from `QVBoxLayout(parent)`
    to `QVBoxLayout()` followed by `parent.setLayout()`.
- v1.1.0 (2025-05-12): Refactored for Username/Password and PySide6
- v1.0.0 (2025-05-12): Initial implementation (PyQt6, User ID only)
"""

import logging
import hashlib
from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QFrame,
    QSpacerItem,
    QSizePolicy,
    QWidget,
    QMessageBox,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import (
    QFont,
    QPalette,
    QColor,
    QScreen,
)  # Added imports for styling if needed

from views.base_view import BaseView
from config.app_config import AppConfig
from config.database_config import db_manager
from models import User


class LoginScreen(BaseView):
    """User login screen for authentication with username and password."""

    login_successful = Signal(str)
    exit_requested = Signal()

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(self.__class__.__name__)
        # Apply specific palette/styling for this screen if needed,
        # otherwise it inherits from BaseView
        self.apply_login_screen_styling()

    def apply_login_screen_styling(self):
        """Apply styles specific to the Login Screen, potentially overriding BaseView."""
        # Example: Set a specific background if different from BaseView
        # palette = self.palette()
        # palette.setColor(QPalette.ColorRole.Window, QColor("#e9ecef")) # Light grey example
        # self.setPalette(palette)
        # self.setAutoFillBackground(True)
        pass  # No specific overrides for now, using BaseView style

    def setup_ui(self):
        """Setup the login screen UI elements."""
        self.set_title("Login")
        self.setMinimumSize(450, 400)
        self.center_on_screen()

        # Main login layout for the central widget
        login_layout = QVBoxLayout()
        self.central_widget.setLayout(login_layout)  # Correct way to set layout

        login_layout.setContentsMargins(30, 30, 30, 30)
        login_layout.setSpacing(20)
        login_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Login form frame
        form_frame = QFrame()
        form_frame.setFrameStyle(QFrame.Shape.StyledPanel | QFrame.Shadow.Raised)
        # Use object name for more specific styling if needed later
        form_frame.setObjectName("LoginFormFrame")
        form_frame.setStyleSheet(
            f"""
            #LoginFormFrame {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                border: 1px solid #dee2e6;
                border-radius: 8px;
                padding: 30px;
                max-width: 400px;
            }}
            """
        )

        form_layout = QVBoxLayout(form_frame)  # Layout for the frame's content
        form_layout.setSpacing(15)
        form_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Title
        title_label = QLabel(AppConfig.APP_NAME)
        title_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 20, QFont.Weight.Bold)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            f"color: {AppConfig.PRIMARY_COLOR}; margin-bottom: 5px; background: transparent;"
        )
        form_layout.addWidget(title_label)

        # Version Label
        version_label = QLabel(f"Version {AppConfig.APP_VERSION}")
        version_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 10)
        version_label.setFont(version_font)
        version_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        version_label.setStyleSheet(
            f"color: {AppConfig.TEXT_SECONDARY}; margin-bottom: 20px; background: transparent;"
        )
        form_layout.addWidget(version_label)

        # Username label and input
        username_label = QLabel("Username:")
        username_label.setStyleSheet(self.get_label_style())
        form_layout.addWidget(username_label)

        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText("Enter your username")
        self.username_input.setFixedHeight(40)
        self.username_input.setStyleSheet(self.get_input_style())  # Apply input style
        self.username_input.returnPressed.connect(self.handle_login)
        form_layout.addWidget(self.username_input)

        # Password label and input
        password_label = QLabel("Password:")
        password_label.setStyleSheet(self.get_label_style())
        form_layout.addWidget(password_label)

        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText("Enter your password")
        self.password_input.setFixedHeight(40)
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setStyleSheet(self.get_input_style())  # Apply input style
        self.password_input.returnPressed.connect(self.handle_login)
        form_layout.addWidget(self.password_input)

        # Spacer
        spacer = QSpacerItem(
            20, 20, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )
        form_layout.addItem(spacer)

        # Button layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)

        self.login_button = QPushButton("Login")
        self.login_button.clicked.connect(self.handle_login)
        self.login_button.setMinimumHeight(40)
        self.login_button.setStyleSheet(self.get_button_style(AppConfig.PRIMARY_COLOR))

        self.exit_button = QPushButton("Exit")
        self.exit_button.clicked.connect(self.handle_exit)
        self.exit_button.setMinimumHeight(40)
        self.exit_button.setStyleSheet(self.get_button_style(AppConfig.SECONDARY_COLOR))

        button_layout.addWidget(self.login_button)
        button_layout.addWidget(self.exit_button)
        form_layout.addLayout(button_layout)

        # Add the form frame to the main layout
        login_layout.addWidget(form_frame)

        # Set focus
        self.username_input.setFocus()

        # Set modality
        self.setWindowModality(Qt.WindowModality.ApplicationModal)

    def get_label_style(self):
        """Returns the standard style for labels."""
        # Ensure background is transparent to inherit window background
        return f"""
            QLabel {{
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                font-weight: bold;
                color: {AppConfig.TEXT_COLOR};
                margin-bottom: 2px;
                background-color: transparent;
            }}
        """

    def get_input_style(self):
        """Returns the standard style for input fields, removing box-shadow."""
        # Inherits from BaseView stylesheet, but we define focus explicitly here
        # to ensure box-shadow is removed from this specific context too.
        return f"""
            QLineEdit {{
                border: 1px solid #ced4da;
                border-radius: 4px;
                padding: 8px 12px;
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                background-color: white;
                color: {AppConfig.TEXT_COLOR}; /* Ensure text color is set */
            }}
            QLineEdit:focus {{
                border-color: {AppConfig.PRIMARY_COLOR};
                /* Removed unsupported box-shadow */
            }}
        """

    def get_button_style(self, background_color, hover_color=None):
        """Returns the standard style for buttons."""
        # Calculate hover color if not provided
        if hover_color is None:
            try:
                r = int(background_color[1:3], 16)
                g = int(background_color[3:5], 16)
                b = int(background_color[5:7], 16)
                hover_color = f"#{max(0, r-20):02x}{max(0, g-20):02x}{max(0, b-20):02x}"
            except:
                hover_color = background_color

        return f"""
            QPushButton {{
                background-color: {background_color};
                color: white;
                border: none;
                padding: 10px 16px;
                border-radius: 4px;
                font-family: "{AppConfig.DEFAULT_FONT_FAMILY}";
                font-size: {AppConfig.DEFAULT_FONT_SIZE}pt;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: {hover_color};
            }}
            QPushButton:pressed {{
                background-color: {background_color};
            }}
            QPushButton:disabled {{
                background-color: #adb5bd;
                color: #f8f9fa;
            }}
        """

    def handle_login(self):
        """Handle login attempt using username and password."""
        username = self.username_input.text().strip()
        password = self.password_input.text()

        if not username:
            self.show_warning("Login Failed", "Please enter a username.")
            self.username_input.setFocus()
            return
        if not password:
            self.show_warning("Login Failed", "Please enter a password.")
            self.password_input.setFocus()
            return

        is_valid, user_id = self.validate_credentials(username, password)

        if is_valid:
            self.logger.info(f"User '{user_id}' logged in successfully")
            self.login_successful.emit(user_id)
            self.close()
        else:
            self.show_error("Login Failed", "Invalid username or password.")
            self.password_input.clear()
            self.username_input.setFocus()
            self.username_input.selectAll()

    def validate_credentials(self, username, password):
        """Validate username and password against the database."""
        session = None
        target_user_id = username.upper()  # Standardize username for query
        self.logger.debug(f"Attempting validation for user: {target_user_id}")
        try:
            session = db_manager.get_session()
            user = session.query(User).filter(User.user_id == target_user_id).first()

            if user:
                self.logger.debug(
                    f"User found in DB: ID={user.user_id}, Active={user.is_active}"
                )
                if user.is_active:
                    # Hash the entered password using SHA-256
                    entered_password_hash = hashlib.sha256(
                        password.encode("utf-8")
                    ).hexdigest()

                    # --- DEBUG LOGGING START ---
                    self.logger.debug(f"Comparing Hashes for user '{user.user_id}':")
                    self.logger.debug(f"  Entered Hash: {entered_password_hash}")
                    self.logger.debug(f"  Stored Hash : {user.password_hash}")
                    # --- DEBUG LOGGING END ---

                    # Compare the hash with the stored hash
                    if entered_password_hash == user.password_hash:
                        self.logger.info(
                            f"Password validation successful for user '{user.user_id}'."
                        )
                        return True, user.user_id
                    else:
                        self.logger.warning(
                            f"Password hash mismatch for user '{user.user_id}'."
                        )
                        return False, None
                else:
                    self.logger.warning(f"User '{user.user_id}' is inactive.")
                    return False, None
            else:
                self.logger.warning(f"User '{target_user_id}' not found in database.")
                return False, None

        except Exception as e:
            self.logger.error(
                f"Error during credential validation for '{target_user_id}': {e}",
                exc_info=True,
            )
            self.show_error(
                "Login Error", "An error occurred during login. Please check logs."
            )
            return False, None
        finally:
            if session:
                db_manager.close_session()

    def handle_exit(self):
        """Handle exit button click."""
        self.logger.info("Exit requested from login screen.")
        self.exit_requested.emit()
        self.close()

    def keyPressEvent(self, event):
        """Handle key press events (e.g., ESC to exit)."""
        if event.key() == Qt.Key.Key_Escape:
            self.handle_exit()
        else:
            super().keyPressEvent(event)

    # --- Message Box Helpers (Inherited from BaseView) ---
    # No need to override if BaseView uses PySide6 QMessageBox correctly.
    # def show_error(self, title, message): ...
    # def show_warning(self, title, message): ...
    # def show_info(self, title, message): ...


=============== FILE: views\auth\small_login_dialog.py ===============

# views/auth/small_login_dialog.py

"""
EDSI Veterinary Management System - Simplified Login Dialog
Version: 2.0.4
Purpose: Clean, simple login dialog using UserController for authentication.
         Ensures consistent authentication mechanism (bcrypt) across the application.
Last Updated: May 29, 2025
Author: Claude Assistant (Refactored by Gemini)

Changelog:
- v2.0.4 (2025-05-29):
    - Refactored to use UserController.authenticate_user() for login attempts.
    - Removed internal _authenticate_user and _verify_password methods.
    - Removed hashlib import and direct database session usage for authentication.
    - Login ID is now passed to UserController without uppercasing;
      controller handles case-insensitive lookup.
    - User feedback messages now sourced from UserController.
- v2.0.3 (2025-05-24):
    - Fixed RuntimeError: Internal C++ object already deleted
    - Added early return on successful login to prevent widget access after dialog closure
    - Added proper error handling for widget cleanup
- v2.0.2 (2025-05-24):
    - Updated database session handling for login attempts
    - Added last login timestamp update on successful authentication
- v2.0.1 (2025-05-24):
    - Fixed authentication to work with simplified database structure
    - Improved error handling and user feedback
- v2.0.0 (2025-05-24):
    - Complete rewrite for Phase 1 (Chunk 1) simplification
    - Removed UserController dependency and complex validation
    - Simplified to direct database authentication
    - Clean signal handling without over-engineering
    - Proper error handling and user feedback
    - Consistent dark theme styling
    - Focused on working login flow
    - Removed circular import issues
    - Clear separation of concerns
"""

import logging

# REMOVED: import hashlib - No longer used
from typing import Optional

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QMessageBox,
    QDialogButtonBox,
    QHBoxLayout,  # Retained, though not explicitly used in this version's example layout
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QPalette, QColor

from config.app_config import AppConfig

# REMOVED: from config.database_config import get_db_session - Controller handles session
# REMOVED: from models.user_models import User - Controller returns user info
from controllers.user_controller import UserController  # ADDED


class SmallLoginDialog(QDialog):
    """
    Simple login dialog for user authentication.
    Displays over the splash screen and handles user login.
    """

    # Signals
    login_successful = Signal(str)  # Emits user_id on successful login
    dialog_closed = Signal()  # Emits when dialog is closed

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.user_controller = UserController()  # ADDED UserController instance

        self.setWindowTitle("EDSI Login")
        self.setModal(True)
        self.setFixedSize(380, 250)

        self._setup_ui()
        self._apply_theme()

    def _setup_ui(self):
        """Setup the login dialog UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        title_label = QLabel("User Login")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet(
            """
            QLabel {
                font-size: 16px;
                font-weight: bold;
                padding: 10px;
            }
        """
        )
        layout.addWidget(title_label)

        self.user_id_input = QLineEdit()
        self.user_id_input.setPlaceholderText("Login ID")
        self.user_id_input.setMaxLength(20)
        layout.addWidget(self.user_id_input)

        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText("Password")
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_input.setMaxLength(255)  # Max length for input field
        layout.addWidget(self.password_input)

        self.password_input.returnPressed.connect(self._attempt_login)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )

        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        ok_button.setText("Login")

        self.button_box.accepted.connect(self._attempt_login)
        self.button_box.rejected.connect(self.reject)

        layout.addWidget(self.button_box)
        self.user_id_input.setFocus()

    def _apply_theme(self):
        """Apply dark theme to the dialog"""
        palette = QPalette()
        palette.setColor(
            QPalette.ColorRole.Window, QColor(AppConfig.DARK_WIDGET_BACKGROUND)
        )
        palette.setColor(
            QPalette.ColorRole.WindowText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        palette.setColor(
            QPalette.ColorRole.Base, QColor(AppConfig.DARK_INPUT_FIELD_BACKGROUND)
        )
        palette.setColor(QPalette.ColorRole.Text, QColor(AppConfig.DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(AppConfig.DARK_BUTTON_BG))
        palette.setColor(
            QPalette.ColorRole.ButtonText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        palette.setColor(
            QPalette.ColorRole.PlaceholderText, QColor(AppConfig.DARK_TEXT_TERTIARY)
        )
        self.setPalette(palette)

        self.setStyleSheet(
            f"""
            QDialog {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QLabel {{
                color: {AppConfig.DARK_TEXT_PRIMARY};
            }}
            QLineEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px;
                font-size: 14px;
            }}
            QLineEdit:focus {{
                border-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 15px;
                font-size: 13px;
                min-width: 80px;
            }}
            QPushButton:hover {{
                background-color: {AppConfig.DARK_BUTTON_HOVER};
            }}
            QPushButton:pressed {{
                background-color: {AppConfig.DARK_ITEM_HOVER};
            }}
            QPushButton[text="Login"] {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
            QPushButton[text="Login"]:hover {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION}dd; /* Assuming alpha modification if supported */
            }}
        """
        )

    def _attempt_login(self):
        """Attempt to authenticate the user using UserController"""
        login_id = self.user_id_input.text().strip()  # REMOVED .upper()
        password = self.password_input.text()

        if not login_id:
            self._show_error("Login ID is required.")
            self.user_id_input.setFocus()
            return

        if not password:
            self._show_error("Password is required.")
            self.password_input.setFocus()
            return

        # Authenticate user via UserController
        try:
            # UserController.authenticate_user returns -> Tuple[bool, str, Optional[Dict[str, Any]]]
            success, message, user_info = self.user_controller.authenticate_user(
                login_id, password
            )

            if success and user_info:
                actual_user_id = user_info.get(
                    "user_id", login_id
                )  # Use actual user_id from DB
                self.logger.info(f"User '{actual_user_id}' logged in successfully")
                # UserController's authenticate_user now handles updating last_login and committing
                self.login_successful.emit(actual_user_id)
                # self.accept() # No need to call accept() here, login_successful signal triggers closure in main.py
                return  # Exit immediately on success

            else:
                # Display the message from UserController (e.g., "Invalid login ID or password", "User inactive")
                self._show_error(
                    message or "Login failed. Please check your credentials."
                )
                self.logger.warning(
                    f"Failed login attempt for user input: {login_id}. Reason: {message}"
                )

        except Exception as e:  # Catch any unexpected errors from controller call
            self.logger.error(
                f"Login error during controller interaction: {e}", exc_info=True
            )
            self._show_error(
                "An unexpected error occurred during login. Please try again."
            )

        # Only clear password on failed login (we return early on success)
        try:
            self.password_input.clear()
            self.password_input.setFocus()
        except RuntimeError:
            self.logger.debug(
                "Password input widget might be deleted, skipping clear/focus."
            )

    # REMOVED: _authenticate_user(self, login_id: str, password: str) -> Optional[User]:
    # REMOVED: _verify_password(self, plain_password: str, password_hash: str) -> bool:

    def _show_error(self, message: str):
        """Show error message to user"""
        # Ensure widget exists before showing message box, in case dialog is closing.
        if self.isVisible():
            QMessageBox.critical(self, "Login Failed", message)
        else:
            self.logger.warning(
                f"Login dialog not visible, error not shown to user: {message}"
            )

    def reject(self):
        """Handle dialog rejection (Cancel button or Esc key)"""
        self.logger.debug("Login dialog cancelled by user")
        self.dialog_closed.emit()
        super().reject()

    # accept() is implicitly handled by login_successful signal flow in main.py;
    # direct call to self.accept() after emitting login_successful is removed
    # to let main.py manage the dialog closure after successful signal processing.
    # If accept() is needed for other QDialogButtonBox scenarios, it could be:
    # def accept(self):
    #     # This might be called if _attempt_login directly calls self.accept()
    #     # For now, _attempt_login calls return on success.
    #     self.logger.debug("Login dialog accepted (e.g. if OK directly called accept)")
    #     super().accept()

    def closeEvent(self, event):
        """Handle dialog close event (e.g., window 'X' button)"""
        # Check if login was successful; if so, accept() might have already been called
        # or login_successful emitted. If not, it's like a reject.
        self.logger.debug("Login dialog closed via closeEvent (e.g., X button)")
        self.dialog_closed.emit()  # Ensure dialog_closed is emitted
        super().closeEvent(event)


=============== FILE: views\auth\splash_screen.py ===============

# views/auth/splash_screen.py

"""
EDSI Veterinary Management System - Image-Based Splash Screen with Interactive Areas
Version: 1.3.2
Purpose: Displays an image-based splash screen with clickable login/exit areas.
         Corrected signal names to match usage in main.py.
         Updated AppConfig usage for asset path.
Last Updated: May 24, 2025
Author: Claude Assistant (Correcting user's v1.3.0, further modified by Gemini)

Changelog:
- v1.3.2 (2025-05-24):
    - Changed image_path construction in setup_splash_ui to use AppConfig.ASSETS_DIR
      resolving AttributeError for AppConfig.get_app_dir().
- v1.3.1 (2025-05-18):
    - Renamed signal `login_area_clicked` to `login_requested`.
    - Renamed signal `exit_area_clicked` to `exit_requested`.
- v1.3.0 (2025-05-16): (User's Base Version)
    - Implemented interactive image splash screen.
    - Loads splash_screen.jpg from assets.
    - Overlays transparent QPushButtons for "Login" and "Exit" areas based on coordinates.
    - Emits `login_area_clicked` or `exit_area_clicked` signals.
    - Removed old timer and generic key/mouse press handlers.
- v1.2.0 (2025-05-15): Attempted image display (placeholder).
- v1.1.0 (2025-05-12): Original text-based splash screen.
"""

import os
import logging
from typing import Optional

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton, QApplication
from PySide6.QtCore import (
    Qt,
    Signal,
    QSize,
    QRect,
    QTimer,
)
from PySide6.QtGui import QPixmap, QPalette, QColor

from config.app_config import AppConfig


class SplashScreen(QWidget):
    """EDSI splash screen that appears on startup, image-based with interactive areas."""

    login_requested = Signal()
    exit_requested = Signal()

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setWindowFlags(
            Qt.WindowType.SplashScreen
            | Qt.WindowType.FramelessWindowHint
            | Qt.WindowType.WindowStaysOnTopHint
        )

        self.pixmap: Optional[QPixmap] = None
        self.image_label: Optional[QLabel] = None
        self.login_button_overlay: Optional[QPushButton] = None
        self.exit_button_overlay: Optional[QPushButton] = None

        self.setup_splash_ui()

    def setup_splash_ui(self):
        try:
            # MODIFIED: Use AppConfig.ASSETS_DIR directly
            image_path = os.path.join(AppConfig.ASSETS_DIR, "splash_screen.jpg")
            self.logger.info(f"Attempting to load splash image from: {image_path}")

            if not os.path.exists(image_path):
                self.logger.error(
                    f"Splash screen image not found at {image_path}. Using fallback."
                )
                self._setup_fallback_ui()
                return

            self.pixmap = QPixmap(image_path)

            if self.pixmap.isNull():
                self.logger.error(
                    f"CRITICAL: Could not load splash image from {image_path}. Using fallback."
                )
                self._setup_fallback_ui()
                return

            self.setFixedSize(self.pixmap.size())
            self.center_on_screen()

            self.image_label = QLabel(self)
            self.image_label.setPixmap(self.pixmap)
            self.image_label.setGeometry(
                0, 0, self.pixmap.width(), self.pixmap.height()
            )
            self.image_label.setScaledContents(True)

            login_coords = QRect(280, 340, 95, 35)
            exit_coords = QRect(380, 340, 95, 35)

            self.login_button_overlay = QPushButton(self.image_label)
            self.login_button_overlay.setGeometry(login_coords)
            self.login_button_overlay.setFlat(True)
            self.login_button_overlay.setStyleSheet(
                "QPushButton { background-color: transparent; border: none; }"
            )
            self.login_button_overlay.setCursor(Qt.CursorShape.PointingHandCursor)
            self.login_button_overlay.clicked.connect(self.login_requested.emit)
            self.login_button_overlay.setToolTip("Login to EDSI System")

            self.exit_button_overlay = QPushButton(self.image_label)
            self.exit_button_overlay.setGeometry(exit_coords)
            self.exit_button_overlay.setFlat(True)
            self.exit_button_overlay.setStyleSheet(
                "QPushButton { background-color: transparent; border: none; }"
            )
            self.exit_button_overlay.setCursor(Qt.CursorShape.PointingHandCursor)
            self.exit_button_overlay.clicked.connect(self.exit_requested.emit)
            self.exit_button_overlay.setToolTip("Exit Application")

            v_layout = QVBoxLayout(self)
            v_layout.addWidget(self.image_label)
            v_layout.setContentsMargins(0, 0, 0, 0)
            self.setLayout(v_layout)

            self.logger.info("Splash screen UI setup complete.")

        except Exception as e:
            self.logger.error(f"Error setting up splash screen UI: {e}", exc_info=True)
            self._setup_fallback_ui()
            QTimer.singleShot(0, self.show)

    def _setup_fallback_ui(self):
        self.logger.info("Setting up fallback UI for splash screen.")
        if self.image_label:
            self.image_label.deleteLater()
            self.image_label = None
        if self.login_button_overlay:
            self.login_button_overlay.deleteLater()
            self.login_button_overlay = None
        if self.exit_button_overlay:
            self.exit_button_overlay.deleteLater()
            self.exit_button_overlay = None

        current_layout = self.layout()
        if current_layout is not None:
            while current_layout.count():
                child = current_layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()

        self.setFixedSize(350, 150)
        fallback_label = QLabel("EDSI Loading...", self)
        fallback_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        fallback_label.setStyleSheet(
            "background-color: #2D3748; color: white; font-size: 18px; padding: 20px; border-radius: 5px;"
        )
        main_layout = QVBoxLayout(self)
        main_layout.addWidget(fallback_label)
        self.setLayout(main_layout)
        self.center_on_screen()

    def center_on_screen(self):
        primary_screen = QApplication.primaryScreen()
        if primary_screen:
            screen_geometry = primary_screen.availableGeometry()
            self.move(screen_geometry.center() - self.rect().center())
        else:
            self.logger.warning(
                "Primary screen not available for centering splash, using default position."
            )
            self.move(100, 100)

    def showEvent(self, event):
        self.logger.debug("Splash screen shown.")
        super().showEvent(event)

    def closeEvent(self, event):
        self.logger.debug("Splash screen closed.")
        super().closeEvent(event)


=============== FILE: views\horse\__init__.py ===============

# views/horse/__init__.py

"""Horse views package"""


=============== FILE: views\horse\horse_unified_management.py ===============

# views/horse/horse_unified_management.py
"""
EDSI Veterinary Management System - Unified Horse Management Screen (Dark Theme)
Version: 1.12.2
Purpose: Unified interface for horse management, including invoice history.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v1.12.2 (2025-06-10):
    - Restored the complete and unabridged version of the file, fixing an
      AttributeError caused by missing helper methods from a previous,
      incomplete file update. All functionality should now be present.
- v1.12.1 (2025-06-10):
    - Fixed a critical AttributeError by adding the missing `display_details_state` method.
    - Added _on_payment_recorded handler to refresh horse details after a
      payment is made, ensuring all tabs reflect the new balance.
- v1.11.0 (2025-06-09):
    - Added _on_invoice_deleted handler to refresh the BillingTab and
      InvoiceHistoryTab after an invoice is deleted.
- v1.10.0 (2025-06-09):
    - Implemented a signal/slot mechanism to refresh the InvoiceHistoryTab
      automatically after an invoice is created in the BillingTab.
"""

import logging
from datetime import (
    datetime,
    date,
)
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QFrame,
    QListWidgetItem,
    QTabWidget,
    QWidget,
    QSplitter,
    QRadioButton,
    QButtonGroup,
    QApplication,
    QMenu,
    QDialog,
    QMessageBox,
    QStatusBar,
)
from PySide6.QtCore import Qt, Signal, QTimer, QDate
from PySide6.QtGui import (
    QFont,
    QPalette,
    QColor,
    QAction,
    QKeyEvent,
    QShowEvent,
    QCloseEvent,
)
from sqlalchemy.orm.exc import DetachedInstanceError

from views.base_view import BaseView
from config.app_config import (
    AppConfig,
    DARK_BACKGROUND,
    DARK_WIDGET_BACKGROUND,
    DARK_HEADER_FOOTER,
    DARK_BORDER,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
    DARK_PRIMARY_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_ITEM_HOVER,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_INPUT_FIELD_BACKGROUND,
    DEFAULT_FONT_FAMILY,
    DARK_SUCCESS_ACTION,
    DARK_DANGER_ACTION,
)
from controllers.horse_controller import HorseController
from controllers.owner_controller import OwnerController
from controllers.location_controller import LocationController
from controllers.financial_controller import FinancialController
from models import (
    Horse,
    Location as LocationModel,
    Owner as OwnerModel,
)

from .tabs.basic_info_tab import BasicInfoTab
from .tabs.owners_tab import OwnersTab
from .tabs.location_tab import LocationTab
from .tabs.billing_tab import BillingTab
from .tabs.invoice_history_tab import InvoiceHistoryTab
from .widgets.horse_list_widget import HorseListWidget


class HorseUnifiedManagement(BaseView):
    horse_selection_changed = Signal(int)
    exit_requested = Signal()
    setup_requested = Signal()
    closing = Signal()

    def __init__(self, current_user=None):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info(
            f"HorseUnifiedManagement __init__ started for user: {current_user}"
        )
        self.current_user = current_user or "ADMIN"
        self.horse_controller = HorseController()
        self.owner_controller = OwnerController()
        self.location_controller = LocationController()
        self.financial_controller = FinancialController()

        self.tab_widget: Optional[QTabWidget] = None
        self.basic_info_tab: Optional[BasicInfoTab] = None
        self.owners_tab: Optional[OwnersTab] = None
        self.location_tab: Optional[LocationTab] = None
        self.billing_tab: Optional[BillingTab] = None
        self.invoice_history_tab: Optional[InvoiceHistoryTab] = None

        self.horse_list: Optional[HorseListWidget] = None
        self.empty_frame: Optional[QFrame] = None
        self.horse_details_content_widget: Optional[QWidget] = None
        self.horse_title: Optional[QLabel] = None
        self.horse_info_line: Optional[QLabel] = None
        self.add_horse_btn: Optional[QPushButton] = None
        self.edit_horse_btn: Optional[QPushButton] = None
        self.refresh_btn: Optional[QPushButton] = None
        self.help_btn: Optional[QPushButton] = None
        self.print_btn: Optional[QPushButton] = None
        self.setup_icon_btn: Optional[QPushButton] = None
        self.user_menu_button: Optional[QPushButton] = None
        self.user_menu: Optional[QMenu] = None
        self.active_only_radio: Optional[QRadioButton] = None
        self.all_horses_radio: Optional[QRadioButton] = None
        self.deactivated_radio: Optional[QRadioButton] = None
        self.filter_group: Optional[QButtonGroup] = None
        self.search_input: Optional[QLineEdit] = None
        self.splitter: Optional[QSplitter] = None
        self.list_widget_container: Optional[QWidget] = None
        self.details_widget: Optional[QWidget] = None
        self.details_layout: Optional[QVBoxLayout] = None
        self.status_bar: Optional[QStatusBar] = None
        self.status_label: Optional[QLabel] = None
        self.footer_horse_count_label: Optional[QLabel] = None
        self.shortcut_label: Optional[QLabel] = None

        super().__init__()

        self.horses_list_data: List[Horse] = []
        self.current_horse: Optional[Horse] = None
        self._has_changes_in_active_tab: bool = False
        self._is_new_mode: bool = False

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self.perform_search)

        self.logger.debug("Scheduling load_initial_data with QTimer.singleShot(0).")
        QTimer.singleShot(0, self.load_initial_data)
        self.logger.info(
            "HorseUnifiedManagement screen __init__ finished (initial data load deferred)."
        )

    def setup_ui(self):
        self.logger.info("HorseUnifiedManagement.setup_ui: EXECUTION CONFIRMED.")

        self.set_title("Horse Management")
        self.resize(1200, 800)

        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        self.setup_header(main_layout)
        self.setup_action_bar(main_layout)
        self.setup_main_content(main_layout)
        self.setup_footer(main_layout)
        self.setup_connections()

        self.logger.info("HorseUnifiedManagement.setup_ui: All components initialized.")

    def showEvent(self, event: QShowEvent):
        self.logger.info("HorseUnifiedManagement showEvent: START")
        super().showEvent(event)

        self.logger.debug(
            "showEvent: Checking core UI elements (empty_frame, horse_details_content_widget)..."
        )
        if (
            not hasattr(self, "empty_frame")
            or not self.empty_frame
            or not hasattr(self, "horse_details_content_widget")
            or not self.horse_details_content_widget
        ):
            self.logger.error(
                "showEvent: Core UI elements for displaying state are NOT ready. UI setup might be incomplete. Aborting showEvent further processing."
            )
            return
        self.logger.debug("showEvent: Core UI elements check PASSED.")

        if self.current_horse:
            self.logger.debug(
                "showEvent: current_horse exists. Calling display_details_state."
            )
            self.display_details_state()
            self.logger.debug("showEvent: display_details_state call completed.")
            if (
                self.basic_info_tab
                and not self._is_new_mode
                and hasattr(self.basic_info_tab, "_is_editing")
                and not self.basic_info_tab._is_editing
            ):
                self.logger.debug("showEvent: Setting basic_info_tab to read-only.")
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.basic_info_tab.set_form_read_only(True)
                self.logger.debug("showEvent: basic_info_tab set to read-only.")
        else:
            self.logger.debug(
                "showEvent: No current_horse. Calling display_empty_state."
            )
            self.display_empty_state()
            self.logger.debug("showEvent: display_empty_state call completed.")

        self.logger.debug("showEvent: Calling update_main_action_buttons_state.")
        self.update_main_action_buttons_state()
        self.logger.debug("showEvent: update_main_action_buttons_state call completed.")

        self.logger.info(
            "HorseUnifiedManagement showEvent: FINISHED - screen should be visible."
        )

    def display_empty_state(self):
        self.logger.debug("display_empty_state: START")

        if hasattr(self, "empty_frame") and self.empty_frame:
            self.logger.debug("display_empty_state: Showing empty_frame.")
            self.empty_frame.show()
        else:
            self.logger.warning(
                "display_empty_state: empty_frame not available or not valid."
            )

        if (
            hasattr(self, "horse_details_content_widget")
            and self.horse_details_content_widget
        ):
            self.logger.debug(
                "display_empty_state: Hiding horse_details_content_widget."
            )
            self.horse_details_content_widget.hide()
        else:
            self.logger.warning(
                "display_empty_state: horse_details_content_widget not available."
            )

        self.current_horse = None
        self._is_new_mode = False
        self._has_changes_in_active_tab = False
        self.logger.debug("display_empty_state: Basic state flags reset.")

        if self.basic_info_tab:
            self.logger.debug(
                "display_empty_state: Calling basic_info_tab.clear_fields()."
            )
            try:
                self.basic_info_tab.clear_fields()
                self.logger.debug(
                    "display_empty_state: basic_info_tab.clear_fields() successful."
                )
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.logger.debug(
                        "display_empty_state: Attempting basic_info_tab.set_form_read_only(True)."
                    )
                    self.basic_info_tab.set_form_read_only(True)
                    self.logger.debug(
                        "display_empty_state: basic_info_tab.set_form_read_only(True) done."
                    )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in basic_info_tab.clear_fields or set_form_read_only: {e}",
                    exc_info=True,
                )

        if hasattr(self.basic_info_tab, "update_buttons_state"):
            self.logger.debug(
                "display_empty_state: Calling basic_info_tab.update_buttons_state(...)."
            )
            try:
                self.basic_info_tab.update_buttons_state(
                    is_editing_or_new=False, has_selection=False, has_changes=False
                )
                self.logger.debug(
                    "display_empty_state: basic_info_tab.update_buttons_state() successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in basic_info_tab.update_buttons_state: {e}",
                    exc_info=True,
                )
        else:
            self.logger.error("display_empty_state: BasicInfoTab is None.")

        if self.owners_tab and hasattr(self.owners_tab, "load_owners_for_horse"):
            self.logger.debug(
                "display_empty_state: Calling owners_tab.load_owners_for_horse(None)."
            )
            try:
                self.owners_tab.load_owners_for_horse(None)
                self.logger.debug(
                    "display_empty_state: owners_tab.load_owners_for_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in owners_tab.load_owners_for_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: OwnersTab is None or missing method."
            )

        if self.location_tab and hasattr(self.location_tab, "load_location_for_horse"):
            self.logger.debug(
                "display_empty_state: Calling location_tab.load_location_for_horse(None)."
            )
            try:
                self.location_tab.load_location_for_horse(None)
                self.logger.debug(
                    "display_empty_state: location_tab.load_location_for_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in location_tab.load_location_for_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: LocationTab is None or missing method."
            )

        if self.billing_tab and hasattr(self.billing_tab, "set_current_horse"):
            self.logger.debug(
                "display_empty_state: Calling billing_tab.set_current_horse(None)."
            )
            try:
                self.billing_tab.set_current_horse(None)
                self.logger.debug(
                    "display_empty_state: billing_tab.set_current_horse(None) successful."
                )
            except Exception as e:
                self.logger.error(
                    f"display_empty_state: Error in billing_tab.set_current_horse: {e}",
                    exc_info=True,
                )
        else:
            self.logger.warning(
                "display_empty_state: BillingTab is None or missing set_current_horse method."
            )

        if hasattr(self, "horse_title") and self.horse_title:
            self.logger.debug("display_empty_state: Setting horse_title text.")
            self.horse_title.setText("No Horse Selected")
        else:
            self.logger.warning(
                "display_empty_state: horse_title QLabel not available."
            )

        self.logger.debug("display_empty_state: Calling _update_horse_info_line(None).")
        self._update_horse_info_line(None)
        self.logger.debug(
            "display_empty_state: _update_horse_info_line(None) call completed."
        )

        self.logger.debug("display_empty_state: Calling update_status.")
        self.update_status("No horse selected. Add a new horse or select from list.")
        self.logger.info("display_empty_state: FINISHED")

    def display_details_state(self):
        self.logger.debug("display_details_state: START")
        if hasattr(self, "empty_frame") and self.empty_frame:
            self.empty_frame.hide()
        if (
            hasattr(self, "horse_details_content_widget")
            and self.horse_details_content_widget
        ):
            self.horse_details_content_widget.show()
        self.logger.debug("display_details_state: FINISHED")

    def update_main_action_buttons_state(self):
        self.logger.debug("update_main_action_buttons_state: START")
        can_add_new = not self._is_new_mode and not self._has_changes_in_active_tab
        if hasattr(self, "add_horse_btn") and self.add_horse_btn:
            self.add_horse_btn.setEnabled(can_add_new)
            self.logger.debug(
                f"update_main_action_buttons_state: add_horse_btn enabled: {can_add_new}"
            )
        else:
            self.logger.warning(
                "add_horse_btn not initialized in update_main_action_buttons_state"
            )

        form_is_editable_by_tab = False
        if self.basic_info_tab and hasattr(self.basic_info_tab, "_is_editing"):
            form_is_editable_by_tab = self.basic_info_tab._is_editing

        can_edit_selected = (
            self.current_horse is not None
            and not self._is_new_mode
            and not self._has_changes_in_active_tab
            and not form_is_editable_by_tab
        )

        if hasattr(self, "edit_horse_btn") and self.edit_horse_btn:
            self.edit_horse_btn.setEnabled(can_edit_selected)
            self.logger.debug(
                f"update_main_action_buttons_state: edit_horse_btn enabled: {can_edit_selected}"
            )
        else:
            self.logger.warning(
                "edit_horse_btn not initialized in update_main_action_buttons_state"
            )

        if self.basic_info_tab and hasattr(self.basic_info_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating basic_info_tab buttons."
            )
            try:
                is_editing_or_new_val = self._is_new_mode or form_is_editable_by_tab
                has_selection_val = self.current_horse is not None
                has_changes_val = self._has_changes_in_active_tab
                self.basic_info_tab.update_buttons_state(
                    is_editing_or_new_val, has_selection_val, has_changes_val
                )
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling basic_info_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.owners_tab and hasattr(self.owners_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating owners_tab buttons."
            )
            try:
                self.owners_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling owners_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.location_tab and hasattr(self.location_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating location_tab buttons."
            )
            try:
                self.location_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling location_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        if self.billing_tab and hasattr(self.billing_tab, "update_buttons_state"):
            self.logger.debug(
                "update_main_action_buttons_state: Updating billing_tab buttons."
            )
            try:
                self.billing_tab.update_buttons_state()
            except Exception as e:
                self.logger.error(
                    f"update_main_action_buttons_state: Error calling billing_tab.update_buttons_state: {e}",
                    exc_info=True,
                )

        self.logger.debug("update_main_action_buttons_state: FINISHED")

    def discard_changes(self):
        self.logger.debug("discard_changes: START")
        if not self._is_new_mode and not self._has_changes_in_active_tab:
            if (
                self.current_horse
                and self.basic_info_tab
                and hasattr(self.basic_info_tab, "_is_editing")
                and self.basic_info_tab._is_editing
            ):
                self.logger.info(
                    "discard_changes: Form in edit mode, no data changes. Reverting to read-only."
                )
                if hasattr(self.basic_info_tab, "set_form_read_only"):
                    self.basic_info_tab.set_form_read_only(True)
                self.update_main_action_buttons_state()
                self.update_status(
                    f"Viewing: {self.current_horse.horse_name or 'horse'}"
                )
                self.logger.debug("discard_changes: FINISHED (no actual changes)")
                return
            self.update_status("No changes to discard.")
            self.logger.debug("discard_changes: FINISHED (no changes to discard)")
            return

        if self.show_question("Confirm Discard", "Discard unsaved changes?"):
            self.logger.info("discard_changes: User confirmed discard.")
            was_in_new_mode = self._is_new_mode
            self._is_new_mode = False
            self._has_changes_in_active_tab = False
            if self.basic_info_tab:
                self.logger.debug("discard_changes: Clearing BasicInfoTab.")
                try:
                    self.basic_info_tab.clear_fields()
                    if hasattr(self.basic_info_tab, "set_form_read_only"):
                        self.basic_info_tab.set_form_read_only(True)
                except Exception as e:
                    self.logger.error(
                        f"discard_changes: Error in basic_info_tab.clear_fields/set_form_read_only: {e}",
                        exc_info=True,
                    )

            if self.current_horse and not was_in_new_mode:
                self.logger.debug(
                    f"discard_changes: Reloading horse ID {self.current_horse.horse_id}."
                )
                self.load_horse_details(self.current_horse.horse_id)
            else:
                self.logger.debug(
                    "discard_changes: Was new or no current horse. Selecting first in list or empty state."
                )
                if self.horse_list and self.horse_list.count() > 0:
                    self.horse_list.setCurrentRow(0)
                else:
                    self.display_empty_state()
            self.update_main_action_buttons_state()
            self.update_status("Changes discarded.")
        else:
            self.logger.info("discard_changes: User cancelled discard.")
        self.logger.debug("discard_changes: FINISHED")

    def load_initial_data(self):
        self.logger.info("load_initial_data: START - Attempting to load horses.")
        try:
            self.load_horses()
            self.logger.info(
                "load_initial_data: FINISHED - load_horses call completed."
            )
        except Exception as e:
            self.logger.error(
                f"load_initial_data: CRITICAL ERROR during load_horses: {e}",
                exc_info=True,
            )
            self.show_error(
                "Initial Data Load Failed", f"Could not load initial horse data: {e}"
            )

    def closeEvent(self, event: QCloseEvent):
        self.logger.warning(f"HorseUnifiedManagement closeEvent. Type: {event.type()}")
        self.closing.emit()
        super().closeEvent(event)
        self.logger.warning("HorseUnifiedManagement finished processing closeEvent.")

    def get_form_input_style(self, base_bg=DARK_INPUT_FIELD_BACKGROUND):
        return f"""
            QLineEdit, QComboBox, QDateEdit, QDoubleSpinBox {{ background-color: {base_bg}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px 10px; font-size: 13px; }}
            QLineEdit:focus, QComboBox:focus, QDateEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QLineEdit:disabled, QComboBox:disabled, QDateEdit:disabled, QDoubleSpinBox:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; border-color: {DARK_HEADER_FOOTER}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; width: 15px; }} QComboBox::down-arrow {{ color: {DARK_TEXT_SECONDARY}; }}
            QDateEdit::up-button, QDateEdit::down-button {{ width: 18px; }}
            QComboBox QAbstractItemView {{ background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG}; selection-color: {DARK_HIGHLIGHT_TEXT}; }}
        """

    def get_generic_button_style(self):
        return f"""
            QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px; }} 
            QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} 
            QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}
        """

    def get_toolbar_button_style(self, bg_color_hex, text_color_hex="#ffffff"):
        if len(bg_color_hex) == 4 and bg_color_hex.startswith("#"):
            bg_color_hex = f"#{bg_color_hex[1]*2}{bg_color_hex[2]*2}{bg_color_hex[3]*2}"
        try:
            base_qcolor = QColor(bg_color_hex)
            hover_bg = base_qcolor.lighter(115).name()
            pressed_bg = base_qcolor.darker(110).name()
        except ValueError:
            hover_bg, pressed_bg = DARK_BUTTON_HOVER, DARK_BUTTON_BG
            self.logger.warning(
                f"Could not parse color: {bg_color_hex} for button style."
            )
        return f"""
            QPushButton {{ background-color: {bg_color_hex}; color: {text_color_hex}; border: none; border-radius: 4px; padding: 8px 16px; font-size: 13px; font-weight: 500; }} 
            QPushButton:hover {{ background-color: {hover_bg}; }} QPushButton:pressed {{ background-color: {pressed_bg}; }} 
            QPushButton:disabled {{ background-color: #adb5bd; color: #f8f9fa; }}
        """

    def setup_header(self, parent_layout):
        self.logger.debug("setup_header: START")
        header_frame = QFrame()
        header_frame.setObjectName("HeaderFrame")
        header_frame.setFixedHeight(55)
        header_frame.setStyleSheet(
            f"""#HeaderFrame{{background-color:{DARK_HEADER_FOOTER};border:none;padding:0 20px;}} QLabel{{color:{DARK_TEXT_PRIMARY};background-color:transparent;}} QPushButton#UserMenuButton{{color:{DARK_TEXT_SECONDARY};font-size:12px;background-color:transparent;border:none;padding:5px;text-align:right;}} QPushButton#UserMenuButton::menu-indicator{{image:none;}} QPushButton#UserMenuButton:hover{{color:{DARK_TEXT_PRIMARY};background-color:{QColor(DARK_ITEM_HOVER).lighter(110).name(QColor.NameFormat.HexRgb)}33;}}"""
        )
        header_layout = QHBoxLayout(header_frame)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(15)
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setSpacing(2)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addStretch()
        title_label = QLabel("EDSI - Horse Management")
        title_label.setFont(QFont(DEFAULT_FONT_FAMILY, 15, QFont.Weight.Bold))
        left_layout.addWidget(title_label)
        breadcrumb_label = QLabel(" Horse Management")
        breadcrumb_label.setStyleSheet(
            f"color:{DARK_TEXT_SECONDARY};font-size:11px;background:transparent;"
        )
        left_layout.addWidget(breadcrumb_label)
        left_layout.addStretch()
        right_widget = QWidget()
        right_layout = QHBoxLayout(right_widget)
        right_layout.setSpacing(10)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.refresh_btn = QPushButton("")
        self.refresh_btn.setToolTip("Refresh Data (F5)")
        self.help_btn = QPushButton("")
        self.help_btn.setToolTip("Help (F1)")
        self.print_btn = QPushButton("")
        self.print_btn.setToolTip("Print Options")
        self.setup_icon_btn = QPushButton("")
        self.setup_icon_btn.setToolTip("System Setup")
        header_button_style = f"""QPushButton{{background-color:{DARK_BUTTON_BG};color:{DARK_TEXT_PRIMARY};border:1px solid {DARK_BORDER};border-radius:4px;padding:5px;font-size:14px;min-width:28px;max-width:28px;min-height:28px;max-height:28px;}} QPushButton:hover{{background-color:{DARK_BUTTON_HOVER};}} QPushButton:pressed{{background-color:{DARK_BUTTON_BG};}}"""
        for btn in [
            self.refresh_btn,
            self.help_btn,
            self.print_btn,
            self.setup_icon_btn,
        ]:
            if btn:
                btn.setStyleSheet(header_button_style)
        self.user_menu_button = QPushButton(f" User: {self.current_user}")
        self.user_menu_button.setObjectName("UserMenuButton")
        self.user_menu_button.setToolTip("User options")
        self.user_menu_button.setFlat(True)
        self.user_menu = QMenu(self)
        self.user_menu.setStyleSheet(
            f"""QMenu{{background-color:{DARK_WIDGET_BACKGROUND};color:{DARK_TEXT_PRIMARY};border:1px solid {DARK_BORDER};padding:5px;}} QMenu::item{{padding:5px 20px 5px 20px;min-width:100px;}} QMenu::item:selected{{background-color:{DARK_HIGHLIGHT_BG}70;color:{DARK_HIGHLIGHT_TEXT};}} QMenu::separator{{height:1px;background:{DARK_BORDER};margin-left:5px;margin-right:5px;}}"""
        )
        logout_action = QAction("Log Out", self)
        logout_action.triggered.connect(self.handle_logout_request_from_menu)
        self.user_menu.addAction(logout_action)
        if self.user_menu_button:
            self.user_menu_button.setMenu(self.user_menu)
        for btn in [
            self.refresh_btn,
            self.help_btn,
            self.print_btn,
            self.setup_icon_btn,
            self.user_menu_button,
        ]:
            if btn:
                right_layout.addWidget(btn)
        header_layout.addWidget(left_widget)
        header_layout.addStretch()
        header_layout.addWidget(right_widget)
        parent_layout.addWidget(header_frame)
        self.logger.debug("setup_header: END")

    def setup_action_bar(self, parent_layout):
        self.logger.debug("setup_action_bar: START")
        action_bar_frame = QFrame()
        action_bar_frame.setObjectName("ActionBarFrame")
        action_bar_frame.setFixedHeight(50)
        action_bar_frame.setStyleSheet(
            f"""#ActionBarFrame{{background-color:{DARK_BACKGROUND};border:none;border-bottom:1px solid {DARK_BORDER};padding:0 20px;}} QPushButton{{min-height:30px;}} QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;}} QRadioButton::indicator{{width:13px;height:13px;}} QRadioButton{{color:{DARK_TEXT_SECONDARY};background:transparent;padding:5px;}}"""
        )
        action_bar_layout = QHBoxLayout(action_bar_frame)
        action_bar_layout.setContentsMargins(0, 0, 0, 0)
        action_bar_layout.setSpacing(12)
        action_bar_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.add_horse_btn = QPushButton(" Add Horse")
        self.edit_horse_btn = QPushButton(" Edit Selected")
        action_button_style_str = self.get_generic_button_style()
        add_btn_bg_color = DARK_PRIMARY_ACTION
        if len(add_btn_bg_color) == 4:
            add_btn_bg_color = f"#{add_btn_bg_color[1]*2}{add_btn_bg_color[2]*2}{add_btn_bg_color[3]*2}"
        if self.add_horse_btn:
            self.add_horse_btn.setStyleSheet(
                action_button_style_str.replace(
                    DARK_BUTTON_BG, add_btn_bg_color + "B3"
                ).replace(f"color:{DARK_TEXT_PRIMARY}", "color:white;")
            )
        if self.edit_horse_btn:
            self.edit_horse_btn.setStyleSheet(action_button_style_str)
        action_bar_layout.addWidget(self.add_horse_btn)
        action_bar_layout.addWidget(self.edit_horse_btn)
        self.filter_group = QButtonGroup(self)
        self.active_only_radio = QRadioButton("Active Only")
        self.all_horses_radio = QRadioButton("All Horses")
        self.deactivated_radio = QRadioButton("Deactivated")
        for btn in [
            self.active_only_radio,
            self.all_horses_radio,
            self.deactivated_radio,
        ]:
            if btn:
                self.filter_group.addButton(btn)
                action_bar_layout.addWidget(btn)
        if self.active_only_radio:
            self.active_only_radio.setChecked(True)
        action_bar_layout.addStretch()
        self.search_input = QLineEdit()
        if self.search_input:
            self.search_input.setPlaceholderText(" Search...")
            self.search_input.setFixedHeight(30)
            self.search_input.setFixedWidth(220)
            self.search_input.setStyleSheet(
                self.get_form_input_style(base_bg=DARK_HEADER_FOOTER)
            )
        action_bar_layout.addWidget(self.search_input)
        if self.edit_horse_btn:
            self.edit_horse_btn.setEnabled(False)
        parent_layout.addWidget(action_bar_frame)
        self.logger.debug("setup_action_bar: END")

    def setup_main_content(self, parent_layout):
        self.logger.debug("setup_main_content: START")
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        self.splitter.setHandleWidth(1)
        self.splitter.setStyleSheet(
            f"""QSplitter{{background-color:{DARK_BACKGROUND};border:none;}} QSplitter::handle{{background-color:{DARK_BORDER};}} QSplitter::handle:horizontal{{width:1px;}} QSplitter::handle:pressed{{background-color:{DARK_TEXT_SECONDARY};}}"""
        )
        self.setup_horse_list_panel()
        self.setup_horse_details_panel()
        self.splitter.setSizes([300, 850])
        self.splitter.setStretchFactor(0, 0)
        self.splitter.setStretchFactor(1, 1)
        self.splitter.setCollapsible(0, False)
        self.splitter.setCollapsible(1, False)
        parent_layout.addWidget(self.splitter, 1)
        self.logger.debug("setup_main_content: END")

    def setup_horse_details_panel(self):
        self.logger.debug("setup_horse_details_panel: START")
        self.details_widget = QWidget()
        self.details_widget.setStyleSheet(
            f"background-color:{DARK_BACKGROUND};border:none;"
        )
        self.details_layout = QVBoxLayout(self.details_widget)
        self.details_layout.setContentsMargins(15, 10, 15, 10)
        self.details_layout.setSpacing(15)
        self.horse_details_content_widget = QWidget()
        details_content_layout = QVBoxLayout(self.horse_details_content_widget)
        details_content_layout.setContentsMargins(0, 0, 0, 0)
        details_content_layout.setSpacing(15)
        self.setup_horse_header_details(details_content_layout)
        self.setup_horse_tabs(details_content_layout)
        self.setup_empty_state()
        if self.details_layout and self.empty_frame:
            self.details_layout.addWidget(self.empty_frame)
        if self.details_layout and self.horse_details_content_widget:
            self.details_layout.addWidget(self.horse_details_content_widget)
        if self.horse_details_content_widget:
            self.horse_details_content_widget.hide()
        if self.splitter:
            self.splitter.addWidget(self.details_widget)
        self.logger.debug("setup_horse_details_panel: END")

    def setup_horse_tabs(self, parent_layout_for_tabs):
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_HORSE_TABS START ---")
        try:
            self.tab_widget = QTabWidget()
            self.tab_widget.setObjectName("DetailsTabWidget")
            self.tab_widget.setStyleSheet(
                f"""QTabWidget#DetailsTabWidget::pane{{border:1px solid {AppConfig.DARK_BORDER};background-color:{AppConfig.DARK_WIDGET_BACKGROUND};border-radius:6px;margin-top:-1px;}} QTabBar::tab{{padding:8px 15px;margin-right:2px;background-color:{AppConfig.DARK_BUTTON_BG};color:{AppConfig.DARK_TEXT_SECONDARY};border:1px solid {AppConfig.DARK_BORDER};border-bottom:none;border-top-left-radius:5px;border-top-right-radius:5px;min-width:90px;font-size:13px;font-weight:500;}} QTabBar::tab:selected{{background-color:{AppConfig.DARK_WIDGET_BACKGROUND};color:{AppConfig.DARK_TEXT_PRIMARY};border-color:{AppConfig.DARK_BORDER};border-bottom-color:{AppConfig.DARK_WIDGET_BACKGROUND};}} QTabBar::tab:!selected:hover{{background-color:{AppConfig.DARK_BUTTON_HOVER};color:{AppConfig.DARK_TEXT_PRIMARY};}} QTabBar{{border:none;background-color:transparent;margin-bottom:0px;}}"""
            )

            self.basic_info_tab = BasicInfoTab(
                horse_controller=self.horse_controller, parent=self
            )
            self.tab_widget.addTab(self.basic_info_tab, " Basic Info")
            self.logger.info("BasicInfoTab created.")

            self.owners_tab = OwnersTab(
                parent_view=self,
                horse_controller=self.horse_controller,
                owner_controller=self.owner_controller,
            )
            self.tab_widget.addTab(self.owners_tab, " Owners")
            self.logger.info("OwnersTab created.")

            self.location_tab = LocationTab(
                parent_view=self,
                horse_controller=self.horse_controller,
                location_controller=self.location_controller,
            )
            self.tab_widget.addTab(self.location_tab, " Location")
            self.logger.info("LocationTab created.")

            self.billing_tab = BillingTab(
                financial_controller=self.financial_controller, parent=self
            )
            self.tab_widget.addTab(self.billing_tab, " Billing")
            self.logger.info("BillingTab created.")

            self.invoice_history_tab = InvoiceHistoryTab(
                financial_controller=self.financial_controller, parent=self
            )
            self.tab_widget.addTab(self.invoice_history_tab, " Invoice History")
            self.logger.info("InvoiceHistoryTab created.")

            parent_layout_for_tabs.addWidget(self.tab_widget, 1)
            self.logger.info("Tabs added.")
        except Exception as e:
            self.logger.error(f"ERROR setup_horse_tabs: {e}", exc_info=True)
            if hasattr(self, "tab_widget") and self.tab_widget:
                self.tab_widget.deleteLater()
            self.tab_widget = None
            self.basic_info_tab = None
            self.owners_tab = None
            self.location_tab = None
            self.billing_tab = None
            self.invoice_history_tab = None

    def setup_connections(self):
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_CONNECTIONS START ---")
        if hasattr(self, "add_horse_btn") and self.add_horse_btn:
            self.add_horse_btn.clicked.connect(self.add_new_horse)
        if hasattr(self, "edit_horse_btn") and self.edit_horse_btn:
            self.edit_horse_btn.clicked.connect(self.edit_selected_horse)
        if hasattr(self, "refresh_btn") and self.refresh_btn:
            self.refresh_btn.clicked.connect(self.refresh_data)
        if hasattr(self, "help_btn") and self.help_btn:
            self.help_btn.clicked.connect(self.show_help)
        if hasattr(self, "setup_icon_btn") and self.setup_icon_btn:
            self.setup_icon_btn.clicked.connect(self.setup_requested.emit)
        if hasattr(self, "active_only_radio") and self.active_only_radio:
            self.active_only_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "all_horses_radio") and self.all_horses_radio:
            self.all_horses_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "deactivated_radio") and self.deactivated_radio:
            self.deactivated_radio.toggled.connect(self.on_filter_changed)
        if hasattr(self, "search_input") and self.search_input:
            self.search_input.textChanged.connect(self.on_search_text_changed)
        if hasattr(self, "horse_list") and self.horse_list:
            self.horse_list.itemSelectionChanged.connect(self.on_selection_changed)
            self.horse_list.itemDoubleClicked.connect(self.edit_selected_horse)

        if self.basic_info_tab:
            self.logger.info("Connecting BasicInfoTab signals.")
            if hasattr(self.basic_info_tab, "data_modified"):
                self.basic_info_tab.data_modified.connect(self._on_tab_data_modified)
            if hasattr(self.basic_info_tab, "save_requested"):
                self.basic_info_tab.save_requested.connect(self.save_changes)
            if hasattr(self.basic_info_tab, "discard_requested"):
                self.basic_info_tab.discard_requested.connect(self.discard_changes)
            if hasattr(self.basic_info_tab, "toggle_active_requested"):
                self.basic_info_tab.toggle_active_requested.connect(
                    self.handle_toggle_active_status_from_tab
                )
        else:
            self.logger.warning(
                "BasicInfoTab is None, its signals cannot be connected."
            )
        if self.owners_tab:
            self.logger.info("Connecting OwnersTab signals.")
            if hasattr(self.owners_tab, "owner_association_changed"):
                self.owners_tab.owner_association_changed.connect(
                    self._on_owner_association_changed
                )
        else:
            self.logger.warning("OwnersTab is None, its signals cannot be connected.")
        if self.location_tab:
            self.logger.info("Connecting LocationTab signals.")
            if hasattr(self.location_tab, "location_assignment_changed"):
                self.location_tab.location_assignment_changed.connect(
                    self._handle_location_assignment_change
                )
        else:
            self.logger.warning("LocationTab is None, its signals cannot be connected.")
        if self.billing_tab:
            self.billing_tab.status_message.connect(self.update_status)
            if hasattr(self.billing_tab, "invoice_created"):
                self.billing_tab.invoice_created.connect(self._on_invoice_created)

        if self.invoice_history_tab:
            self.logger.info("Connecting InvoiceHistoryTab signals.")
            self.invoice_history_tab.status_message.connect(self.update_status)
            if hasattr(self.invoice_history_tab, "invoice_deleted"):
                self.invoice_history_tab.invoice_deleted.connect(
                    self._on_invoice_deleted
                )
            if hasattr(self.invoice_history_tab, "payment_recorded"):
                self.invoice_history_tab.payment_recorded.connect(
                    self._on_payment_recorded
                )
        else:
            self.logger.warning(
                "InvoiceHistoryTab is None, its signals cannot be connected."
            )
        self.logger.info("--- HORSEUNIFIEDMANAGEMENT.SETUP_CONNECTIONS END ---")


=============== FILE: views\horse\dialogs\__init__.py ===============

# views/horse/dialogs/__init__.py

from .add_charge_dialog import AddChargeDialog
from .edit_charge_dialog import EditChargeDialog
from .edit_all_charges_dialog import EditAllChargesDialog
from .create_link_owner_dialog import CreateAndLinkOwnerDialog
from .link_existing_owner_dialog import LinkExistingOwnerDialog
from .select_existing_location_dialog import SelectExistingLocationDialog

__all__ = [
    "AddChargeDialog",
    "EditChargeDialog",
    "EditAllChargesDialog",
    "CreateAndLinkOwnerDialog",
    "LinkExistingOwnerDialog",
    "SelectExistingLocationDialog",
]


=============== FILE: views\horse\dialogs\add_charge_dialog.py ===============

# views/horse/dialogs/add_charge_dialog.py
"""
EDSI Veterinary Management System - Add Charge Dialog
Version: 3.4.0
Purpose: Dialog for entering multiple charge transactions for a horse using a table.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v3.4.0 (2025-06-09):
    - Refactored to use ChargeCodeController instead of FinancialController to
      fetch the list of charge codes, resolving an AttributeError.
    - Imported ChargeCodeController and instantiated it in __init__.
    - Modified _load_initial_data to call get_all_charge_codes(status_filter="active").
- v3.3.2 (2025-06-08):
    - Bug Fix: Re-implemented "add row on Enter" functionality using a subclassed
      QLineEdit to correctly intercept the key press and prevent the dialog
      from closing prematurely.
- v3.3.1 (2025-06-07):
    - Bug Fix: Corrected the behavior of the Enter key. It no longer closes the
      dialog but now correctly adds a new charge row for rapid data entry.
    - Removed the `EnterKeyEventFilter` in favor of connecting the `returnPressed`
      signal directly from the QLineEdit widgets in the table.
    - Disabled the default button behavior on the dialog's button box.
- v3.3.0 (2025-06-07):
    - Added a tax rate input field to allow for percentage-based tax calculation.
- v3.2.0 (2025-06-07):
    - Re-styled all input fields to match the BasicInfoTab style.
- v3.1.0 (2025-06-07):
    - Updated header format to match the main HorseUnifiedManagement screen.
    - Repositioned the Save/Cancel buttons to the bottom-left of the dialog.
- v3.0.3 (2025-06-07):
    - Bug Fix: Corrected signal name from `currentRowChanged` to `currentCellChanged`.
- v3.0.2 (2025-06-07):
    - Bug Fix: Corrected an AttributeError by using QAbstractSpinBox.ButtonSymbols.NoButtons.
- v3.0.1 (2025-06-07):
    - Bug Fix: Imported the `Slot` decorator from PySide6.QtCore.
- v3.0.0 (2025-06-07):
    - Complete refactor to a `QTableWidget`-based interface for charge entry.
"""

import logging
from decimal import Decimal, InvalidOperation
from datetime import date
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QPushButton,
    QLabel,
    QDialogButtonBox,
    QMessageBox,
    QWidget,
    QHBoxLayout,
    QSpacerItem,
    QSizePolicy,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QLineEdit,
    QCompleter,
    QDoubleSpinBox,
    QCheckBox,
    QAbstractItemView,
    QFormLayout,
    QTextEdit,
    QApplication,
    QAbstractSpinBox,
)
from PySide6.QtCore import Qt, Signal, QTimer, QEvent, QObject, Slot
from PySide6.QtGui import QFont, QColor, QPainter, QPen, QKeyEvent

from models import Horse, Transaction, ChargeCode
from controllers import FinancialController, ChargeCodeController
from config.app_config import AppConfig


class BoxedCellDelegate(QStyledItemDelegate):
    """A delegate to draw borders around cells to give them a 'boxed' look."""

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index):
        super().paint(painter, option, index)
        painter.save()
        pen = QPen(QColor(AppConfig.DARK_BORDER))
        pen.setWidth(1)
        painter.setPen(pen)
        painter.drawRect(option.rect)
        painter.restore()


class EnterKeyLineEdit(QLineEdit):
    """A QLineEdit that emits a signal when Enter is pressed and consumes the event."""

    enter_pressed = Signal()

    def keyPressEvent(self, event: QKeyEvent):
        if event.key() in [Qt.Key.Key_Return, Qt.Key.Key_Enter]:
            event.accept()
            self.enter_pressed.emit()
        else:
            super().keyPressEvent(event)


class AddChargeDialog(QDialog):
    """A dialog for adding multiple charge items for a horse in a table."""

    charges_saved = Signal(list)

    def __init__(
        self,
        horse: Horse,
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse = horse
        self.financial_controller = financial_controller
        self.charge_code_controller = ChargeCodeController()
        self.current_user_id = QApplication.instance().current_user_id

        self.setWindowTitle(f"Add Charges for: {self.horse.horse_name}")
        self.setMinimumSize(1200, 700)

        self._charge_codes_list: List[ChargeCode] = []
        self._charge_code_lookup: Dict[str, ChargeCode] = {}
        self._alt_code_lookup: Dict[str, ChargeCode] = {}
        self._row_notes: Dict[int, str] = {}
        self._current_notes_row: Optional[int] = None
        self._taxable_subtotal = Decimal(0)

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()

        self._populate_header()
        QTimer.singleShot(0, self._load_initial_data)

    def _get_input_field_style(self) -> str:
        """Generates the requested style for all input fields."""
        return f"""
            QLineEdit, QDoubleSpinBox, QTextEdit, EnterKeyLineEdit {{
                background-color: #3E3E3E;
                color: white;
                border: 1px solid white;
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus, EnterKeyLineEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QCheckBox::indicator {{
                width: 14px;
                height: 14px;
                border: 1px solid white;
                border-radius: 3px;
                background-color: #3E3E3E;
            }}
            QCheckBox::indicator:checked {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                border-color: {AppConfig.DARK_SUCCESS_ACTION};
            }}
            QCompleter::popup {{
                background-color: {AppConfig.DARK_WIDGET_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
            }}
            QCompleter::popup::item:selected {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
            }}
        """

    def _setup_ui(self):
        """Initializes and lays out the UI widgets based on the new design."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        # --- Header ---
        self.horse_title_label = QLabel()
        self.horse_info_line_label = QLabel()
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.addWidget(self.horse_title_label)
        header_layout.addWidget(self.horse_info_line_label)
        main_layout.addWidget(header_widget)

        # --- Main Content: Table and Notes ---
        content_layout = QHBoxLayout()
        table_container = QWidget()
        table_layout = QVBoxLayout(table_container)
        table_layout.setContentsMargins(0, 0, 0, 0)

        self.charges_table = QTableWidget()
        table_layout.addWidget(self.charges_table)

        self.notes_edit = QTextEdit()
        table_layout.addWidget(self.notes_edit)
        table_layout.setStretchFactor(self.charges_table, 3)
        table_layout.setStretchFactor(self.notes_edit, 1)

        content_layout.addWidget(table_container)
        main_layout.addLayout(content_layout, 1)

        # --- Footer ---
        footer_layout = QHBoxLayout()
        footer_layout.setContentsMargins(0, 10, 0, 0)

        self.button_box = QDialogButtonBox()
        self.save_button = self.button_box.addButton(
            "Save Charges", QDialogButtonBox.ButtonRole.AcceptRole
        )
        self.cancel_button = self.button_box.addButton(
            "Cancel", QDialogButtonBox.ButtonRole.RejectRole
        )
        self.save_button.setAutoDefault(False)
        self.cancel_button.setAutoDefault(False)

        totals_container = QWidget()
        totals_form_layout = QFormLayout(totals_container)
        totals_form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        self.subtotal_label = QLabel("$0.00")
        self.taxable_subtotal_label = QLabel("$0.00")
        self.tax_amount_input = QDoubleSpinBox()
        self.tax_rate_input = QDoubleSpinBox()
        self.grand_total_label = QLabel("$0.00")

        tax_layout = QHBoxLayout()
        tax_layout.addWidget(self.tax_rate_input)
        tax_layout.addWidget(self.tax_amount_input)

        totals_form_layout.addRow("Subtotal:", self.subtotal_label)
        totals_form_layout.addRow("Taxable Subtotal:", self.taxable_subtotal_label)
        totals_form_layout.addRow("Tax (% / Amt):", tax_layout)
        totals_form_layout.addRow("<b>Grand Total:</b>", self.grand_total_label)

        footer_layout.addWidget(self.button_box)
        footer_layout.addStretch()
        footer_layout.addWidget(totals_container)

        main_layout.addLayout(footer_layout)

    def _populate_header(self):
        self.horse_title_label.setText(self.horse.horse_name)

        age_str = self._calculate_age(self.horse.date_of_birth)
        owner_name = self._get_display_owner_name(self.horse)
        location_name = self._get_display_location_name(self.horse)

        info_parts = [
            f"Acct: {self.horse.account_number or 'N/A'}",
            f" {owner_name}",
            f"Breed: {self.horse.breed or 'N/A'}",
            f"Color: {self.horse.color or 'N/A'}",
            f"Sex: {self.horse.sex or 'N/A'}",
            f"Age: {age_str}",
            f" {location_name}",
        ]
        self.horse_info_line_label.setText(" | ".join(info_parts))

    def _apply_styles(self):
        """Applies consistent styling to the dialog's widgets."""
        self.horse_title_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 16, QFont.Weight.Bold)
        )
        self.horse_title_label.setStyleSheet(f"color:{AppConfig.DARK_TEXT_PRIMARY};")
        self.horse_info_line_label.setStyleSheet(
            f"color:{AppConfig.DARK_TEXT_SECONDARY}; font-size: 11px;"
        )

        self.charges_table.setColumnCount(7)
        self.charges_table.setHorizontalHeaderLabels(
            ["Code", "Alt. Code", "Description", "Qty", "Unit Price", "Tax", "Total"]
        )
        self.charges_table.verticalHeader().setVisible(False)
        self.charges_table.setItemDelegate(BoxedCellDelegate(self))
        header = self.charges_table.horizontalHeader()
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        self.charges_table.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.charges_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )

        self.notes_edit.setPlaceholderText(
            "Notes for the selected line item will appear here..."
        )

        self.tax_rate_input.setDecimals(4)
        self.tax_rate_input.setRange(0.00, 100.00)
        self.tax_rate_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.tax_rate_input.setSuffix(" %")

        self.tax_amount_input.setDecimals(2)
        self.tax_amount_input.setRange(0.00, 99999.99)
        self.tax_amount_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.tax_amount_input.setPrefix("$ ")

        totals_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 11)
        self.subtotal_label.setFont(totals_font)
        self.taxable_subtotal_label.setFont(totals_font)
        self.grand_total_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        )

        self.save_button.setMinimumSize(120, 40)
        self.cancel_button.setMinimumSize(120, 40)

        save_button_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                color: white;
                border: 1px solid {QColor(AppConfig.DARK_SUCCESS_ACTION).darker(120).name()};
                border-radius: 4px;
            }}
            QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}
        """
        cancel_button_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
            }}
            QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}
        """
        self.save_button.setStyleSheet(save_button_style)
        self.cancel_button.setStyleSheet(cancel_button_style)

        field_style = self._get_input_field_style()
        self.notes_edit.setStyleSheet(field_style)
        self.tax_amount_input.setStyleSheet(field_style)
        self.tax_rate_input.setStyleSheet(field_style)

    def _setup_connections(self):
        self.save_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        self.tax_rate_input.valueChanged.connect(self._calculate_tax_from_rate)
        self.tax_amount_input.valueChanged.connect(self._clear_tax_rate_on_manual_edit)

        self.charges_table.currentCellChanged.connect(self._handle_row_change)
        self.notes_edit.textChanged.connect(self._save_notes_for_current_row)

    def _load_initial_data(self):
        self._charge_codes_list = self.charge_code_controller.get_all_charge_codes(
            status_filter="active"
        )
        self._charge_code_lookup = {
            cc.code.upper(): cc for cc in self._charge_codes_list
        }
        self._alt_code_lookup = {
            cc.alternate_code.upper(): cc
            for cc in self._charge_codes_list
            if cc.alternate_code
        }
        self.logger.debug(f"Loaded {len(self._charge_codes_list)} charge codes.")
        self._add_charge_row()

    @Slot(int)
    def _handle_enter_in_row(self, row: int):
        self._add_charge_row(from_row=row)

    def _add_charge_row(self, from_row: Optional[int] = None):
        """Adds a new, empty row to the charges table."""
        if from_row is None:
            row_to_insert = self.charges_table.rowCount()
        else:
            row_to_insert = from_row + 1

        self.charges_table.insertRow(row_to_insert)
        self._setup_row_widgets(row_to_insert)
        self.charges_table.setCurrentCell(row_to_insert, 0)

    def _setup_row_widgets(self, row: int):
        """Places the appropriate widgets into the cells of a given row."""
        field_style = self._get_input_field_style()

        # Code
        code_edit = EnterKeyLineEdit()
        code_edit.setStyleSheet(field_style)
        code_completer = QCompleter([cc.code for cc in self._charge_codes_list])
        code_completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        code_completer.popup().setStyleSheet(field_style)
        code_edit.setCompleter(code_completer)
        code_edit.editingFinished.connect(lambda r=row: self._on_code_entered(r))
        code_edit.enter_pressed.connect(lambda r=row: self._handle_enter_in_row(r))
        self.charges_table.setCellWidget(row, 0, code_edit)

        # Alt Code
        alt_code_edit = EnterKeyLineEdit()
        alt_code_edit.setStyleSheet(field_style)
        alt_code_completer = QCompleter(
            [cc.alternate_code for cc in self._charge_codes_list if cc.alternate_code]
        )
        alt_code_completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        alt_code_completer.popup().setStyleSheet(field_style)
        alt_code_edit.setCompleter(alt_code_completer)
        alt_code_edit.editingFinished.connect(
            lambda r=row: self._on_alt_code_entered(r)
        )
        alt_code_edit.enter_pressed.connect(lambda r=row: self._handle_enter_in_row(r))
        self.charges_table.setCellWidget(row, 1, alt_code_edit)

        # Description (read-only)
        desc_item = QTableWidgetItem()
        desc_item.setFlags(desc_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
        self.charges_table.setItem(row, 2, desc_item)

        # Qty
        qty_spinbox = QDoubleSpinBox()
        qty_spinbox.setStyleSheet(field_style)
        qty_spinbox.setDecimals(3)
        qty_spinbox.setRange(0.001, 9999.0)
        qty_spinbox.setValue(1.0)
        qty_spinbox.valueChanged.connect(self._update_totals)
        self.charges_table.setCellWidget(row, 3, qty_spinbox)

        # Unit Price
        price_spinbox = QDoubleSpinBox()
        price_spinbox.setStyleSheet(field_style)
        price_spinbox.setDecimals(2)
        price_spinbox.setRange(0.00, 99999.99)
        price_spinbox.setPrefix("$ ")
        price_spinbox.valueChanged.connect(self._update_totals)
        self.charges_table.setCellWidget(row, 4, price_spinbox)

        # Taxable
        tax_checkbox = QCheckBox()
        tax_checkbox.setStyleSheet(field_style)
        tax_checkbox.stateChanged.connect(self._update_totals)
        chk_widget = QWidget()
        chk_layout = QHBoxLayout(chk_widget)
        chk_layout.addWidget(tax_checkbox)
        chk_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        chk_layout.setContentsMargins(0, 0, 0, 0)
        self.charges_table.setCellWidget(row, 5, chk_widget)

        # Total
        total_item = QTableWidgetItem("$0.00")
        total_item.setTextAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        total_item.setFlags(total_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
        self.charges_table.setItem(row, 6, total_item)

    def _on_code_entered(self, row: int):
        code_widget = self.charges_table.cellWidget(row, 0)
        if isinstance(code_widget, QLineEdit):
            code = code_widget.text().upper()
            charge_code = self._charge_code_lookup.get(code)
            self._populate_row_from_charge_code(row, charge_code)

    def _on_alt_code_entered(self, row: int):
        alt_code_widget = self.charges_table.cellWidget(row, 1)
        if isinstance(alt_code_widget, QLineEdit):
            alt_code = alt_code_widget.text().upper()
            charge_code = self._alt_code_lookup.get(alt_code)
            self._populate_row_from_charge_code(row, charge_code)

    def _populate_row_from_charge_code(
        self, row: int, charge_code: Optional[ChargeCode]
    ):
        if charge_code:
            code_widget = self.charges_table.cellWidget(row, 0)
            if isinstance(code_widget, QLineEdit):
                code_widget.setText(charge_code.code)
            alt_code_widget = self.charges_table.cellWidget(row, 1)
            if isinstance(alt_code_widget, QLineEdit):
                alt_code_widget.setText(charge_code.alternate_code or "")
            self.charges_table.item(row, 2).setText(charge_code.description)
            price_widget = self.charges_table.cellWidget(row, 4)
            if isinstance(price_widget, QDoubleSpinBox):
                price_widget.setValue(float(charge_code.standard_charge))
            tax_widget_container = self.charges_table.cellWidget(row, 5)
            if tax_widget_container:
                tax_checkbox = tax_widget_container.findChild(QCheckBox)
                if tax_checkbox:
                    tax_checkbox.setChecked(charge_code.taxable)
        self._update_totals()

    @Slot(int, int, int, int)
    def _handle_row_change(
        self, currentRow, currentColumn, previousRow, previousColumn
    ):
        if previousRow != -1 and previousRow < self.charges_table.rowCount():
            self._save_notes_for_current_row()

        self._current_notes_row = currentRow
        current_notes = self._row_notes.get(currentRow, "")

        self.notes_edit.blockSignals(True)
        self.notes_edit.setPlainText(current_notes)
        self.notes_edit.blockSignals(False)

        if currentRow != -1:
            self.notes_edit.setPlaceholderText(f"Notes for line {currentRow + 1}...")
        else:
            self.notes_edit.setPlaceholderText(
                "Notes for the selected line item will appear here..."
            )

    @Slot()
    def _save_notes_for_current_row(self):
        if (
            self._current_notes_row is not None
            and self._current_notes_row < self.charges_table.rowCount()
        ):
            notes = self.notes_edit.toPlainText().strip()
            if notes:
                self._row_notes[self._current_notes_row] = notes
            elif self._current_notes_row in self._row_notes:
                del self._row_notes[self._current_notes_row]

    def _update_totals(self):
        subtotal = Decimal(0)
        self._taxable_subtotal = Decimal(0)
        for row in range(self.charges_table.rowCount()):
            try:
                qty_widget = self.charges_table.cellWidget(row, 3)
                price_widget = self.charges_table.cellWidget(row, 4)
                tax_container = self.charges_table.cellWidget(row, 5)

                if qty_widget and price_widget:
                    qty = Decimal(qty_widget.value())
                    price = Decimal(price_widget.value())
                    line_total = (qty * price).quantize(Decimal("0.01"))
                    self.charges_table.item(row, 6).setText(f"${line_total:.2f}")

                    subtotal += line_total
                    if tax_container and tax_container.findChild(QCheckBox).isChecked():
                        self._taxable_subtotal += line_total
            except (InvalidOperation, TypeError, AttributeError) as e:
                self.logger.warning(f"Could not calculate total for row {row}: {e}")
                continue

        manual_tax = Decimal(self.tax_amount_input.value())
        grand_total = subtotal + manual_tax

        self.subtotal_label.setText(f"${subtotal:.2f}")
        self.taxable_subtotal_label.setText(f"${self._taxable_subtotal:.2f}")
        self.grand_total_label.setText(f"${grand_total:.2f}")

    @Slot(float)
    def _calculate_tax_from_rate(self, rate: float):
        tax_rate = Decimal(rate) / Decimal(100)
        tax_amount = (self._taxable_subtotal * tax_rate).quantize(Decimal("0.01"))

        self.tax_amount_input.blockSignals(True)
        self.tax_amount_input.setValue(float(tax_amount))
        self.tax_amount_input.blockSignals(False)
        self._update_totals()

    @Slot(float)
    def _clear_tax_rate_on_manual_edit(self, amount: float):
        self.tax_rate_input.blockSignals(True)
        self.tax_rate_input.setValue(0.0)
        self.tax_rate_input.blockSignals(False)
        # We don't call _update_totals here, as this is the primary signal source for totals when edited manually.
        # The valueChanged on this spinbox will trigger a separate totals update.
        # To be safe, we'll call it.
        self._update_totals()

    def get_data_from_table(self) -> List[Dict[str, Any]]:
        """Collects and validates data from all rows in the table."""
        charges_to_save = []
        for row in range(self.charges_table.rowCount()):
            try:
                code_widget = self.charges_table.cellWidget(row, 0)
                desc_item = self.charges_table.item(row, 2)
                qty_widget = self.charges_table.cellWidget(row, 3)
                price_widget = self.charges_table.cellWidget(row, 4)
                tax_container = self.charges_table.cellWidget(row, 5)

                code = code_widget.text().upper()
                charge_code_obj = self._charge_code_lookup.get(code)

                if not charge_code_obj or not desc_item or not desc_item.text():
                    continue

                charges_to_save.append(
                    {
                        "charge_code_id": charge_code_obj.id,
                        "description": desc_item.text(),
                        "quantity": Decimal(qty_widget.value()),
                        "unit_price": Decimal(price_widget.value()),
                        "taxable": tax_container.findChild(QCheckBox).isChecked(),
                        "item_notes": self._row_notes.get(row),
                    }
                )
            except Exception as e:
                self.logger.error(f"Error processing row {row} for saving: {e}")
        return charges_to_save

    def accept(self):
        """Gathers data from the table and sends it to the controller to be saved."""
        self._save_notes_for_current_row()
        charges_to_save = self.get_data_from_table()

        if not charges_to_save:
            QMessageBox.warning(
                self, "No Charges", "Please add at least one valid charge item."
            )
            return

        if not self.horse.owners:
            QMessageBox.critical(
                self,
                "Billing Error",
                "This horse has no owner assigned and cannot be billed.",
            )
            return

        success, message, new_transactions = (
            self.financial_controller.add_charge_batch_to_horse(
                horse_id=self.horse.horse_id,
                owner_id=self.horse.owners[0].owner_id,
                charge_items=charges_to_save,
                batch_transaction_date=date.today(),
                administered_by_user_id=self.current_user_id,
            )
        )

        if success:
            self.charges_saved.emit(new_transactions)
            super().accept()
        else:
            QMessageBox.critical(self, "Error Saving Charges", message)

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"

    def _get_display_owner_name(self, horse: Horse) -> str:
        if not horse.owners:
            return "No Owner Associated"

        first_owner = horse.owners[0]
        name_parts = []
        if first_owner.farm_name:
            name_parts.append(first_owner.farm_name)

        person_name_parts = []
        if first_owner.first_name:
            person_name_parts.append(first_owner.first_name)
        if first_owner.last_name:
            person_name_parts.append(first_owner.last_name)

        person_name_str = " ".join(person_name_parts).strip()
        if person_name_str:
            if name_parts:
                name_parts.append(f"({person_name_str})")
            else:
                name_parts.append(person_name_str)

        return (
            " ".join(name_parts) if name_parts else f"Owner ID: {first_owner.owner_id}"
        )

    def _get_display_location_name(self, horse: Horse) -> str:
        return horse.location.location_name if horse.location else "N/A"


=============== FILE: views\horse\dialogs\add_edit_location_dialog.py ===============

# views/admin/dialogs/add_edit_location_dialog.py
"""
EDSI Veterinary Management System - Add/Edit Location Dialog
Version: 1.0.0
Purpose: Dialog for creating and editing practice locations.
Last Updated: May 19, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-05-19):
    - Initial implementation for adding and editing locations.
    - Fields: Location Name, Description, Is Active.
    - Uses LocationController for backend operations.
    - Styled for dark theme using imported constants.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QLineEdit,
    QTextEdit,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.location_controller import LocationController
from models import Location as LocationModel

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class AddEditLocationDialog(QDialog):
    def __init__(
        self,
        parent_view,
        controller: LocationController,
        current_user_id: str,
        location: Optional[LocationModel] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.controller = controller
        self.current_user_id = current_user_id
        self.location = location
        self.is_edit_mode = location is not None

        self.setWindowTitle(f"{'Edit' if self.is_edit_mode else 'Add'} Location")
        self.setMinimumWidth(450)

        self._setup_palette()
        self._setup_ui()
        if self.is_edit_mode and self.location:
            self._populate_fields()

    def _get_dialog_specific_input_field_style(self) -> str:
        """Generates style string for input fields within this dialog."""
        return f"""
            QLineEdit, QTextEdit {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER};
                border-radius: 4px;
                padding: 6px;
                min-height: 20px;
            }}
            QLineEdit:focus, QTextEdit:focus {{
                border-color: {DARK_PRIMARY_ACTION};
            }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        """Generates generic button style string for this dialog."""
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        form_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.WrapAllRows)
        form_layout.setContentsMargins(15, 15, 15, 15)
        form_layout.setSpacing(10)

        input_style = self._get_dialog_specific_input_field_style()
        dialog_styles = (
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top:3px; }}"
            + f"QCheckBox::indicator {{ width: 13px; height: 13px; }}"
        )
        self.setStyleSheet(dialog_styles)

        self.location_name_input = QLineEdit()
        self.location_name_input.setStyleSheet(input_style)
        self.location_name_input.setPlaceholderText("e.g., Main Barn, Paddock A")
        form_layout.addRow("Location Name*:", self.location_name_input)

        self.description_input = QTextEdit()
        self.description_input.setStyleSheet(input_style)
        self.description_input.setPlaceholderText(
            "Optional description or details about the location"
        )
        self.description_input.setFixedHeight(80)
        form_layout.addRow("Description:", self.description_input)

        self.is_active_checkbox = QCheckBox("Location is Active")
        self.is_active_checkbox.setChecked(True)  # Default to active for new locations
        form_layout.addRow("", self.is_active_checkbox)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith("#"):
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _populate_fields(self):
        """Populates fields if in edit mode."""
        if self.location:  # Should always be true if self.is_edit_mode is true
            self.location_name_input.setText(self.location.location_name)
            self.description_input.setPlainText(self.location.description or "")
            self.is_active_checkbox.setChecked(self.location.is_active)

    def get_data(self) -> Dict[str, Any]:
        """Collects data from the form fields."""
        return {
            "location_name": self.location_name_input.text().strip(),
            "description": self.description_input.toPlainText().strip(),
            "is_active": self.is_active_checkbox.isChecked(),
        }

    def validate_and_accept(self):
        """Validates form data and accepts dialog if valid."""
        data = self.get_data()

        # Use controller's validation method
        is_valid, errors = self.controller.validate_location_data(
            data,
            is_new=(not self.is_edit_mode),
            location_id_to_check_for_unique=(
                self.location.location_id
                if self.is_edit_mode and self.location
                else None
            ),
        )

        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct the following errors:\n- " + "\n- ".join(errors),
            )
            return  # Keep dialog open

        try:
            if self.is_edit_mode and self.location:
                success, message = self.controller.update_location(
                    self.location.location_id, data, self.current_user_id
                )
            else:
                success, message, _ = self.controller.create_location(
                    data, self.current_user_id
                )

            if success:
                # Show info message from the parent view for consistency if possible
                if hasattr(self.parent(), "show_info"):
                    self.parent().show_info("Success", message)
                else:
                    QMessageBox.information(self, "Success", message)
                super().accept()  # Close dialog with Accepted state
            else:
                QMessageBox.critical(
                    self, "Error", message or "An unknown error occurred."
                )
                # Keep dialog open if controller indicates failure that might be correctable
        except Exception as e:
            self.logger.error(f"Error during location save/update: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Operation Failed", f"An unexpected error occurred: {e}"
            )
            # Keep dialog open


=============== FILE: views\horse\dialogs\create_link_owner_dialog.py ===============

# views/horse/dialogs/create_link_owner_dialog.py
"""
EDSI Veterinary Management System - Create New Owner and Link Dialog
Version: 1.0.8
Purpose: Dialog for creating a new owner and linking them to a horse with a percentage.
         - Corrected tuple unpacking error in _setup_ui by ensuring all field
           definitions in `fields_setup` list have a consistent number of elements.
Last Updated: May 26, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.0.8 (2025-05-26):
    - In `_setup_ui`, standardized the tuples in the `fields_setup` list to consistently
      provide 8 elements (label, name, layout coordinates, widget_type_str, placeholder).
    - Updated the for-loop unpacking these tuples to match the 8 elements,
      resolving the "ValueError: not enough values to unpack".
- v1.0.7 (2025-05-26):
    - Modified `__init__` to accept an optional `total_ownership_validator` callback.
    - Updated `validate_and_accept` to call this external validator.
- v1.0.6 (2025-05-26):
    - Redesigned UI to use a two-column QGridLayout for owner detail fields.
# ... (rest of previous changelog entries assumed present)
"""

import logging
from typing import Optional, Dict, List, Callable

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QComboBox,
    QDoubleSpinBox,
    QCheckBox,
    QDialogButtonBox,
    QMessageBox,
    QLabel,
    QWidget,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class CreateAndLinkOwnerDialog(QDialog):
    def __init__(
        self,
        parent_view,
        horse_name: str,
        current_user_login: str,
        total_ownership_validator: Optional[
            Callable[[Optional[int], float], bool]
        ] = None,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_name = horse_name
        self.current_user_login = current_user_login
        self.owner_controller = OwnerController()
        self.total_ownership_validator = total_ownership_validator

        self.setWindowTitle(f"Create & Link New Owner to {self.horse_name}")
        self.setMinimumWidth(750)

        self._setup_palette()
        self._setup_ui()

        if "state_code" in self.form_fields and isinstance(
            self.form_fields["state_code"], QComboBox
        ):
            self._populate_states_combo(self.form_fields["state_code"])

    def _get_dialog_specific_input_field_style(self):
        # (Same as v1.0.7)
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; subcontrol-position: right center; width: 15px; }}
            QComboBox::down-arrow {{ image: url(none); }} /* Consider a Qt built-in or SVG icon for better dark theme compatibility */
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }} """

    def _get_dialog_generic_button_style(self):
        # (Same as v1.0.7)
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_palette(self):
        # (Same as v1.0.7)
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        main_dialog_layout = QVBoxLayout(self)
        main_dialog_layout.setSpacing(15)
        main_dialog_layout.setContentsMargins(15, 15, 15, 15)

        instruction_label = QLabel(
            f"Enter details for the new owner to be linked to <b>{self.horse_name}</b>."
        )
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 5px; background-color: transparent;"
        )
        instruction_label.setWordWrap(True)
        main_dialog_layout.addWidget(instruction_label)

        grid_layout = QGridLayout()
        grid_layout.setHorizontalSpacing(20)
        grid_layout.setVerticalSpacing(10)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(3, 1)

        self.form_fields = {}
        specific_input_style = self._get_dialog_specific_input_field_style()

        # Each tuple: (Label, field_name, r_lbl, c_lbl, r_fld, c_fld, widget_type_str, placeholder_or_None)
        fields_setup = [
            ("Farm Name:", "farm_name", 0, 0, 0, 1, "QLineEdit", None),
            ("Account #:", "account_number", 0, 2, 0, 3, "QLineEdit", None),
            ("First Name:", "first_name", 1, 0, 1, 1, "QLineEdit", None),
            ("Last Name*:", "last_name", 1, 2, 1, 3, "QLineEdit", None),
            ("Address 1*:", "address_line1", 2, 0, 2, 1, "QLineEdit", None),
            ("Address 2:", "address_line2", 2, 2, 2, 3, "QLineEdit", None),
            ("City*:", "city", 3, 0, 3, 1, "QLineEdit", None),
            ("State*:", "state_code", 3, 2, 3, 3, "QComboBox", None),
            ("Zip/Postal*:", "zip_code", 4, 0, 4, 1, "QLineEdit", None),
            ("Country:", "country_name", 4, 2, 4, 3, "QLineEdit", "e.g. USA"),
            ("Phone:", "phone", 5, 0, 5, 1, "QLineEdit", None),
            ("Email:", "email", 5, 2, 5, 3, "QLineEdit", None),
        ]

        for (
            label_text,
            field_name,
            r_lbl,
            c_lbl,
            r_fld,
            c_fld,
            widget_type_str,
            placeholder_text,
        ) in fields_setup:
            lbl = QLabel(label_text)
            grid_layout.addWidget(lbl, r_lbl, c_lbl, Qt.AlignmentFlag.AlignRight)

            widget: QWidget  # Type hint for clarity
            if widget_type_str == "QComboBox":
                widget = QComboBox()
            else:  # Default to QLineEdit
                widget = QLineEdit()
                if placeholder_text:  # Check if placeholder_text is not None
                    widget.setPlaceholderText(placeholder_text)

            widget.setStyleSheet(specific_input_style)
            self.form_fields[field_name] = widget
            grid_layout.addWidget(widget, r_fld, c_fld)

        # Row 6: Ownership Percentage and Active Checkbox
        self.percentage_input = QDoubleSpinBox()
        self.percentage_input.setRange(0.00, 100.00)
        self.percentage_input.setDecimals(2)
        self.percentage_input.setSuffix(" %")
        self.percentage_input.setValue(100.00)
        self.percentage_input.setStyleSheet(specific_input_style)
        grid_layout.addWidget(
            QLabel("Ownership %*:"), 6, 0, Qt.AlignmentFlag.AlignRight
        )
        grid_layout.addWidget(self.percentage_input, 6, 1)

        self.form_fields["is_active"] = QCheckBox("Owner is Active")
        self.form_fields["is_active"].setChecked(True)
        self.form_fields["is_active"].setStyleSheet(
            f"QCheckBox{{color:{DARK_TEXT_SECONDARY};background:transparent;padding-top:3px;}}QCheckBox::indicator{{width:13px;height:13px;}}"
        )
        grid_layout.addWidget(
            self.form_fields["is_active"],
            6,
            3,
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
        )  # Align left in its cell

        main_dialog_layout.addLayout(grid_layout)
        main_dialog_layout.addStretch(1)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(
            "Create & Link Owner"
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg = DARK_SUCCESS_ACTION
                ok_bg = (
                    f"#{ok_bg[1]*2}{ok_bg[2]*2}{ok_bg[3]*2}"
                    if len(ok_bg) == 4
                    else ok_bg
                )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton{{background-color:{ok_bg};color:white;}}"
                )
        main_dialog_layout.addWidget(self.button_box)
        self.setStyleSheet(
            f"QDialog{{background-color:{DARK_WIDGET_BACKGROUND};}} QLabel{{color:{DARK_TEXT_SECONDARY};background:transparent;padding-top:3px;}} QCheckBox::indicator{{width:13px;height:13px;}} QCheckBox{{color:{DARK_TEXT_SECONDARY};}}"
        )

    def _populate_states_combo(self, combo_box: QComboBox):
        # (Same as v1.0.7)
        try:
            ref_data = self.owner_controller.get_owner_form_reference_data()
            states: List[Dict[str, str]] = ref_data.get("states", [])
            combo_box.blockSignals(True)
            combo_box.clear()
            combo_box.addItem("", None)
            for state_data in states:
                combo_box.addItem(state_data["name"], state_data["id"])
            combo_box.blockSignals(False)
            self.logger.debug(f"Populated states: {len(states)}")
        except Exception as e:
            self.logger.error(f"Error populating states: {e}", exc_info=True)
            QMessageBox.warning(self, "Error", "Could not load states.")

    def validate_and_accept(self):
        # (Same as v1.0.7 - calls self.total_ownership_validator)
        owner_data = {}
        for field_name, widget in self.form_fields.items():
            if isinstance(widget, QLineEdit):
                owner_data[field_name] = widget.text().strip()
            elif isinstance(widget, QComboBox):
                owner_data[field_name] = widget.currentData()
            elif isinstance(widget, QCheckBox):
                owner_data[field_name] = widget.isChecked()
        percentage = self.percentage_input.value()

        is_valid, errors = self.owner_controller.validate_owner_data(
            owner_data, is_new=True
        )
        if not is_valid:
            QMessageBox.warning(
                self,
                "Input Error",
                "Please correct owner details:\n- " + "\n- ".join(errors),
            )
            return
        if not (0.00 <= percentage <= 100.00):
            QMessageBox.warning(
                self,
                "Input Error",
                "Ownership percentage must be between 0.00 and 100.00.",
            )
            return
        if self.total_ownership_validator:
            if not self.total_ownership_validator(
                None, percentage
            ):  # Pass None for owner_id_being_changed (new owner)
                self.logger.debug(
                    "External total ownership validation failed for new owner link."
                )
                return
        self.logger.debug("CreateAndLinkOwnerDialog validation successful, accepting.")
        super().accept()

    def get_data(self) -> Optional[Dict]:
        # (Same as v1.0.7)
        owner_details = {}
        for field_name, widget in self.form_fields.items():
            if isinstance(widget, QLineEdit):
                owner_details[field_name] = widget.text().strip()
            elif isinstance(widget, QComboBox):
                owner_details[field_name] = widget.currentData()
            elif isinstance(widget, QCheckBox):
                owner_details[field_name] = widget.isChecked()
        return {
            "owner_details": owner_details,
            "percentage": self.percentage_input.value(),
        }


=============== FILE: views\horse\dialogs\edit_all_charges_dialog.py ===============

# views/horse/dialogs/edit_all_charges_dialog.py
"""
EDSI Veterinary Management System - Edit All Charges Dialog
Version: 1.1.1
Purpose: A dialog for bulk-editing all un-invoiced charges for a horse.
Last Updated: June 8, 2025
Author: Gemini

Changelog:
- v1.1.1 (2025-06-08):
    - Bug Fix: Added defensive checks to the `_update_totals` method to prevent
      warnings caused by a race condition during dialog initialization.
- v1.1.0 (2025-06-08):
    - Updated the header to display the full, detailed information line for the
      horse, matching the main application screens for consistency.
- v1.0.0 (2025-06-08):
    - Initial creation of the dialog.
"""

import logging
from decimal import Decimal, InvalidOperation
from datetime import date
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QPushButton,
    QLabel,
    QDialogButtonBox,
    QMessageBox,
    QWidget,
    QHBoxLayout,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QLineEdit,
    QCompleter,
    QDoubleSpinBox,
    QCheckBox,
    QAbstractItemView,
    QFormLayout,
    QTextEdit,
    QApplication,
    QAbstractSpinBox,
)
from PySide6.QtCore import Qt, Signal, QTimer, Slot
from PySide6.QtGui import QFont, QColor, QPainter, QPen

from models import Horse, Transaction, ChargeCode
from controllers import FinancialController
from config.app_config import AppConfig


class BoxedCellDelegate(QStyledItemDelegate):
    """A delegate to draw borders around cells to give them a 'boxed' look."""

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index):
        super().paint(painter, option, index)
        painter.save()
        pen = QPen(QColor(AppConfig.DARK_BORDER))
        pen.setWidth(1)
        painter.setPen(pen)
        painter.drawRect(option.rect)
        painter.restore()


class EditAllChargesDialog(QDialog):
    """A dialog for editing a batch of existing charge items for a horse."""

    charges_updated = Signal()

    def __init__(
        self,
        horse: Horse,
        transactions: List[Transaction],
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse = horse
        self.transactions = transactions
        self.financial_controller = financial_controller
        self.current_user_id = QApplication.instance().current_user_id

        self.setWindowTitle(
            f"Edit All Un-invoiced Charges for: {self.horse.horse_name}"
        )
        self.setMinimumSize(1200, 700)

        self._charge_codes_list: List[ChargeCode] = []
        self._charge_code_lookup: Dict[str, ChargeCode] = {}
        self._alt_code_lookup: Dict[str, ChargeCode] = {}
        self._row_notes: Dict[int, str] = {}
        self._current_notes_row: Optional[int] = None
        self._taxable_subtotal = Decimal(0)

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()

        self._populate_header()
        QTimer.singleShot(0, self._load_initial_data)

    def _get_input_field_style(self) -> str:
        """Generates the requested style for all input fields."""
        return f"""
            QLineEdit, QDoubleSpinBox, QTextEdit {{
                background-color: #3E3E3E;
                color: white;
                border: 1px solid white;
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
            }}
            QCheckBox::indicator {{
                width: 14px;
                height: 14px;
                border: 1px solid white;
                border-radius: 3px;
                background-color: #3E3E3E;
            }}
            QCheckBox::indicator:checked {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                border-color: {AppConfig.DARK_SUCCESS_ACTION};
            }}
        """

    def _setup_ui(self):
        """Initializes and lays out the UI widgets based on the new design."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        self.horse_title_label = QLabel()
        self.horse_info_line_label = QLabel()
        header_widget = QWidget()
        header_layout = QVBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.addWidget(self.horse_title_label)
        header_layout.addWidget(self.horse_info_line_label)
        main_layout.addWidget(header_widget)

        table_container = QWidget()
        table_layout = QVBoxLayout(table_container)
        table_layout.setContentsMargins(0, 0, 0, 0)
        self.charges_table = QTableWidget()
        table_layout.addWidget(self.charges_table)
        self.notes_edit = QTextEdit()
        table_layout.addWidget(self.notes_edit)
        table_layout.setStretchFactor(self.charges_table, 3)
        table_layout.setStretchFactor(self.notes_edit, 1)
        main_layout.addWidget(table_container, 1)

        footer_layout = QHBoxLayout()
        footer_layout.setContentsMargins(0, 10, 0, 0)
        self.button_box = QDialogButtonBox()
        self.save_button = self.button_box.addButton(
            "Save Changes", QDialogButtonBox.ButtonRole.AcceptRole
        )
        self.cancel_button = self.button_box.addButton(
            "Cancel", QDialogButtonBox.ButtonRole.RejectRole
        )
        footer_layout.addWidget(self.button_box)
        footer_layout.addStretch()

        totals_container = QWidget()
        totals_form_layout = QFormLayout(totals_container)
        totals_form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        self.subtotal_label = QLabel("$0.00")
        self.taxable_subtotal_label = QLabel("$0.00")
        self.tax_amount_input = QDoubleSpinBox()
        self.tax_rate_input = QDoubleSpinBox()
        self.grand_total_label = QLabel("$0.00")
        tax_layout = QHBoxLayout()
        tax_layout.addWidget(self.tax_rate_input)
        tax_layout.addWidget(self.tax_amount_input)
        totals_form_layout.addRow("Subtotal:", self.subtotal_label)
        totals_form_layout.addRow("Taxable Subtotal:", self.taxable_subtotal_label)
        totals_form_layout.addRow("Tax (% / Amt):", tax_layout)
        totals_form_layout.addRow("<b>Grand Total:</b>", self.grand_total_label)
        footer_layout.addWidget(totals_container)
        main_layout.addLayout(footer_layout)

    def _populate_header(self):
        self.horse_title_label.setText(self.horse.horse_name)
        age_str = self._calculate_age(self.horse.date_of_birth)
        owner_name = self._get_display_owner_name(self.horse)
        location_name = self._get_display_location_name(self.horse)
        info_parts = [
            f"Acct: {self.horse.account_number or 'N/A'}",
            f" {owner_name}",
            f"Breed: {self.horse.breed or 'N/A'}",
            f"Color: {self.horse.color or 'N/A'}",
            f"Sex: {self.horse.sex or 'N/A'}",
            f"Age: {age_str}",
            f" {location_name}",
        ]
        self.horse_info_line_label.setText(" | ".join(info_parts))

    def _apply_styles(self):
        """Applies consistent styling to the dialog's widgets."""
        self.horse_title_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 16, QFont.Weight.Bold)
        )
        self.horse_title_label.setStyleSheet(f"color:{AppConfig.DARK_TEXT_PRIMARY};")
        self.horse_info_line_label.setStyleSheet(
            f"color:{AppConfig.DARK_TEXT_SECONDARY}; font-size: 11px;"
        )

        self.charges_table.setColumnCount(7)
        self.charges_table.setHorizontalHeaderLabels(
            ["Code", "Alt. Code", "Description", "Qty", "Unit Price", "Tax", "Total"]
        )
        self.charges_table.verticalHeader().setVisible(False)
        self.charges_table.setItemDelegate(BoxedCellDelegate(self))
        header = self.charges_table.horizontalHeader()
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        self.charges_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )

        self.notes_edit.setPlaceholderText(
            "Notes for the selected line item will appear here..."
        )

        self.tax_rate_input.setDecimals(4)
        self.tax_rate_input.setRange(0.00, 100.00)
        self.tax_rate_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.tax_rate_input.setSuffix(" %")

        self.tax_amount_input.setDecimals(2)
        self.tax_amount_input.setRange(0.00, 99999.99)
        self.tax_amount_input.setButtonSymbols(QAbstractSpinBox.ButtonSymbols.NoButtons)
        self.tax_amount_input.setPrefix("$ ")

        totals_font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 11)
        self.subtotal_label.setFont(totals_font)
        self.taxable_subtotal_label.setFont(totals_font)
        self.grand_total_label.setFont(
            QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        )

        self.save_button.setMinimumSize(120, 40)
        self.cancel_button.setMinimumSize(120, 40)

        save_button_style = f"""QPushButton {{ background-color: {AppConfig.DARK_SUCCESS_ACTION}; color: white; border: 1px solid {QColor(AppConfig.DARK_SUCCESS_ACTION).darker(120).name()}; border-radius: 4px; }} QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}"""
        cancel_button_style = f"""QPushButton {{ background-color: {AppConfig.DARK_BUTTON_BG}; color: {AppConfig.DARK_TEXT_PRIMARY}; border: 1px solid {AppConfig.DARK_BORDER}; border-radius: 4px; }} QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}"""
        self.save_button.setStyleSheet(save_button_style)
        self.cancel_button.setStyleSheet(cancel_button_style)

        field_style = self._get_input_field_style()
        self.notes_edit.setStyleSheet(field_style)
        self.tax_amount_input.setStyleSheet(field_style)
        self.tax_rate_input.setStyleSheet(field_style)

    def _setup_connections(self):
        self.save_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        self.tax_rate_input.valueChanged.connect(self._calculate_tax_from_rate)
        self.tax_amount_input.valueChanged.connect(self._clear_tax_rate_on_manual_edit)
        self.charges_table.currentCellChanged.connect(self._handle_row_change)
        self.notes_edit.textChanged.connect(self._save_notes_for_current_row)

    def _load_initial_data(self):
        """Populates the table with the transactions passed during init."""
        self.charges_table.setRowCount(len(self.transactions))
        for row, trans in enumerate(self.transactions):
            self._setup_row_widgets(row)
            self._populate_row_from_transaction(row, trans)

        self._update_totals()
        if self.charges_table.rowCount() > 0:
            self.charges_table.setCurrentCell(0, 0)

    def _setup_row_widgets(self, row: int):
        """Places the appropriate widgets into the cells of a given row."""
        field_style = self._get_input_field_style()
        code_item = QTableWidgetItem()
        alt_code_item = QTableWidgetItem()
        desc_item = QTableWidgetItem()

        for item in [code_item, alt_code_item, desc_item]:
            item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEditable)

        self.charges_table.setItem(row, 0, code_item)
        self.charges_table.setItem(row, 1, alt_code_item)
        self.charges_table.setItem(row, 2, desc_item)

        qty_spinbox = QDoubleSpinBox()
        qty_spinbox.setStyleSheet(field_style)
        qty_spinbox.setDecimals(3)
        qty_spinbox.setRange(0.001, 9999.0)
        qty_spinbox.valueChanged.connect(self._update_totals)
        self.charges_table.setCellWidget(row, 3, qty_spinbox)

        price_spinbox = QDoubleSpinBox()
        price_spinbox.setStyleSheet(field_style)
        price_spinbox.setDecimals(2)
        price_spinbox.setRange(0.00, 99999.99)
        price_spinbox.setPrefix("$ ")
        price_spinbox.valueChanged.connect(self._update_totals)
        self.charges_table.setCellWidget(row, 4, price_spinbox)

        tax_checkbox = QCheckBox()
        tax_checkbox.setStyleSheet(field_style)
        tax_checkbox.stateChanged.connect(self._update_totals)
        chk_widget = QWidget()
        chk_layout = QHBoxLayout(chk_widget)
        chk_layout.addWidget(tax_checkbox)
        chk_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        chk_layout.setContentsMargins(0, 0, 0, 0)
        self.charges_table.setCellWidget(row, 5, chk_widget)

        total_item = QTableWidgetItem("$0.00")
        total_item.setTextAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        total_item.setFlags(total_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
        self.charges_table.setItem(row, 6, total_item)

    def _populate_row_from_transaction(self, row: int, trans: Transaction):
        """Fills a pre-made row's widgets with transaction data."""
        self.charges_table.item(row, 0).setData(
            Qt.ItemDataRole.UserRole, trans.transaction_id
        )
        self.charges_table.item(row, 0).setText(
            trans.charge_code.code if trans.charge_code else "N/A"
        )
        self.charges_table.item(row, 1).setText(
            trans.charge_code.alternate_code if trans.charge_code else "N/A"
        )
        self.charges_table.item(row, 2).setText(trans.description)
        self.charges_table.cellWidget(row, 3).setValue(float(trans.quantity))
        self.charges_table.cellWidget(row, 4).setValue(float(trans.unit_price))
        self.charges_table.cellWidget(row, 5).findChild(QCheckBox).setChecked(
            trans.taxable
        )
        self._row_notes[row] = trans.item_notes or ""

    @Slot(int, int, int, int)
    def _handle_row_change(
        self, currentRow, currentColumn, previousRow, previousColumn
    ):
        if previousRow != -1 and previousRow < self.charges_table.rowCount():
            self._save_notes_for_current_row()
        self._current_notes_row = currentRow
        current_notes = self._row_notes.get(currentRow, "")
        self.notes_edit.blockSignals(True)
        self.notes_edit.setPlainText(current_notes)
        self.notes_edit.blockSignals(False)
        self.notes_edit.setPlaceholderText(f"Notes for line {currentRow + 1}...")

    @Slot()
    def _save_notes_for_current_row(self):
        if (
            self._current_notes_row is not None
            and self._current_notes_row < self.charges_table.rowCount()
        ):
            self._row_notes[self._current_notes_row] = (
                self.notes_edit.toPlainText().strip()
            )

    def _update_totals(self):
        subtotal = Decimal(0)
        self._taxable_subtotal = Decimal(0)
        for row in range(self.charges_table.rowCount()):
            try:
                qty_widget = self.charges_table.cellWidget(row, 3)
                price_widget = self.charges_table.cellWidget(row, 4)
                tax_container = self.charges_table.cellWidget(row, 5)

                if qty_widget and price_widget:
                    qty = Decimal(qty_widget.value())
                    price = Decimal(price_widget.value())
                    line_total = (qty * price).quantize(Decimal("0.01"))

                    total_item = self.charges_table.item(row, 6)
                    if not total_item:
                        total_item = QTableWidgetItem()
                        self.charges_table.setItem(row, 6, total_item)
                    total_item.setText(f"${line_total:.2f}")

                    subtotal += line_total
                    if tax_container and tax_container.findChild(QCheckBox).isChecked():
                        self._taxable_subtotal += line_total
            except Exception as e:
                self.logger.warning(f"Could not calculate total for row {row}: {e}")
                continue

        manual_tax = Decimal(self.tax_amount_input.value())
        grand_total = subtotal + manual_tax
        self.subtotal_label.setText(f"${subtotal:.2f}")
        self.taxable_subtotal_label.setText(f"${self._taxable_subtotal:.2f}")
        self.grand_total_label.setText(f"${grand_total:.2f}")

    @Slot(float)
    def _calculate_tax_from_rate(self, rate: float):
        tax_rate = Decimal(rate) / Decimal(100)
        tax_amount = (self._taxable_subtotal * tax_rate).quantize(Decimal("0.01"))
        self.tax_amount_input.blockSignals(True)
        self.tax_amount_input.setValue(float(tax_amount))
        self.tax_amount_input.blockSignals(False)
        self._update_totals()

    @Slot(float)
    def _clear_tax_rate_on_manual_edit(self, amount: float):
        self.tax_rate_input.blockSignals(True)
        self.tax_rate_input.setValue(0.0)
        self.tax_rate_input.blockSignals(False)
        self._update_totals()

    def accept(self):
        """Gathers data and sends updates to the controller."""
        self._save_notes_for_current_row()
        errors = []
        for row in range(self.charges_table.rowCount()):
            trans_id = self.charges_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            if not trans_id:
                continue

            data = {
                "transaction_date": self.transactions[row].transaction_date,
                "description": self.charges_table.item(row, 2).text(),
                "quantity": Decimal(self.charges_table.cellWidget(row, 3).value()),
                "unit_price": Decimal(self.charges_table.cellWidget(row, 4).value()),
                "taxable": self.charges_table.cellWidget(row, 5)
                .findChild(QCheckBox)
                .isChecked(),
                "item_notes": self._row_notes.get(row, "").strip() or None,
            }
            success, message = self.financial_controller.update_charge_transaction(
                transaction_id=trans_id, data=data, current_user_id=self.current_user_id
            )
            if not success:
                errors.append(f"Line {row+1} ({data['description']}): {message}")

        if errors:
            QMessageBox.critical(
                self,
                "Error Saving Charges",
                "Could not save all changes:\n\n" + "\n".join(errors),
            )
        else:
            QMessageBox.information(
                self, "Success", "All charges updated successfully."
            )
            self.charges_updated.emit()
            super().accept()

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"

    def _get_display_owner_name(self, horse: Horse) -> str:
        if not horse.owners:
            return "No Owner Associated"

        first_owner = horse.owners[0]
        name_parts = []
        if first_owner.farm_name:
            name_parts.append(first_owner.farm_name)

        person_name_parts = []
        if first_owner.first_name:
            person_name_parts.append(first_owner.first_name)
        if first_owner.last_name:
            person_name_parts.append(first_owner.last_name)

        person_name_str = " ".join(person_name_parts).strip()
        if person_name_str:
            if name_parts:
                name_parts.append(f"({person_name_str})")
            else:
                name_parts.append(person_name_str)

        return (
            " ".join(name_parts) if name_parts else f"Owner ID: {first_owner.owner_id}"
        )

    def _get_display_location_name(self, horse: Horse) -> str:
        return horse.location.location_name if horse.location else "N/A"


=============== FILE: views\horse\dialogs\edit_charge_dialog.py ===============

# views/horse/dialogs/edit_charge_dialog.py
"""
EDSI Veterinary Management System - Edit Charge Dialog
Version: 1.3.1
Purpose: Dialog for editing the details of a single charge transaction.
         - Corrected styling for read-only fields.
Last Updated: June 8, 2025
Author: Gemini

Changelog:
- v1.3.1 (2025-06-08):
    - Removed a specific style rule for read-only QLineEdits to ensure they
      have the same background color as other input fields for a consistent look.
- v1.3.0 (2025-06-08):
    - Added read-only display fields for "Code" and "Alt. Code" to the top of
      the dialog for better user context.
- v1.2.0 (2025-06-07):
    - Styled the Save (green) and Cancel (gray) buttons with a visible
      border and appropriate colors for better UI consistency and clarity.
- v1.1.0 (2025-06-07):
    - Applied a new, standardized style to all input widgets.
- v1.0.3 (2025-06-07):
    - Bug Fix: Corrected all references to use `item_notes` instead of `notes`.
"""

import logging
from decimal import Decimal, InvalidOperation
from datetime import date
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QDialogButtonBox,
    QMessageBox,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QCheckBox,
    QTextEdit,
    QLabel,
    QHBoxLayout,
)
from PySide6.QtCore import Qt, QDate
from PySide6.QtGui import QPalette, QColor

from models import Transaction
from controllers import FinancialController
from config.app_config import AppConfig


class EditChargeDialog(QDialog):
    """A dialog for editing a single charge item."""

    def __init__(
        self,
        transaction: Transaction,
        financial_controller: FinancialController,
        current_user_id: str,
        parent=None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.transaction = transaction
        self.financial_controller = financial_controller
        self.current_user_id = current_user_id

        self.setWindowTitle(f"Edit Charge: {self.transaction.description[:30]}...")
        self.setMinimumWidth(500)

        self._setup_palette()
        self._setup_ui()
        self._apply_styles()
        self._populate_form()

        self.button_box.accepted.connect(self.save_changes)
        self.button_box.rejected.connect(self.reject)

    def _get_input_field_style(self) -> str:
        """Generates the standard style for all input fields in the dialog."""
        return f"""
            QLineEdit, QDateEdit, QDoubleSpinBox, QTextEdit {{
                background-color: #3E3E3E;
                color: white;
                border: 1px solid white;
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDateEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QCheckBox::indicator {{
                width: 14px;
                height: 14px;
                border: 1px solid white;
                border-radius: 3px;
                background-color: #3E3E3E;
            }}
            QCheckBox::indicator:checked {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                border-color: {AppConfig.DARK_SUCCESS_ACTION};
            }}
        """

    def _setup_palette(self):
        """Sets up the dark theme palette for the dialog."""
        palette = QPalette()
        palette.setColor(
            QPalette.ColorRole.Window, QColor(AppConfig.DARK_WIDGET_BACKGROUND)
        )
        palette.setColor(
            QPalette.ColorRole.WindowText, QColor(AppConfig.DARK_TEXT_PRIMARY)
        )
        self.setPalette(palette)

    def _setup_ui(self):
        """Initializes and lays out the UI widgets."""
        layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.code_display = QLineEdit()
        self.alt_code_display = QLineEdit()
        self.service_date_edit = QDateEdit()
        self.service_date_edit.setCalendarPopup(True)
        self.service_date_edit.setDisplayFormat("yyyy-MM-dd")

        self.description_edit = QLineEdit()
        self.qty_spinbox = QDoubleSpinBox()
        self.price_spinbox = QDoubleSpinBox()
        self.taxable_checkbox = QCheckBox("This item is taxable")
        self.notes_edit = QTextEdit()

        code_layout = QHBoxLayout()
        code_layout.addWidget(self.code_display)
        code_layout.addWidget(QLabel("Alt. Code:"))
        code_layout.addWidget(self.alt_code_display)

        form_layout.addRow("Charge Code:", code_layout)
        form_layout.addRow("Service Date:", self.service_date_edit)
        form_layout.addRow("Description:", self.description_edit)
        form_layout.addRow("Quantity:", self.qty_spinbox)
        form_layout.addRow("Unit Price:", self.price_spinbox)
        form_layout.addRow("", self.taxable_checkbox)
        form_layout.addRow("Item Notes:", self.notes_edit)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Save
            | QDialogButtonBox.StandardButton.Cancel
        )

        layout.addLayout(form_layout)
        layout.addWidget(self.button_box)

    def _apply_styles(self):
        """Applies consistent styling to the dialog's widgets."""
        field_style = self._get_input_field_style()

        self.code_display.setReadOnly(True)
        self.alt_code_display.setReadOnly(True)

        # Apply the same style to all fields
        for widget in [
            self.code_display,
            self.alt_code_display,
            self.service_date_edit,
            self.description_edit,
            self.qty_spinbox,
            self.price_spinbox,
            self.taxable_checkbox,
            self.notes_edit,
        ]:
            widget.setStyleSheet(field_style)

        self.qty_spinbox.setDecimals(3)
        self.qty_spinbox.setRange(0.001, 9999.999)
        self.price_spinbox.setDecimals(2)
        self.price_spinbox.setRange(0.00, 99999.99)
        self.price_spinbox.setPrefix("$ ")
        self.notes_edit.setMinimumHeight(80)

        # Style Save and Cancel buttons
        save_button = self.button_box.button(QDialogButtonBox.StandardButton.Save)
        cancel_button = self.button_box.button(QDialogButtonBox.StandardButton.Cancel)

        save_button_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_SUCCESS_ACTION};
                color: white;
                border: 1px solid {QColor(AppConfig.DARK_SUCCESS_ACTION).darker(120).name()};
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }}
            QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}
        """
        cancel_button_style = f"""
            QPushButton {{
                background-color: {AppConfig.DARK_BUTTON_BG};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 8px 16px;
            }}
            QPushButton:hover {{ background-color: {AppConfig.DARK_BUTTON_HOVER}; }}
        """
        save_button.setStyleSheet(save_button_style)
        cancel_button.setStyleSheet(cancel_button_style)

    def _populate_form(self):
        """Fills the form widgets with data from the transaction object."""
        if self.transaction.charge_code:
            self.code_display.setText(self.transaction.charge_code.code)
            self.alt_code_display.setText(
                self.transaction.charge_code.alternate_code or ""
            )
        else:
            self.code_display.setText("N/A")
            self.alt_code_display.setText("N/A")

        self.service_date_edit.setDate(QDate(self.transaction.transaction_date))
        self.description_edit.setText(self.transaction.description)
        self.qty_spinbox.setValue(float(self.transaction.quantity))
        self.price_spinbox.setValue(float(self.transaction.unit_price))
        self.taxable_checkbox.setChecked(self.transaction.taxable)
        self.notes_edit.setPlainText(self.transaction.item_notes or "")

    def get_data_from_form(self) -> Dict[str, Any]:
        """Collects and returns the current data from the form widgets."""
        return {
            "transaction_date": self.service_date_edit.date().toPython(),
            "description": self.description_edit.text().strip(),
            "quantity": Decimal(str(self.qty_spinbox.value())),
            "unit_price": Decimal(str(self.price_spinbox.value())),
            "taxable": self.taxable_checkbox.isChecked(),
            "item_notes": self.notes_edit.toPlainText().strip() or None,
        }

    def save_changes(self):
        """Validates and saves the changes via the financial controller."""
        updated_data = self.get_data_from_form()

        if not updated_data["description"]:
            QMessageBox.warning(
                self, "Validation Error", "Description cannot be empty."
            )
            return

        success, message = self.financial_controller.update_charge_transaction(
            transaction_id=self.transaction.transaction_id,
            data=updated_data,
            current_user_id=self.current_user_id,
        )

        if success:
            QMessageBox.information(self, "Success", message)
            self.accept()
        else:
            QMessageBox.critical(self, "Error", message)


=============== FILE: views\horse\dialogs\link_existing_owner_dialog.py ===============

# views/horse/dialogs/link_existing_owner_dialog.py
"""
EDSI Veterinary Management System - Link Existing Owner Dialog
Version: 1.0.4
Purpose: Dialog for selecting an existing owner and linking them to a horse.
         Allows 0% ownership and ensures dialog stays open on validation error.
Last Updated: May 19, 2025
Author: Claude Assistant

Changelog:
- v1.0.4 (2025-05-19):
    - Changed percentage_input range and validation to allow 0.00%.
    - Ensured dialog validation logic explicitly keeps dialog open on error.
- v1.0.3 (2025-05-19):
    - Resolved AppConfig constant AttributeError by importing constants directly.
    - Removed import of UserManagementScreen and localized style helper methods.
    - Added missing `from typing import Optional, Dict, List`.
    - Improved UI consistency, label alignment, and QComboBox population logic.
    - Ensured setAutoFillBackground(True) is called after setPalette.
    - Set a base stylesheet for the dialog to ensure `QLabel` color is consistent.
- v1.0.2 (User's May 17th version):
    - Changed percentage_spinbox minimum to 0.00 to allow 0% ownership.
    - Updated percentage validation in `get_data` to allow 0%.
"""
import logging
from typing import Optional, Dict, List

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QComboBox,
    QDoubleSpinBox,
    QDialogButtonBox,
    QMessageBox,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt

from controllers.owner_controller import OwnerController
from models import Owner as OwnerModel

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class LinkExistingOwnerDialog(QDialog):
    def __init__(self, parent_view_or_dialog, horse_name: str):
        super().__init__(parent_view_or_dialog)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_name = horse_name
        self.owner_controller = OwnerController()
        self.owners_list: List[OwnerModel] = []
        self.selected_owner_id: Optional[int] = None

        self.setWindowTitle(f"Link Existing Owner to {self.horse_name}")
        self.setMinimumWidth(500)

        self._setup_palette()
        self._setup_ui()
        self._load_owners_and_search()

    def _get_dialog_specific_input_field_style(self) -> str:
        return f"""
            QLineEdit, QComboBox, QTextEdit, QDoubleSpinBox {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QDoubleSpinBox:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
            QComboBox::drop-down {{ border: none; background-color: transparent; subcontrol-position: right center; width: 15px; }}
            QComboBox::down-arrow {{ image: url(none); }}
            QComboBox QAbstractItemView {{
                background-color: {DARK_WIDGET_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; selection-background-color: {DARK_HIGHLIGHT_BG};
                selection-color: {DARK_HIGHLIGHT_TEXT};
            }} """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _get_dialog_list_widget_style(self) -> str:
        return f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none; border-radius: 4px;
            }}
            QListWidget::item {{ padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND}; }}
            QListWidget::item:selected {{ background-color: {DARK_PRIMARY_ACTION}4D; color: #ffffff; border-left: 3px solid {DARK_PRIMARY_ACTION}; }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }} """

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(12)
        layout.setContentsMargins(15, 15, 15, 15)
        self.setStyleSheet(
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; }}"
        )
        instruction_label = QLabel(
            f"Search for an existing owner to link to <b>{self.horse_name}</b>, select them from the list, then specify their ownership percentage."
        )
        instruction_label.setWordWrap(True)
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 8px; background-color: transparent;"
        )
        layout.addWidget(instruction_label)
        input_style = self._get_dialog_specific_input_field_style()
        list_widget_style = self._get_dialog_list_widget_style()
        search_layout = QHBoxLayout()
        search_label = QLabel("Search Owner:")
        self.owner_search_input = QLineEdit()
        self.owner_search_input.setPlaceholderText("Name or Account #")
        self.owner_search_input.setStyleSheet(input_style)
        self.owner_search_input.textChanged.connect(self._load_owners_and_search)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.owner_search_input, 1)
        layout.addLayout(search_layout)
        self.owner_results_list = QListWidget()
        self.owner_results_list.setStyleSheet(list_widget_style)
        self.owner_results_list.setFixedHeight(150)
        self.owner_results_list.itemClicked.connect(self._on_owner_selected_from_search)
        layout.addWidget(self.owner_results_list)
        self.selected_owner_label = QLabel("Selected Owner:")
        self.selected_owner_display_text = QLabel("<i>No owner selected</i>")
        self.selected_owner_display_text.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-style: italic; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
        )
        self.selected_owner_display_text.setMinimumHeight(20 + 12)
        layout.addWidget(self.selected_owner_label)
        layout.addWidget(self.selected_owner_display_text)
        percentage_layout = QHBoxLayout()
        percentage_label = QLabel("Ownership %:*")
        percentage_label.setAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        self.percentage_spinbox = QDoubleSpinBox()
        self.percentage_spinbox.setStyleSheet(input_style)
        self.percentage_spinbox.setRange(0.00, 100.00)  # MODIFIED: Allow 0.00
        self.percentage_spinbox.setDecimals(2)
        self.percentage_spinbox.setSuffix(" %")
        self.percentage_spinbox.setValue(100.00)
        percentage_layout.addWidget(percentage_label)
        percentage_layout.addWidget(self.percentage_spinbox)
        percentage_layout.addStretch()
        layout.addLayout(percentage_layout)
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText("Link Owner")
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)
        self.button_box.accepted.connect(self._validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if (
                self.button_box.buttonRole(button)
                == QDialogButtonBox.ButtonRole.AcceptRole
            ):
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith("#"):
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _load_owners_and_search(self):
        search_term = (
            self.owner_search_input.text()
            if hasattr(self, "owner_search_input")
            else ""
        )
        try:
            self.owners_list = self.owner_controller.get_all_owners_for_lookup(
                search_term
            )
            self.owner_results_list.blockSignals(True)
            self.owner_results_list.clear()
            if self.owners_list:
                for o_data in self.owners_list:
                    item = QListWidgetItem(o_data["name_account"])
                    item.setData(Qt.ItemDataRole.UserRole, o_data["id"])
                    self.owner_results_list.addItem(item)
            else:
                self.owner_results_list.addItem(
                    "No owners found matching search."
                    if search_term
                    else "No active owners available."
                )
            self.owner_results_list.blockSignals(False)
        except Exception as e:
            self.logger.error(f"Error loading/searching owners: {e}", exc_info=True)
            QMessageBox.critical(
                self, "Load Error", "Could not load existing owners for search."
            )
            self.owner_results_list.blockSignals(True)
            self.owner_results_list.clear()
            self.owner_results_list.addItem("Error loading owners")
            self.owner_results_list.blockSignals(False)
        self._clear_selection_state()

    def _on_owner_selected_from_search(self, item: QListWidgetItem):
        owner_id = item.data(Qt.ItemDataRole.UserRole)
        if owner_id is not None:
            self.selected_owner_id = owner_id
            self.selected_owner_display_text.setText(item.text())
            self.selected_owner_display_text.setStyleSheet(
                f"color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
            )
            self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(True)
            self.logger.info(
                f"Owner selected from search: ID {self.selected_owner_id}, Display: {item.text()}"
            )
        else:
            self._clear_selection_state()

    def _clear_selection_state(self):
        self.selected_owner_id = None
        self.selected_owner_display_text.setText("<i>No owner selected</i>")
        self.selected_owner_display_text.setStyleSheet(
            f"color: {DARK_TEXT_TERTIARY}; font-style: italic; border: 1px solid {DARK_BORDER}; background-color: {DARK_INPUT_FIELD_BACKGROUND}; padding: 6px; border-radius: 4px;"
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)

    def _validate_and_accept(self):
        if self.selected_owner_id is None:
            QMessageBox.warning(
                self,
                "Selection Error",
                "Please search for and select an owner from the list.",
            )
            return  # Keep dialog open
        percentage = self.percentage_spinbox.value()
        if not (0.00 <= percentage <= 100.00):  # MODIFIED: Allow 0.00
            QMessageBox.warning(
                self,
                "Input Error",
                "Ownership percentage must be between 0.00 and 100.00.",
            )
            return  # Keep dialog open
        self.logger.debug("LinkExistingOwnerDialog validation successful, accepting.")
        super().accept()  # Close dialog with Accepted result

    def get_data(self) -> Optional[Dict]:
        if self.selected_owner_id is None:
            return None
        return {
            "owner_id": self.selected_owner_id,
            "percentage": self.percentage_spinbox.value(),
        }


=============== FILE: views\horse\dialogs\record_payment_dialog.py ===============

# views/horse/dialogs/record_payment_dialog.py
"""
EDSI Veterinary Management System - Record Payment Dialog
Version: 1.0.0
Purpose: Dialog for recording a payment against a specific invoice.
Last Updated: June 10, 2025
Author: Gemini
"""
import logging
from decimal import Decimal
from typing import Optional, Dict, Any

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QFormLayout,
    QDialogButtonBox,
    QMessageBox,
    QLineEdit,
    QDateEdit,
    QDoubleSpinBox,
    QComboBox,
    QTextEdit,
    QLabel,
)
from PySide6.QtCore import Qt, QDate
from PySide6.QtGui import QPalette, QColor, QFont

from models import Invoice
from controllers import FinancialController
from config.app_config import AppConfig


class RecordPaymentDialog(QDialog):
    """A dialog for recording a payment for an invoice."""

    PAYMENT_METHODS = ["Check", "Credit Card", "Cash", "Wire Transfer", "Other"]

    def __init__(
        self,
        invoice: Invoice,
        financial_controller: FinancialController,
        current_user_id: str,
        parent=None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.invoice = invoice
        self.financial_controller = financial_controller
        self.current_user_id = current_user_id

        self.setWindowTitle("Record Payment")
        self.setMinimumWidth(500)

        self._setup_ui()
        self._apply_styles()
        self._populate_form()

        self.button_box.accepted.connect(self.save_payment)
        self.button_box.rejected.connect(self.reject)

    def _get_input_field_style(self) -> str:
        return f"""
            QLineEdit, QDateEdit, QDoubleSpinBox, QTextEdit, QComboBox {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                color: {AppConfig.DARK_TEXT_PRIMARY};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDateEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus, QComboBox:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
            }}
        """

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        self.form_layout = QFormLayout()
        self.form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

        self.owner_label = QLabel()
        self.invoice_label = QLabel()
        self.balance_due_label = QLabel()

        self.amount_input = QDoubleSpinBox()
        self.date_input = QDateEdit()
        self.method_combo = QComboBox()
        self.reference_input = QLineEdit()
        self.notes_edit = QTextEdit()

        self.form_layout.addRow("Owner:", self.owner_label)
        self.form_layout.addRow("Invoice #:", self.invoice_label)
        self.form_layout.addRow("Balance Due:", self.balance_due_label)
        self.form_layout.addRow("Payment Amount*:", self.amount_input)
        self.form_layout.addRow("Payment Date*:", self.date_input)
        self.form_layout.addRow("Payment Method*:", self.method_combo)
        self.form_layout.addRow("Reference #:", self.reference_input)
        self.form_layout.addRow("Notes:", self.notes_edit)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(
            "Record Payment"
        )

        layout.addLayout(self.form_layout)
        layout.addWidget(self.button_box)

    def _apply_styles(self):
        self.setStyleSheet(
            f"background-color: {AppConfig.DARK_WIDGET_BACKGROUND}; color: {AppConfig.DARK_TEXT_PRIMARY};"
        )
        input_style = self._get_input_field_style()

        for widget in [
            self.amount_input,
            self.date_input,
            self.method_combo,
            self.reference_input,
            self.notes_edit,
        ]:
            widget.setStyleSheet(input_style)

        for label in [self.owner_label, self.invoice_label, self.balance_due_label]:
            label.setStyleSheet("font-weight: bold;")

        self.amount_input.setRange(0.01, 999999.99)
        self.amount_input.setDecimals(2)
        self.amount_input.setPrefix("$ ")

        self.date_input.setCalendarPopup(True)
        self.date_input.setDisplayFormat("yyyy-MM-dd")

        self.method_combo.addItems(self.PAYMENT_METHODS)
        self.notes_edit.setFixedHeight(60)

    def _populate_form(self):
        owner_name = "N/A"
        if self.invoice.owner:
            owner_name = (
                self.invoice.owner.farm_name
                or f"{self.invoice.owner.first_name} {self.invoice.owner.last_name}"
            )

        self.owner_label.setText(owner_name)
        self.invoice_label.setText(f"INV-{self.invoice.invoice_id}")
        self.balance_due_label.setText(f"${self.invoice.balance_due:.2f}")
        self.amount_input.setValue(float(self.invoice.balance_due))
        self.date_input.setDate(QDate.currentDate())

    def get_data(self) -> Optional[Dict[str, Any]]:
        amount = Decimal(self.amount_input.value())
        if amount <= 0:
            QMessageBox.warning(
                self, "Validation Error", "Payment amount must be greater than zero."
            )
            return None
        if amount > self.invoice.balance_due:
            QMessageBox.warning(
                self,
                "Validation Error",
                "Payment amount cannot be greater than the balance due.",
            )
            return None

        return {
            "invoice_id": self.invoice.invoice_id,
            "owner_id": self.invoice.owner_id,
            "amount": amount,
            "payment_date": self.date_input.date().toPython(),
            "payment_method": self.method_combo.currentText(),
            "reference_number": self.reference_input.text().strip() or None,
            "notes": self.notes_edit.toPlainText().strip() or None,
            "user_id": self.current_user_id,
        }

    def save_payment(self):
        payment_data = self.get_data()
        if not payment_data:
            return

        success, message = self.financial_controller.record_payment(payment_data)

        if success:
            QMessageBox.information(self, "Success", message)
            self.accept()
        else:
            QMessageBox.critical(self, "Error", message)


=============== FILE: views\horse\dialogs\select_existing_location_dialog.py ===============

# views/horse/dialogs/select_existing_location_dialog.py
"""
EDSI Veterinary Management System - Select Existing Location Dialog
Version: 1.0.0
Purpose: Dialog for searching and selecting an existing active location.
Last Updated: May 20, 2025
Author: Gemini

Changelog:
- v1.0.0 (2025-05-20):
    - Initial implementation.
    - UI with search input (QLineEdit) and results list (QListWidget).
    - Fetches active locations using LocationController.
    - Search functionality filters locations by name (case-insensitive).
    - "Select Location" (OK) button enabled only when a location is selected.
    - Provides get_selected_location_id() method.
    - Styled for dark theme.
"""

import logging
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QDialogButtonBox,
    QApplication,  # For clipboard
)
from PySide6.QtGui import QPalette, QColor
from PySide6.QtCore import Qt, QTimer

from controllers.location_controller import LocationController
from models import Location as LocationModel  # Import the model

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_ITEM_HOVER,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DARK_PRIMARY_ACTION,
    DARK_HIGHLIGHT_BG,
    DARK_HIGHLIGHT_TEXT,
    DARK_TEXT_TERTIARY,
    DARK_TEXT_SECONDARY,
    DARK_SUCCESS_ACTION,
    DARK_BORDER,
    DARK_HEADER_FOOTER,
)


class SelectExistingLocationDialog(QDialog):
    """Dialog to search and select an existing active location."""

    def __init__(self, parent_view, horse_name: str):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_name = horse_name
        self.location_controller = LocationController()
        self.all_active_locations: List[LocationModel] = []
        self.selected_location_id: Optional[int] = None

        self.setWindowTitle(f"Select Location for {self.horse_name}")
        self.setMinimumWidth(450)
        self.setMinimumHeight(350)

        self._setup_palette()
        self._setup_ui()
        self._load_initial_locations()

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self._filter_locations_list)

    def _get_dialog_specific_input_field_style(self) -> str:
        return f"""
            QLineEdit {{
                background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY};
                border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 6px; min-height: 20px;
            }}
            QLineEdit:focus {{ border-color: {DARK_PRIMARY_ACTION}; }}
        """

    def _get_dialog_generic_button_style(self) -> str:
        return (
            f"QPushButton {{background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _get_dialog_list_widget_style(self) -> str:
        return f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none; border-radius: 4px;
            }}
            QListWidget::item {{ padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER}; background-color: {DARK_WIDGET_BACKGROUND}; }}
            QListWidget::item:selected {{ background-color: {DARK_PRIMARY_ACTION}4D; color: #ffffff; border-left: 3px solid {DARK_PRIMARY_ACTION}; }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }}
        """

    def _setup_palette(self):
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Base, QColor(DARK_INPUT_FIELD_BACKGROUND))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(DARK_ITEM_HOVER))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(DARK_WIDGET_BACKGROUND))
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Text, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.Button, QColor(DARK_BUTTON_BG))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(DARK_TEXT_PRIMARY))
        palette.setColor(QPalette.ColorRole.BrightText, QColor(Qt.GlobalColor.red))
        palette.setColor(QPalette.ColorRole.Link, QColor(DARK_PRIMARY_ACTION))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(DARK_HIGHLIGHT_BG))
        palette.setColor(
            QPalette.ColorRole.HighlightedText, QColor(DARK_HIGHLIGHT_TEXT)
        )
        palette.setColor(QPalette.ColorRole.PlaceholderText, QColor(DARK_TEXT_TERTIARY))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)
        self.setStyleSheet(
            f"QLabel {{ color: {DARK_TEXT_SECONDARY}; background-color: transparent; padding-top: 3px; }}"
        )

        instruction_label = QLabel(
            f"Search for and select a location to assign to <b>{self.horse_name}</b>."
        )
        instruction_label.setWordWrap(True)
        instruction_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-bottom: 5px; background-color: transparent;"
        )
        layout.addWidget(instruction_label)

        input_style = self._get_dialog_specific_input_field_style()
        list_widget_style = self._get_dialog_list_widget_style()

        search_layout = QHBoxLayout()
        search_label = QLabel("Search Location:")
        self.location_search_input = QLineEdit()
        self.location_search_input.setPlaceholderText(
            "Enter location name to search..."
        )
        self.location_search_input.setStyleSheet(input_style)
        self.location_search_input.textChanged.connect(self._on_search_text_changed)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.location_search_input, 1)
        layout.addLayout(search_layout)

        self.locations_results_list = QListWidget()
        self.locations_results_list.setStyleSheet(list_widget_style)
        self.locations_results_list.itemClicked.connect(self._on_location_selected)
        layout.addWidget(self.locations_results_list, 1)  # Give stretch factor

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        self.ok_button.setText("Select Location")
        self.ok_button.setEnabled(False)  # Disabled until a location is selected

        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

        generic_button_style = self._get_dialog_generic_button_style()
        for button in self.button_box.buttons():
            button.setMinimumHeight(30)
            button.setStyleSheet(generic_button_style)
            if button == self.ok_button:
                ok_bg_color = DARK_SUCCESS_ACTION
                if len(ok_bg_color) == 4 and ok_bg_color.startswith(
                    "#"
                ):  # Expand 3-digit hex
                    ok_bg_color = (
                        f"#{ok_bg_color[1]*2}{ok_bg_color[2]*2}{ok_bg_color[3]*2}"
                    )
                button.setStyleSheet(
                    generic_button_style
                    + f"QPushButton {{ background-color: {ok_bg_color}; color: white; }}"
                )
        layout.addWidget(self.button_box)

    def _load_initial_locations(self):
        try:
            self.all_active_locations = self.location_controller.get_all_locations(
                status_filter="active"
            )
            self._filter_locations_list()  # Populate initially with all active
            self.logger.info(
                f"Loaded {len(self.all_active_locations)} active locations initially."
            )
        except Exception as e:
            self.logger.error(
                f"Error loading initial active locations: {e}", exc_info=True
            )
            QMessageBox.critical(self, "Load Error", "Could not load active locations.")
            self.locations_results_list.addItem("Error loading locations.")

    def _on_search_text_changed(self):
        self.search_timer.start(300)  # Debounce search

    def _filter_locations_list(self):
        search_term = self.location_search_input.text().strip().lower()
        self.locations_results_list.clear()
        self.selected_location_id = None  # Clear selection on new search
        self.ok_button.setEnabled(False)

        found_any = False
        for loc in self.all_active_locations:
            if search_term in loc.location_name.lower():
                item_text = f"{loc.location_name}"
                if loc.city and loc.state_code:
                    item_text += f" ({loc.city}, {loc.state_code})"
                elif loc.city:
                    item_text += f" ({loc.city})"

                list_item = QListWidgetItem(item_text)
                list_item.setData(Qt.ItemDataRole.UserRole, loc.location_id)
                self.locations_results_list.addItem(list_item)
                found_any = True

        if not found_any:
            self.locations_results_list.addItem(
                "No locations match your search."
                if search_term
                else "No active locations found."
            )

    def _on_location_selected(self, item: QListWidgetItem):
        location_id = item.data(Qt.ItemDataRole.UserRole)
        if location_id is not None:
            self.selected_location_id = location_id
            self.ok_button.setEnabled(True)
            self.logger.info(
                f"Location selected: ID {self.selected_location_id}, Display: {item.text()}"
            )
        else:
            self.selected_location_id = None
            self.ok_button.setEnabled(False)
            self.logger.info("Location selection cleared or invalid item clicked.")

    def get_selected_location_id(self) -> Optional[int]:
        """Returns the ID of the selected location if the dialog was accepted."""
        if self.result() == QDialog.DialogCode.Accepted:
            return self.selected_location_id
        return None


=============== FILE: views\horse\tabs\__init__.py ===============



=============== FILE: views\horse\tabs\basic_info_tab.py ===============

# views/horse/tabs/basic_info_tab.py
"""
EDSI Veterinary Management System - Horse Basic Info Tab
Version: 1.4.1
Purpose: UI for displaying and editing basic information of a horse.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.4.1 (2025-06-09):
    - Bug Fix: Corrected logic in `update_buttons_state` to enable Save/Discard
      buttons immediately when entering Add or Edit mode.
- v1.4.0 (2025-06-08):
    - Bug Fix: Corrected the logic in `update_buttons_state` to ensure the
      "Deactivate/Activate Horse" button is enabled whenever a horse is
      selected, not only when the form is in edit mode.
"""

import logging
from typing import Optional, Dict, Any, TYPE_CHECKING
from datetime import date

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGridLayout,
    QLineEdit,
    QDateEdit,
    QLabel,
    QComboBox,
    QFrame,
    QScrollArea,
    QHBoxLayout,
    QPushButton,
    QTextEdit,
    QFormLayout,
)
from PySide6.QtCore import Qt, Signal, QDate, QSize
from PySide6.QtGui import QDoubleValidator, QIcon, QColor, QFont

from controllers.horse_controller import HorseController
from config.app_config import AppConfig


if TYPE_CHECKING:
    from models import Horse, Owner as OwnerModel


class BasicInfoTab(QWidget):
    data_modified = Signal()
    save_requested = Signal()
    discard_requested = Signal()
    toggle_active_requested = Signal(bool)
    edit_mode_toggled = Signal(bool)

    SEX_OPTIONS = ["Unknown", "Stallion", "Mare", "Gelding", "Colt", "Filly"]

    INPUT_FIELD_STYLE = (
        "background-color: #3E3E3E; "
        "color: white; "
        "border: 1px solid #B0B0B0; "
        "border-radius: 3px; "
        "padding: 5px;"
    )
    TEXT_AREA_STYLE = INPUT_FIELD_STYLE
    COMBO_DATE_STYLE = INPUT_FIELD_STYLE
    DEACTIVATE_BUTTON_STYLE = (
        "QPushButton {"
        "background-color: #FFC107; color: black; border: 1px solid #707070; "
        "border-radius: 3px; padding: 6px 12px; }"
        "QPushButton:hover { background-color: #FFD54F; }"
        "QPushButton:pressed { background-color: #FFA000; }"
    )
    DISCARD_BUTTON_STYLE = (
        "QPushButton {"
        "background-color: #212121; color: white; border: 1px solid #707070; "
        "border-radius: 3px; padding: 6px 12px; }"
        "QPushButton:hover { background-color: #424242; }"
        "QPushButton:pressed { background-color: #000000; }"
    )
    SAVE_BUTTON_STYLE = (
        f"QPushButton {{"
        f"background-color: {AppConfig.DARK_SUCCESS_ACTION}; color: white; border: 1px solid #707070; "
        f"border-radius: 3px; padding: 6px 12px; }}"
        f"QPushButton:hover {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).lighter(115).name()}; }}"
        f"QPushButton:pressed {{ background-color: {QColor(AppConfig.DARK_SUCCESS_ACTION).darker(110).name()}; }}"
    )

    def __init__(
        self,
        horse_controller: Optional[HorseController] = None,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.horse_controller = (
            horse_controller if horse_controller else HorseController()
        )
        self.parent_view: Optional[QWidget] = parent

        self.current_horse_id: Optional[int] = None
        self._is_new_mode: bool = False
        self._is_editing: bool = False
        self._has_unsaved_changes: bool = False
        self._current_horse_is_active: bool = True

        self.horse_name_input: QLineEdit
        self.breed_input: QLineEdit
        self.sex_combo: QComboBox
        self.reg_number_input: QLineEdit
        self.tattoo_number_input: QLineEdit
        self.location_display_label: QLabel
        self.owner_display_label: QLabel
        self.account_number_input: QLineEdit
        self.color_input: QLineEdit
        self.dob_input: QDateEdit
        self.microchip_id_input: QLineEdit
        self.brand_input: QLineEdit
        self.band_tag_input: QLineEdit
        self.coggins_date_input: QDateEdit
        self.height_input: QLineEdit
        self.description_input: QTextEdit
        self.save_btn: QPushButton
        self.discard_btn: QPushButton
        self.toggle_active_btn: QPushButton

        self._suppress_data_changed_signal = False
        self._setup_ui()
        self.set_form_read_only(True)
        self.update_buttons_state(
            is_editing_or_new=False, has_selection=False, has_changes=False
        )

    def _setup_ui(self):
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        scroll_area = QScrollArea(self)
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        content_widget = QWidget()
        outer_layout = QVBoxLayout(content_widget)
        outer_layout.setContentsMargins(15, 15, 15, 15)
        outer_layout.setSpacing(15)
        top_grid_layout = QGridLayout()
        top_grid_layout.setSpacing(10)
        top_grid_layout.setHorizontalSpacing(20)
        top_grid_layout.setColumnStretch(1, 1)
        top_grid_layout.setColumnStretch(3, 1)

        # UI Fields (full implementation)
        self.horse_name_input = QLineEdit()
        self.horse_name_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(QLabel("Name*:"), 0, 0, Qt.AlignmentFlag.AlignRight)
        top_grid_layout.addWidget(self.horse_name_input, 0, 1)

        self.account_number_input = QLineEdit()
        self.account_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(
            QLabel("Account Number:"), 0, 2, Qt.AlignmentFlag.AlignRight
        )
        top_grid_layout.addWidget(self.account_number_input, 0, 3)

        self.breed_input = QLineEdit()
        self.breed_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(QLabel("Breed:"), 1, 0, Qt.AlignmentFlag.AlignRight)
        top_grid_layout.addWidget(self.breed_input, 1, 1)

        self.color_input = QLineEdit()
        self.color_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(QLabel("Color:"), 1, 2, Qt.AlignmentFlag.AlignRight)
        top_grid_layout.addWidget(self.color_input, 1, 3)

        self.sex_combo = QComboBox()
        self.sex_combo.addItems(self.SEX_OPTIONS)
        self.sex_combo.currentIndexChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(QLabel("Sex:"), 2, 0, Qt.AlignmentFlag.AlignRight)
        top_grid_layout.addWidget(self.sex_combo, 2, 1)

        self.dob_input = QDateEdit()
        self.dob_input.setCalendarPopup(True)
        self.dob_input.setDisplayFormat("yyyy-MM-dd")
        self.dob_input.setDate(QDate(2000, 1, 1))
        self.dob_input.setMaximumDate(QDate.currentDate())
        self.dob_input.setSpecialValueText(" ")
        self.dob_input.dateChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(
            QLabel("Date of Birth:"), 2, 2, Qt.AlignmentFlag.AlignRight
        )
        top_grid_layout.addWidget(self.dob_input, 2, 3)

        self.reg_number_input = QLineEdit()
        self.reg_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(
            QLabel("Reg. Number:"), 3, 0, Qt.AlignmentFlag.AlignRight
        )
        top_grid_layout.addWidget(self.reg_number_input, 3, 1)

        self.microchip_id_input = QLineEdit()
        self.microchip_id_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(
            QLabel("Microchip ID:"), 3, 2, Qt.AlignmentFlag.AlignRight
        )
        top_grid_layout.addWidget(self.microchip_id_input, 3, 3)

        self.tattoo_number_input = QLineEdit()
        self.tattoo_number_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(QLabel("Tattoo:"), 4, 0, Qt.AlignmentFlag.AlignRight)
        top_grid_layout.addWidget(self.tattoo_number_input, 4, 1)

        self.brand_input = QLineEdit()
        self.brand_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(QLabel("Brand:"), 4, 2, Qt.AlignmentFlag.AlignRight)
        top_grid_layout.addWidget(self.brand_input, 4, 3)

        self.location_display_label = QLabel("N/A")
        top_grid_layout.addWidget(
            QLabel("Location:"), 5, 0, Qt.AlignmentFlag.AlignRight
        )
        top_grid_layout.addWidget(self.location_display_label, 5, 1)

        self.band_tag_input = QLineEdit()
        self.band_tag_input.textChanged.connect(self._on_data_modified)
        top_grid_layout.addWidget(
            QLabel("Band/Tag:"), 5, 2, Qt.AlignmentFlag.AlignRight
        )
        top_grid_layout.addWidget(self.band_tag_input, 5, 3)

        self.owner_display_label = QLabel("N/A")
        top_grid_layout.addWidget(QLabel("Owner:"), 6, 0, Qt.AlignmentFlag.AlignRight)
        top_grid_layout.addWidget(self.owner_display_label, 6, 1)

        outer_layout.addLayout(top_grid_layout)

        coggins_height_layout = QGridLayout()
        coggins_height_layout.setSpacing(10)
        coggins_height_layout.setHorizontalSpacing(20)
        coggins_height_layout.setColumnStretch(1, 1)
        coggins_height_layout.setColumnStretch(3, 1)

        self.coggins_date_input = QDateEdit()
        self.coggins_date_input.setCalendarPopup(True)
        self.coggins_date_input.setDisplayFormat("yyyy-MM-dd")
        self.coggins_date_input.setDate(QDate(2000, 1, 1))
        self.coggins_date_input.setSpecialValueText(" ")
        self.coggins_date_input.dateChanged.connect(self._on_data_modified)
        coggins_height_layout.addWidget(
            QLabel("Coggins Date:"), 0, 0, Qt.AlignmentFlag.AlignRight
        )
        coggins_height_layout.addWidget(self.coggins_date_input, 0, 1)

        self.height_input = QLineEdit()
        double_validator = QDoubleValidator(0.00, 99.99, 2)
        double_validator.setNotation(QDoubleValidator.Notation.StandardNotation)
        self.height_input.setValidator(double_validator)
        self.height_input.textChanged.connect(self._on_data_modified)
        coggins_height_layout.addWidget(
            QLabel("Height (Hands):"), 0, 2, Qt.AlignmentFlag.AlignRight
        )
        coggins_height_layout.addWidget(self.height_input, 0, 3)
        outer_layout.addLayout(coggins_height_layout)

        description_form_layout = QFormLayout()
        description_form_layout.setContentsMargins(0, 0, 0, 0)
        description_form_layout.setSpacing(10)
        description_form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        self.description_input = QTextEdit()
        self.description_input.setFixedHeight(80)
        self.description_input.textChanged.connect(self._on_data_modified)
        description_form_layout.addRow(
            QLabel("Description/Markings:"), self.description_input
        )
        outer_layout.addLayout(description_form_layout)

        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setSpacing(10)
        self.toggle_active_btn = QPushButton("Deactivate Horse")
        self.toggle_active_btn.clicked.connect(self._request_toggle_active)
        self.discard_btn = QPushButton("Discard Changes")
        self.discard_btn.clicked.connect(self.discard_requested.emit)
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self.save_requested.emit)
        button_layout.addWidget(self.toggle_active_btn)
        button_layout.addStretch()
        button_layout.addWidget(self.discard_btn)  # Swapped order
        button_layout.addWidget(self.save_btn)  # Swapped order
        outer_layout.addWidget(button_frame)

        outer_layout.addStretch(1)
        scroll_area.setWidget(content_widget)
        self.main_layout.addWidget(scroll_area)

        # Apply Styles
        for widget in content_widget.findChildren(QLineEdit):
            widget.setStyleSheet(self.INPUT_FIELD_STYLE)
        for widget in content_widget.findChildren(QDateEdit):
            widget.setStyleSheet(self.COMBO_DATE_STYLE)
        for widget in content_widget.findChildren(QComboBox):
            widget.setStyleSheet(self.COMBO_DATE_STYLE)
        for widget in content_widget.findChildren(QTextEdit):
            widget.setStyleSheet(self.TEXT_AREA_STYLE)
        for widget in [self.owner_display_label, self.location_display_label]:
            widget.setStyleSheet(self.INPUT_FIELD_STYLE)
        self.save_btn.setStyleSheet(self.SAVE_BUTTON_STYLE)
        self.discard_btn.setStyleSheet(self.DISCARD_BUTTON_STYLE)
        self.toggle_active_btn.setStyleSheet(self.DEACTIVATE_BUTTON_STYLE)

    def _request_toggle_active(self):
        self.toggle_active_requested.emit(self._current_horse_is_active)

    def update_toggle_active_button_text(self, is_active: bool):
        self.toggle_active_btn.setText(
            "Deactivate Horse" if is_active else "Activate Horse"
        )
        self._current_horse_is_active = is_active

    def populate_form_data(self, horse_data: Optional["Horse"]):
        self.logger.debug(
            f"Populating BasicInfoTab with horse_data: {horse_data.horse_name if horse_data else 'None'}"
        )
        self._suppress_data_changed_signal = True
        if horse_data:
            self.current_horse_id = horse_data.horse_id
            self.horse_name_input.setText(horse_data.horse_name or "")
            self.account_number_input.setText(horse_data.account_number or "")
            self.breed_input.setText(horse_data.breed or "")
            self.color_input.setText(horse_data.color or "")
            sex_idx = self.sex_combo.findText(
                horse_data.sex or "Unknown", Qt.MatchFlag.MatchFixedString
            )
            self.sex_combo.setCurrentIndex(sex_idx if sex_idx >= 0 else 0)
            if horse_data.date_of_birth:
                self.dob_input.setDate(
                    QDate.fromString(str(horse_data.date_of_birth), "yyyy-MM-dd")
                )
            else:
                self.dob_input.setDate(self.dob_input.minimumDate().addDays(-1))
                self.dob_input.setDate(QDate(2000, 1, 1))
            self.reg_number_input.setText(getattr(horse_data, "reg_number", "") or "")
            self.microchip_id_input.setText(horse_data.chip_number or "")
            self.tattoo_number_input.setText(horse_data.tattoo_number or "")
            self.brand_input.setText(getattr(horse_data, "brand", "") or "")
            self.band_tag_input.setText(getattr(horse_data, "band_tag", "") or "")
            self.location_display_label.setText(
                horse_data.location.location_name if horse_data.location else "N/A"
            )
            self.owner_display_label.setText(self._get_display_owner_name(horse_data))
            if horse_data.coggins_date:
                self.coggins_date_input.setDate(
                    QDate.fromString(str(horse_data.coggins_date), "yyyy-MM-dd")
                )
            else:
                self.coggins_date_input.setDate(
                    self.coggins_date_input.minimumDate().addDays(-1)
                )
                self.coggins_date_input.setDate(QDate(2000, 1, 1))
            self.height_input.setText(
                f"{horse_data.height_hands:.2f}"
                if horse_data.height_hands is not None
                else ""
            )
            self.description_input.setPlainText(horse_data.description or "")
            self.update_toggle_active_button_text(horse_data.is_active)
            self.set_form_read_only(True)
            self._is_new_mode = False
            self._is_editing = False
            self.update_buttons_state(
                is_editing_or_new=False, has_selection=True, has_changes=False
            )
        else:
            self.clear_fields(suppress_signal=True)
            self.set_form_read_only(True)
            self._is_new_mode = False
            self._is_editing = False
            self.update_buttons_state(
                is_editing_or_new=False, has_selection=False, has_changes=False
            )
        self._has_unsaved_changes = False
        self._suppress_data_changed_signal = False

    def _on_data_modified(self, *args):
        if self._suppress_data_changed_signal:
            return
        if not self.horse_name_input.isReadOnly():
            if not self._has_unsaved_changes:
                self._has_unsaved_changes = True
                self.logger.debug("Data modified. Flag set.")
                self.data_modified.emit()
            self.update_buttons_state(
                is_editing_or_new=(self._is_new_mode or self._is_editing),
                has_selection=(self.current_horse_id is not None),
                has_changes=True,
            )

    def get_data_from_form(self) -> Dict[str, Any]:
        def get_date_object(date_edit_widget: QDateEdit) -> Optional[date]:
            q_date = date_edit_widget.date()
            if (
                date_edit_widget.text().strip() == ""
                or q_date < date_edit_widget.minimumDate()
                or not q_date.isValid()
                or q_date == date_edit_widget.minimumDate().addDays(-1)
            ):
                return None
            return date(q_date.year(), q_date.month(), q_date.day())

        data = {
            "horse_name": self.horse_name_input.text().strip() or None,
            "account_number": self.account_number_input.text().strip() or None,
            "breed": self.breed_input.text().strip() or None,
            "color": self.color_input.text().strip() or None,
            "sex": (
                self.sex_combo.currentText()
                if self.sex_combo.currentText() != "Unknown"
                else None
            ),
            "date_of_birth": get_date_object(self.dob_input),
            "chip_number": self.microchip_id_input.text().strip() or None,
            "tattoo_number": self.tattoo_number_input.text().strip() or None,
            "is_active": self._current_horse_is_active,
            "reg_number": self.reg_number_input.text().strip() or None,
            "brand": self.brand_input.text().strip() or None,
            "band_tag": self.band_tag_input.text().strip() or None,
            "coggins_date": get_date_object(self.coggins_date_input),
            "height_hands": (
                float(self.height_input.text())
                if self.height_input.text().strip()
                else None
            ),
            "description": self.description_input.toPlainText().strip() or None,
            "date_deceased": None,
        }
        return data

    def set_form_read_only(self, read_only: bool):
        self.logger.debug(f"BasicInfoTab.set_form_read_only: {read_only}")
        self._suppress_data_changed_signal = True
        line_edit_fields = [
            self.horse_name_input,
            self.account_number_input,
            self.breed_input,
            self.color_input,
            self.reg_number_input,
            self.microchip_id_input,
            self.tattoo_number_input,
            self.brand_input,
            self.band_tag_input,
            self.height_input,
        ]
        for field in line_edit_fields:
            field.setReadOnly(read_only)
        interactive_widgets = [self.sex_combo, self.dob_input, self.coggins_date_input]
        for widget in interactive_widgets:
            widget.setEnabled(not read_only)
        self.description_input.setReadOnly(read_only)
        self._is_editing = not read_only
        if read_only:
            self._has_unsaved_changes = False
        self._suppress_data_changed_signal = False

    def clear_fields(self, suppress_signal: bool = False):
        if suppress_signal:
            self._suppress_data_changed_signal = True
        self.current_horse_id = None
        self.horse_name_input.clear()
        self.account_number_input.clear()
        self.breed_input.clear()
        self.color_input.clear()
        self.sex_combo.setCurrentIndex(0)
        self.dob_input.setDate(self.dob_input.minimumDate().addDays(-1))
        self.dob_input.setDate(QDate(2000, 1, 1))
        self.reg_number_input.clear()
        self.microchip_id_input.clear()
        self.tattoo_number_input.clear()
        self.brand_input.clear()
        self.band_tag_input.clear()
        self.location_display_label.setText("N/A")
        self.owner_display_label.setText("N/A")
        self.coggins_date_input.setDate(
            self.coggins_date_input.minimumDate().addDays(-1)
        )
        self.coggins_date_input.setDate(QDate(2000, 1, 1))
        self.height_input.clear()
        self.description_input.clear()
        self.update_toggle_active_button_text(True)
        if suppress_signal:
            self._suppress_data_changed_signal = False
        self._has_unsaved_changes = False
        if not suppress_signal:
            self.data_modified.emit()

    def set_new_mode(self, is_new: bool):
        self.logger.info(f"BasicInfoTab set_new_mode: {is_new}")
        self._is_new_mode = is_new
        self._is_editing = True
        self.current_horse_id = None
        self.clear_fields(suppress_signal=True)
        self.set_form_read_only(False)
        self._has_unsaved_changes = False
        self.update_buttons_state(
            is_editing_or_new=True, has_selection=False, has_changes=False
        )
        self.edit_mode_toggled.emit(True)
        self.horse_name_input.setFocus()

    def set_edit_mode(self, editable: bool):
        self.logger.info(f"BasicInfoTab set_edit_mode: {editable}")
        self._is_new_mode = False
        self._is_editing = editable
        self.set_form_read_only(not editable)
        if editable:
            self._has_unsaved_changes = False
            self.horse_name_input.setFocus()
        self.update_buttons_state(
            is_editing_or_new=editable,
            has_selection=(self.current_horse_id is not None),
            has_changes=self._has_unsaved_changes,
        )
        self.edit_mode_toggled.emit(editable)

    def update_buttons_state(
        self, is_editing_or_new: bool, has_selection: bool, has_changes: bool
    ):
        can_save = (is_editing_or_new or self._is_editing) and has_changes
        can_discard = is_editing_or_new or self._is_editing
        can_toggle_active = has_selection and not self._is_new_mode

        self.save_btn.setEnabled(
            can_save or is_editing_or_new
        )  # Enable Save immediately in new/edit mode
        self.discard_btn.setEnabled(can_discard)
        self.toggle_active_btn.setEnabled(can_toggle_active)

        if not has_selection and not self._is_new_mode:
            self.update_toggle_active_button_text(True)
            self.toggle_active_btn.setEnabled(False)
        elif self._is_new_mode:
            self.update_toggle_active_button_text(True)
            self.toggle_active_btn.setEnabled(False)

    def has_unsaved_changes(self) -> bool:
        return self._has_unsaved_changes

    def mark_as_saved(self):
        self.logger.debug("BasicInfoTab.mark_as_saved.")
        self._has_unsaved_changes = False
        self._is_editing = False
        self.set_form_read_only(True)
        self.update_buttons_state(False, (self.current_horse_id is not None), False)

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yr" if age_val == 1 else f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"

    def _get_display_owner_name(self, horse: "Horse") -> str:
        if not horse.owners:
            return "No Owner Associated"
        first_owner = horse.owners[0]
        name_parts = []
        if first_owner.farm_name:
            name_parts.append(first_owner.farm_name)
        person_name_parts = []
        if first_owner.first_name:
            person_name_parts.append(first_owner.first_name)
        if first_owner.last_name:
            person_name_parts.append(first_owner.last_name)
        person_name_str = " ".join(person_name_parts).strip()
        if person_name_str:
            if name_parts:
                name_parts.append(f"({person_name_str})")
            else:
                name_parts.append(person_name_str)
        return (
            " ".join(name_parts) if name_parts else f"Owner ID: {first_owner.owner_id}"
        )

    def _get_display_location_name(self, horse: "Horse") -> str:
        return horse.location.location_name if horse.location else "N/A"


=============== FILE: views\horse\tabs\billing_tab.py ===============

# views/horse/tabs/billing_tab.py
"""
EDSI Veterinary Management System - Horse Billing Tab
Version: 1.9.0
Purpose: UI for displaying and managing billing charges for a specific horse.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.9.0 (2025-06-09):
    - Added invoice_created signal to notify parent views when an invoice
      has been successfully generated, allowing other UI components to refresh.
- v1.8.0 (2025-06-09):
    - Updated `load_transactions` to use the refactored `get_transactions_for_horse`
      controller method that now filters by status instead of an 'invoiced' flag.
- v1.7.0 (2025-06-09):
    - Refactored `_create_invoice` to call `generate_invoices_from_transactions`.
"""

import logging
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QTableWidget,
    QPushButton,
    QHBoxLayout,
    QHeaderView,
    QAbstractItemView,
    QTableWidgetItem,
    QMessageBox,
    QDialog,
    QApplication,
    QLabel,
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QFont, QColor

from models import Horse, Transaction
from controllers import FinancialController
from ..dialogs.add_charge_dialog import AddChargeDialog
from ..dialogs.edit_charge_dialog import EditChargeDialog
from ..dialogs.edit_all_charges_dialog import EditAllChargesDialog
from config.app_config import AppConfig


class BillingTab(QWidget):
    status_message = Signal(str)
    invoice_created = Signal()

    def __init__(
        self,
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.financial_controller = financial_controller
        self.current_horse: Optional[Horse] = None
        self.transactions: List[Transaction] = []

        self._setup_ui()
        self._setup_connections()
        self.clear_display()

    def _create_action_button(
        self,
        text: str,
        icon_char: str,
        base_color: str,
        border_color: Optional[str] = None,
    ) -> QPushButton:
        button = QPushButton(f" {icon_char}  {text}")
        font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 10)
        font.setBold(True)
        button.setFont(font)
        button.setMinimumHeight(36)

        border_style = (
            f"border: 1px solid {border_color};" if border_color else "border: none;"
        )

        button.setStyleSheet(
            f"""
            QPushButton {{
                background-color: {base_color};
                color: white;
                border-radius: 5px;
                padding: 5px 15px;
                text-align: center;
                {border_style}
            }}
            QPushButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
                border: 1px solid {AppConfig.DARK_TEXT_TERTIARY};
            }}
            QPushButton:hover {{
                background-color: {QColor(base_color).lighter(115).name()};
            }}
        """
        )
        return button

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        action_layout = QHBoxLayout()
        action_layout.setSpacing(10)

        self.add_charge_btn = self._create_action_button(
            "Add New Charges", "", AppConfig.DARK_SUCCESS_ACTION
        )
        self.edit_charge_btn = self._create_action_button(
            "Edit Selected",
            "",
            AppConfig.DARK_BUTTON_BG,
            AppConfig.DARK_PRIMARY_ACTION,
        )
        self.edit_all_btn = self._create_action_button(
            "Edit All", "", AppConfig.DARK_BUTTON_BG, AppConfig.DARK_PRIMARY_ACTION
        )
        self.delete_charge_btn = self._create_action_button(
            "Delete Selected",
            "",
            AppConfig.DARK_BUTTON_BG,
            AppConfig.DARK_DANGER_ACTION,
        )
        self.create_invoice_btn = self._create_action_button(
            "Create Invoice", "", AppConfig.DARK_PRIMARY_ACTION
        )

        action_layout.addWidget(self.add_charge_btn)
        action_layout.addWidget(self.edit_charge_btn)
        action_layout.addWidget(self.edit_all_btn)
        action_layout.addWidget(self.delete_charge_btn)
        action_layout.addStretch()
        action_layout.addWidget(self.create_invoice_btn)
        main_layout.addLayout(action_layout)

        self.title_label = QLabel("Un-invoiced Charges")
        font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold)
        self.title_label.setFont(font)
        self.title_label.setStyleSheet(
            f"color: {AppConfig.DARK_TEXT_SECONDARY}; margin-top: 10px;"
        )
        main_layout.addWidget(self.title_label)

        self.transactions_table = QTableWidget()
        self.transactions_table.setColumnCount(7)
        self.transactions_table.setHorizontalHeaderLabels(
            ["ID", "Code", "Alt. Code", "Description", "Qty", "Unit Price", "Total"]
        )
        self.transactions_table.setEditTriggers(
            QAbstractItemView.EditTrigger.NoEditTriggers
        )
        self.transactions_table.setSelectionBehavior(
            QAbstractItemView.SelectionBehavior.SelectRows
        )
        self.transactions_table.setSelectionMode(
            QAbstractItemView.SelectionMode.SingleSelection
        )
        self.transactions_table.verticalHeader().setVisible(False)
        self.transactions_table.horizontalHeader().setStretchLastSection(True)
        self.transactions_table.horizontalHeader().setSectionResizeMode(
            3, QHeaderView.ResizeMode.Stretch
        )
        self.transactions_table.setColumnHidden(0, True)
        self.transactions_table.setStyleSheet(
            f"""
            QTableWidget {{
                gridline-color: {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                border-radius: 4px;
            }}
            QHeaderView::section {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                padding: 5px;
                border: none;
                border-bottom: 1px solid {AppConfig.DARK_BORDER};
            }}
            QTableWidget::item {{ padding: 5px; }}
            QTableWidget::item:selected {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """
        )
        main_layout.addWidget(self.transactions_table)

        total_layout = QHBoxLayout()
        total_layout.addStretch()
        total_due_title_label = QLabel("Total Due:")
        font.setPointSize(14)
        total_due_title_label.setFont(font)
        self.total_due_label = QLabel("$0.00")
        self.total_due_label.setFont(font)
        self.total_due_label.setStyleSheet("color: white;")

        total_layout.addWidget(total_due_title_label)
        total_layout.addWidget(self.total_due_label)
        main_layout.addLayout(total_layout)

    def _setup_connections(self):
        self.add_charge_btn.clicked.connect(self._launch_add_charge_dialog)
        self.edit_charge_btn.clicked.connect(self._edit_selected_charge)
        self.edit_all_btn.clicked.connect(self._launch_edit_all_charges_dialog)
        self.delete_charge_btn.clicked.connect(self._delete_selected_charge)
        self.create_invoice_btn.clicked.connect(self._create_invoice)
        self.transactions_table.itemSelectionChanged.connect(self.update_buttons_state)
        self.transactions_table.cellDoubleClicked.connect(self._edit_selected_charge)

    def set_current_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.load_transactions()
        self.update_buttons_state()

    def load_transactions(self):
        if not self.current_horse:
            self.clear_display()
            return
        self.transactions = self.financial_controller.get_transactions_for_horse(
            self.current_horse.horse_id
        )
        self.populate_transactions_table()

    def populate_transactions_table(self):
        self.transactions_table.setRowCount(0)
        if self.transactions:
            self.transactions_table.setRowCount(len(self.transactions))
            for row, trans in enumerate(self.transactions):
                trans_id = trans.transaction_id
                id_item = QTableWidgetItem(str(trans_id))
                id_item.setData(Qt.ItemDataRole.UserRole, trans_id)
                self.transactions_table.setItem(row, 0, id_item)

                code = trans.charge_code.code if trans.charge_code else "N/A"
                alt_code = (
                    trans.charge_code.alternate_code if trans.charge_code else "N/A"
                )

                self.transactions_table.setItem(row, 1, QTableWidgetItem(code))
                self.transactions_table.setItem(row, 2, QTableWidgetItem(alt_code))
                self.transactions_table.setItem(
                    row, 3, QTableWidgetItem(trans.description)
                )
                self.transactions_table.setItem(
                    row, 4, QTableWidgetItem(str(trans.quantity))
                )
                self.transactions_table.setItem(
                    row, 5, QTableWidgetItem(f"{trans.unit_price:.2f}")
                )
                self.transactions_table.setItem(
                    row, 6, QTableWidgetItem(f"{trans.total_price:.2f}")
                )
        self._update_total_due_display()
        self.update_buttons_state()

    def clear_display(self):
        self.transactions_table.setRowCount(0)
        self.transactions = []
        self.current_horse = None
        self.update_buttons_state()
        self._update_total_due_display()

    def update_buttons_state(self):
        has_horse = self.current_horse is not None
        has_transactions = len(self.transactions) > 0
        has_selection = (
            has_transactions and len(self.transactions_table.selectedItems()) > 0
        )

        self.add_charge_btn.setEnabled(has_horse)
        self.edit_charge_btn.setEnabled(has_selection)
        self.edit_all_btn.setEnabled(has_transactions)
        self.delete_charge_btn.setEnabled(has_selection)
        self.create_invoice_btn.setEnabled(has_transactions)

    def _update_total_due_display(self):
        total_due = sum(
            trans.total_price
            for trans in self.transactions
            if trans and hasattr(trans, "total_price")
        )
        self.total_due_label.setText(f"${total_due:.2f}")

    def _create_invoice(self):
        """Handler for the 'Create Invoice' button."""
        if not self.current_horse or not self.transactions:
            self.status_message.emit("No charges available to create an invoice.")
            return

        transaction_ids = [t.transaction_id for t in self.transactions]
        total_due = sum(t.total_price for t in self.transactions)

        current_user_id = (
            self.parent_view.current_user
            if hasattr(self.parent_view, "current_user")
            else "Unknown"
        )
        owner_count = len(self.current_horse.owner_associations)

        confirmation_message = (
            f"This will generate {owner_count} separate invoice(s) for all owners of {self.current_horse.horse_name}, "
            f"splitting a total of ${total_due:.2f} based on their ownership percentage.\n\nProceed?"
        )

        if self.parent_view.show_question(
            "Confirm Invoice Generation", confirmation_message
        ):
            success, message, new_invoices = (
                self.financial_controller.generate_invoices_from_transactions(
                    source_transaction_ids=transaction_ids,
                    current_user_id=current_user_id,
                )
            )
            if success:
                self.status_message.emit(message)
                self.load_transactions()
                self.invoice_created.emit()
            else:
                self.parent_view.show_error("Invoice Creation Failed", message)

    def _launch_add_charge_dialog(self):
        if not self.current_horse:
            return
        dialog = AddChargeDialog(self.current_horse, self.financial_controller, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit(
                f"New charges added for {self.current_horse.horse_name}."
            )
            self.load_transactions()

    def _launch_edit_all_charges_dialog(self):
        if not self.current_horse or not self.transactions:
            return
        dialog = EditAllChargesDialog(
            self.current_horse, self.transactions, self.financial_controller, self
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit(
                f"Charges updated for {self.current_horse.horse_name}."
            )
            self.load_transactions()

    @Slot(int, int)
    def _edit_selected_charge(self, row=None, column=None):
        selected_items = self.transactions_table.selectedItems()
        if not selected_items:
            return

        selected_row = selected_items[0].row()
        transaction_id = self.transactions_table.item(selected_row, 0).data(
            Qt.ItemDataRole.UserRole
        )

        transaction_to_edit = self.financial_controller.get_transaction_by_id(
            transaction_id
        )
        if not transaction_to_edit:
            QMessageBox.critical(
                self, "Error", "Could not find the selected transaction to edit."
            )
            return

        dialog = EditChargeDialog(
            transaction=transaction_to_edit,
            financial_controller=self.financial_controller,
            current_user_id=QApplication.instance().current_user_id,
            parent=self,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit("Charge updated successfully.")
            self.load_transactions()

    def _delete_selected_charge(self):
        selected_items = self.transactions_table.selectedItems()
        if not selected_items:
            return

        row = selected_items[0].row()
        transaction_id = self.transactions_table.item(row, 0).data(
            Qt.ItemDataRole.UserRole
        )
        description = self.transactions_table.item(row, 3).text()

        if self.parent_view and hasattr(self.parent_view, "show_question"):
            reply_is_yes = self.parent_view.show_question(
                "Confirm Delete",
                f"Are you sure you want to delete this charge?\n\n- {description}",
            )
        else:
            reply = QMessageBox.question(
                self,
                "Confirm Delete",
                f"Are you sure you want to delete this charge?\n\n- {description}",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
            reply_is_yes = reply == QMessageBox.StandardButton.Yes

        if reply_is_yes:
            success, message = self.financial_controller.delete_charge_transaction(
                transaction_id
            )
            if success:
                self.status_message.emit(message)
                self.load_transactions()
            else:
                QMessageBox.critical(self, "Error", message)


=============== FILE: views\horse\tabs\invoice_history_tab.py ===============

# views/horse/tabs/invoice_history_tab.py
"""
EDSI Veterinary Management System - Invoice History Tab
Version: 2.5.0
Purpose: UI for displaying and managing historical invoices for a horse's owners.
Last Updated: June 10, 2025
Author: Gemini

Changelog:
- v2.5.0 (2025-06-10):
    - Added "Record Payment" button and workflow.
    - Button is enabled for single, unpaid invoices.
    - Launches the new RecordPaymentDialog.
    - Added `payment_recorded` signal to notify parent view to refresh data.
- v2.4.0 (2025-06-10):
    - Fixed bug in _on_invoice_selected where details would not show.
    - Enabled batch emailing and deleting for multiple selected invoices.
- v2.3.0 (2025-06-10):
    - Enabled multi-selection (ExtendedSelection) on the main invoices table.
    - Refactored _print_selected_invoice to handle batch saving to a directory.
- v2.2.0 (2025-06-09):
    - Updated PDF save locations to use the new `AppConfig.INVOICES_DIR`.
- v2.1.0 (2025-06-09):
    - Added "Email Invoice" button and functionality.
"""
import logging
import os
import webbrowser
import urllib.parse
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QTableWidget,
    QPushButton,
    QHBoxLayout,
    QHeaderView,
    QAbstractItemView,
    QTableWidgetItem,
    QLabel,
    QFileDialog,
    QMessageBox,
    QDialog,
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QFont, QColor

from models import Horse, Invoice, Transaction
from controllers import FinancialController, CompanyProfileController
from reports import InvoiceGenerator
from config.app_config import AppConfig
from ..dialogs.record_payment_dialog import RecordPaymentDialog


class InvoiceHistoryTab(QWidget):
    """Tab widget for displaying and managing invoice history."""

    status_message = Signal(str)
    invoice_deleted = Signal()
    payment_recorded = Signal()

    def __init__(
        self,
        financial_controller: FinancialController,
        parent: Optional[QWidget] = None,
    ):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent
        self.financial_controller = financial_controller
        self.company_profile_controller = CompanyProfileController()
        self.current_horse: Optional[Horse] = None
        self.invoices: List[Invoice] = []

        self._setup_ui()
        self._setup_connections()

    def _create_action_button(
        self,
        text: str,
        icon_char: str,
        base_color: str,
        border_color: Optional[str] = None,
    ) -> QPushButton:
        button = QPushButton(f" {icon_char}  {text}")
        font = QFont(AppConfig.DEFAULT_FONT_FAMILY, 10)
        font.setBold(True)
        button.setFont(font)
        button.setMinimumHeight(36)

        border_style = (
            f"border: 1px solid {border_color};" if border_color else "border: none;"
        )

        button.setStyleSheet(
            f"""
            QPushButton {{
                background-color: {base_color};
                color: white;
                border-radius: 5px;
                padding: 5px 15px;
                text-align: center;
                {border_style}
            }}
            QPushButton:disabled {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_TERTIARY};
                border: 1px solid {AppConfig.DARK_TEXT_TERTIARY};
            }}
            QPushButton:hover {{
                background-color: {QColor(base_color).lighter(115).name()};
            }}
        """
        )
        return button

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        action_layout = QHBoxLayout()
        self.record_payment_btn = self._create_action_button(
            "Record Payment", "", AppConfig.DARK_SUCCESS_ACTION
        )
        self.email_invoice_btn = self._create_action_button(
            "Email Selected Invoice(s)",
            "",
            AppConfig.DARK_BUTTON_BG,
            AppConfig.DARK_PRIMARY_ACTION,
        )
        self.print_invoice_btn = self._create_action_button(
            "Print Selected Invoice(s)",
            "",
            AppConfig.DARK_BUTTON_BG,
            AppConfig.DARK_PRIMARY_ACTION,
        )
        self.delete_invoice_btn = self._create_action_button(
            "Delete Selected Invoice(s)", "", AppConfig.DARK_DANGER_ACTION
        )

        action_layout.addWidget(self.record_payment_btn)
        action_layout.addStretch()
        action_layout.addWidget(self.email_invoice_btn)
        action_layout.addWidget(self.print_invoice_btn)
        action_layout.addWidget(self.delete_invoice_btn)
        main_layout.addLayout(action_layout)

        main_layout.addWidget(QLabel("All Invoices for This Horse's Owners"))
        self.invoices_table = self._create_table(
            ["Invoice #", "Date", "Billed To", "Total", "Balance Due", "Status"],
            multi_select=True,
        )
        self.invoices_table.horizontalHeader().setSectionResizeMode(
            0, QHeaderView.ResizeMode.ResizeToContents
        )
        self.invoices_table.horizontalHeader().setSectionResizeMode(
            2, QHeaderView.ResizeMode.Stretch
        )
        self.invoices_table.horizontalHeader().setSectionResizeMode(
            5, QHeaderView.ResizeMode.Stretch
        )
        main_layout.addWidget(self.invoices_table)

        main_layout.addWidget(QLabel("Details for Selected Invoice"))
        self.invoice_details_table = self._create_table(
            ["Date", "Code", "Description", "Qty", "Unit Price", "Line Total"]
        )
        self.invoice_details_table.horizontalHeader().setSectionResizeMode(
            2, QHeaderView.ResizeMode.Stretch
        )
        main_layout.addWidget(self.invoice_details_table)

        main_layout.setStretchFactor(self.invoices_table, 2)
        main_layout.setStretchFactor(self.invoice_details_table, 1)

        self.update_buttons_state()

    def _create_table(
        self, headers: List[str], multi_select: bool = False
    ) -> QTableWidget:
        table = QTableWidget()
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)

        if multi_select:
            table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        else:
            table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)

        table.verticalHeader().setVisible(False)
        table.setStyleSheet(
            f"""
            QTableWidget {{
                gridline-color: {AppConfig.DARK_BORDER};
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                border-radius: 4px;
            }}
            QHeaderView::section {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
                padding: 5px; border: none;
                border-bottom: 1px solid {AppConfig.DARK_BORDER};
            }}
            QTableWidget::item {{ padding: 5px; }}
            QTableWidget::item:selected {{
                background-color: {AppConfig.DARK_PRIMARY_ACTION};
                color: {AppConfig.DARK_HIGHLIGHT_TEXT};
            }}
        """
        )
        return table

    def _setup_connections(self):
        self.invoices_table.itemSelectionChanged.connect(self._on_invoice_selected)
        self.print_invoice_btn.clicked.connect(self._print_selected_invoice)
        self.email_invoice_btn.clicked.connect(self._email_selected_invoice)
        self.delete_invoice_btn.clicked.connect(self._delete_selected_invoice)
        self.record_payment_btn.clicked.connect(self._launch_record_payment_dialog)

    def set_current_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.load_invoices()

    def load_invoices(self):
        self.invoices_table.setRowCount(0)
        self.invoice_details_table.setRowCount(0)

        if not self.current_horse or not self.current_horse.owners:
            self.invoices = []
            self.update_buttons_state()
            return

        owner_ids = {owner.owner_id for owner in self.current_horse.owners}
        all_invoices = []
        for owner_id in owner_ids:
            owner_invoices = self.financial_controller.get_invoices_for_owner(owner_id)
            all_invoices.extend(owner_invoices)

        self.invoices = sorted(
            all_invoices, key=lambda inv: inv.invoice_date, reverse=True
        )

        for inv in self.invoices:
            row = self.invoices_table.rowCount()
            self.invoices_table.insertRow(row)

            owner_name = "N/A"
            if inv.owner:
                owner_name = (
                    inv.owner.farm_name
                    or f"{inv.owner.first_name} {inv.owner.last_name}"
                )

            self.invoices_table.setItem(
                row, 0, QTableWidgetItem(f"INV-{inv.invoice_id}")
            )
            self.invoices_table.setItem(
                row, 1, QTableWidgetItem(inv.invoice_date.strftime("%Y-%m-%d"))
            )
            self.invoices_table.setItem(row, 2, QTableWidgetItem(owner_name))
            self.invoices_table.setItem(
                row, 3, QTableWidgetItem(f"${inv.grand_total:.2f}")
            )
            self.invoices_table.setItem(
                row, 4, QTableWidgetItem(f"${inv.balance_due:.2f}")
            )
            self.invoices_table.setItem(row, 5, QTableWidgetItem(inv.status))
            self.invoices_table.item(row, 0).setData(
                Qt.ItemDataRole.UserRole, inv.invoice_id
            )

        self.update_buttons_state()

    def _on_invoice_selected(self):
        self.invoice_details_table.setRowCount(0)
        selected_rows = self.invoices_table.selectionModel().selectedRows()

        if len(selected_rows) == 1:
            selected_row_index = selected_rows[0].row()
            invoice_id = self.invoices_table.item(selected_row_index, 0).data(
                Qt.ItemDataRole.UserRole
            )
            transactions = self.financial_controller.get_transactions_for_invoice(
                invoice_id
            )
            for trans in transactions:
                row = self.invoice_details_table.rowCount()
                self.invoice_details_table.insertRow(row)
                self.invoice_details_table.setItem(
                    row,
                    0,
                    QTableWidgetItem(trans.transaction_date.strftime("%Y-%m-%d")),
                )
                self.invoice_details_table.setItem(
                    row,
                    1,
                    QTableWidgetItem(
                        trans.charge_code.code if trans.charge_code else ""
                    ),
                )
                self.invoice_details_table.setItem(
                    row, 2, QTableWidgetItem(trans.description)
                )
                self.invoice_details_table.setItem(
                    row, 3, QTableWidgetItem(str(trans.quantity))
                )
                self.invoice_details_table.setItem(
                    row, 4, QTableWidgetItem(f"${trans.unit_price:.2f}")
                )
                self.invoice_details_table.setItem(
                    row, 5, QTableWidgetItem(f"${trans.total_price:.2f}")
                )

        self.update_buttons_state()

    def _get_selected_invoices(self) -> List[Invoice]:
        """Helper to get the full Invoice objects for all selected rows."""
        selected_invoices = []
        selected_rows = self.invoices_table.selectionModel().selectedRows()
        if not selected_rows:
            return []

        selected_ids = {
            self.invoices_table.item(row.row(), 0).data(Qt.ItemDataRole.UserRole)
            for row in selected_rows
        }

        for inv in self.invoices:
            if inv.invoice_id in selected_ids:
                selected_invoices.append(inv)
        return selected_invoices

    def _launch_record_payment_dialog(self):
        selected_invoices = self._get_selected_invoices()
        if len(selected_invoices) != 1:
            self.status_message.emit(
                "Please select a single invoice to record a payment."
            )
            return

        invoice_to_pay = selected_invoices[0]
        if invoice_to_pay.balance_due <= 0:
            self.status_message.emit("This invoice has been fully paid.")
            return

        current_user_id = (
            self.parent_view.current_user
            if hasattr(self.parent_view, "current_user")
            else "Unknown"
        )
        dialog = RecordPaymentDialog(
            invoice=invoice_to_pay,
            financial_controller=self.financial_controller,
            current_user_id=current_user_id,
            parent=self,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.status_message.emit(
                f"Payment recorded for Invoice #{invoice_to_pay.invoice_id}."
            )
            self.payment_recorded.emit()

    def _email_selected_invoice(self):
        """Generates a PDF of the invoice and opens the user's mail client."""
        selected_invoices = self._get_selected_invoices()
        if not selected_invoices:
            self.status_message.emit("Please select one or more invoices to email.")
            return

        if len(selected_invoices) > 1:
            reply = self.parent_view.show_question(
                "Confirm Batch Email",
                f"This will attempt to open {len(selected_invoices)} separate draft emails. Do you want to continue?",
            )
            if not reply:
                return

        company_profile = self.company_profile_controller.get_company_profile()
        company_name = (
            company_profile.company_name if company_profile else "Your Company"
        )
        invoices_dir = AppConfig.INVOICES_DIR
        generator = InvoiceGenerator()

        for inv in selected_invoices:
            owner = inv.owner
            if not owner or not owner.email:
                self.parent_view.show_warning(
                    "Missing Information",
                    f"Invoice INV-{inv.invoice_id} cannot be emailed because the owner has no email address.",
                )
                continue

            pdf_filename = f"Invoice-{inv.invoice_id} for {owner.last_name}.pdf"
            file_path = os.path.join(invoices_dir, pdf_filename)

            try:
                success, message = generator.generate_invoice_pdf(
                    inv.invoice_id, file_path
                )
                if not success:
                    self.parent_view.show_error(
                        "PDF Error",
                        f"Failed to generate PDF for INV-{inv.invoice_id}:\n{message}",
                    )
                    continue
            except Exception as e:
                self.logger.error(
                    f"An unexpected error occurred during PDF generation for INV-{inv.invoice_id}: {e}",
                    exc_info=True,
                )
                self.parent_view.show_error(
                    "Critical Error",
                    f"An unexpected error occurred during PDF generation for INV-{inv.invoice_id}:\n{e}",
                )
                continue

            subject = f"Invoice from {company_name}"
            body = f"Dear {owner.first_name or owner.last_name},\n\nPlease find your invoice attached.\n\nThank you,\n{company_name}"
            mailto_url = f"mailto:{owner.email}?subject={urllib.parse.quote(subject)}&body={urllib.parse.quote(body)}"
            webbrowser.open(mailto_url)

        QMessageBox.information(
            self,
            "Email Process Complete",
            f"Your email client should have opened with drafts for the selected invoices.\n\n"
            f"The invoice PDFs have been saved to the 'invoices' folder.\n\n"
            "Please attach the correct file to each email before sending.",
        )

    def _print_selected_invoice(self):
        selected_invoices = self._get_selected_invoices()
        if not selected_invoices:
            self.status_message.emit("Please select one or more invoices to print.")
            return

        if len(selected_invoices) > 1:
            folder_path = QFileDialog.getExistingDirectory(
                self, "Select Folder to Save Invoices", AppConfig.INVOICES_DIR
            )
            if not folder_path:
                self.logger.info("Batch PDF save was cancelled by the user.")
                return

            generator = InvoiceGenerator()
            for inv in selected_invoices:
                file_path = os.path.join(folder_path, f"Invoice-{inv.invoice_id}.pdf")
                generator.generate_invoice_pdf(inv.invoice_id, file_path)

            QMessageBox.information(
                self,
                "Success",
                f"{len(selected_invoices)} invoices successfully saved to:\n{folder_path}",
            )
        else:
            selected_invoice = selected_invoices[0]
            default_filename = f"Invoice-{selected_invoice.invoice_id}.pdf"
            default_path = os.path.join(AppConfig.INVOICES_DIR, default_filename)
            file_path, _ = QFileDialog.getSaveFileName(
                self, "Save Invoice PDF", default_path, "PDF Files (*.pdf)"
            )
            if not file_path:
                return

            try:
                generator = InvoiceGenerator()
                success, message = generator.generate_invoice_pdf(
                    selected_invoice.invoice_id, file_path
                )
                if success:
                    self.parent_view.show_info(
                        "Success", f"Invoice successfully saved to:\n{file_path}"
                    )
                else:
                    self.parent_view.show_error(
                        "Error", f"Failed to generate PDF:\n{message}"
                    )
            except Exception as e:
                self.logger.error(
                    f"An unexpected error occurred during PDF generation: {e}",
                    exc_info=True,
                )
                self.parent_view.show_error(
                    "Critical Error", f"An unexpected error occurred:\n{e}"
                )

    def _delete_selected_invoice(self):
        selected_invoices = self._get_selected_invoices()
        if not selected_invoices:
            self.status_message.emit("Please select one or more invoices to delete.")
            return

        invoice_list_str = "\n - ".join(
            [f"INV-{inv.invoice_id}" for inv in selected_invoices]
        )
        warning_message = (
            f"Are you sure you want to permanently delete the following {len(selected_invoices)} invoice(s)?\n\n- {invoice_list_str}\n\n"
            "This will adjust each owner's balance accordingly.\n\n"
            "<b>IMPORTANT:</b> This action will NOT make the original charges billable again. "
            "This action cannot be undone."
        )

        if self.parent_view.show_question("Confirm Delete Invoice(s)", warning_message):
            current_user_id = (
                self.parent_view.current_user
                if hasattr(self.parent_view, "current_user")
                else "Unknown"
            )
            success_count = 0
            for inv in selected_invoices:
                success, message = self.financial_controller.delete_invoice(
                    inv.invoice_id, current_user_id
                )
                if success:
                    success_count += 1
                else:
                    self.parent_view.show_error(
                        f"Deletion Failed for INV-{inv.invoice_id}", message
                    )

            if success_count > 0:
                self.status_message.emit(
                    f"Successfully deleted {success_count} invoice(s)."
                )
                self.invoice_deleted.emit()

    def update_buttons_state(self):
        selection_count = len(self.invoices_table.selectionModel().selectedRows())

        self.print_invoice_btn.setEnabled(selection_count > 0)
        self.email_invoice_btn.setEnabled(selection_count > 0)
        self.delete_invoice_btn.setEnabled(selection_count > 0)

        has_single_unpaid_selection = False
        if selection_count == 1:
            selected_invoice = self._get_selected_invoices()[0]
            if selected_invoice.balance_due > 0:
                has_single_unpaid_selection = True

        self.record_payment_btn.setEnabled(has_single_unpaid_selection)


=============== FILE: views\horse\tabs\location_tab.py ===============

# views/horse/tabs/location_tab.py
"""
EDSI Veterinary Management System - Horse Location Tab
Version: 1.0.1
Purpose: Manages the assignment of a single location to a horse.
         - Modified assign/remove location logic to call HorseController for
           database persistence BEFORE emitting location_assignment_changed signal,
           ensuring data integrity and proper UI updates in parent views.
Last Updated: May 25, 2025
Author: Gemini

Changelog:
- v1.0.1 (2025-05-25):
    - Refactored `_assign_location_to_horse`: Now calls
      `horse_controller.assign_horse_to_location` to save the assignment
      to the database. Emits `location_assignment_changed` only on successful save.
      Updates local UI based on controller success.
    - Refactored `_handle_remove_location_link`: Now calls
      `horse_controller.remove_horse_from_location` to update the database.
      Emits `location_assignment_changed` (with None for location) only on
      successful removal. Updates local UI based on controller success.
    - Ensured user feedback (info/error messages) is provided based on the
      outcome of controller operations.
- v1.0.0 (2025-05-20):
    - Initial implementation.
    - UI with current location display (QLabel).
    - Buttons: "Create New & Link Location", "Link Existing Location", "Remove Location Link".
    - Integrates AddEditLocationDialog and SelectExistingLocationDialog.
    - Emits location_assignment_changed(location_id: Optional[int], location_name: Optional[str]) signal.
"""

import logging
from typing import Optional, Dict

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFrame,
    QDialog,
    QMessageBox,  # Explicitly imported for clarity, though parent_view might handle
)
from PySide6.QtCore import Qt, Signal

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_TEXT_SECONDARY,
    DARK_BORDER,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_SUCCESS_ACTION,
    DARK_PRIMARY_ACTION,
    DARK_DANGER_ACTION,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
)
from models import (
    Horse,
)  # LocationModel not directly used here, controller returns names/ids
from controllers.horse_controller import HorseController
from controllers.location_controller import LocationController
from views.admin.dialogs.add_edit_location_dialog import AddEditLocationDialog
from views.horse.dialogs.select_existing_location_dialog import (
    SelectExistingLocationDialog,
)


class LocationTab(QWidget):
    """Tab widget for managing a horse's single assigned location."""

    location_assignment_changed = Signal(
        object
    )  # Emits a dict: {'id': Optional[int], 'name': Optional[str]}

    def __init__(
        self,
        parent_view,
        horse_controller: HorseController,
        location_controller: LocationController,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_controller = horse_controller
        self.location_controller = location_controller

        self.current_horse: Optional[Horse] = None
        self._current_location_id: Optional[int] = None
        self._current_location_name: str = "N/A"

        self.current_user_login = "UnknownUser"
        if hasattr(self.parent_view, "current_user") and self.parent_view.current_user:
            self.current_user_login = self.parent_view.current_user
        else:
            self.logger.warning(
                "Could not determine current_user for LocationTab auditing."
            )

        self.setStyleSheet(f"background-color: {DARK_WIDGET_BACKGROUND};")
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(15)

        self._setup_ui(main_layout)
        self._setup_connections()
        self.update_buttons_state()

    def _get_generic_button_style(self) -> str:
        if hasattr(self.parent_view, "get_generic_button_style"):
            return self.parent_view.get_generic_button_style()
        return (
            f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; "
            f"font-size: 12px; font-weight: 500; min-height: 28px;}} "
            f"QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} "
            f"QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"
        )

    def _setup_ui(self, main_layout: QVBoxLayout):
        location_display_frame = QFrame()
        location_display_frame.setStyleSheet("background-color: transparent;")
        location_display_layout = QHBoxLayout(location_display_frame)
        location_display_layout.setContentsMargins(0, 0, 0, 10)

        current_location_title_label = QLabel("Currently Assigned Location:")
        current_location_title_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-weight: bold; background: transparent;"
        )
        self.current_location_display_label = QLabel(self._current_location_name)
        self.current_location_display_label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; font-size: 14px; background-color: {DARK_INPUT_FIELD_BACKGROUND}; "
            f"border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; min-height: 22px;"
        )
        self.current_location_display_label.setWordWrap(True)

        location_display_layout.addWidget(current_location_title_label)
        location_display_layout.addWidget(self.current_location_display_label, 1)
        main_layout.addWidget(location_display_frame)

        action_buttons_layout = QHBoxLayout()
        self.create_link_location_btn = QPushButton(" Create New & Assign Location")
        self.link_existing_location_btn = QPushButton(" Assign Existing Location")
        self.remove_location_link_btn = QPushButton(" Clear Assigned Location")

        button_style = self._get_generic_button_style()
        self.create_link_location_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_SUCCESS_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        self.link_existing_location_btn.setStyleSheet(
            button_style.replace(
                DARK_BUTTON_BG, DARK_PRIMARY_ACTION
            )  # Assuming default text color is fine
        )
        self.remove_location_link_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_DANGER_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )

        action_buttons_layout.addWidget(self.create_link_location_btn)
        action_buttons_layout.addWidget(self.link_existing_location_btn)
        action_buttons_layout.addWidget(self.remove_location_link_btn)
        action_buttons_layout.addStretch()
        main_layout.addLayout(action_buttons_layout)
        main_layout.addStretch(1)

    def _setup_connections(self):
        self.create_link_location_btn.clicked.connect(
            self._handle_create_and_link_location
        )
        self.link_existing_location_btn.clicked.connect(
            self._handle_link_existing_location
        )
        self.remove_location_link_btn.clicked.connect(self._handle_remove_location_link)

    def load_location_for_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.logger.debug(
            f"LocationTab: Loading location for horse: {horse.horse_name if horse else 'None'}"
        )
        if self.current_horse and self.current_horse.horse_id is not None:
            # The horse object passed might already be eager-loaded by HorseUnifiedManagement
            # If not, self.horse_controller.get_horse_by_id() would re-fetch.
            # For consistency, let's use the passed horse object directly if its location is loaded.
            # If horse.location is not loaded, then a fresh fetch might be needed,
            # but this should ideally be handled by the caller providing a fully loaded horse.

            # Let's assume the passed 'horse' object has its .location eager-loaded
            # by HorseUnifiedManagement calling HorseController.get_horse_by_id().
            self._current_location_id = self.current_horse.current_location_id
            if self.current_horse.location and hasattr(
                self.current_horse.location, "location_name"
            ):
                self._current_location_name = (
                    self.current_horse.location.location_name or "N/A"
                )
            else:
                self._current_location_name = (
                    "N/A"  # If location object is None or no name
                )

            self.logger.debug(
                f"LocationTab: Horse ID {self.current_horse.horse_id}, "
                f"current_location_id: {self._current_location_id}, "
                f"current_location_name: '{self._current_location_name}'"
            )
        else:
            self._current_location_id = None
            self._current_location_name = "N/A (No horse selected)"
            self.logger.debug("LocationTab: No current horse, location set to N/A.")

        self.current_location_display_label.setText(self._current_location_name)
        self.update_buttons_state()

    def _handle_create_and_link_location(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Assign Location", "Please select a horse first."
            )
            return
        self.logger.info(
            f"Initiating Create & Assign New Location for horse: {self.current_horse.horse_name}"
        )

        dialog = AddEditLocationDialog(
            self.parent_view,
            self.location_controller,
            self.current_user_login,
            location=None,
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # IMPORTANT: AddEditLocationDialog must be modified to return the created location's ID and name
            # For example, by adding methods like dialog.get_created_location_id() and dialog.get_created_location_name()
            created_location_id = getattr(
                dialog, "created_location_id", None
            )  # Hypothetical
            created_location_name = getattr(
                dialog, "created_location_name", None
            )  # Hypothetical

            if created_location_id is not None and created_location_name is not None:
                self.logger.info(
                    f"New location created: ID {created_location_id}, Name '{created_location_name}'. Assigning to horse."
                )
                self._assign_location_to_horse(
                    created_location_id, created_location_name
                )
            else:
                self.logger.warning(
                    "AddEditLocationDialog did not return created location details. User may need to assign manually."
                )
                self.parent_view.show_info(
                    "Location Created",
                    "New location created. If not automatically assigned, please use 'Assign Existing Location' to link it.",
                )
        else:
            self.logger.info("Create & Assign New Location dialog cancelled.")

    def _handle_link_existing_location(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Assign Location", "Please select a horse first."
            )
            return
        self.logger.info(
            f"Initiating Assign Existing Location for horse: {self.current_horse.horse_name}"
        )

        dialog = SelectExistingLocationDialog(
            self.parent_view, self.current_horse.horse_name or "Selected Horse"
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_id = dialog.get_selected_location_id()
            if selected_id is not None:
                # Fetch location details to get the name for UI update and signal
                loc_obj = self.location_controller.get_location_by_id(selected_id)
                if loc_obj and hasattr(loc_obj, "location_name"):
                    self._assign_location_to_horse(
                        loc_obj.location_id, loc_obj.location_name
                    )
                else:
                    self.parent_view.show_error(
                        "Error",
                        f"Could not retrieve details for Location ID {selected_id}.",
                    )
            else:
                self.parent_view.show_warning(
                    "Assign Location", "No location was selected."
                )
        else:
            self.logger.info("Assign Existing Location dialog cancelled.")

    def _assign_location_to_horse(self, location_id: int, location_name: str):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.logger.error("No current horse to assign location to.")
            self.parent_view.show_error(
                "Error", "No horse selected to assign location."
            )
            return

        self.logger.info(
            f"Attempting to assign Location ID {location_id} ('{location_name}') to Horse ID {self.current_horse.horse_id}"
        )

        # Call controller to persist the change
        success, message = self.horse_controller.assign_horse_to_location(
            horse_id=self.current_horse.horse_id,
            location_id=location_id,
            notes=None,  # Or add a notes field to this tab/dialog if needed
            modified_by_user=self.current_user_login,
        )

        if success:
            self._current_location_id = location_id
            self._current_location_name = location_name
            self.current_location_display_label.setText(self._current_location_name)

            self.logger.info(
                f"Successfully assigned Location ID {location_id} to Horse ID {self.current_horse.horse_id}. Emitting signal."
            )
            self.location_assignment_changed.emit(
                {"id": location_id, "name": location_name}
            )
            self.parent_view.show_info(
                "Location Assigned", message
            )  # Use message from controller
        else:
            self.logger.error(f"Failed to assign location: {message}")
            self.parent_view.show_error("Assignment Failed", message)

        self.update_buttons_state()

    def _handle_remove_location_link(self):
        if not self.current_horse or self.current_horse.horse_id is None:
            self.parent_view.show_warning(
                "Clear Location", "Please select a horse first."
            )
            return
        if self._current_location_id is None:  # Check local state first
            self.parent_view.show_info(
                "Clear Location", "No location is currently assigned to this horse."
            )
            return

        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        if self.parent_view.show_question(
            "Confirm Clear Location",
            f"Are you sure you want to clear the location assignment for horse '{horse_name_display}'?",
        ):
            self.logger.info(
                f"Attempting to clear location for horse ID {self.current_horse.horse_id}, current loc ID: {self._current_location_id}"
            )

            success, message = self.horse_controller.remove_horse_from_location(
                horse_id=self.current_horse.horse_id,
                location_id=self._current_location_id,  # Pass current location ID to ensure correct history update
                modified_by_user=self.current_user_login,
            )

            if success:
                self._current_location_id = None
                self._current_location_name = "N/A"
                self.current_location_display_label.setText(self._current_location_name)

                self.logger.info(
                    f"Successfully cleared location for Horse ID {self.current_horse.horse_id}. Emitting signal."
                )
                self.location_assignment_changed.emit({"id": None, "name": "N/A"})
                self.parent_view.show_info(
                    "Location Cleared", message
                )  # Use message from controller
            else:
                self.logger.error(f"Failed to clear location: {message}")
                self.parent_view.show_error("Clear Location Failed", message)

            self.update_buttons_state()
        else:
            self.logger.info("Clear location assignment cancelled by user.")

    def update_buttons_state(self):
        is_horse_selected = (
            self.current_horse is not None and self.current_horse.horse_id is not None
        )
        is_location_assigned = self._current_location_id is not None

        self.create_link_location_btn.setEnabled(is_horse_selected)
        self.link_existing_location_btn.setEnabled(is_horse_selected)
        self.remove_location_link_btn.setEnabled(
            is_horse_selected and is_location_assigned
        )


=============== FILE: views\horse\tabs\owners_tab.py ===============

# views/horse/tabs/owners_tab.py
"""
EDSI Veterinary Management System - Horse Owners Tab
Version: 1.3.0
Purpose: Manages the association of owners with a specific horse.
Last Updated: June 9, 2025
Author: Gemini

Changelog:
- v1.3.0 (2025-06-09):
    - Added double-click functionality to the owners list. Users can now
      double-click a linked owner to open the AddEditOwnerDialog and edit
      their details directly.
    - Implemented the _handle_edit_owner method to manage this workflow.
- v1.2.5 (2025-05-26):
    - Modified `_handle_create_and_link_owner` and `_handle_link_existing_owner`
      to pass a new method `_validate_total_ownership_for_dialog` as a callback
      to `CreateAndLinkOwnerDialog` and `LinkExistingOwnerDialog` respectively.
    - The dialogs will now call this callback to perform total ownership
      validation before closing. If validation fails, the dialog remains open.
- v1.2.4 (2025-05-26):
    - Added `_validate_total_ownership` helper method for client-side validation.
    - Integrated this validation into relevant handler methods.
"""

import logging
from typing import Optional, List, Dict
from decimal import Decimal

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QLabel,
    QFrame,
    QDoubleSpinBox,
    QMessageBox,
    QDialog,
    QListWidgetItem,
)
from PySide6.QtCore import Qt, Signal

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_BUTTON_BG,
    DARK_TEXT_PRIMARY,
    DARK_BORDER,
    DARK_INPUT_FIELD_BACKGROUND,
    DARK_SUCCESS_ACTION,
    DARK_PRIMARY_ACTION,
    DARK_DANGER_ACTION,
    DARK_TEXT_SECONDARY,
    DARK_ITEM_HOVER,
    DARK_BUTTON_HOVER,
    DARK_HEADER_FOOTER,
    DARK_TEXT_TERTIARY,
)
from models import Horse, Owner as OwnerModel
from controllers.horse_controller import HorseController
from controllers.owner_controller import OwnerController

from ..dialogs.create_link_owner_dialog import CreateAndLinkOwnerDialog
from ..dialogs.link_existing_owner_dialog import LinkExistingOwnerDialog
from ...admin.dialogs.add_edit_owner_dialog import AddEditOwnerDialog
from ..widgets.horse_owner_list_widget import HorseOwnerListWidget


class OwnersTab(QWidget):
    owner_association_changed = Signal(str)

    def __init__(
        self,
        parent_view,
        horse_controller: HorseController,
        owner_controller: OwnerController,
    ):
        super().__init__(parent_view)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.parent_view = parent_view
        self.horse_controller = horse_controller
        self.owner_controller = owner_controller
        self.current_horse: Optional[Horse] = None
        self.current_horse_owners_assoc: List[Dict] = []
        self.selected_horse_owner_assoc_id: Optional[int] = None
        self.current_user_login = "UnknownUser"
        if hasattr(self.parent_view, "current_user") and self.parent_view.current_user:
            self.current_user_login = self.parent_view.current_user
        else:
            self.logger.warning(
                "Could not determine current_user for OwnersTab auditing."
            )
        self.setStyleSheet(f"background-color: {DARK_WIDGET_BACKGROUND};")
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)
        self._setup_ui(main_layout)
        self._setup_connections()
        self.update_buttons_state()

    def _get_generic_button_style(self) -> str:
        if hasattr(self.parent_view, "get_generic_button_style"):
            return self.parent_view.get_generic_button_style()
        return f"QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; border-radius: 4px; padding: 8px 12px; font-size: 12px; font-weight: 500; min-height: 28px;}} QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }} QPushButton:disabled {{ background-color: {DARK_HEADER_FOOTER}; color: {DARK_TEXT_TERTIARY}; }}"

    def _get_input_style(self) -> str:
        return f"QDoubleSpinBox {{ background-color: {DARK_INPUT_FIELD_BACKGROUND}; color: {DARK_TEXT_PRIMARY}; border: 1px solid {DARK_BORDER}; padding: 5px; border-radius: 4px; }}"

    def _setup_ui(self, main_layout: QVBoxLayout):
        owners_action_layout = QHBoxLayout()
        self.create_link_owner_btn = QPushButton(" Create New & Link Owner")
        self.link_existing_owner_btn = QPushButton(" Link Existing Owner")
        self.remove_horse_owner_btn = QPushButton(" Remove Selected Owner Link")
        button_style = self._get_generic_button_style()
        self.create_link_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_SUCCESS_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        self.link_existing_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_PRIMARY_ACTION)
        )
        self.remove_horse_owner_btn.setStyleSheet(
            button_style.replace(DARK_BUTTON_BG, DARK_DANGER_ACTION).replace(
                f"color: {DARK_TEXT_PRIMARY}", "color: white;"
            )
        )
        owners_action_layout.addWidget(self.create_link_owner_btn)
        owners_action_layout.addWidget(self.link_existing_owner_btn)
        owners_action_layout.addWidget(self.remove_horse_owner_btn)
        owners_action_layout.addStretch()
        main_layout.addLayout(owners_action_layout)
        self.current_owners_list_widget = HorseOwnerListWidget()
        owners_list_label = QLabel(
            "Current Owners & Percentages (Double-click to Edit):"
        )
        owners_list_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; background: transparent; margin-bottom: 5px; font-weight: bold;"
        )
        main_layout.addWidget(owners_list_label)
        main_layout.addWidget(self.current_owners_list_widget, 1)
        self.percentage_edit_frame = QFrame()
        self.percentage_edit_frame.setStyleSheet("background-color: transparent;")
        percentage_edit_layout = QHBoxLayout(self.percentage_edit_frame)
        percentage_edit_layout.setContentsMargins(0, 5, 0, 0)
        self.selected_owner_for_pct_label = QLabel("Edit % for:")
        self.selected_owner_for_pct_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; margin-right: 5px;"
        )
        self.edit_owner_percentage_spinbox = QDoubleSpinBox()
        self.edit_owner_percentage_spinbox.setRange(0.00, 100.00)
        self.edit_owner_percentage_spinbox.setDecimals(2)
        self.edit_owner_percentage_spinbox.setSuffix(" %")
        self.edit_owner_percentage_spinbox.setStyleSheet(self._get_input_style())
        self.edit_owner_percentage_spinbox.setFixedWidth(100)
        self.save_owner_percentage_btn = QPushButton(" Save %")
        self.save_owner_percentage_btn.setStyleSheet(
            self._get_generic_button_style().replace(
                DARK_BUTTON_BG, DARK_SUCCESS_ACTION
            )
        )
        percentage_edit_layout.addWidget(self.selected_owner_for_pct_label)
        percentage_edit_layout.addWidget(self.edit_owner_percentage_spinbox)
        percentage_edit_layout.addWidget(self.save_owner_percentage_btn)
        percentage_edit_layout.addStretch()
        main_layout.addWidget(self.percentage_edit_frame)
        self.percentage_edit_frame.hide()

    def _setup_connections(self):
        self.current_owners_list_widget.itemSelectionChanged.connect(
            self._on_horse_owner_selection_changed
        )
        self.current_owners_list_widget.itemDoubleClicked.connect(
            self._handle_edit_owner
        )
        self.create_link_owner_btn.clicked.connect(self._handle_create_and_link_owner)
        self.link_existing_owner_btn.clicked.connect(self._handle_link_existing_owner)
        self.remove_horse_owner_btn.clicked.connect(
            self._handle_remove_owner_from_horse
        )
        self.save_owner_percentage_btn.clicked.connect(
            self._handle_save_owner_percentage
        )

    def load_owners_for_horse(self, horse: Optional[Horse]):
        self.current_horse = horse
        self.current_owners_list_widget.clear()
        self.selected_horse_owner_assoc_id = None
        self.current_horse_owners_assoc = []
        if self.current_horse and self.current_horse.horse_id is not None:
            self.logger.debug(
                f"Populating owners for horse ID {self.current_horse.horse_id}"
            )
            self.current_horse_owners_assoc = self.horse_controller.get_horse_owners(
                self.current_horse.horse_id
            )
            for owner_assoc_data in self.current_horse_owners_assoc:
                item_text = f"{owner_assoc_data.get('owner_name', 'N/A')} - {owner_assoc_data.get('percentage_ownership', 0.0):.2f}%"
                list_item = QListWidgetItem(item_text)
                list_item.setData(
                    Qt.ItemDataRole.UserRole, owner_assoc_data.get("owner_id")
                )
                self.current_owners_list_widget.addItem(list_item)
        else:
            self.logger.debug("No current horse or horse ID to load owners for.")
        self.percentage_edit_frame.hide()
        self.update_buttons_state()

    def _on_horse_owner_selection_changed(self):
        selected_items = self.current_owners_list_widget.selectedItems()
        if selected_items:
            list_item = selected_items[0]
            self.selected_horse_owner_assoc_id = list_item.data(
                Qt.ItemDataRole.UserRole
            )
            self.logger.info(f"Owner ID {self.selected_horse_owner_assoc_id} selected.")
            assoc_data = next(
                (
                    ho
                    for ho in self.current_horse_owners_assoc
                    if ho["owner_id"] == self.selected_horse_owner_assoc_id
                ),
                None,
            )
            if assoc_data:
                self.edit_owner_percentage_spinbox.setValue(
                    assoc_data.get("percentage_ownership", 0.0)
                )
                self.selected_owner_for_pct_label.setText(
                    f"Edit % for: {assoc_data.get('owner_name','N/A')}"
                )
                self.percentage_edit_frame.show()
            else:
                self.logger.warning(
                    f"No data for selected owner ID {self.selected_horse_owner_assoc_id}"
                )
                self.percentage_edit_frame.hide()
        else:
            self.selected_horse_owner_assoc_id = None
            self.percentage_edit_frame.hide()
            self.logger.info("Owner selection cleared.")
        self.update_buttons_state()

    def _handle_edit_owner(self, item: QListWidgetItem):
        """Opens the AddEditOwnerDialog for the double-clicked owner."""
        owner_id = item.data(Qt.ItemDataRole.UserRole)
        if owner_id is None:
            return

        self.logger.info(f"Edit requested for owner ID: {owner_id}")
        owner_to_edit = self.owner_controller.get_owner_by_id(owner_id)

        if owner_to_edit:
            dialog = AddEditOwnerDialog(
                parent_view=self.parent_view,
                owner_controller=self.owner_controller,
                owner_object=owner_to_edit,
                current_user_id=self.current_user_login,
            )
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.logger.info(f"Owner ID {owner_id} was updated. Refreshing list.")
                # After saving, reload the owners for the current horse
                self.load_owners_for_horse(self.current_horse)
                # Notify the main screen that data has changed
                self.owner_association_changed.emit(
                    f"Details updated for owner '{owner_to_edit.last_name}'."
                )
        else:
            self.parent_view.show_error(
                "Error", f"Could not retrieve details for owner ID {owner_id}."
            )

    def _validate_total_ownership_for_dialog(
        self,
        owner_id_being_changed: Optional[int],
        new_percentage_for_this_owner: float,
    ) -> bool:
        """Called by dialogs to validate total ownership before they accept."""
        if not self.current_horse:
            return False
        current_total_other_owners = Decimal("0.00")
        for assoc in self.current_horse_owners_assoc:
            if (
                owner_id_being_changed is not None
                and assoc.get("owner_id") == owner_id_being_changed
            ):
                continue
            current_total_other_owners += Decimal(
                str(assoc.get("percentage_ownership", 0.0))
            )

        prospective_total = current_total_other_owners + Decimal(
            str(new_percentage_for_this_owner)
        )
        self.logger.debug(
            f"Dialog validation: Others total={current_total_other_owners}, New%={new_percentage_for_this_owner}, Prospective={prospective_total}"
        )
        if prospective_total > Decimal("100.00"):
            msg = (
                f"Total ownership cannot exceed 100%.\n"
                f"Other owners: {current_total_other_owners:.2f}%\n"
                f"This owner: {new_percentage_for_this_owner:.2f}%\n"
                f"Resulting total: {prospective_total:.2f}%"
            )
            QMessageBox.warning(
                self.parent_view, "Ownership Error", msg
            )  # Show error via parent_view
            return False
        return True

    def _handle_create_and_link_owner(self):
        if not self.current_horse:
            self.parent_view.show_warning("Add Owner", "Select horse first.")
            return
        self.logger.info(
            f"Initiating Create & Link Owner for: {self.current_horse.horse_name}"
        )

        # Pass the validation method to the dialog
        dialog = CreateAndLinkOwnerDialog(
            self,
            self.current_horse.horse_name or "Selected Horse",
            self.current_user_login,
            total_ownership_validator=self._validate_total_ownership_for_dialog,  # Pass callback
        )
        if (
            dialog.exec() == QDialog.DialogCode.Accepted
        ):  # Dialog only accepts if ALL validation (incl. total %) passed
            data = dialog.get_data()
            if (
                data
                and data.get("owner_details")
                and data.get("percentage") is not None
            ):
                owner_details, percentage = data["owner_details"], data["percentage"]
                self.logger.info(
                    f"Dialog OK. Owner: {owner_details}, Percentage: {percentage}"
                )
                # Total ownership validation already done by the dialog via callback
                success_create, msg_create, new_owner_obj = (
                    self.owner_controller.create_master_owner(
                        owner_details, self.current_user_login
                    )
                )
                if (
                    success_create
                    and new_owner_obj
                    and self.current_horse
                    and self.current_horse.horse_id is not None
                ):
                    success_link, msg_link = self.horse_controller.add_owner_to_horse(
                        self.current_horse.horse_id,
                        new_owner_obj.owner_id,
                        percentage,
                        self.current_user_login,
                    )
                    if success_link:
                        self.parent_view.show_info("Owner Linked", msg_link)
                        self.load_owners_for_horse(self.current_horse)
                        self.owner_association_changed.emit(msg_link)
                    else:
                        self.parent_view.show_error("Link Error", msg_link)
                else:
                    self.parent_view.show_error(
                        "Create Error", msg_create or "Could not create owner."
                    )
            else:
                self.logger.warning("Create dialog accepted, but no valid data.")
                self.parent_view.show_warning("Data Error", "No data from form.")
        else:
            self.logger.info("Create & link owner dialog cancelled.")

    def _handle_link_existing_owner(self):
        if not self.current_horse:
            self.parent_view.show_warning("Link Owner", "Select horse first.")
            return
        self.logger.info(
            f"Initiating Link Existing Owner for: {self.current_horse.horse_name}"
        )

        # LinkExistingOwnerDialog needs similar modification to accept validator
        # For now, we'll keep its internal validation and add OwnersTab validation after it closes.
        # This means if total % validation fails, user has to re-open LinkExistingOwnerDialog.
        # Ideal solution: Modify LinkExistingOwnerDialog to also take the callback.

        dialog = LinkExistingOwnerDialog(
            self, self.current_horse.horse_name or "Selected Horse"
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_data()
            if (
                data
                and data.get("owner_id") is not None
                and data.get("percentage") is not None
                and self.current_horse
                and self.current_horse.horse_id is not None
            ):
                owner_id, percentage = data["owner_id"], data["percentage"]
                self.logger.info(
                    f"Linking owner ID {owner_id} with {percentage}% to horse ID {self.current_horse.horse_id}"
                )

                # Perform total ownership validation AFTER dialog closes for this dialog type (can be improved)
                if not self._validate_total_ownership_for_dialog(None, percentage):
                    # User has to click "Link Existing Owner" again if this fails.
                    return

                success_link, msg_link = self.horse_controller.add_owner_to_horse(
                    self.current_horse.horse_id,
                    owner_id,
                    percentage,
                    self.current_user_login,
                )
                if success_link:
                    self.parent_view.show_info("Owner Linked", msg_link)
                    self.load_owners_for_horse(self.current_horse)
                    self.owner_association_changed.emit(msg_link)
                else:
                    self.parent_view.show_error("Link Error", msg_link)
            else:
                self.logger.warning("No data from link dialog.")
                self.parent_view.show_warning("Data Error", "No selection from form.")
        else:
            self.logger.info("Link existing owner dialog cancelled.")

    def _handle_save_owner_percentage(self):
        if (
            not self.current_horse
            or self.current_horse.horse_id is None
            or self.selected_horse_owner_assoc_id is None
        ):
            self.parent_view.show_warning(
                "Save %", "Select horse and owner to update %."
            )
            return
        new_percentage = self.edit_owner_percentage_spinbox.value()

        # VALIDATION using the dialog-focused validator
        if not self._validate_total_ownership_for_dialog(
            self.selected_horse_owner_assoc_id, new_percentage
        ):
            return  # Error message already shown by validator

        self.logger.info(
            f"Updating % for owner ID {self.selected_horse_owner_assoc_id} on horse ID {self.current_horse.horse_id} to {new_percentage}%"
        )
        success, message = self.horse_controller.update_horse_owner_percentage(
            self.current_horse.horse_id,
            self.selected_horse_owner_assoc_id,
            new_percentage,
            self.current_user_login,
        )
        if success:
            self.parent_view.show_info("Percentage Updated", message)
            self.load_owners_for_horse(self.current_horse)
            self.owner_association_changed.emit(message)
        else:
            self.parent_view.show_error("Update % Error", message)

    def _handle_remove_owner_from_horse(self):
        if (
            not self.current_horse
            or self.current_horse.horse_id is None
            or self.selected_horse_owner_assoc_id is None
        ):
            warn_msg = "Select horse and owner from list."
            if hasattr(self.parent_view, "show_warning"):
                self.parent_view.show_warning("Remove Owner", warn_msg)
            else:
                QMessageBox.warning(self, "Remove Owner", warn_msg)
                return
        owner_id_to_remove = self.selected_horse_owner_assoc_id
        owner_display_name = f"Owner ID {owner_id_to_remove}"
        for oa in self.current_horse_owners_assoc:
            if oa.get("owner_id") == owner_id_to_remove:
                owner_display_name = oa.get("owner_name", owner_display_name)
                break
        horse_name_display = (
            self.current_horse.horse_name or f"ID {self.current_horse.horse_id}"
        )
        confirm_msg = (
            f"Remove owner '{owner_display_name}' from horse '{horse_name_display}'?"
        )
        proceed = False
        if hasattr(self.parent_view, "show_question"):
            proceed = self.parent_view.show_question("Confirm Removal", confirm_msg)
        else:
            proceed = (
                QMessageBox.question(
                    self,
                    "Confirm Removal",
                    confirm_msg,
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No,
                )
                == QMessageBox.StandardButton.Yes
            )
        if proceed:
            self.logger.info(
                f"Confirmed removal of owner ID {owner_id_to_remove} from horse ID {self.current_horse.horse_id}"
            )
            success, message = self.horse_controller.remove_owner_from_horse(
                self.current_horse.horse_id, owner_id_to_remove, self.current_user_login
            )
            if success:
                if hasattr(self.parent_view, "show_info"):
                    self.parent_view.show_info("Owner Removed", message)
                else:
                    QMessageBox.information(self, "Owner Removed", message)
                self.load_owners_for_horse(self.current_horse)
                self.owner_association_changed.emit(message)
            else:
                if hasattr(self.parent_view, "show_error"):
                    self.parent_view.show_error("Remove Error", message)
                else:
                    QMessageBox.critical(self, "Remove Error", message)
        else:
            self.logger.info("Owner removal cancelled.")

    def update_buttons_state(self):
        is_horse_selected = (
            self.current_horse is not None and self.current_horse.horse_id is not None
        )
        is_owner_in_list_selected = self.selected_horse_owner_assoc_id is not None
        self.create_link_owner_btn.setEnabled(is_horse_selected)
        self.link_existing_owner_btn.setEnabled(is_horse_selected)
        self.remove_horse_owner_btn.setEnabled(
            is_horse_selected and is_owner_in_list_selected
        )
        self.save_owner_percentage_btn.setEnabled(
            is_horse_selected and is_owner_in_list_selected
        )
        self.percentage_edit_frame.setVisible(
            is_horse_selected and is_owner_in_list_selected
        )


=============== FILE: views\horse\widgets\__init__.py ===============

# views/widgets/__init__.py
"""
EDMS reusable custom widgets package.
"""


=============== FILE: views\horse\widgets\charge_line_item_widget.py ===============

# views/horse/widgets/charge_line_item_widget.py
"""
EDSI Veterinary Management System - Charge Line Item Widget
Version: 1.1.0
Purpose: A self-contained widget for a single charge line item, including notes.
         - Added styling for input fields.
Last Updated: June 6, 2025
Author: Gemini
"""
import logging
from decimal import Decimal, InvalidOperation
from typing import Optional, List, Dict, Any

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QDoubleSpinBox,
    QCheckBox,
    QTextEdit,
    QCompleter,
    QToolButton,
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QFont, QIcon

from models import ChargeCode
from config.app_config import AppConfig


class ChargeLineItemWidget(QWidget):
    """A widget representing a single, editable charge line."""

    remove_requested = Signal(QWidget)
    amount_changed = Signal()

    def __init__(self, charge_codes: List[ChargeCode], parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self._charge_codes = charge_codes if charge_codes else []
        self._charge_code_lookup = {cc.code: cc for cc in self._charge_codes}
        self._alt_code_lookup = {
            cc.alternate_code: cc for cc in self._charge_codes if cc.alternate_code
        }

        self.charge_data: Optional[ChargeCode] = None

        self._setup_ui()
        self._apply_styles()
        self._setup_connections()

    def _setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 10)
        main_layout.setSpacing(5)
        self.setStyleSheet(
            f"background-color: {AppConfig.DARK_WIDGET_BACKGROUND}; border-radius: 5px; padding: 5px;"
        )

        top_layout = QHBoxLayout()
        top_layout.setSpacing(5)

        self.charge_code_input = QLineEdit()
        self.alt_code_input = QLineEdit()
        self.description_label = QLineEdit()
        self.qty_spinbox = QDoubleSpinBox()
        self.price_spinbox = QDoubleSpinBox()
        self.taxable_checkbox = QCheckBox()
        self.total_label = QLabel("$0.00")
        self.remove_button = QToolButton()

        top_layout.addWidget(self.charge_code_input, 2)
        top_layout.addWidget(self.alt_code_input, 2)
        top_layout.addWidget(self.description_label, 6)
        top_layout.addWidget(self.qty_spinbox, 1)
        top_layout.addWidget(self.price_spinbox, 2)
        top_layout.addWidget(self.taxable_checkbox)
        top_layout.addWidget(self.total_label, 2)
        top_layout.addWidget(self.remove_button)

        self.notes_edit = QTextEdit()

        main_layout.addLayout(top_layout)
        main_layout.addWidget(self.notes_edit)

    def _apply_styles(self):
        # Apply the "boxed" style to all input fields
        input_style = f"""
            QLineEdit, QDoubleSpinBox, QTextEdit {{
                background-color: {AppConfig.DARK_INPUT_FIELD_BACKGROUND};
                border: 1px solid {AppConfig.DARK_BORDER};
                border-radius: 4px;
                padding: 5px;
            }}
            QLineEdit:focus, QDoubleSpinBox:focus, QTextEdit:focus {{
                border: 1px solid {AppConfig.DARK_PRIMARY_ACTION};
            }}
            QLineEdit[readOnly="true"] {{
                background-color: {AppConfig.DARK_HEADER_FOOTER};
                color: {AppConfig.DARK_TEXT_SECONDARY};
            }}
        """
        self.setStyleSheet(self.styleSheet() + input_style)

        self.charge_code_input.setPlaceholderText("Code")
        self.alt_code_input.setPlaceholderText("Alt Code")
        self.description_label.setPlaceholderText("Description")
        self.description_label.setReadOnly(True)

        self.qty_spinbox.setRange(0.001, 9999.0)
        self.qty_spinbox.setDecimals(3)
        self.qty_spinbox.setValue(1.0)

        self.price_spinbox.setRange(0.00, 99999.99)
        self.price_spinbox.setDecimals(2)
        self.price_spinbox.setPrefix("$ ")

        self.total_label.setAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )
        self.total_label.setMinimumWidth(80)

        self.notes_edit.setPlaceholderText("Enter notes for this line item...")
        self.notes_edit.setFixedHeight(40)

        self.remove_button.setIcon(QIcon(":/icons/delete"))  # Placeholder
        self.remove_button.setToolTip("Remove this charge")

    def _setup_connections(self):
        self.charge_code_input.editingFinished.connect(self._on_code_entered)
        self.alt_code_input.editingFinished.connect(self._on_alt_code_entered)
        self.qty_spinbox.valueChanged.connect(self._update_total)
        self.price_spinbox.valueChanged.connect(self._update_total)
        self.taxable_checkbox.stateChanged.connect(self.amount_changed.emit)
        self.remove_button.clicked.connect(lambda: self.remove_requested.emit(self))

    @Slot()
    def _on_code_entered(self):
        code_text = self.charge_code_input.text().upper()
        self.charge_data = self._charge_code_lookup.get(code_text)
        self._populate_from_charge_code()

    @Slot()
    def _on_alt_code_entered(self):
        alt_code_text = self.alt_code_input.text().upper()
        self.charge_data = self._alt_code_lookup.get(alt_code_text)
        self._populate_from_charge_code()

    def _populate_from_charge_code(self):
        if self.charge_data:
            self.charge_code_input.setText(self.charge_data.code)
            self.alt_code_input.setText(self.charge_data.alternate_code or "")
            self.description_label.setText(self.charge_data.description)
            self.price_spinbox.setValue(float(self.charge_data.standard_charge))
            self.taxable_checkbox.setChecked(self.charge_data.taxable)
        self._update_total()

    @Slot()
    def _update_total(self):
        try:
            qty = Decimal(self.qty_spinbox.value())
            price = Decimal(self.price_spinbox.value())
            total = qty * price
            self.total_label.setText(f"${total:.2f}")
        except (InvalidOperation, TypeError):
            self.total_label.setText("$0.00")
        self.amount_changed.emit()

    def get_data(self) -> Optional[Dict[str, Any]]:
        if not self.charge_data:
            return None

        return {
            "charge_code_id": self.charge_data.id,
            "description": self.description_label.text(),
            "quantity": Decimal(str(self.qty_spinbox.value())),
            "unit_price": Decimal(str(self.price_spinbox.value())),
            "total_price": (
                Decimal(str(self.qty_spinbox.value()))
                * Decimal(str(self.price_spinbox.value()))
            ),
            "taxable": self.taxable_checkbox.isChecked(),
            "item_notes": self.notes_edit.toPlainText().strip() or None,
        }


=============== FILE: views\horse\widgets\custom_question_dialog.py ===============

# views/widgets/custom_question_dialog.py
"""
EDSI Veterinary Management System - Custom Question Dialog
Version: 1.0.0
Purpose: A custom QDialog that mimics QMessageBox.question but allows for
         reliable and explicit styling of its buttons.
Last Updated: June 8, 2025
Author: Gemini
"""

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QPushButton,
    QSpacerItem,
    QSizePolicy,
    QDialogButtonBox,
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QFont, QColor, QPalette

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_SUCCESS_ACTION,
    DARK_BUTTON_BG,
    DARK_BUTTON_HOVER,
    DEFAULT_FONT_FAMILY,
    DARK_BORDER,
)


class CustomQuestionDialog(QDialog):
    """A custom dialog to ask a Yes/No question with fully styleable buttons."""

    def __init__(self, title: str, message: str, parent=None):
        super().__init__(parent)

        self.setWindowTitle(title)
        self.setModal(True)
        self.setMinimumWidth(350)

        # --- Palette and Base Style ---
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(DARK_WIDGET_BACKGROUND))
        self.setPalette(palette)
        self.setAutoFillBackground(True)

        # --- Layout ---
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(20)

        # --- Message Label ---
        self.message_label = QLabel(message)
        self.message_label.setFont(QFont(DEFAULT_FONT_FAMILY, 10))
        self.message_label.setStyleSheet(f"color: {DARK_TEXT_PRIMARY};")
        self.message_label.setWordWrap(True)
        self.message_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        main_layout.addWidget(self.message_label)

        # --- Button Layout ---
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)

        spacer = QSpacerItem(
            40, 20, QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum
        )
        button_layout.addSpacerItem(spacer)

        self.no_button = QPushButton("No")
        self.yes_button = QPushButton("Yes")

        button_layout.addWidget(self.no_button)
        button_layout.addWidget(self.yes_button)

        main_layout.addLayout(button_layout)

        self.no_button.setDefault(True)
        self.yes_button.setAutoDefault(False)

        # --- Connections ---
        self.yes_button.clicked.connect(self.accept)
        self.no_button.clicked.connect(self.reject)

        # --- Apply Styles ---
        self._apply_button_styles()

    def _apply_button_styles(self):
        """Applies the 'boxed-in' style directly to the buttons."""
        base_style = """
            QPushButton {
                border: 1px solid white;
                border-radius: 4px;
                padding: 8px 16px;
                min-width: 80px;
                font-weight: bold;
            }
        """

        self.yes_button.setStyleSheet(
            base_style
            + f"""
            QPushButton {{ background-color: {DARK_SUCCESS_ACTION}; color: white; }}
            QPushButton:hover {{ background-color: {QColor(DARK_SUCCESS_ACTION).lighter(115).name()}; }}
        """
        )

        self.no_button.setStyleSheet(
            base_style
            + f"""
            QPushButton {{ background-color: {DARK_BUTTON_BG}; color: {DARK_TEXT_PRIMARY}; }}
            QPushButton:hover {{ background-color: {DARK_BUTTON_HOVER}; }}
        """
        )


=============== FILE: views\horse\widgets\horse_list_widget.py ===============

# views/horse/widgets/horse_list_widget.py
"""
EDSI Veterinary Management System - Horse List Widget
Version: 1.0.3
Purpose: Custom QListWidget for displaying a list of horses with specific styling
         and item representation. Corrected double-click event handling.
Last Updated: June 8, 2025
Author: Claude Assistant (Modified by Gemini)

Changelog:
- v1.0.3 (2025-06-08):
    - Re-implemented `mouseDoubleClickEvent` to more reliably emit the
      `itemDoubleClicked` signal, fixing the double-click-to-edit feature.
- v1.0.2 (2025-06-08):
    - Bug Fix: Overrode `mouseDoubleClickEvent` to ensure the `itemDoubleClicked`
      signal is emitted correctly, even when using custom item widgets.
- v1.0.1 (2025-05-18):
    - Corrected AppConfig constant usage.
- v1.0.0 (2025-05-17):
    - Initial extraction from horse_unified_management.py.
"""

import logging
from typing import Optional
from datetime import date

from PySide6.QtWidgets import QListWidget, QVBoxLayout, QLabel, QWidget
from PySide6.QtGui import QFont, QMouseEvent
from PySide6.QtCore import Qt

from config.app_config import (
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_BORDER,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
    DEFAULT_FONT_FAMILY,
    DARK_TEXT_SECONDARY,
    DARK_TEXT_TERTIARY,
)


class HorseListWidget(QListWidget):
    """Custom list widget styled for the dark theme and responsible for horse item rendering."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setStyleSheet(
            f"""
            QListWidget {{
                border: none; background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY}; outline: none;
            }}
            QListWidget::item {{
                padding: 10px 15px; border-bottom: 1px solid {DARK_BORDER};
                min-height: 55px; background-color: {DARK_WIDGET_BACKGROUND};
            }}
            QListWidget::item:selected {{
                background-color: {DARK_PRIMARY_ACTION}40; /* RGBA */
                border-left: 3px solid {DARK_PRIMARY_ACTION};
                color: #ffffff;
            }}
            QListWidget::item:hover:!selected {{ background-color: {DARK_ITEM_HOVER}; }}
            """
        )

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        """
        Overrides the default double-click handler to ensure the itemDoubleClicked
        signal is emitted reliably, even when using custom widgets.
        """
        item = self.itemAt(event.pos())
        if item:
            self.logger.debug(
                f"Double click detected on item for horse ID: {item.data(Qt.ItemDataRole.UserRole)}"
            )
            self.itemDoubleClicked.emit(item)
        # We do not call the super() implementation, as we are handling the event completely.
        # This prevents any potential conflicts.

    def create_horse_list_item_widget(self, horse) -> QWidget:
        """
        Creates a custom widget for displaying a single horse item in the list.
        Args:
            horse: The horse data object.
        Returns:
            QWidget: The custom widget for the list item.
        """
        widget = QWidget()
        widget.setStyleSheet(
            f"background-color: transparent; border: none; color: {DARK_TEXT_PRIMARY};"
        )
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(0, 5, 0, 5)
        layout.setSpacing(2)

        name_label = QLabel(horse.horse_name or "Unnamed Horse")
        name_label.setFont(QFont(DEFAULT_FONT_FAMILY, 12, QFont.Weight.Bold))
        name_label.setStyleSheet(
            f"color: {DARK_TEXT_PRIMARY}; background: transparent;"
        )

        info_text = f"Acct: {horse.account_number or 'N/A'} | {horse.breed or 'N/A'}"
        info_label = QLabel(info_text)
        info_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-size: 10px; background: transparent;"
        )

        details_text = f"{horse.color or '?'} | {horse.sex or '?'} | {self._calculate_age(horse.date_of_birth)}"
        details_label = QLabel(details_text)
        details_label.setStyleSheet(
            f"color: {DARK_TEXT_SECONDARY}; font-size: 10px; background: transparent;"
        )

        location_text = horse.location.location_name if horse.location else "N/A"
        location_label = QLabel(f" {location_text}")
        location_label.setStyleSheet(
            f"color: {DARK_TEXT_TERTIARY}; font-size: 10px; background: transparent;"
        )

        layout.addWidget(name_label)
        layout.addWidget(info_label)
        layout.addWidget(details_label)
        layout.addWidget(location_label)
        layout.addStretch()
        return widget

    def _calculate_age(self, birth_date_obj: Optional[date]) -> str:
        """
        Calculates the age of the horse based on the birth date.
        Args:
            birth_date_obj: The date of birth of the horse.
        Returns:
            str: A string representation of the horse's age.
        """
        if not birth_date_obj or not isinstance(birth_date_obj, date):
            return "Age N/A"
        try:
            today = date.today()
            age_val = (
                today.year
                - birth_date_obj.year
                - (
                    (today.month, today.day)
                    < (birth_date_obj.month, birth_date_obj.day)
                )
            )
            return f"{age_val} yr" if age_val == 1 else f"{age_val} yrs"
        except Exception as e:
            self.logger.error(
                f"Error calculating age for date {birth_date_obj}: {e}", exc_info=True
            )
            return "Age Error"


=============== FILE: views\horse\widgets\horse_owner_list_widget.py ===============

# views/horse/widgets/horse_owner_list_widget.py

"""
EDSI Veterinary Management System - Horse Owner List Widget
Version: 1.0.1
Purpose: Custom QListWidget for displaying horse-owner associations with specific styling.
         Corrected AppConfig constant usage.
Last Updated: May 18, 2025
Author: Claude Assistant

Changelog:
- v1.0.1 (2025-05-18):
    - Corrected AppConfig constant usage. Imported constants directly instead of
      accessing them via the AppConfig class.
- v1.0.0 (2025-05-17):
    - Initial extraction from horse_unified_management.py.
"""

import logging
from PySide6.QtWidgets import QListWidget

# QColor might not be directly used if config provides strings, but good to keep if needed by palette
from PySide6.QtGui import QColor

# Corrected import: Import constants directly
from config.app_config import (
    DARK_BORDER,
    DARK_WIDGET_BACKGROUND,
    DARK_TEXT_PRIMARY,
    DARK_PRIMARY_ACTION,
    DARK_ITEM_HOVER,
)


class HorseOwnerListWidget(QListWidget):
    """Custom list widget for displaying horse owners in the Owners tab."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.setStyleSheet(
            f"""
            QListWidget {{
                border: 1px solid {DARK_BORDER};
                background-color: {DARK_WIDGET_BACKGROUND};
                color: {DARK_TEXT_PRIMARY};
                outline: none; border-radius: 4px;
            }}
            QListWidget::item {{
                padding: 8px 12px; border-bottom: 1px solid {DARK_BORDER};
            }}
            QListWidget::item:selected {{
                background-color: {DARK_PRIMARY_ACTION}50; /* Using alpha for selection */
                color: #ffffff; /* Ensure text is readable on selection */
            }}
            QListWidget::item:hover:!selected {{
                background-color: {DARK_ITEM_HOVER};
            }}
            """
        )


